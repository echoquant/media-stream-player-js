diff --git a/dist/media-stream-library.legacy.min.js b/dist/media-stream-library.legacy.min.js
index 18f77257393b94f21c04b391d0daeb82ecab6c2f..15533ab9d173f488928cb81edd9453983bae048e 100644
--- a/dist/media-stream-library.legacy.min.js
+++ b/dist/media-stream-library.legacy.min.js
@@ -1,2 +1,28711 @@
-/*! For license information please see media-stream-library.legacy.min.js.LICENSE.txt */
-!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports.mediaStreamLibrary=e():t.mediaStreamLibrary=e()}(self,(function(){return(()=>{var t={7997:(t,e,r)=>{var n=r(2695);e.formatArgs=function(e){if(e[0]=(this.useColors?"%c":"")+this.namespace+(this.useColors?" %c":" ")+e[0]+(this.useColors?"%c ":" ")+"+"+t.exports.humanize(this.diff),!this.useColors)return;const r="color: "+this.color;e.splice(1,0,r,"color: inherit");let n=0,o=0;e[0].replace(/%[a-zA-Z%]/g,(t=>{"%%"!==t&&(n++,"%c"===t&&(o=n))})),e.splice(o,0,r)},e.save=function(t){try{t?e.storage.setItem("debug",t):e.storage.removeItem("debug")}catch(t){}},e.load=function(){let t;try{t=e.storage.getItem("debug")}catch(t){}return!t&&void 0!==n&&"env"in n&&(t=n.env.DEBUG),t},e.useColors=function(){return!("undefined"==typeof window||!window.process||"renderer"!==window.process.type&&!window.process.__nwjs)||("undefined"==typeof navigator||!navigator.userAgent||!navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))&&("undefined"!=typeof document&&document.documentElement&&document.documentElement.style&&document.documentElement.style.WebkitAppearance||"undefined"!=typeof window&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||"undefined"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)&&parseInt(RegExp.$1,10)>=31||"undefined"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/))},e.storage=function(){try{return localStorage}catch(t){}}(),e.destroy=(()=>{let t=!1;return()=>{t||(t=!0,console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."))}})(),e.colors=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"],e.log=console.debug||console.log||(()=>{}),t.exports=r(4069)(e);const{formatters:o}=t.exports;o.j=function(t){try{return JSON.stringify(t)}catch(t){return"[UnexpectedJSONParseError]: "+t.message}}},4069:(t,e,r)=>{t.exports=function(t){function e(t){let r,o,i,a=null;function u(...t){if(!u.enabled)return;const n=u,o=Number(new Date),i=o-(r||o);n.diff=i,n.prev=r,n.curr=o,r=o,t[0]=e.coerce(t[0]),"string"!=typeof t[0]&&t.unshift("%O");let a=0;t[0]=t[0].replace(/%([a-zA-Z%])/g,((r,o)=>{if("%%"===r)return"%";a++;const i=e.formatters[o];if("function"==typeof i){const e=t[a];r=i.call(n,e),t.splice(a,1),a--}return r})),e.formatArgs.call(n,t),(n.log||e.log).apply(n,t)}return u.namespace=t,u.useColors=e.useColors(),u.color=e.selectColor(t),u.extend=n,u.destroy=e.destroy,Object.defineProperty(u,"enabled",{enumerable:!0,configurable:!1,get:()=>null!==a?a:(o!==e.namespaces&&(o=e.namespaces,i=e.enabled(t)),i),set:t=>{a=t}}),"function"==typeof e.init&&e.init(u),u}function n(t,r){const n=e(this.namespace+(void 0===r?":":r)+t);return n.log=this.log,n}function o(t){return t.toString().substring(2,t.toString().length-2).replace(/\.\*\?$/,"*")}return e.debug=e,e.default=e,e.coerce=function(t){return t instanceof Error?t.stack||t.message:t},e.disable=function(){const t=[...e.names.map(o),...e.skips.map(o).map((t=>"-"+t))].join(",");return e.enable(""),t},e.enable=function(t){let r;e.save(t),e.namespaces=t,e.names=[],e.skips=[];const n=("string"==typeof t?t:"").split(/[\s,]+/),o=n.length;for(r=0;r<o;r++)n[r]&&("-"===(t=n[r].replace(/\*/g,".*?"))[0]?e.skips.push(new RegExp("^"+t.substr(1)+"$")):e.names.push(new RegExp("^"+t+"$")))},e.enabled=function(t){if("*"===t[t.length-1])return!0;let r,n;for(r=0,n=e.skips.length;r<n;r++)if(e.skips[r].test(t))return!1;for(r=0,n=e.names.length;r<n;r++)if(e.names[r].test(t))return!0;return!1},e.humanize=r(6117),e.destroy=function(){console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")},Object.keys(t).forEach((r=>{e[r]=t[r]})),e.names=[],e.skips=[],e.formatters={},e.selectColor=function(t){let r=0;for(let e=0;e<t.length;e++)r=(r<<5)-r+t.charCodeAt(e),r|=0;return e.colors[Math.abs(r)%e.colors.length]},e.enable(e.load()),e}},7378:(t,e)=>{"use strict";e.byteLength=function(t){var e=s(t),r=e[0],n=e[1];return 3*(r+n)/4-n},e.toByteArray=function(t){var e,r,i=s(t),a=i[0],u=i[1],c=new o(function(t,e,r){return 3*(e+r)/4-r}(0,a,u)),f=0,l=u>0?a-4:a;for(r=0;r<l;r+=4)e=n[t.charCodeAt(r)]<<18|n[t.charCodeAt(r+1)]<<12|n[t.charCodeAt(r+2)]<<6|n[t.charCodeAt(r+3)],c[f++]=e>>16&255,c[f++]=e>>8&255,c[f++]=255&e;return 2===u&&(e=n[t.charCodeAt(r)]<<2|n[t.charCodeAt(r+1)]>>4,c[f++]=255&e),1===u&&(e=n[t.charCodeAt(r)]<<10|n[t.charCodeAt(r+1)]<<4|n[t.charCodeAt(r+2)]>>2,c[f++]=e>>8&255,c[f++]=255&e),c},e.fromByteArray=function(t){for(var e,n=t.length,o=n%3,i=[],a=16383,u=0,s=n-o;u<s;u+=a)i.push(c(t,u,u+a>s?s:u+a));return 1===o?(e=t[n-1],i.push(r[e>>2]+r[e<<4&63]+"==")):2===o&&(e=(t[n-2]<<8)+t[n-1],i.push(r[e>>10]+r[e>>4&63]+r[e<<2&63]+"=")),i.join("")};for(var r=[],n=[],o="undefined"!=typeof Uint8Array?Uint8Array:Array,i="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",a=0,u=i.length;a<u;++a)r[a]=i[a],n[i.charCodeAt(a)]=a;function s(t){var e=t.length;if(e%4>0)throw new Error("Invalid string. Length must be a multiple of 4");var r=t.indexOf("=");return-1===r&&(r=e),[r,r===e?0:4-r%4]}function c(t,e,n){for(var o,i,a=[],u=e;u<n;u+=3)o=(t[u]<<16&16711680)+(t[u+1]<<8&65280)+(255&t[u+2]),a.push(r[(i=o)>>18&63]+r[i>>12&63]+r[i>>6&63]+r[63&i]);return a.join("")}n["-".charCodeAt(0)]=62,n["_".charCodeAt(0)]=63},7866:(t,e,r)=>{"use strict";const n=r(7378),o=r(9258),i="function"==typeof Symbol&&"function"==typeof Symbol.for?Symbol.for("nodejs.util.inspect.custom"):null;e.Buffer=s,e.SlowBuffer=function(t){return+t!=t&&(t=0),s.alloc(+t)},e.INSPECT_MAX_BYTES=50;const a=2147483647;function u(t){if(t>a)throw new RangeError('The value "'+t+'" is invalid for option "size"');const e=new Uint8Array(t);return Object.setPrototypeOf(e,s.prototype),e}function s(t,e,r){if("number"==typeof t){if("string"==typeof e)throw new TypeError('The "string" argument must be of type string. Received type number');return l(t)}return c(t,e,r)}function c(t,e,r){if("string"==typeof t)return function(t,e){if("string"==typeof e&&""!==e||(e="utf8"),!s.isEncoding(e))throw new TypeError("Unknown encoding: "+e);const r=0|y(t,e);let n=u(r);const o=n.write(t,e);return o!==r&&(n=n.slice(0,o)),n}(t,e);if(ArrayBuffer.isView(t))return function(t){if(J(t,Uint8Array)){const e=new Uint8Array(t);return h(e.buffer,e.byteOffset,e.byteLength)}return p(t)}(t);if(null==t)throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof t);if(J(t,ArrayBuffer)||t&&J(t.buffer,ArrayBuffer))return h(t,e,r);if("undefined"!=typeof SharedArrayBuffer&&(J(t,SharedArrayBuffer)||t&&J(t.buffer,SharedArrayBuffer)))return h(t,e,r);if("number"==typeof t)throw new TypeError('The "value" argument must not be of type number. Received type number');const n=t.valueOf&&t.valueOf();if(null!=n&&n!==t)return s.from(n,e,r);const o=function(t){if(s.isBuffer(t)){const e=0|d(t.length),r=u(e);return 0===r.length||t.copy(r,0,0,e),r}return void 0!==t.length?"number"!=typeof t.length||K(t.length)?u(0):p(t):"Buffer"===t.type&&Array.isArray(t.data)?p(t.data):void 0}(t);if(o)return o;if("undefined"!=typeof Symbol&&null!=Symbol.toPrimitive&&"function"==typeof t[Symbol.toPrimitive])return s.from(t[Symbol.toPrimitive]("string"),e,r);throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof t)}function f(t){if("number"!=typeof t)throw new TypeError('"size" argument must be of type number');if(t<0)throw new RangeError('The value "'+t+'" is invalid for option "size"')}function l(t){return f(t),u(t<0?0:0|d(t))}function p(t){const e=t.length<0?0:0|d(t.length),r=u(e);for(let n=0;n<e;n+=1)r[n]=255&t[n];return r}function h(t,e,r){if(e<0||t.byteLength<e)throw new RangeError('"offset" is outside of buffer bounds');if(t.byteLength<e+(r||0))throw new RangeError('"length" is outside of buffer bounds');let n;return n=void 0===e&&void 0===r?new Uint8Array(t):void 0===r?new Uint8Array(t,e):new Uint8Array(t,e,r),Object.setPrototypeOf(n,s.prototype),n}function d(t){if(t>=a)throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+a.toString(16)+" bytes");return 0|t}function y(t,e){if(s.isBuffer(t))return t.length;if(ArrayBuffer.isView(t)||J(t,ArrayBuffer))return t.byteLength;if("string"!=typeof t)throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type '+typeof t);const r=t.length,n=arguments.length>2&&!0===arguments[2];if(!n&&0===r)return 0;let o=!1;for(;;)switch(e){case"ascii":case"latin1":case"binary":return r;case"utf8":case"utf-8":return G(t).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return 2*r;case"hex":return r>>>1;case"base64":return $(t).length;default:if(o)return n?-1:G(t).length;e=(""+e).toLowerCase(),o=!0}}function v(t,e,r){let n=!1;if((void 0===e||e<0)&&(e=0),e>this.length)return"";if((void 0===r||r>this.length)&&(r=this.length),r<=0)return"";if((r>>>=0)<=(e>>>=0))return"";for(t||(t="utf8");;)switch(t){case"hex":return j(this,e,r);case"utf8":case"utf-8":return R(this,e,r);case"ascii":return k(this,e,r);case"latin1":case"binary":return P(this,e,r);case"base64":return x(this,e,r);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return A(this,e,r);default:if(n)throw new TypeError("Unknown encoding: "+t);t=(t+"").toLowerCase(),n=!0}}function b(t,e,r){const n=t[e];t[e]=t[r],t[r]=n}function m(t,e,r,n,o){if(0===t.length)return-1;if("string"==typeof r?(n=r,r=0):r>2147483647?r=2147483647:r<-2147483648&&(r=-2147483648),K(r=+r)&&(r=o?0:t.length-1),r<0&&(r=t.length+r),r>=t.length){if(o)return-1;r=t.length-1}else if(r<0){if(!o)return-1;r=0}if("string"==typeof e&&(e=s.from(e,n)),s.isBuffer(e))return 0===e.length?-1:g(t,e,r,n,o);if("number"==typeof e)return e&=255,"function"==typeof Uint8Array.prototype.indexOf?o?Uint8Array.prototype.indexOf.call(t,e,r):Uint8Array.prototype.lastIndexOf.call(t,e,r):g(t,[e],r,n,o);throw new TypeError("val must be string, number or Buffer")}function g(t,e,r,n,o){let i,a=1,u=t.length,s=e.length;if(void 0!==n&&("ucs2"===(n=String(n).toLowerCase())||"ucs-2"===n||"utf16le"===n||"utf-16le"===n)){if(t.length<2||e.length<2)return-1;a=2,u/=2,s/=2,r/=2}function c(t,e){return 1===a?t[e]:t.readUInt16BE(e*a)}if(o){let n=-1;for(i=r;i<u;i++)if(c(t,i)===c(e,-1===n?0:i-n)){if(-1===n&&(n=i),i-n+1===s)return n*a}else-1!==n&&(i-=i-n),n=-1}else for(r+s>u&&(r=u-s),i=r;i>=0;i--){let r=!0;for(let n=0;n<s;n++)if(c(t,i+n)!==c(e,n)){r=!1;break}if(r)return i}return-1}function w(t,e,r,n){r=Number(r)||0;const o=t.length-r;n?(n=Number(n))>o&&(n=o):n=o;const i=e.length;let a;for(n>i/2&&(n=i/2),a=0;a<n;++a){const n=parseInt(e.substr(2*a,2),16);if(K(n))return a;t[r+a]=n}return a}function _(t,e,r,n){return Y(G(e,t.length-r),t,r,n)}function S(t,e,r,n){return Y(function(t){const e=[];for(let r=0;r<t.length;++r)e.push(255&t.charCodeAt(r));return e}(e),t,r,n)}function E(t,e,r,n){return Y($(e),t,r,n)}function O(t,e,r,n){return Y(function(t,e){let r,n,o;const i=[];for(let a=0;a<t.length&&!((e-=2)<0);++a)r=t.charCodeAt(a),n=r>>8,o=r%256,i.push(o),i.push(n);return i}(e,t.length-r),t,r,n)}function x(t,e,r){return 0===e&&r===t.length?n.fromByteArray(t):n.fromByteArray(t.slice(e,r))}function R(t,e,r){r=Math.min(t.length,r);const n=[];let o=e;for(;o<r;){const e=t[o];let i=null,a=e>239?4:e>223?3:e>191?2:1;if(o+a<=r){let r,n,u,s;switch(a){case 1:e<128&&(i=e);break;case 2:r=t[o+1],128==(192&r)&&(s=(31&e)<<6|63&r,s>127&&(i=s));break;case 3:r=t[o+1],n=t[o+2],128==(192&r)&&128==(192&n)&&(s=(15&e)<<12|(63&r)<<6|63&n,s>2047&&(s<55296||s>57343)&&(i=s));break;case 4:r=t[o+1],n=t[o+2],u=t[o+3],128==(192&r)&&128==(192&n)&&128==(192&u)&&(s=(15&e)<<18|(63&r)<<12|(63&n)<<6|63&u,s>65535&&s<1114112&&(i=s))}}null===i?(i=65533,a=1):i>65535&&(i-=65536,n.push(i>>>10&1023|55296),i=56320|1023&i),n.push(i),o+=a}return function(t){const e=t.length;if(e<=T)return String.fromCharCode.apply(String,t);let r="",n=0;for(;n<e;)r+=String.fromCharCode.apply(String,t.slice(n,n+=T));return r}(n)}e.kMaxLength=a,s.TYPED_ARRAY_SUPPORT=function(){try{const t=new Uint8Array(1),e={foo:function(){return 42}};return Object.setPrototypeOf(e,Uint8Array.prototype),Object.setPrototypeOf(t,e),42===t.foo()}catch(t){return!1}}(),s.TYPED_ARRAY_SUPPORT||"undefined"==typeof console||"function"!=typeof console.error||console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."),Object.defineProperty(s.prototype,"parent",{enumerable:!0,get:function(){if(s.isBuffer(this))return this.buffer}}),Object.defineProperty(s.prototype,"offset",{enumerable:!0,get:function(){if(s.isBuffer(this))return this.byteOffset}}),s.poolSize=8192,s.from=function(t,e,r){return c(t,e,r)},Object.setPrototypeOf(s.prototype,Uint8Array.prototype),Object.setPrototypeOf(s,Uint8Array),s.alloc=function(t,e,r){return function(t,e,r){return f(t),t<=0?u(t):void 0!==e?"string"==typeof r?u(t).fill(e,r):u(t).fill(e):u(t)}(t,e,r)},s.allocUnsafe=function(t){return l(t)},s.allocUnsafeSlow=function(t){return l(t)},s.isBuffer=function(t){return null!=t&&!0===t._isBuffer&&t!==s.prototype},s.compare=function(t,e){if(J(t,Uint8Array)&&(t=s.from(t,t.offset,t.byteLength)),J(e,Uint8Array)&&(e=s.from(e,e.offset,e.byteLength)),!s.isBuffer(t)||!s.isBuffer(e))throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');if(t===e)return 0;let r=t.length,n=e.length;for(let o=0,i=Math.min(r,n);o<i;++o)if(t[o]!==e[o]){r=t[o],n=e[o];break}return r<n?-1:n<r?1:0},s.isEncoding=function(t){switch(String(t).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},s.concat=function(t,e){if(!Array.isArray(t))throw new TypeError('"list" argument must be an Array of Buffers');if(0===t.length)return s.alloc(0);let r;if(void 0===e)for(e=0,r=0;r<t.length;++r)e+=t[r].length;const n=s.allocUnsafe(e);let o=0;for(r=0;r<t.length;++r){let e=t[r];if(J(e,Uint8Array))o+e.length>n.length?(s.isBuffer(e)||(e=s.from(e)),e.copy(n,o)):Uint8Array.prototype.set.call(n,e,o);else{if(!s.isBuffer(e))throw new TypeError('"list" argument must be an Array of Buffers');e.copy(n,o)}o+=e.length}return n},s.byteLength=y,s.prototype._isBuffer=!0,s.prototype.swap16=function(){const t=this.length;if(t%2!=0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(let e=0;e<t;e+=2)b(this,e,e+1);return this},s.prototype.swap32=function(){const t=this.length;if(t%4!=0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(let e=0;e<t;e+=4)b(this,e,e+3),b(this,e+1,e+2);return this},s.prototype.swap64=function(){const t=this.length;if(t%8!=0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(let e=0;e<t;e+=8)b(this,e,e+7),b(this,e+1,e+6),b(this,e+2,e+5),b(this,e+3,e+4);return this},s.prototype.toString=function(){const t=this.length;return 0===t?"":0===arguments.length?R(this,0,t):v.apply(this,arguments)},s.prototype.toLocaleString=s.prototype.toString,s.prototype.equals=function(t){if(!s.isBuffer(t))throw new TypeError("Argument must be a Buffer");return this===t||0===s.compare(this,t)},s.prototype.inspect=function(){let t="";const r=e.INSPECT_MAX_BYTES;return t=this.toString("hex",0,r).replace(/(.{2})/g,"$1 ").trim(),this.length>r&&(t+=" ... "),"<Buffer "+t+">"},i&&(s.prototype[i]=s.prototype.inspect),s.prototype.compare=function(t,e,r,n,o){if(J(t,Uint8Array)&&(t=s.from(t,t.offset,t.byteLength)),!s.isBuffer(t))throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type '+typeof t);if(void 0===e&&(e=0),void 0===r&&(r=t?t.length:0),void 0===n&&(n=0),void 0===o&&(o=this.length),e<0||r>t.length||n<0||o>this.length)throw new RangeError("out of range index");if(n>=o&&e>=r)return 0;if(n>=o)return-1;if(e>=r)return 1;if(this===t)return 0;let i=(o>>>=0)-(n>>>=0),a=(r>>>=0)-(e>>>=0);const u=Math.min(i,a),c=this.slice(n,o),f=t.slice(e,r);for(let t=0;t<u;++t)if(c[t]!==f[t]){i=c[t],a=f[t];break}return i<a?-1:a<i?1:0},s.prototype.includes=function(t,e,r){return-1!==this.indexOf(t,e,r)},s.prototype.indexOf=function(t,e,r){return m(this,t,e,r,!0)},s.prototype.lastIndexOf=function(t,e,r){return m(this,t,e,r,!1)},s.prototype.write=function(t,e,r,n){if(void 0===e)n="utf8",r=this.length,e=0;else if(void 0===r&&"string"==typeof e)n=e,r=this.length,e=0;else{if(!isFinite(e))throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");e>>>=0,isFinite(r)?(r>>>=0,void 0===n&&(n="utf8")):(n=r,r=void 0)}const o=this.length-e;if((void 0===r||r>o)&&(r=o),t.length>0&&(r<0||e<0)||e>this.length)throw new RangeError("Attempt to write outside buffer bounds");n||(n="utf8");let i=!1;for(;;)switch(n){case"hex":return w(this,t,e,r);case"utf8":case"utf-8":return _(this,t,e,r);case"ascii":case"latin1":case"binary":return S(this,t,e,r);case"base64":return E(this,t,e,r);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return O(this,t,e,r);default:if(i)throw new TypeError("Unknown encoding: "+n);n=(""+n).toLowerCase(),i=!0}},s.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};const T=4096;function k(t,e,r){let n="";r=Math.min(t.length,r);for(let o=e;o<r;++o)n+=String.fromCharCode(127&t[o]);return n}function P(t,e,r){let n="";r=Math.min(t.length,r);for(let o=e;o<r;++o)n+=String.fromCharCode(t[o]);return n}function j(t,e,r){const n=t.length;(!e||e<0)&&(e=0),(!r||r<0||r>n)&&(r=n);let o="";for(let n=e;n<r;++n)o+=X[t[n]];return o}function A(t,e,r){const n=t.slice(e,r);let o="";for(let t=0;t<n.length-1;t+=2)o+=String.fromCharCode(n[t]+256*n[t+1]);return o}function C(t,e,r){if(t%1!=0||t<0)throw new RangeError("offset is not uint");if(t+e>r)throw new RangeError("Trying to access beyond buffer length")}function I(t,e,r,n,o,i){if(!s.isBuffer(t))throw new TypeError('"buffer" argument must be a Buffer instance');if(e>o||e<i)throw new RangeError('"value" argument is out of bounds');if(r+n>t.length)throw new RangeError("Index out of range")}function L(t,e,r,n,o){H(e,n,o,t,r,7);let i=Number(e&BigInt(4294967295));t[r++]=i,i>>=8,t[r++]=i,i>>=8,t[r++]=i,i>>=8,t[r++]=i;let a=Number(e>>BigInt(32)&BigInt(4294967295));return t[r++]=a,a>>=8,t[r++]=a,a>>=8,t[r++]=a,a>>=8,t[r++]=a,r}function B(t,e,r,n,o){H(e,n,o,t,r,7);let i=Number(e&BigInt(4294967295));t[r+7]=i,i>>=8,t[r+6]=i,i>>=8,t[r+5]=i,i>>=8,t[r+4]=i;let a=Number(e>>BigInt(32)&BigInt(4294967295));return t[r+3]=a,a>>=8,t[r+2]=a,a>>=8,t[r+1]=a,a>>=8,t[r]=a,r+8}function M(t,e,r,n,o,i){if(r+n>t.length)throw new RangeError("Index out of range");if(r<0)throw new RangeError("Index out of range")}function U(t,e,r,n,i){return e=+e,r>>>=0,i||M(t,0,r,4),o.write(t,e,r,n,23,4),r+4}function N(t,e,r,n,i){return e=+e,r>>>=0,i||M(t,0,r,8),o.write(t,e,r,n,52,8),r+8}s.prototype.slice=function(t,e){const r=this.length;(t=~~t)<0?(t+=r)<0&&(t=0):t>r&&(t=r),(e=void 0===e?r:~~e)<0?(e+=r)<0&&(e=0):e>r&&(e=r),e<t&&(e=t);const n=this.subarray(t,e);return Object.setPrototypeOf(n,s.prototype),n},s.prototype.readUintLE=s.prototype.readUIntLE=function(t,e,r){t>>>=0,e>>>=0,r||C(t,e,this.length);let n=this[t],o=1,i=0;for(;++i<e&&(o*=256);)n+=this[t+i]*o;return n},s.prototype.readUintBE=s.prototype.readUIntBE=function(t,e,r){t>>>=0,e>>>=0,r||C(t,e,this.length);let n=this[t+--e],o=1;for(;e>0&&(o*=256);)n+=this[t+--e]*o;return n},s.prototype.readUint8=s.prototype.readUInt8=function(t,e){return t>>>=0,e||C(t,1,this.length),this[t]},s.prototype.readUint16LE=s.prototype.readUInt16LE=function(t,e){return t>>>=0,e||C(t,2,this.length),this[t]|this[t+1]<<8},s.prototype.readUint16BE=s.prototype.readUInt16BE=function(t,e){return t>>>=0,e||C(t,2,this.length),this[t]<<8|this[t+1]},s.prototype.readUint32LE=s.prototype.readUInt32LE=function(t,e){return t>>>=0,e||C(t,4,this.length),(this[t]|this[t+1]<<8|this[t+2]<<16)+16777216*this[t+3]},s.prototype.readUint32BE=s.prototype.readUInt32BE=function(t,e){return t>>>=0,e||C(t,4,this.length),16777216*this[t]+(this[t+1]<<16|this[t+2]<<8|this[t+3])},s.prototype.readBigUInt64LE=Z((function(t){W(t>>>=0,"offset");const e=this[t],r=this[t+7];void 0!==e&&void 0!==r||z(t,this.length-8);const n=e+256*this[++t]+65536*this[++t]+this[++t]*2**24,o=this[++t]+256*this[++t]+65536*this[++t]+r*2**24;return BigInt(n)+(BigInt(o)<<BigInt(32))})),s.prototype.readBigUInt64BE=Z((function(t){W(t>>>=0,"offset");const e=this[t],r=this[t+7];void 0!==e&&void 0!==r||z(t,this.length-8);const n=e*2**24+65536*this[++t]+256*this[++t]+this[++t],o=this[++t]*2**24+65536*this[++t]+256*this[++t]+r;return(BigInt(n)<<BigInt(32))+BigInt(o)})),s.prototype.readIntLE=function(t,e,r){t>>>=0,e>>>=0,r||C(t,e,this.length);let n=this[t],o=1,i=0;for(;++i<e&&(o*=256);)n+=this[t+i]*o;return o*=128,n>=o&&(n-=Math.pow(2,8*e)),n},s.prototype.readIntBE=function(t,e,r){t>>>=0,e>>>=0,r||C(t,e,this.length);let n=e,o=1,i=this[t+--n];for(;n>0&&(o*=256);)i+=this[t+--n]*o;return o*=128,i>=o&&(i-=Math.pow(2,8*e)),i},s.prototype.readInt8=function(t,e){return t>>>=0,e||C(t,1,this.length),128&this[t]?-1*(255-this[t]+1):this[t]},s.prototype.readInt16LE=function(t,e){t>>>=0,e||C(t,2,this.length);const r=this[t]|this[t+1]<<8;return 32768&r?4294901760|r:r},s.prototype.readInt16BE=function(t,e){t>>>=0,e||C(t,2,this.length);const r=this[t+1]|this[t]<<8;return 32768&r?4294901760|r:r},s.prototype.readInt32LE=function(t,e){return t>>>=0,e||C(t,4,this.length),this[t]|this[t+1]<<8|this[t+2]<<16|this[t+3]<<24},s.prototype.readInt32BE=function(t,e){return t>>>=0,e||C(t,4,this.length),this[t]<<24|this[t+1]<<16|this[t+2]<<8|this[t+3]},s.prototype.readBigInt64LE=Z((function(t){W(t>>>=0,"offset");const e=this[t],r=this[t+7];void 0!==e&&void 0!==r||z(t,this.length-8);const n=this[t+4]+256*this[t+5]+65536*this[t+6]+(r<<24);return(BigInt(n)<<BigInt(32))+BigInt(e+256*this[++t]+65536*this[++t]+this[++t]*2**24)})),s.prototype.readBigInt64BE=Z((function(t){W(t>>>=0,"offset");const e=this[t],r=this[t+7];void 0!==e&&void 0!==r||z(t,this.length-8);const n=(e<<24)+65536*this[++t]+256*this[++t]+this[++t];return(BigInt(n)<<BigInt(32))+BigInt(this[++t]*2**24+65536*this[++t]+256*this[++t]+r)})),s.prototype.readFloatLE=function(t,e){return t>>>=0,e||C(t,4,this.length),o.read(this,t,!0,23,4)},s.prototype.readFloatBE=function(t,e){return t>>>=0,e||C(t,4,this.length),o.read(this,t,!1,23,4)},s.prototype.readDoubleLE=function(t,e){return t>>>=0,e||C(t,8,this.length),o.read(this,t,!0,52,8)},s.prototype.readDoubleBE=function(t,e){return t>>>=0,e||C(t,8,this.length),o.read(this,t,!1,52,8)},s.prototype.writeUintLE=s.prototype.writeUIntLE=function(t,e,r,n){t=+t,e>>>=0,r>>>=0,n||I(this,t,e,r,Math.pow(2,8*r)-1,0);let o=1,i=0;for(this[e]=255&t;++i<r&&(o*=256);)this[e+i]=t/o&255;return e+r},s.prototype.writeUintBE=s.prototype.writeUIntBE=function(t,e,r,n){t=+t,e>>>=0,r>>>=0,n||I(this,t,e,r,Math.pow(2,8*r)-1,0);let o=r-1,i=1;for(this[e+o]=255&t;--o>=0&&(i*=256);)this[e+o]=t/i&255;return e+r},s.prototype.writeUint8=s.prototype.writeUInt8=function(t,e,r){return t=+t,e>>>=0,r||I(this,t,e,1,255,0),this[e]=255&t,e+1},s.prototype.writeUint16LE=s.prototype.writeUInt16LE=function(t,e,r){return t=+t,e>>>=0,r||I(this,t,e,2,65535,0),this[e]=255&t,this[e+1]=t>>>8,e+2},s.prototype.writeUint16BE=s.prototype.writeUInt16BE=function(t,e,r){return t=+t,e>>>=0,r||I(this,t,e,2,65535,0),this[e]=t>>>8,this[e+1]=255&t,e+2},s.prototype.writeUint32LE=s.prototype.writeUInt32LE=function(t,e,r){return t=+t,e>>>=0,r||I(this,t,e,4,4294967295,0),this[e+3]=t>>>24,this[e+2]=t>>>16,this[e+1]=t>>>8,this[e]=255&t,e+4},s.prototype.writeUint32BE=s.prototype.writeUInt32BE=function(t,e,r){return t=+t,e>>>=0,r||I(this,t,e,4,4294967295,0),this[e]=t>>>24,this[e+1]=t>>>16,this[e+2]=t>>>8,this[e+3]=255&t,e+4},s.prototype.writeBigUInt64LE=Z((function(t,e=0){return L(this,t,e,BigInt(0),BigInt("0xffffffffffffffff"))})),s.prototype.writeBigUInt64BE=Z((function(t,e=0){return B(this,t,e,BigInt(0),BigInt("0xffffffffffffffff"))})),s.prototype.writeIntLE=function(t,e,r,n){if(t=+t,e>>>=0,!n){const n=Math.pow(2,8*r-1);I(this,t,e,r,n-1,-n)}let o=0,i=1,a=0;for(this[e]=255&t;++o<r&&(i*=256);)t<0&&0===a&&0!==this[e+o-1]&&(a=1),this[e+o]=(t/i>>0)-a&255;return e+r},s.prototype.writeIntBE=function(t,e,r,n){if(t=+t,e>>>=0,!n){const n=Math.pow(2,8*r-1);I(this,t,e,r,n-1,-n)}let o=r-1,i=1,a=0;for(this[e+o]=255&t;--o>=0&&(i*=256);)t<0&&0===a&&0!==this[e+o+1]&&(a=1),this[e+o]=(t/i>>0)-a&255;return e+r},s.prototype.writeInt8=function(t,e,r){return t=+t,e>>>=0,r||I(this,t,e,1,127,-128),t<0&&(t=255+t+1),this[e]=255&t,e+1},s.prototype.writeInt16LE=function(t,e,r){return t=+t,e>>>=0,r||I(this,t,e,2,32767,-32768),this[e]=255&t,this[e+1]=t>>>8,e+2},s.prototype.writeInt16BE=function(t,e,r){return t=+t,e>>>=0,r||I(this,t,e,2,32767,-32768),this[e]=t>>>8,this[e+1]=255&t,e+2},s.prototype.writeInt32LE=function(t,e,r){return t=+t,e>>>=0,r||I(this,t,e,4,2147483647,-2147483648),this[e]=255&t,this[e+1]=t>>>8,this[e+2]=t>>>16,this[e+3]=t>>>24,e+4},s.prototype.writeInt32BE=function(t,e,r){return t=+t,e>>>=0,r||I(this,t,e,4,2147483647,-2147483648),t<0&&(t=4294967295+t+1),this[e]=t>>>24,this[e+1]=t>>>16,this[e+2]=t>>>8,this[e+3]=255&t,e+4},s.prototype.writeBigInt64LE=Z((function(t,e=0){return L(this,t,e,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))})),s.prototype.writeBigInt64BE=Z((function(t,e=0){return B(this,t,e,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))})),s.prototype.writeFloatLE=function(t,e,r){return U(this,t,e,!0,r)},s.prototype.writeFloatBE=function(t,e,r){return U(this,t,e,!1,r)},s.prototype.writeDoubleLE=function(t,e,r){return N(this,t,e,!0,r)},s.prototype.writeDoubleBE=function(t,e,r){return N(this,t,e,!1,r)},s.prototype.copy=function(t,e,r,n){if(!s.isBuffer(t))throw new TypeError("argument should be a Buffer");if(r||(r=0),n||0===n||(n=this.length),e>=t.length&&(e=t.length),e||(e=0),n>0&&n<r&&(n=r),n===r)return 0;if(0===t.length||0===this.length)return 0;if(e<0)throw new RangeError("targetStart out of bounds");if(r<0||r>=this.length)throw new RangeError("Index out of range");if(n<0)throw new RangeError("sourceEnd out of bounds");n>this.length&&(n=this.length),t.length-e<n-r&&(n=t.length-e+r);const o=n-r;return this===t&&"function"==typeof Uint8Array.prototype.copyWithin?this.copyWithin(e,r,n):Uint8Array.prototype.set.call(t,this.subarray(r,n),e),o},s.prototype.fill=function(t,e,r,n){if("string"==typeof t){if("string"==typeof e?(n=e,e=0,r=this.length):"string"==typeof r&&(n=r,r=this.length),void 0!==n&&"string"!=typeof n)throw new TypeError("encoding must be a string");if("string"==typeof n&&!s.isEncoding(n))throw new TypeError("Unknown encoding: "+n);if(1===t.length){const e=t.charCodeAt(0);("utf8"===n&&e<128||"latin1"===n)&&(t=e)}}else"number"==typeof t?t&=255:"boolean"==typeof t&&(t=Number(t));if(e<0||this.length<e||this.length<r)throw new RangeError("Out of range index");if(r<=e)return this;let o;if(e>>>=0,r=void 0===r?this.length:r>>>0,t||(t=0),"number"==typeof t)for(o=e;o<r;++o)this[o]=t;else{const i=s.isBuffer(t)?t:s.from(t,n),a=i.length;if(0===a)throw new TypeError('The value "'+t+'" is invalid for argument "value"');for(o=0;o<r-e;++o)this[o+e]=i[o%a]}return this};const D={};function F(t,e,r){D[t]=class extends r{constructor(){super(),Object.defineProperty(this,"message",{value:e.apply(this,arguments),writable:!0,configurable:!0}),this.name=`${this.name} [${t}]`,this.stack,delete this.name}get code(){return t}set code(t){Object.defineProperty(this,"code",{configurable:!0,enumerable:!0,value:t,writable:!0})}toString(){return`${this.name} [${t}]: ${this.message}`}}}function q(t){let e="",r=t.length;const n="-"===t[0]?1:0;for(;r>=n+4;r-=3)e=`_${t.slice(r-3,r)}${e}`;return`${t.slice(0,r)}${e}`}function H(t,e,r,n,o,i){if(t>r||t<e){const n="bigint"==typeof e?"n":"";let o;throw o=i>3?0===e||e===BigInt(0)?`>= 0${n} and < 2${n} ** ${8*(i+1)}${n}`:`>= -(2${n} ** ${8*(i+1)-1}${n}) and < 2 ** ${8*(i+1)-1}${n}`:`>= ${e}${n} and <= ${r}${n}`,new D.ERR_OUT_OF_RANGE("value",o,t)}!function(t,e,r){W(e,"offset"),void 0!==t[e]&&void 0!==t[e+r]||z(e,t.length-(r+1))}(n,o,i)}function W(t,e){if("number"!=typeof t)throw new D.ERR_INVALID_ARG_TYPE(e,"number",t)}function z(t,e,r){if(Math.floor(t)!==t)throw W(t,r),new D.ERR_OUT_OF_RANGE(r||"offset","an integer",t);if(e<0)throw new D.ERR_BUFFER_OUT_OF_BOUNDS;throw new D.ERR_OUT_OF_RANGE(r||"offset",`>= ${r?1:0} and <= ${e}`,t)}F("ERR_BUFFER_OUT_OF_BOUNDS",(function(t){return t?`${t} is outside of buffer bounds`:"Attempt to access memory outside buffer bounds"}),RangeError),F("ERR_INVALID_ARG_TYPE",(function(t,e){return`The "${t}" argument must be of type number. Received type ${typeof e}`}),TypeError),F("ERR_OUT_OF_RANGE",(function(t,e,r){let n=`The value of "${t}" is out of range.`,o=r;return Number.isInteger(r)&&Math.abs(r)>2**32?o=q(String(r)):"bigint"==typeof r&&(o=String(r),(r>BigInt(2)**BigInt(32)||r<-(BigInt(2)**BigInt(32)))&&(o=q(o)),o+="n"),n+=` It must be ${e}. Received ${o}`,n}),RangeError);const V=/[^+/0-9A-Za-z-_]/g;function G(t,e){let r;e=e||1/0;const n=t.length;let o=null;const i=[];for(let a=0;a<n;++a){if(r=t.charCodeAt(a),r>55295&&r<57344){if(!o){if(r>56319){(e-=3)>-1&&i.push(239,191,189);continue}if(a+1===n){(e-=3)>-1&&i.push(239,191,189);continue}o=r;continue}if(r<56320){(e-=3)>-1&&i.push(239,191,189),o=r;continue}r=65536+(o-55296<<10|r-56320)}else o&&(e-=3)>-1&&i.push(239,191,189);if(o=null,r<128){if((e-=1)<0)break;i.push(r)}else if(r<2048){if((e-=2)<0)break;i.push(r>>6|192,63&r|128)}else if(r<65536){if((e-=3)<0)break;i.push(r>>12|224,r>>6&63|128,63&r|128)}else{if(!(r<1114112))throw new Error("Invalid code point");if((e-=4)<0)break;i.push(r>>18|240,r>>12&63|128,r>>6&63|128,63&r|128)}}return i}function $(t){return n.toByteArray(function(t){if((t=(t=t.split("=")[0]).trim().replace(V,"")).length<2)return"";for(;t.length%4!=0;)t+="=";return t}(t))}function Y(t,e,r,n){let o;for(o=0;o<n&&!(o+r>=e.length||o>=t.length);++o)e[o+r]=t[o];return o}function J(t,e){return t instanceof e||null!=t&&null!=t.constructor&&null!=t.constructor.name&&t.constructor.name===e.name}function K(t){return t!=t}const X=function(){const t="0123456789abcdef",e=new Array(256);for(let r=0;r<16;++r){const n=16*r;for(let o=0;o<16;++o)e[n+o]=t[r]+t[o]}return e}();function Z(t){return"undefined"==typeof BigInt?Q:t}function Q(){throw new Error("BigInt not supported")}},488:t=>{"use strict";var e,r="object"==typeof Reflect?Reflect:null,n=r&&"function"==typeof r.apply?r.apply:function(t,e,r){return Function.prototype.apply.call(t,e,r)};e=r&&"function"==typeof r.ownKeys?r.ownKeys:Object.getOwnPropertySymbols?function(t){return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t))}:function(t){return Object.getOwnPropertyNames(t)};var o=Number.isNaN||function(t){return t!=t};function i(){i.init.call(this)}t.exports=i,t.exports.once=function(t,e){return new Promise((function(r,n){function o(){void 0!==i&&t.removeListener("error",i),r([].slice.call(arguments))}var i;"error"!==e&&(i=function(r){t.removeListener(e,o),n(r)},t.once("error",i)),t.once(e,o)}))},i.EventEmitter=i,i.prototype._events=void 0,i.prototype._eventsCount=0,i.prototype._maxListeners=void 0;var a=10;function u(t){if("function"!=typeof t)throw new TypeError('The "listener" argument must be of type Function. Received type '+typeof t)}function s(t){return void 0===t._maxListeners?i.defaultMaxListeners:t._maxListeners}function c(t,e,r,n){var o,i,a,c;if(u(r),void 0===(i=t._events)?(i=t._events=Object.create(null),t._eventsCount=0):(void 0!==i.newListener&&(t.emit("newListener",e,r.listener?r.listener:r),i=t._events),a=i[e]),void 0===a)a=i[e]=r,++t._eventsCount;else if("function"==typeof a?a=i[e]=n?[r,a]:[a,r]:n?a.unshift(r):a.push(r),(o=s(t))>0&&a.length>o&&!a.warned){a.warned=!0;var f=new Error("Possible EventEmitter memory leak detected. "+a.length+" "+String(e)+" listeners added. Use emitter.setMaxListeners() to increase limit");f.name="MaxListenersExceededWarning",f.emitter=t,f.type=e,f.count=a.length,c=f,console&&console.warn&&console.warn(c)}return t}function f(){if(!this.fired)return this.target.removeListener(this.type,this.wrapFn),this.fired=!0,0===arguments.length?this.listener.call(this.target):this.listener.apply(this.target,arguments)}function l(t,e,r){var n={fired:!1,wrapFn:void 0,target:t,type:e,listener:r},o=f.bind(n);return o.listener=r,n.wrapFn=o,o}function p(t,e,r){var n=t._events;if(void 0===n)return[];var o=n[e];return void 0===o?[]:"function"==typeof o?r?[o.listener||o]:[o]:r?function(t){for(var e=new Array(t.length),r=0;r<e.length;++r)e[r]=t[r].listener||t[r];return e}(o):d(o,o.length)}function h(t){var e=this._events;if(void 0!==e){var r=e[t];if("function"==typeof r)return 1;if(void 0!==r)return r.length}return 0}function d(t,e){for(var r=new Array(e),n=0;n<e;++n)r[n]=t[n];return r}Object.defineProperty(i,"defaultMaxListeners",{enumerable:!0,get:function(){return a},set:function(t){if("number"!=typeof t||t<0||o(t))throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received '+t+".");a=t}}),i.init=function(){void 0!==this._events&&this._events!==Object.getPrototypeOf(this)._events||(this._events=Object.create(null),this._eventsCount=0),this._maxListeners=this._maxListeners||void 0},i.prototype.setMaxListeners=function(t){if("number"!=typeof t||t<0||o(t))throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received '+t+".");return this._maxListeners=t,this},i.prototype.getMaxListeners=function(){return s(this)},i.prototype.emit=function(t){for(var e=[],r=1;r<arguments.length;r++)e.push(arguments[r]);var o="error"===t,i=this._events;if(void 0!==i)o=o&&void 0===i.error;else if(!o)return!1;if(o){var a;if(e.length>0&&(a=e[0]),a instanceof Error)throw a;var u=new Error("Unhandled error."+(a?" ("+a.message+")":""));throw u.context=a,u}var s=i[t];if(void 0===s)return!1;if("function"==typeof s)n(s,this,e);else{var c=s.length,f=d(s,c);for(r=0;r<c;++r)n(f[r],this,e)}return!0},i.prototype.addListener=function(t,e){return c(this,t,e,!1)},i.prototype.on=i.prototype.addListener,i.prototype.prependListener=function(t,e){return c(this,t,e,!0)},i.prototype.once=function(t,e){return u(e),this.on(t,l(this,t,e)),this},i.prototype.prependOnceListener=function(t,e){return u(e),this.prependListener(t,l(this,t,e)),this},i.prototype.removeListener=function(t,e){var r,n,o,i,a;if(u(e),void 0===(n=this._events))return this;if(void 0===(r=n[t]))return this;if(r===e||r.listener===e)0==--this._eventsCount?this._events=Object.create(null):(delete n[t],n.removeListener&&this.emit("removeListener",t,r.listener||e));else if("function"!=typeof r){for(o=-1,i=r.length-1;i>=0;i--)if(r[i]===e||r[i].listener===e){a=r[i].listener,o=i;break}if(o<0)return this;0===o?r.shift():function(t,e){for(;e+1<t.length;e++)t[e]=t[e+1];t.pop()}(r,o),1===r.length&&(n[t]=r[0]),void 0!==n.removeListener&&this.emit("removeListener",t,a||e)}return this},i.prototype.off=i.prototype.removeListener,i.prototype.removeAllListeners=function(t){var e,r,n;if(void 0===(r=this._events))return this;if(void 0===r.removeListener)return 0===arguments.length?(this._events=Object.create(null),this._eventsCount=0):void 0!==r[t]&&(0==--this._eventsCount?this._events=Object.create(null):delete r[t]),this;if(0===arguments.length){var o,i=Object.keys(r);for(n=0;n<i.length;++n)"removeListener"!==(o=i[n])&&this.removeAllListeners(o);return this.removeAllListeners("removeListener"),this._events=Object.create(null),this._eventsCount=0,this}if("function"==typeof(e=r[t]))this.removeListener(t,e);else if(void 0!==e)for(n=e.length-1;n>=0;n--)this.removeListener(t,e[n]);return this},i.prototype.listeners=function(t){return p(this,t,!0)},i.prototype.rawListeners=function(t){return p(this,t,!1)},i.listenerCount=function(t,e){return"function"==typeof t.listenerCount?t.listenerCount(e):h.call(t,e)},i.prototype.listenerCount=h,i.prototype.eventNames=function(){return this._eventsCount>0?e(this._events):[]}},9258:(t,e)=>{e.read=function(t,e,r,n,o){var i,a,u=8*o-n-1,s=(1<<u)-1,c=s>>1,f=-7,l=r?o-1:0,p=r?-1:1,h=t[e+l];for(l+=p,i=h&(1<<-f)-1,h>>=-f,f+=u;f>0;i=256*i+t[e+l],l+=p,f-=8);for(a=i&(1<<-f)-1,i>>=-f,f+=n;f>0;a=256*a+t[e+l],l+=p,f-=8);if(0===i)i=1-c;else{if(i===s)return a?NaN:1/0*(h?-1:1);a+=Math.pow(2,n),i-=c}return(h?-1:1)*a*Math.pow(2,i-n)},e.write=function(t,e,r,n,o,i){var a,u,s,c=8*i-o-1,f=(1<<c)-1,l=f>>1,p=23===o?Math.pow(2,-24)-Math.pow(2,-77):0,h=n?0:i-1,d=n?1:-1,y=e<0||0===e&&1/e<0?1:0;for(e=Math.abs(e),isNaN(e)||e===1/0?(u=isNaN(e)?1:0,a=f):(a=Math.floor(Math.log(e)/Math.LN2),e*(s=Math.pow(2,-a))<1&&(a--,s*=2),(e+=a+l>=1?p/s:p*Math.pow(2,1-l))*s>=2&&(a++,s/=2),a+l>=f?(u=0,a=f):a+l>=1?(u=(e*s-1)*Math.pow(2,o),a+=l):(u=e*Math.pow(2,l-1)*Math.pow(2,o),a=0));o>=8;t[r+h]=255&u,h+=d,u/=256,o-=8);for(a=a<<o|u,c+=o;c>0;t[r+h]=255&a,h+=d,a/=256,c-=8);t[r+h-d]|=128*y}},3730:t=>{"function"==typeof Object.create?t.exports=function(t,e){e&&(t.super_=e,t.prototype=Object.create(e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}))}:t.exports=function(t,e){if(e){t.super_=e;var r=function(){};r.prototype=e.prototype,t.prototype=new r,t.prototype.constructor=t}}},6117:t=>{var e=1e3,r=60*e,n=60*r,o=24*n;function i(t,e,r,n){var o=e>=1.5*r;return Math.round(t/r)+" "+n+(o?"s":"")}t.exports=function(t,a){a=a||{};var u,s,c=typeof t;if("string"===c&&t.length>0)return function(t){if(!((t=String(t)).length>100)){var i=/^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(t);if(i){var a=parseFloat(i[1]);switch((i[2]||"ms").toLowerCase()){case"years":case"year":case"yrs":case"yr":case"y":return 315576e5*a;case"weeks":case"week":case"w":return 6048e5*a;case"days":case"day":case"d":return a*o;case"hours":case"hour":case"hrs":case"hr":case"h":return a*n;case"minutes":case"minute":case"mins":case"min":case"m":return a*r;case"seconds":case"second":case"secs":case"sec":case"s":return a*e;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return a;default:return}}}}(t);if("number"===c&&isFinite(t))return a.long?(u=t,(s=Math.abs(u))>=o?i(u,s,o,"day"):s>=n?i(u,s,n,"hour"):s>=r?i(u,s,r,"minute"):s>=e?i(u,s,e,"second"):u+" ms"):function(t){var i=Math.abs(t);return i>=o?Math.round(t/o)+"d":i>=n?Math.round(t/n)+"h":i>=r?Math.round(t/r)+"m":i>=e?Math.round(t/e)+"s":t+"ms"}(t);throw new Error("val is not a non-empty string or a valid number. val="+JSON.stringify(t))}},2695:t=>{var e,r,n=t.exports={};function o(){throw new Error("setTimeout has not been defined")}function i(){throw new Error("clearTimeout has not been defined")}function a(t){if(e===setTimeout)return setTimeout(t,0);if((e===o||!e)&&setTimeout)return e=setTimeout,setTimeout(t,0);try{return e(t,0)}catch(r){try{return e.call(null,t,0)}catch(r){return e.call(this,t,0)}}}!function(){try{e="function"==typeof setTimeout?setTimeout:o}catch(t){e=o}try{r="function"==typeof clearTimeout?clearTimeout:i}catch(t){r=i}}();var u,s=[],c=!1,f=-1;function l(){c&&u&&(c=!1,u.length?s=u.concat(s):f=-1,s.length&&p())}function p(){if(!c){var t=a(l);c=!0;for(var e=s.length;e;){for(u=s,s=[];++f<e;)u&&u[f].run();f=-1,e=s.length}u=null,c=!1,function(t){if(r===clearTimeout)return clearTimeout(t);if((r===i||!r)&&clearTimeout)return r=clearTimeout,clearTimeout(t);try{r(t)}catch(e){try{return r.call(null,t)}catch(e){return r.call(this,t)}}}(t)}}function h(t,e){this.fun=t,this.array=e}function d(){}n.nextTick=function(t){var e=new Array(arguments.length-1);if(arguments.length>1)for(var r=1;r<arguments.length;r++)e[r-1]=arguments[r];s.push(new h(t,e)),1!==s.length||c||a(p)},h.prototype.run=function(){this.fun.apply(null,this.array)},n.title="browser",n.browser=!0,n.env={},n.argv=[],n.version="",n.versions={},n.on=d,n.addListener=d,n.once=d,n.off=d,n.removeListener=d,n.removeAllListeners=d,n.emit=d,n.prependListener=d,n.prependOnceListener=d,n.listeners=function(t){return[]},n.binding=function(t){throw new Error("process.binding is not supported")},n.cwd=function(){return"/"},n.chdir=function(t){throw new Error("process.chdir is not supported")},n.umask=function(){return 0}},553:t=>{"use strict";var e={};function r(t,r,n){n||(n=Error);var o=function(t){var e,n;function o(e,n,o){return t.call(this,function(t,e,n){return"string"==typeof r?r:r(t,e,n)}(e,n,o))||this}return n=t,(e=o).prototype=Object.create(n.prototype),e.prototype.constructor=e,e.__proto__=n,o}(n);o.prototype.name=n.name,o.prototype.code=t,e[t]=o}function n(t,e){if(Array.isArray(t)){var r=t.length;return t=t.map((function(t){return String(t)})),r>2?"one of ".concat(e," ").concat(t.slice(0,r-1).join(", "),", or ")+t[r-1]:2===r?"one of ".concat(e," ").concat(t[0]," or ").concat(t[1]):"of ".concat(e," ").concat(t[0])}return"of ".concat(e," ").concat(String(t))}r("ERR_INVALID_OPT_VALUE",(function(t,e){return'The value "'+e+'" is invalid for option "'+t+'"'}),TypeError),r("ERR_INVALID_ARG_TYPE",(function(t,e,r){var o,i,a,u,s;if("string"==typeof e&&(i="not ",e.substr(0,i.length)===i)?(o="must not be",e=e.replace(/^not /,"")):o="must be",function(t,e,r){return(void 0===r||r>t.length)&&(r=t.length),t.substring(r-e.length,r)===e}(t," argument"))a="The ".concat(t," ").concat(o," ").concat(n(e,"type"));else{var c=("number"!=typeof s&&(s=0),s+".".length>(u=t).length||-1===u.indexOf(".",s)?"argument":"property");a='The "'.concat(t,'" ').concat(c," ").concat(o," ").concat(n(e,"type"))}return a+". Received type ".concat(typeof r)}),TypeError),r("ERR_STREAM_PUSH_AFTER_EOF","stream.push() after EOF"),r("ERR_METHOD_NOT_IMPLEMENTED",(function(t){return"The "+t+" method is not implemented"})),r("ERR_STREAM_PREMATURE_CLOSE","Premature close"),r("ERR_STREAM_DESTROYED",(function(t){return"Cannot call "+t+" after a stream was destroyed"})),r("ERR_MULTIPLE_CALLBACK","Callback called multiple times"),r("ERR_STREAM_CANNOT_PIPE","Cannot pipe, not readable"),r("ERR_STREAM_WRITE_AFTER_END","write after end"),r("ERR_STREAM_NULL_VALUES","May not write null values to stream",TypeError),r("ERR_UNKNOWN_ENCODING",(function(t){return"Unknown encoding: "+t}),TypeError),r("ERR_STREAM_UNSHIFT_AFTER_END_EVENT","stream.unshift() after end event"),t.exports.q=e},673:(t,e,r)=>{"use strict";var n=r(2695),o=Object.keys||function(t){var e=[];for(var r in t)e.push(r);return e};t.exports=f;var i=r(5006),a=r(8719);r(3730)(f,i);for(var u=o(a.prototype),s=0;s<u.length;s++){var c=u[s];f.prototype[c]||(f.prototype[c]=a.prototype[c])}function f(t){if(!(this instanceof f))return new f(t);i.call(this,t),a.call(this,t),this.allowHalfOpen=!0,t&&(!1===t.readable&&(this.readable=!1),!1===t.writable&&(this.writable=!1),!1===t.allowHalfOpen&&(this.allowHalfOpen=!1,this.once("end",l)))}function l(){this._writableState.ended||n.nextTick(p,this)}function p(t){t.end()}Object.defineProperty(f.prototype,"writableHighWaterMark",{enumerable:!1,get:function(){return this._writableState.highWaterMark}}),Object.defineProperty(f.prototype,"writableBuffer",{enumerable:!1,get:function(){return this._writableState&&this._writableState.getBuffer()}}),Object.defineProperty(f.prototype,"writableLength",{enumerable:!1,get:function(){return this._writableState.length}}),Object.defineProperty(f.prototype,"destroyed",{enumerable:!1,get:function(){return void 0!==this._readableState&&void 0!==this._writableState&&this._readableState.destroyed&&this._writableState.destroyed},set:function(t){void 0!==this._readableState&&void 0!==this._writableState&&(this._readableState.destroyed=t,this._writableState.destroyed=t)}})},4343:(t,e,r)=>{"use strict";t.exports=o;var n=r(8597);function o(t){if(!(this instanceof o))return new o(t);n.call(this,t)}r(3730)(o,n),o.prototype._transform=function(t,e,r){r(null,t)}},5006:(t,e,r)=>{"use strict";var n,o=r(2695);t.exports=x,x.ReadableState=O,r(488).EventEmitter;var i,a=function(t,e){return t.listeners(e).length},u=r(8208),s=r(7866).Buffer,c=r.g.Uint8Array||function(){},f=r(6029);i=f&&f.debuglog?f.debuglog("stream"):function(){};var l,p,h,d=r(4506),y=r(3390),v=r(1111).getHighWaterMark,b=r(553).q,m=b.ERR_INVALID_ARG_TYPE,g=b.ERR_STREAM_PUSH_AFTER_EOF,w=b.ERR_METHOD_NOT_IMPLEMENTED,_=b.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;r(3730)(x,u);var S=y.errorOrDestroy,E=["error","close","destroy","pause","resume"];function O(t,e,o){n=n||r(673),t=t||{},"boolean"!=typeof o&&(o=e instanceof n),this.objectMode=!!t.objectMode,o&&(this.objectMode=this.objectMode||!!t.readableObjectMode),this.highWaterMark=v(this,t,"readableHighWaterMark",o),this.buffer=new d,this.length=0,this.pipes=null,this.pipesCount=0,this.flowing=null,this.ended=!1,this.endEmitted=!1,this.reading=!1,this.sync=!0,this.needReadable=!1,this.emittedReadable=!1,this.readableListening=!1,this.resumeScheduled=!1,this.paused=!0,this.emitClose=!1!==t.emitClose,this.autoDestroy=!!t.autoDestroy,this.destroyed=!1,this.defaultEncoding=t.defaultEncoding||"utf8",this.awaitDrain=0,this.readingMore=!1,this.decoder=null,this.encoding=null,t.encoding&&(l||(l=r(9481).s),this.decoder=new l(t.encoding),this.encoding=t.encoding)}function x(t){if(n=n||r(673),!(this instanceof x))return new x(t);var e=this instanceof n;this._readableState=new O(t,this,e),this.readable=!0,t&&("function"==typeof t.read&&(this._read=t.read),"function"==typeof t.destroy&&(this._destroy=t.destroy)),u.call(this)}function R(t,e,r,n,o){i("readableAddChunk",e);var a,u=t._readableState;if(null===e)u.reading=!1,function(t,e){if(i("onEofChunk"),!e.ended){if(e.decoder){var r=e.decoder.end();r&&r.length&&(e.buffer.push(r),e.length+=e.objectMode?1:r.length)}e.ended=!0,e.sync?j(t):(e.needReadable=!1,e.emittedReadable||(e.emittedReadable=!0,A(t)))}}(t,u);else if(o||(a=function(t,e){var r,n;return n=e,s.isBuffer(n)||n instanceof c||"string"==typeof e||void 0===e||t.objectMode||(r=new m("chunk",["string","Buffer","Uint8Array"],e)),r}(u,e)),a)S(t,a);else if(u.objectMode||e&&e.length>0)if("string"==typeof e||u.objectMode||Object.getPrototypeOf(e)===s.prototype||(e=function(t){return s.from(t)}(e)),n)u.endEmitted?S(t,new _):T(t,u,e,!0);else if(u.ended)S(t,new g);else{if(u.destroyed)return!1;u.reading=!1,u.decoder&&!r?(e=u.decoder.write(e),u.objectMode||0!==e.length?T(t,u,e,!1):C(t,u)):T(t,u,e,!1)}else n||(u.reading=!1,C(t,u));return!u.ended&&(u.length<u.highWaterMark||0===u.length)}function T(t,e,r,n){e.flowing&&0===e.length&&!e.sync?(e.awaitDrain=0,t.emit("data",r)):(e.length+=e.objectMode?1:r.length,n?e.buffer.unshift(r):e.buffer.push(r),e.needReadable&&j(t)),C(t,e)}Object.defineProperty(x.prototype,"destroyed",{enumerable:!1,get:function(){return void 0!==this._readableState&&this._readableState.destroyed},set:function(t){this._readableState&&(this._readableState.destroyed=t)}}),x.prototype.destroy=y.destroy,x.prototype._undestroy=y.undestroy,x.prototype._destroy=function(t,e){e(t)},x.prototype.push=function(t,e){var r,n=this._readableState;return n.objectMode?r=!0:"string"==typeof t&&((e=e||n.defaultEncoding)!==n.encoding&&(t=s.from(t,e),e=""),r=!0),R(this,t,e,!1,r)},x.prototype.unshift=function(t){return R(this,t,null,!0,!1)},x.prototype.isPaused=function(){return!1===this._readableState.flowing},x.prototype.setEncoding=function(t){l||(l=r(9481).s);var e=new l(t);this._readableState.decoder=e,this._readableState.encoding=this._readableState.decoder.encoding;for(var n=this._readableState.buffer.head,o="";null!==n;)o+=e.write(n.data),n=n.next;return this._readableState.buffer.clear(),""!==o&&this._readableState.buffer.push(o),this._readableState.length=o.length,this};var k=1073741824;function P(t,e){return t<=0||0===e.length&&e.ended?0:e.objectMode?1:t!=t?e.flowing&&e.length?e.buffer.head.data.length:e.length:(t>e.highWaterMark&&(e.highWaterMark=function(t){return t>=k?t=k:(t--,t|=t>>>1,t|=t>>>2,t|=t>>>4,t|=t>>>8,t|=t>>>16,t++),t}(t)),t<=e.length?t:e.ended?e.length:(e.needReadable=!0,0))}function j(t){var e=t._readableState;i("emitReadable",e.needReadable,e.emittedReadable),e.needReadable=!1,e.emittedReadable||(i("emitReadable",e.flowing),e.emittedReadable=!0,o.nextTick(A,t))}function A(t){var e=t._readableState;i("emitReadable_",e.destroyed,e.length,e.ended),e.destroyed||!e.length&&!e.ended||(t.emit("readable"),e.emittedReadable=!1),e.needReadable=!e.flowing&&!e.ended&&e.length<=e.highWaterMark,U(t)}function C(t,e){e.readingMore||(e.readingMore=!0,o.nextTick(I,t,e))}function I(t,e){for(;!e.reading&&!e.ended&&(e.length<e.highWaterMark||e.flowing&&0===e.length);){var r=e.length;if(i("maybeReadMore read 0"),t.read(0),r===e.length)break}e.readingMore=!1}function L(t){var e=t._readableState;e.readableListening=t.listenerCount("readable")>0,e.resumeScheduled&&!e.paused?e.flowing=!0:t.listenerCount("data")>0&&t.resume()}function B(t){i("readable nexttick read 0"),t.read(0)}function M(t,e){i("resume",e.reading),e.reading||t.read(0),e.resumeScheduled=!1,t.emit("resume"),U(t),e.flowing&&!e.reading&&t.read(0)}function U(t){var e=t._readableState;for(i("flow",e.flowing);e.flowing&&null!==t.read(););}function N(t,e){return 0===e.length?null:(e.objectMode?r=e.buffer.shift():!t||t>=e.length?(r=e.decoder?e.buffer.join(""):1===e.buffer.length?e.buffer.first():e.buffer.concat(e.length),e.buffer.clear()):r=e.buffer.consume(t,e.decoder),r);var r}function D(t){var e=t._readableState;i("endReadable",e.endEmitted),e.endEmitted||(e.ended=!0,o.nextTick(F,e,t))}function F(t,e){if(i("endReadableNT",t.endEmitted,t.length),!t.endEmitted&&0===t.length&&(t.endEmitted=!0,e.readable=!1,e.emit("end"),t.autoDestroy)){var r=e._writableState;(!r||r.autoDestroy&&r.finished)&&e.destroy()}}function q(t,e){for(var r=0,n=t.length;r<n;r++)if(t[r]===e)return r;return-1}x.prototype.read=function(t){i("read",t),t=parseInt(t,10);var e=this._readableState,r=t;if(0!==t&&(e.emittedReadable=!1),0===t&&e.needReadable&&((0!==e.highWaterMark?e.length>=e.highWaterMark:e.length>0)||e.ended))return i("read: emitReadable",e.length,e.ended),0===e.length&&e.ended?D(this):j(this),null;if(0===(t=P(t,e))&&e.ended)return 0===e.length&&D(this),null;var n,o=e.needReadable;return i("need readable",o),(0===e.length||e.length-t<e.highWaterMark)&&i("length less than watermark",o=!0),e.ended||e.reading?i("reading or ended",o=!1):o&&(i("do read"),e.reading=!0,e.sync=!0,0===e.length&&(e.needReadable=!0),this._read(e.highWaterMark),e.sync=!1,e.reading||(t=P(r,e))),null===(n=t>0?N(t,e):null)?(e.needReadable=e.length<=e.highWaterMark,t=0):(e.length-=t,e.awaitDrain=0),0===e.length&&(e.ended||(e.needReadable=!0),r!==t&&e.ended&&D(this)),null!==n&&this.emit("data",n),n},x.prototype._read=function(t){S(this,new w("_read()"))},x.prototype.pipe=function(t,e){var r=this,n=this._readableState;switch(n.pipesCount){case 0:n.pipes=t;break;case 1:n.pipes=[n.pipes,t];break;default:n.pipes.push(t)}n.pipesCount+=1,i("pipe count=%d opts=%j",n.pipesCount,e);var u=e&&!1===e.end||t===o.stdout||t===o.stderr?y:s;function s(){i("onend"),t.end()}n.endEmitted?o.nextTick(u):r.once("end",u),t.on("unpipe",(function e(o,a){i("onunpipe"),o===r&&a&&!1===a.hasUnpiped&&(a.hasUnpiped=!0,i("cleanup"),t.removeListener("close",h),t.removeListener("finish",d),t.removeListener("drain",c),t.removeListener("error",p),t.removeListener("unpipe",e),r.removeListener("end",s),r.removeListener("end",y),r.removeListener("data",l),f=!0,!n.awaitDrain||t._writableState&&!t._writableState.needDrain||c())}));var c=function(t){return function(){var e=t._readableState;i("pipeOnDrain",e.awaitDrain),e.awaitDrain&&e.awaitDrain--,0===e.awaitDrain&&a(t,"data")&&(e.flowing=!0,U(t))}}(r);t.on("drain",c);var f=!1;function l(e){i("ondata");var o=t.write(e);i("dest.write",o),!1===o&&((1===n.pipesCount&&n.pipes===t||n.pipesCount>1&&-1!==q(n.pipes,t))&&!f&&(i("false write response, pause",n.awaitDrain),n.awaitDrain++),r.pause())}function p(e){i("onerror",e),y(),t.removeListener("error",p),0===a(t,"error")&&S(t,e)}function h(){t.removeListener("finish",d),y()}function d(){i("onfinish"),t.removeListener("close",h),y()}function y(){i("unpipe"),r.unpipe(t)}return r.on("data",l),function(t,e,r){if("function"==typeof t.prependListener)return t.prependListener(e,r);t._events&&t._events.error?Array.isArray(t._events.error)?t._events.error.unshift(r):t._events.error=[r,t._events.error]:t.on(e,r)}(t,"error",p),t.once("close",h),t.once("finish",d),t.emit("pipe",r),n.flowing||(i("pipe resume"),r.resume()),t},x.prototype.unpipe=function(t){var e=this._readableState,r={hasUnpiped:!1};if(0===e.pipesCount)return this;if(1===e.pipesCount)return t&&t!==e.pipes||(t||(t=e.pipes),e.pipes=null,e.pipesCount=0,e.flowing=!1,t&&t.emit("unpipe",this,r)),this;if(!t){var n=e.pipes,o=e.pipesCount;e.pipes=null,e.pipesCount=0,e.flowing=!1;for(var i=0;i<o;i++)n[i].emit("unpipe",this,{hasUnpiped:!1});return this}var a=q(e.pipes,t);return-1===a||(e.pipes.splice(a,1),e.pipesCount-=1,1===e.pipesCount&&(e.pipes=e.pipes[0]),t.emit("unpipe",this,r)),this},x.prototype.on=function(t,e){var r=u.prototype.on.call(this,t,e),n=this._readableState;return"data"===t?(n.readableListening=this.listenerCount("readable")>0,!1!==n.flowing&&this.resume()):"readable"===t&&(n.endEmitted||n.readableListening||(n.readableListening=n.needReadable=!0,n.flowing=!1,n.emittedReadable=!1,i("on readable",n.length,n.reading),n.length?j(this):n.reading||o.nextTick(B,this))),r},x.prototype.addListener=x.prototype.on,x.prototype.removeListener=function(t,e){var r=u.prototype.removeListener.call(this,t,e);return"readable"===t&&o.nextTick(L,this),r},x.prototype.removeAllListeners=function(t){var e=u.prototype.removeAllListeners.apply(this,arguments);return"readable"!==t&&void 0!==t||o.nextTick(L,this),e},x.prototype.resume=function(){var t=this._readableState;return t.flowing||(i("resume"),t.flowing=!t.readableListening,function(t,e){e.resumeScheduled||(e.resumeScheduled=!0,o.nextTick(M,t,e))}(this,t)),t.paused=!1,this},x.prototype.pause=function(){return i("call pause flowing=%j",this._readableState.flowing),!1!==this._readableState.flowing&&(i("pause"),this._readableState.flowing=!1,this.emit("pause")),this._readableState.paused=!0,this},x.prototype.wrap=function(t){var e=this,r=this._readableState,n=!1;for(var o in t.on("end",(function(){if(i("wrapped end"),r.decoder&&!r.ended){var t=r.decoder.end();t&&t.length&&e.push(t)}e.push(null)})),t.on("data",(function(o){i("wrapped data"),r.decoder&&(o=r.decoder.write(o)),r.objectMode&&null==o||(r.objectMode||o&&o.length)&&(e.push(o)||(n=!0,t.pause()))})),t)void 0===this[o]&&"function"==typeof t[o]&&(this[o]=function(e){return function(){return t[e].apply(t,arguments)}}(o));for(var a=0;a<E.length;a++)t.on(E[a],this.emit.bind(this,E[a]));return this._read=function(e){i("wrapped _read",e),n&&(n=!1,t.resume())},this},"function"==typeof Symbol&&(x.prototype[Symbol.asyncIterator]=function(){return void 0===p&&(p=r(8187)),p(this)}),Object.defineProperty(x.prototype,"readableHighWaterMark",{enumerable:!1,get:function(){return this._readableState.highWaterMark}}),Object.defineProperty(x.prototype,"readableBuffer",{enumerable:!1,get:function(){return this._readableState&&this._readableState.buffer}}),Object.defineProperty(x.prototype,"readableFlowing",{enumerable:!1,get:function(){return this._readableState.flowing},set:function(t){this._readableState&&(this._readableState.flowing=t)}}),x._fromList=N,Object.defineProperty(x.prototype,"readableLength",{enumerable:!1,get:function(){return this._readableState.length}}),"function"==typeof Symbol&&(x.from=function(t,e){return void 0===h&&(h=r(3733)),h(x,t,e)})},8597:(t,e,r)=>{"use strict";t.exports=f;var n=r(553).q,o=n.ERR_METHOD_NOT_IMPLEMENTED,i=n.ERR_MULTIPLE_CALLBACK,a=n.ERR_TRANSFORM_ALREADY_TRANSFORMING,u=n.ERR_TRANSFORM_WITH_LENGTH_0,s=r(673);function c(t,e){var r=this._transformState;r.transforming=!1;var n=r.writecb;if(null===n)return this.emit("error",new i);r.writechunk=null,r.writecb=null,null!=e&&this.push(e),n(t);var o=this._readableState;o.reading=!1,(o.needReadable||o.length<o.highWaterMark)&&this._read(o.highWaterMark)}function f(t){if(!(this instanceof f))return new f(t);s.call(this,t),this._transformState={afterTransform:c.bind(this),needTransform:!1,transforming:!1,writecb:null,writechunk:null,writeencoding:null},this._readableState.needReadable=!0,this._readableState.sync=!1,t&&("function"==typeof t.transform&&(this._transform=t.transform),"function"==typeof t.flush&&(this._flush=t.flush)),this.on("prefinish",l)}function l(){var t=this;"function"!=typeof this._flush||this._readableState.destroyed?p(this,null,null):this._flush((function(e,r){p(t,e,r)}))}function p(t,e,r){if(e)return t.emit("error",e);if(null!=r&&t.push(r),t._writableState.length)throw new u;if(t._transformState.transforming)throw new a;return t.push(null)}r(3730)(f,s),f.prototype.push=function(t,e){return this._transformState.needTransform=!1,s.prototype.push.call(this,t,e)},f.prototype._transform=function(t,e,r){r(new o("_transform()"))},f.prototype._write=function(t,e,r){var n=this._transformState;if(n.writecb=r,n.writechunk=t,n.writeencoding=e,!n.transforming){var o=this._readableState;(n.needTransform||o.needReadable||o.length<o.highWaterMark)&&this._read(o.highWaterMark)}},f.prototype._read=function(t){var e=this._transformState;null===e.writechunk||e.transforming?e.needTransform=!0:(e.transforming=!0,this._transform(e.writechunk,e.writeencoding,e.afterTransform))},f.prototype._destroy=function(t,e){s.prototype._destroy.call(this,t,(function(t){e(t)}))}},8719:(t,e,r)=>{"use strict";var n,o=r(2695);function i(t){var e=this;this.next=null,this.entry=null,this.finish=function(){!function(t,e,r){var n=t.entry;for(t.entry=null;n;){var o=n.callback;e.pendingcb--,o(undefined),n=n.next}e.corkedRequestsFree.next=t}(e,t)}}t.exports=x,x.WritableState=O;var a,u={deprecate:r(72)},s=r(8208),c=r(7866).Buffer,f=r.g.Uint8Array||function(){},l=r(3390),p=r(1111).getHighWaterMark,h=r(553).q,d=h.ERR_INVALID_ARG_TYPE,y=h.ERR_METHOD_NOT_IMPLEMENTED,v=h.ERR_MULTIPLE_CALLBACK,b=h.ERR_STREAM_CANNOT_PIPE,m=h.ERR_STREAM_DESTROYED,g=h.ERR_STREAM_NULL_VALUES,w=h.ERR_STREAM_WRITE_AFTER_END,_=h.ERR_UNKNOWN_ENCODING,S=l.errorOrDestroy;function E(){}function O(t,e,a){n=n||r(673),t=t||{},"boolean"!=typeof a&&(a=e instanceof n),this.objectMode=!!t.objectMode,a&&(this.objectMode=this.objectMode||!!t.writableObjectMode),this.highWaterMark=p(this,t,"writableHighWaterMark",a),this.finalCalled=!1,this.needDrain=!1,this.ending=!1,this.ended=!1,this.finished=!1,this.destroyed=!1;var u=!1===t.decodeStrings;this.decodeStrings=!u,this.defaultEncoding=t.defaultEncoding||"utf8",this.length=0,this.writing=!1,this.corked=0,this.sync=!0,this.bufferProcessing=!1,this.onwrite=function(t){!function(t,e){var r=t._writableState,n=r.sync,i=r.writecb;if("function"!=typeof i)throw new v;if(function(t){t.writing=!1,t.writecb=null,t.length-=t.writelen,t.writelen=0}(r),e)!function(t,e,r,n,i){--e.pendingcb,r?(o.nextTick(i,n),o.nextTick(A,t,e),t._writableState.errorEmitted=!0,S(t,n)):(i(n),t._writableState.errorEmitted=!0,S(t,n),A(t,e))}(t,r,n,e,i);else{var a=P(r)||t.destroyed;a||r.corked||r.bufferProcessing||!r.bufferedRequest||k(t,r),n?o.nextTick(T,t,r,a,i):T(t,r,a,i)}}(e,t)},this.writecb=null,this.writelen=0,this.bufferedRequest=null,this.lastBufferedRequest=null,this.pendingcb=0,this.prefinished=!1,this.errorEmitted=!1,this.emitClose=!1!==t.emitClose,this.autoDestroy=!!t.autoDestroy,this.bufferedRequestCount=0,this.corkedRequestsFree=new i(this)}function x(t){var e=this instanceof(n=n||r(673));if(!e&&!a.call(x,this))return new x(t);this._writableState=new O(t,this,e),this.writable=!0,t&&("function"==typeof t.write&&(this._write=t.write),"function"==typeof t.writev&&(this._writev=t.writev),"function"==typeof t.destroy&&(this._destroy=t.destroy),"function"==typeof t.final&&(this._final=t.final)),s.call(this)}function R(t,e,r,n,o,i,a){e.writelen=n,e.writecb=a,e.writing=!0,e.sync=!0,e.destroyed?e.onwrite(new m("write")):r?t._writev(o,e.onwrite):t._write(o,i,e.onwrite),e.sync=!1}function T(t,e,r,n){r||function(t,e){0===e.length&&e.needDrain&&(e.needDrain=!1,t.emit("drain"))}(t,e),e.pendingcb--,n(),A(t,e)}function k(t,e){e.bufferProcessing=!0;var r=e.bufferedRequest;if(t._writev&&r&&r.next){var n=e.bufferedRequestCount,o=new Array(n),a=e.corkedRequestsFree;a.entry=r;for(var u=0,s=!0;r;)o[u]=r,r.isBuf||(s=!1),r=r.next,u+=1;o.allBuffers=s,R(t,e,!0,e.length,o,"",a.finish),e.pendingcb++,e.lastBufferedRequest=null,a.next?(e.corkedRequestsFree=a.next,a.next=null):e.corkedRequestsFree=new i(e),e.bufferedRequestCount=0}else{for(;r;){var c=r.chunk,f=r.encoding,l=r.callback;if(R(t,e,!1,e.objectMode?1:c.length,c,f,l),r=r.next,e.bufferedRequestCount--,e.writing)break}null===r&&(e.lastBufferedRequest=null)}e.bufferedRequest=r,e.bufferProcessing=!1}function P(t){return t.ending&&0===t.length&&null===t.bufferedRequest&&!t.finished&&!t.writing}function j(t,e){t._final((function(r){e.pendingcb--,r&&S(t,r),e.prefinished=!0,t.emit("prefinish"),A(t,e)}))}function A(t,e){var r=P(e);if(r&&(function(t,e){e.prefinished||e.finalCalled||("function"!=typeof t._final||e.destroyed?(e.prefinished=!0,t.emit("prefinish")):(e.pendingcb++,e.finalCalled=!0,o.nextTick(j,t,e)))}(t,e),0===e.pendingcb&&(e.finished=!0,t.emit("finish"),e.autoDestroy))){var n=t._readableState;(!n||n.autoDestroy&&n.endEmitted)&&t.destroy()}return r}r(3730)(x,s),O.prototype.getBuffer=function(){for(var t=this.bufferedRequest,e=[];t;)e.push(t),t=t.next;return e},function(){try{Object.defineProperty(O.prototype,"buffer",{get:u.deprecate((function(){return this.getBuffer()}),"_writableState.buffer is deprecated. Use _writableState.getBuffer instead.","DEP0003")})}catch(t){}}(),"function"==typeof Symbol&&Symbol.hasInstance&&"function"==typeof Function.prototype[Symbol.hasInstance]?(a=Function.prototype[Symbol.hasInstance],Object.defineProperty(x,Symbol.hasInstance,{value:function(t){return!!a.call(this,t)||this===x&&t&&t._writableState instanceof O}})):a=function(t){return t instanceof this},x.prototype.pipe=function(){S(this,new b)},x.prototype.write=function(t,e,r){var n,i=this._writableState,a=!1,u=!i.objectMode&&(n=t,c.isBuffer(n)||n instanceof f);return u&&!c.isBuffer(t)&&(t=function(t){return c.from(t)}(t)),"function"==typeof e&&(r=e,e=null),u?e="buffer":e||(e=i.defaultEncoding),"function"!=typeof r&&(r=E),i.ending?function(t,e){var r=new w;S(t,r),o.nextTick(e,r)}(this,r):(u||function(t,e,r,n){var i;return null===r?i=new g:"string"==typeof r||e.objectMode||(i=new d("chunk",["string","Buffer"],r)),!i||(S(t,i),o.nextTick(n,i),!1)}(this,i,t,r))&&(i.pendingcb++,a=function(t,e,r,n,o,i){if(!r){var a=function(t,e,r){return t.objectMode||!1===t.decodeStrings||"string"!=typeof e||(e=c.from(e,r)),e}(e,n,o);n!==a&&(r=!0,o="buffer",n=a)}var u=e.objectMode?1:n.length;e.length+=u;var s=e.length<e.highWaterMark;if(s||(e.needDrain=!0),e.writing||e.corked){var f=e.lastBufferedRequest;e.lastBufferedRequest={chunk:n,encoding:o,isBuf:r,callback:i,next:null},f?f.next=e.lastBufferedRequest:e.bufferedRequest=e.lastBufferedRequest,e.bufferedRequestCount+=1}else R(t,e,!1,u,n,o,i);return s}(this,i,u,t,e,r)),a},x.prototype.cork=function(){this._writableState.corked++},x.prototype.uncork=function(){var t=this._writableState;t.corked&&(t.corked--,t.writing||t.corked||t.bufferProcessing||!t.bufferedRequest||k(this,t))},x.prototype.setDefaultEncoding=function(t){if("string"==typeof t&&(t=t.toLowerCase()),!(["hex","utf8","utf-8","ascii","binary","base64","ucs2","ucs-2","utf16le","utf-16le","raw"].indexOf((t+"").toLowerCase())>-1))throw new _(t);return this._writableState.defaultEncoding=t,this},Object.defineProperty(x.prototype,"writableBuffer",{enumerable:!1,get:function(){return this._writableState&&this._writableState.getBuffer()}}),Object.defineProperty(x.prototype,"writableHighWaterMark",{enumerable:!1,get:function(){return this._writableState.highWaterMark}}),x.prototype._write=function(t,e,r){r(new y("_write()"))},x.prototype._writev=null,x.prototype.end=function(t,e,r){var n=this._writableState;return"function"==typeof t?(r=t,t=null,e=null):"function"==typeof e&&(r=e,e=null),null!=t&&this.write(t,e),n.corked&&(n.corked=1,this.uncork()),n.ending||function(t,e,r){e.ending=!0,A(t,e),r&&(e.finished?o.nextTick(r):t.once("finish",r)),e.ended=!0,t.writable=!1}(this,n,r),this},Object.defineProperty(x.prototype,"writableLength",{enumerable:!1,get:function(){return this._writableState.length}}),Object.defineProperty(x.prototype,"destroyed",{enumerable:!1,get:function(){return void 0!==this._writableState&&this._writableState.destroyed},set:function(t){this._writableState&&(this._writableState.destroyed=t)}}),x.prototype.destroy=l.destroy,x.prototype._undestroy=l.undestroy,x.prototype._destroy=function(t,e){e(t)}},8187:(t,e,r)=>{"use strict";var n,o=r(2695);function i(t,e,r){return e in t?Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[e]=r,t}var a=r(2426),u=Symbol("lastResolve"),s=Symbol("lastReject"),c=Symbol("error"),f=Symbol("ended"),l=Symbol("lastPromise"),p=Symbol("handlePromise"),h=Symbol("stream");function d(t,e){return{value:t,done:e}}function y(t){var e=t[u];if(null!==e){var r=t[h].read();null!==r&&(t[l]=null,t[u]=null,t[s]=null,e(d(r,!1)))}}function v(t){o.nextTick(y,t)}var b=Object.getPrototypeOf((function(){})),m=Object.setPrototypeOf((i(n={get stream(){return this[h]},next:function(){var t=this,e=this[c];if(null!==e)return Promise.reject(e);if(this[f])return Promise.resolve(d(void 0,!0));if(this[h].destroyed)return new Promise((function(e,r){o.nextTick((function(){t[c]?r(t[c]):e(d(void 0,!0))}))}));var r,n=this[l];if(n)r=new Promise(function(t,e){return function(r,n){t.then((function(){e[f]?r(d(void 0,!0)):e[p](r,n)}),n)}}(n,this));else{var i=this[h].read();if(null!==i)return Promise.resolve(d(i,!1));r=new Promise(this[p])}return this[l]=r,r}},Symbol.asyncIterator,(function(){return this})),i(n,"return",(function(){var t=this;return new Promise((function(e,r){t[h].destroy(null,(function(t){t?r(t):e(d(void 0,!0))}))}))})),n),b);t.exports=function(t){var e,r=Object.create(m,(i(e={},h,{value:t,writable:!0}),i(e,u,{value:null,writable:!0}),i(e,s,{value:null,writable:!0}),i(e,c,{value:null,writable:!0}),i(e,f,{value:t._readableState.endEmitted,writable:!0}),i(e,p,{value:function(t,e){var n=r[h].read();n?(r[l]=null,r[u]=null,r[s]=null,t(d(n,!1))):(r[u]=t,r[s]=e)},writable:!0}),e));return r[l]=null,a(t,(function(t){if(t&&"ERR_STREAM_PREMATURE_CLOSE"!==t.code){var e=r[s];return null!==e&&(r[l]=null,r[u]=null,r[s]=null,e(t)),void(r[c]=t)}var n=r[u];null!==n&&(r[l]=null,r[u]=null,r[s]=null,n(d(void 0,!0))),r[f]=!0})),t.on("readable",v.bind(null,r)),r}},4506:(t,e,r)=>{"use strict";function n(t,e){var r=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),r.push.apply(r,n)}return r}function o(t,e,r){return e in t?Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[e]=r,t}function i(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}var a=r(7866).Buffer,u=r(462).inspect,s=u&&u.custom||"inspect";t.exports=function(){function t(){!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,t),this.head=null,this.tail=null,this.length=0}var e,r;return e=t,(r=[{key:"push",value:function(t){var e={data:t,next:null};this.length>0?this.tail.next=e:this.head=e,this.tail=e,++this.length}},{key:"unshift",value:function(t){var e={data:t,next:this.head};0===this.length&&(this.tail=e),this.head=e,++this.length}},{key:"shift",value:function(){if(0!==this.length){var t=this.head.data;return 1===this.length?this.head=this.tail=null:this.head=this.head.next,--this.length,t}}},{key:"clear",value:function(){this.head=this.tail=null,this.length=0}},{key:"join",value:function(t){if(0===this.length)return"";for(var e=this.head,r=""+e.data;e=e.next;)r+=t+e.data;return r}},{key:"concat",value:function(t){if(0===this.length)return a.alloc(0);for(var e,r,n,o=a.allocUnsafe(t>>>0),i=this.head,u=0;i;)e=i.data,r=o,n=u,a.prototype.copy.call(e,r,n),u+=i.data.length,i=i.next;return o}},{key:"consume",value:function(t,e){var r;return t<this.head.data.length?(r=this.head.data.slice(0,t),this.head.data=this.head.data.slice(t)):r=t===this.head.data.length?this.shift():e?this._getString(t):this._getBuffer(t),r}},{key:"first",value:function(){return this.head.data}},{key:"_getString",value:function(t){var e=this.head,r=1,n=e.data;for(t-=n.length;e=e.next;){var o=e.data,i=t>o.length?o.length:t;if(i===o.length?n+=o:n+=o.slice(0,t),0==(t-=i)){i===o.length?(++r,e.next?this.head=e.next:this.head=this.tail=null):(this.head=e,e.data=o.slice(i));break}++r}return this.length-=r,n}},{key:"_getBuffer",value:function(t){var e=a.allocUnsafe(t),r=this.head,n=1;for(r.data.copy(e),t-=r.data.length;r=r.next;){var o=r.data,i=t>o.length?o.length:t;if(o.copy(e,e.length-t,0,i),0==(t-=i)){i===o.length?(++n,r.next?this.head=r.next:this.head=this.tail=null):(this.head=r,r.data=o.slice(i));break}++n}return this.length-=n,e}},{key:s,value:function(t,e){return u(this,function(t){for(var e=1;e<arguments.length;e++){var r=null!=arguments[e]?arguments[e]:{};e%2?n(Object(r),!0).forEach((function(e){o(t,e,r[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(r)):n(Object(r)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(r,e))}))}return t}({},e,{depth:0,customInspect:!1}))}}])&&i(e.prototype,r),t}()},3390:(t,e,r)=>{"use strict";var n=r(2695);function o(t,e){a(t,e),i(t)}function i(t){t._writableState&&!t._writableState.emitClose||t._readableState&&!t._readableState.emitClose||t.emit("close")}function a(t,e){t.emit("error",e)}t.exports={destroy:function(t,e){var r=this,u=this._readableState&&this._readableState.destroyed,s=this._writableState&&this._writableState.destroyed;return u||s?(e?e(t):t&&(this._writableState?this._writableState.errorEmitted||(this._writableState.errorEmitted=!0,n.nextTick(a,this,t)):n.nextTick(a,this,t)),this):(this._readableState&&(this._readableState.destroyed=!0),this._writableState&&(this._writableState.destroyed=!0),this._destroy(t||null,(function(t){!e&&t?r._writableState?r._writableState.errorEmitted?n.nextTick(i,r):(r._writableState.errorEmitted=!0,n.nextTick(o,r,t)):n.nextTick(o,r,t):e?(n.nextTick(i,r),e(t)):n.nextTick(i,r)})),this)},undestroy:function(){this._readableState&&(this._readableState.destroyed=!1,this._readableState.reading=!1,this._readableState.ended=!1,this._readableState.endEmitted=!1),this._writableState&&(this._writableState.destroyed=!1,this._writableState.ended=!1,this._writableState.ending=!1,this._writableState.finalCalled=!1,this._writableState.prefinished=!1,this._writableState.finished=!1,this._writableState.errorEmitted=!1)},errorOrDestroy:function(t,e){var r=t._readableState,n=t._writableState;r&&r.autoDestroy||n&&n.autoDestroy?t.destroy(e):t.emit("error",e)}}},2426:(t,e,r)=>{"use strict";var n=r(553).q.ERR_STREAM_PREMATURE_CLOSE;function o(){}t.exports=function t(e,r,i){if("function"==typeof r)return t(e,null,r);r||(r={}),i=function(t){var e=!1;return function(){if(!e){e=!0;for(var r=arguments.length,n=new Array(r),o=0;o<r;o++)n[o]=arguments[o];t.apply(this,n)}}}(i||o);var a=r.readable||!1!==r.readable&&e.readable,u=r.writable||!1!==r.writable&&e.writable,s=function(){e.writable||f()},c=e._writableState&&e._writableState.finished,f=function(){u=!1,c=!0,a||i.call(e)},l=e._readableState&&e._readableState.endEmitted,p=function(){a=!1,l=!0,u||i.call(e)},h=function(t){i.call(e,t)},d=function(){var t;return a&&!l?(e._readableState&&e._readableState.ended||(t=new n),i.call(e,t)):u&&!c?(e._writableState&&e._writableState.ended||(t=new n),i.call(e,t)):void 0},y=function(){e.req.on("finish",f)};return function(t){return t.setHeader&&"function"==typeof t.abort}(e)?(e.on("complete",f),e.on("abort",d),e.req?y():e.on("request",y)):u&&!e._writableState&&(e.on("end",s),e.on("close",s)),e.on("end",p),e.on("finish",f),!1!==r.error&&e.on("error",h),e.on("close",d),function(){e.removeListener("complete",f),e.removeListener("abort",d),e.removeListener("request",y),e.req&&e.req.removeListener("finish",f),e.removeListener("end",s),e.removeListener("close",s),e.removeListener("finish",f),e.removeListener("end",p),e.removeListener("error",h),e.removeListener("close",d)}}},3733:t=>{t.exports=function(){throw new Error("Readable.from is not available in the browser")}},2970:(t,e,r)=>{"use strict";var n,o=r(553).q,i=o.ERR_MISSING_ARGS,a=o.ERR_STREAM_DESTROYED;function u(t){if(t)throw t}function s(t,e,o,i){i=function(t){var e=!1;return function(){e||(e=!0,t.apply(void 0,arguments))}}(i);var u=!1;t.on("close",(function(){u=!0})),void 0===n&&(n=r(2426)),n(t,{readable:e,writable:o},(function(t){if(t)return i(t);u=!0,i()}));var s=!1;return function(e){if(!u&&!s)return s=!0,function(t){return t.setHeader&&"function"==typeof t.abort}(t)?t.abort():"function"==typeof t.destroy?t.destroy():void i(e||new a("pipe"))}}function c(t){t()}function f(t,e){return t.pipe(e)}function l(t){return t.length?"function"!=typeof t[t.length-1]?u:t.pop():u}t.exports=function(){for(var t=arguments.length,e=new Array(t),r=0;r<t;r++)e[r]=arguments[r];var n,o=l(e);if(Array.isArray(e[0])&&(e=e[0]),e.length<2)throw new i("streams");var a=e.map((function(t,r){var i=r<e.length-1;return s(t,i,r>0,(function(t){n||(n=t),t&&a.forEach(c),i||(a.forEach(c),o(n))}))}));return e.reduce(f)}},1111:(t,e,r)=>{"use strict";var n=r(553).q.ERR_INVALID_OPT_VALUE;t.exports={getHighWaterMark:function(t,e,r,o){var i=function(t,e,r){return null!=t.highWaterMark?t.highWaterMark:e?t[r]:null}(e,o,r);if(null!=i){if(!isFinite(i)||Math.floor(i)!==i||i<0)throw new n(o?r:"highWaterMark",i);return Math.floor(i)}return t.objectMode?16:16384}}},8208:(t,e,r)=>{t.exports=r(488).EventEmitter},9210:t=>{var e=function(t){"use strict";var e,r=Object.prototype,n=r.hasOwnProperty,o="function"==typeof Symbol?Symbol:{},i=o.iterator||"@@iterator",a=o.asyncIterator||"@@asyncIterator",u=o.toStringTag||"@@toStringTag";function s(t,e,r){return Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}),t[e]}try{s({},"")}catch(t){s=function(t,e,r){return t[e]=r}}function c(t,e,r,n){var o=e&&e.prototype instanceof v?e:v,i=Object.create(o.prototype),a=new k(n||[]);return i._invoke=function(t,e,r){var n=l;return function(o,i){if(n===h)throw new Error("Generator is already running");if(n===d){if("throw"===o)throw i;return j()}for(r.method=o,r.arg=i;;){var a=r.delegate;if(a){var u=x(a,r);if(u){if(u===y)continue;return u}}if("next"===r.method)r.sent=r._sent=r.arg;else if("throw"===r.method){if(n===l)throw n=d,r.arg;r.dispatchException(r.arg)}else"return"===r.method&&r.abrupt("return",r.arg);n=h;var s=f(t,e,r);if("normal"===s.type){if(n=r.done?d:p,s.arg===y)continue;return{value:s.arg,done:r.done}}"throw"===s.type&&(n=d,r.method="throw",r.arg=s.arg)}}}(t,r,a),i}function f(t,e,r){try{return{type:"normal",arg:t.call(e,r)}}catch(t){return{type:"throw",arg:t}}}t.wrap=c;var l="suspendedStart",p="suspendedYield",h="executing",d="completed",y={};function v(){}function b(){}function m(){}var g={};s(g,i,(function(){return this}));var w=Object.getPrototypeOf,_=w&&w(w(P([])));_&&_!==r&&n.call(_,i)&&(g=_);var S=m.prototype=v.prototype=Object.create(g);function E(t){["next","throw","return"].forEach((function(e){s(t,e,(function(t){return this._invoke(e,t)}))}))}function O(t,e){function r(o,i,a,u){var s=f(t[o],t,i);if("throw"!==s.type){var c=s.arg,l=c.value;return l&&"object"==typeof l&&n.call(l,"__await")?e.resolve(l.__await).then((function(t){r("next",t,a,u)}),(function(t){r("throw",t,a,u)})):e.resolve(l).then((function(t){c.value=t,a(c)}),(function(t){return r("throw",t,a,u)}))}u(s.arg)}var o;this._invoke=function(t,n){function i(){return new e((function(e,o){r(t,n,e,o)}))}return o=o?o.then(i,i):i()}}function x(t,r){var n=t.iterator[r.method];if(n===e){if(r.delegate=null,"throw"===r.method){if(t.iterator.return&&(r.method="return",r.arg=e,x(t,r),"throw"===r.method))return y;r.method="throw",r.arg=new TypeError("The iterator does not provide a 'throw' method")}return y}var o=f(n,t.iterator,r.arg);if("throw"===o.type)return r.method="throw",r.arg=o.arg,r.delegate=null,y;var i=o.arg;return i?i.done?(r[t.resultName]=i.value,r.next=t.nextLoc,"return"!==r.method&&(r.method="next",r.arg=e),r.delegate=null,y):i:(r.method="throw",r.arg=new TypeError("iterator result is not an object"),r.delegate=null,y)}function R(t){var e={tryLoc:t[0]};1 in t&&(e.catchLoc=t[1]),2 in t&&(e.finallyLoc=t[2],e.afterLoc=t[3]),this.tryEntries.push(e)}function T(t){var e=t.completion||{};e.type="normal",delete e.arg,t.completion=e}function k(t){this.tryEntries=[{tryLoc:"root"}],t.forEach(R,this),this.reset(!0)}function P(t){if(t){var r=t[i];if(r)return r.call(t);if("function"==typeof t.next)return t;if(!isNaN(t.length)){var o=-1,a=function r(){for(;++o<t.length;)if(n.call(t,o))return r.value=t[o],r.done=!1,r;return r.value=e,r.done=!0,r};return a.next=a}}return{next:j}}function j(){return{value:e,done:!0}}return b.prototype=m,s(S,"constructor",m),s(m,"constructor",b),b.displayName=s(m,u,"GeneratorFunction"),t.isGeneratorFunction=function(t){var e="function"==typeof t&&t.constructor;return!!e&&(e===b||"GeneratorFunction"===(e.displayName||e.name))},t.mark=function(t){return Object.setPrototypeOf?Object.setPrototypeOf(t,m):(t.__proto__=m,s(t,u,"GeneratorFunction")),t.prototype=Object.create(S),t},t.awrap=function(t){return{__await:t}},E(O.prototype),s(O.prototype,a,(function(){return this})),t.AsyncIterator=O,t.async=function(e,r,n,o,i){void 0===i&&(i=Promise);var a=new O(c(e,r,n,o),i);return t.isGeneratorFunction(r)?a:a.next().then((function(t){return t.done?t.value:a.next()}))},E(S),s(S,u,"Generator"),s(S,i,(function(){return this})),s(S,"toString",(function(){return"[object Generator]"})),t.keys=function(t){var e=[];for(var r in t)e.push(r);return e.reverse(),function r(){for(;e.length;){var n=e.pop();if(n in t)return r.value=n,r.done=!1,r}return r.done=!0,r}},t.values=P,k.prototype={constructor:k,reset:function(t){if(this.prev=0,this.next=0,this.sent=this._sent=e,this.done=!1,this.delegate=null,this.method="next",this.arg=e,this.tryEntries.forEach(T),!t)for(var r in this)"t"===r.charAt(0)&&n.call(this,r)&&!isNaN(+r.slice(1))&&(this[r]=e)},stop:function(){this.done=!0;var t=this.tryEntries[0].completion;if("throw"===t.type)throw t.arg;return this.rval},dispatchException:function(t){if(this.done)throw t;var r=this;function o(n,o){return u.type="throw",u.arg=t,r.next=n,o&&(r.method="next",r.arg=e),!!o}for(var i=this.tryEntries.length-1;i>=0;--i){var a=this.tryEntries[i],u=a.completion;if("root"===a.tryLoc)return o("end");if(a.tryLoc<=this.prev){var s=n.call(a,"catchLoc"),c=n.call(a,"finallyLoc");if(s&&c){if(this.prev<a.catchLoc)return o(a.catchLoc,!0);if(this.prev<a.finallyLoc)return o(a.finallyLoc)}else if(s){if(this.prev<a.catchLoc)return o(a.catchLoc,!0)}else{if(!c)throw new Error("try statement without catch or finally");if(this.prev<a.finallyLoc)return o(a.finallyLoc)}}}},abrupt:function(t,e){for(var r=this.tryEntries.length-1;r>=0;--r){var o=this.tryEntries[r];if(o.tryLoc<=this.prev&&n.call(o,"finallyLoc")&&this.prev<o.finallyLoc){var i=o;break}}i&&("break"===t||"continue"===t)&&i.tryLoc<=e&&e<=i.finallyLoc&&(i=null);var a=i?i.completion:{};return a.type=t,a.arg=e,i?(this.method="next",this.next=i.finallyLoc,y):this.complete(a)},complete:function(t,e){if("throw"===t.type)throw t.arg;return"break"===t.type||"continue"===t.type?this.next=t.arg:"return"===t.type?(this.rval=this.arg=t.arg,this.method="return",this.next="end"):"normal"===t.type&&e&&(this.next=e),y},finish:function(t){for(var e=this.tryEntries.length-1;e>=0;--e){var r=this.tryEntries[e];if(r.finallyLoc===t)return this.complete(r.completion,r.afterLoc),T(r),y}},catch:function(t){for(var e=this.tryEntries.length-1;e>=0;--e){var r=this.tryEntries[e];if(r.tryLoc===t){var n=r.completion;if("throw"===n.type){var o=n.arg;T(r)}return o}}throw new Error("illegal catch attempt")},delegateYield:function(t,r,n){return this.delegate={iterator:P(t),resultName:r,nextLoc:n},"next"===this.method&&(this.arg=e),y}},t}(t.exports);try{regeneratorRuntime=e}catch(t){"object"==typeof globalThis?globalThis.regeneratorRuntime=e:Function("r","regeneratorRuntime = r")(e)}},9685:(t,e,r)=>{var n=r(7866),o=n.Buffer;function i(t,e){for(var r in t)e[r]=t[r]}function a(t,e,r){return o(t,e,r)}o.from&&o.alloc&&o.allocUnsafe&&o.allocUnsafeSlow?t.exports=n:(i(n,e),e.Buffer=a),a.prototype=Object.create(o.prototype),i(o,a),a.from=function(t,e,r){if("number"==typeof t)throw new TypeError("Argument must not be a number");return o(t,e,r)},a.alloc=function(t,e,r){if("number"!=typeof t)throw new TypeError("Argument must be a number");var n=o(t);return void 0!==e?"string"==typeof r?n.fill(e,r):n.fill(e):n.fill(0),n},a.allocUnsafe=function(t){if("number"!=typeof t)throw new TypeError("Argument must be a number");return o(t)},a.allocUnsafeSlow=function(t){if("number"!=typeof t)throw new TypeError("Argument must be a number");return n.SlowBuffer(t)}},8981:(t,e,r)=>{t.exports=o;var n=r(488).EventEmitter;function o(){n.call(this)}r(3730)(o,n),o.Readable=r(5006),o.Writable=r(8719),o.Duplex=r(673),o.Transform=r(8597),o.PassThrough=r(4343),o.finished=r(2426),o.pipeline=r(2970),o.Stream=o,o.prototype.pipe=function(t,e){var r=this;function o(e){t.writable&&!1===t.write(e)&&r.pause&&r.pause()}function i(){r.readable&&r.resume&&r.resume()}r.on("data",o),t.on("drain",i),t._isStdio||e&&!1===e.end||(r.on("end",u),r.on("close",s));var a=!1;function u(){a||(a=!0,t.end())}function s(){a||(a=!0,"function"==typeof t.destroy&&t.destroy())}function c(t){if(f(),0===n.listenerCount(this,"error"))throw t}function f(){r.removeListener("data",o),t.removeListener("drain",i),r.removeListener("end",u),r.removeListener("close",s),r.removeListener("error",c),t.removeListener("error",c),r.removeListener("end",f),r.removeListener("close",f),t.removeListener("close",f)}return r.on("error",c),t.on("error",c),r.on("end",f),r.on("close",f),t.on("close",f),t.emit("pipe",r),t}},9481:(t,e,r)=>{"use strict";var n=r(9685).Buffer,o=n.isEncoding||function(t){switch((t=""+t)&&t.toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":case"raw":return!0;default:return!1}};function i(t){var e;switch(this.encoding=function(t){var e=function(t){if(!t)return"utf8";for(var e;;)switch(t){case"utf8":case"utf-8":return"utf8";case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return"utf16le";case"latin1":case"binary":return"latin1";case"base64":case"ascii":case"hex":return t;default:if(e)return;t=(""+t).toLowerCase(),e=!0}}(t);if("string"!=typeof e&&(n.isEncoding===o||!o(t)))throw new Error("Unknown encoding: "+t);return e||t}(t),this.encoding){case"utf16le":this.text=s,this.end=c,e=4;break;case"utf8":this.fillLast=u,e=4;break;case"base64":this.text=f,this.end=l,e=3;break;default:return this.write=p,void(this.end=h)}this.lastNeed=0,this.lastTotal=0,this.lastChar=n.allocUnsafe(e)}function a(t){return t<=127?0:t>>5==6?2:t>>4==14?3:t>>3==30?4:t>>6==2?-1:-2}function u(t){var e=this.lastTotal-this.lastNeed,r=function(t,e,r){if(128!=(192&e[0]))return t.lastNeed=0,"";if(t.lastNeed>1&&e.length>1){if(128!=(192&e[1]))return t.lastNeed=1,"";if(t.lastNeed>2&&e.length>2&&128!=(192&e[2]))return t.lastNeed=2,""}}(this,t);return void 0!==r?r:this.lastNeed<=t.length?(t.copy(this.lastChar,e,0,this.lastNeed),this.lastChar.toString(this.encoding,0,this.lastTotal)):(t.copy(this.lastChar,e,0,t.length),void(this.lastNeed-=t.length))}function s(t,e){if((t.length-e)%2==0){var r=t.toString("utf16le",e);if(r){var n=r.charCodeAt(r.length-1);if(n>=55296&&n<=56319)return this.lastNeed=2,this.lastTotal=4,this.lastChar[0]=t[t.length-2],this.lastChar[1]=t[t.length-1],r.slice(0,-1)}return r}return this.lastNeed=1,this.lastTotal=2,this.lastChar[0]=t[t.length-1],t.toString("utf16le",e,t.length-1)}function c(t){var e=t&&t.length?this.write(t):"";if(this.lastNeed){var r=this.lastTotal-this.lastNeed;return e+this.lastChar.toString("utf16le",0,r)}return e}function f(t,e){var r=(t.length-e)%3;return 0===r?t.toString("base64",e):(this.lastNeed=3-r,this.lastTotal=3,1===r?this.lastChar[0]=t[t.length-1]:(this.lastChar[0]=t[t.length-2],this.lastChar[1]=t[t.length-1]),t.toString("base64",e,t.length-r))}function l(t){var e=t&&t.length?this.write(t):"";return this.lastNeed?e+this.lastChar.toString("base64",0,3-this.lastNeed):e}function p(t){return t.toString(this.encoding)}function h(t){return t&&t.length?this.write(t):""}e.s=i,i.prototype.write=function(t){if(0===t.length)return"";var e,r;if(this.lastNeed){if(void 0===(e=this.fillLast(t)))return"";r=this.lastNeed,this.lastNeed=0}else r=0;return r<t.length?e?e+this.text(t,r):this.text(t,r):e||""},i.prototype.end=function(t){var e=t&&t.length?this.write(t):"";return this.lastNeed?e+"":e},i.prototype.text=function(t,e){var r=function(t,e,r){var n=e.length-1;if(n<r)return 0;var o=a(e[n]);return o>=0?(o>0&&(t.lastNeed=o-1),o):--n<r||-2===o?0:(o=a(e[n]))>=0?(o>0&&(t.lastNeed=o-2),o):--n<r||-2===o?0:(o=a(e[n]))>=0?(o>0&&(2===o?o=0:t.lastNeed=o-3),o):0}(this,t,e);if(!this.lastNeed)return t.toString("utf8",e);this.lastTotal=r;var n=t.length-(r-this.lastNeed);return t.copy(this.lastChar,0,n),t.toString("utf8",e,n)},i.prototype.fillLast=function(t){if(this.lastNeed<=t.length)return t.copy(this.lastChar,this.lastTotal-this.lastNeed,0,this.lastNeed),this.lastChar.toString(this.encoding,0,this.lastTotal);t.copy(this.lastChar,this.lastTotal-this.lastNeed,0,t.length),this.lastNeed-=t.length}},2993:(t,e)=>{"use strict";var r=function(){function t(){this._state=new Int32Array(4),this._buffer=new ArrayBuffer(68),this._buffer8=new Uint8Array(this._buffer,0,68),this._buffer32=new Uint32Array(this._buffer,0,17),this.start()}return t.hashStr=function(t,e){return void 0===e&&(e=!1),this.onePassHasher.start().appendStr(t).end(e)},t.hashAsciiStr=function(t,e){return void 0===e&&(e=!1),this.onePassHasher.start().appendAsciiStr(t).end(e)},t._hex=function(e){var r,n,o,i,a=t.hexChars,u=t.hexOut;for(i=0;i<4;i+=1)for(n=8*i,r=e[i],o=0;o<8;o+=2)u[n+1+o]=a.charAt(15&r),r>>>=4,u[n+0+o]=a.charAt(15&r),r>>>=4;return u.join("")},t._md5cycle=function(t,e){var r=t[0],n=t[1],o=t[2],i=t[3];n=((n+=((o=((o+=((i=((i+=((r=((r+=(n&o|~n&i)+e[0]-680876936|0)<<7|r>>>25)+n|0)&n|~r&o)+e[1]-389564586|0)<<12|i>>>20)+r|0)&r|~i&n)+e[2]+606105819|0)<<17|o>>>15)+i|0)&i|~o&r)+e[3]-1044525330|0)<<22|n>>>10)+o|0,n=((n+=((o=((o+=((i=((i+=((r=((r+=(n&o|~n&i)+e[4]-176418897|0)<<7|r>>>25)+n|0)&n|~r&o)+e[5]+1200080426|0)<<12|i>>>20)+r|0)&r|~i&n)+e[6]-1473231341|0)<<17|o>>>15)+i|0)&i|~o&r)+e[7]-45705983|0)<<22|n>>>10)+o|0,n=((n+=((o=((o+=((i=((i+=((r=((r+=(n&o|~n&i)+e[8]+1770035416|0)<<7|r>>>25)+n|0)&n|~r&o)+e[9]-1958414417|0)<<12|i>>>20)+r|0)&r|~i&n)+e[10]-42063|0)<<17|o>>>15)+i|0)&i|~o&r)+e[11]-1990404162|0)<<22|n>>>10)+o|0,n=((n+=((o=((o+=((i=((i+=((r=((r+=(n&o|~n&i)+e[12]+1804603682|0)<<7|r>>>25)+n|0)&n|~r&o)+e[13]-40341101|0)<<12|i>>>20)+r|0)&r|~i&n)+e[14]-1502002290|0)<<17|o>>>15)+i|0)&i|~o&r)+e[15]+1236535329|0)<<22|n>>>10)+o|0,n=((n+=((o=((o+=((i=((i+=((r=((r+=(n&i|o&~i)+e[1]-165796510|0)<<5|r>>>27)+n|0)&o|n&~o)+e[6]-1069501632|0)<<9|i>>>23)+r|0)&n|r&~n)+e[11]+643717713|0)<<14|o>>>18)+i|0)&r|i&~r)+e[0]-373897302|0)<<20|n>>>12)+o|0,n=((n+=((o=((o+=((i=((i+=((r=((r+=(n&i|o&~i)+e[5]-701558691|0)<<5|r>>>27)+n|0)&o|n&~o)+e[10]+38016083|0)<<9|i>>>23)+r|0)&n|r&~n)+e[15]-660478335|0)<<14|o>>>18)+i|0)&r|i&~r)+e[4]-405537848|0)<<20|n>>>12)+o|0,n=((n+=((o=((o+=((i=((i+=((r=((r+=(n&i|o&~i)+e[9]+568446438|0)<<5|r>>>27)+n|0)&o|n&~o)+e[14]-1019803690|0)<<9|i>>>23)+r|0)&n|r&~n)+e[3]-187363961|0)<<14|o>>>18)+i|0)&r|i&~r)+e[8]+1163531501|0)<<20|n>>>12)+o|0,n=((n+=((o=((o+=((i=((i+=((r=((r+=(n&i|o&~i)+e[13]-1444681467|0)<<5|r>>>27)+n|0)&o|n&~o)+e[2]-51403784|0)<<9|i>>>23)+r|0)&n|r&~n)+e[7]+1735328473|0)<<14|o>>>18)+i|0)&r|i&~r)+e[12]-1926607734|0)<<20|n>>>12)+o|0,n=((n+=((o=((o+=((i=((i+=((r=((r+=(n^o^i)+e[5]-378558|0)<<4|r>>>28)+n|0)^n^o)+e[8]-2022574463|0)<<11|i>>>21)+r|0)^r^n)+e[11]+1839030562|0)<<16|o>>>16)+i|0)^i^r)+e[14]-35309556|0)<<23|n>>>9)+o|0,n=((n+=((o=((o+=((i=((i+=((r=((r+=(n^o^i)+e[1]-1530992060|0)<<4|r>>>28)+n|0)^n^o)+e[4]+1272893353|0)<<11|i>>>21)+r|0)^r^n)+e[7]-155497632|0)<<16|o>>>16)+i|0)^i^r)+e[10]-1094730640|0)<<23|n>>>9)+o|0,n=((n+=((o=((o+=((i=((i+=((r=((r+=(n^o^i)+e[13]+681279174|0)<<4|r>>>28)+n|0)^n^o)+e[0]-358537222|0)<<11|i>>>21)+r|0)^r^n)+e[3]-722521979|0)<<16|o>>>16)+i|0)^i^r)+e[6]+76029189|0)<<23|n>>>9)+o|0,n=((n+=((o=((o+=((i=((i+=((r=((r+=(n^o^i)+e[9]-640364487|0)<<4|r>>>28)+n|0)^n^o)+e[12]-421815835|0)<<11|i>>>21)+r|0)^r^n)+e[15]+530742520|0)<<16|o>>>16)+i|0)^i^r)+e[2]-995338651|0)<<23|n>>>9)+o|0,n=((n+=((i=((i+=(n^((r=((r+=(o^(n|~i))+e[0]-198630844|0)<<6|r>>>26)+n|0)|~o))+e[7]+1126891415|0)<<10|i>>>22)+r|0)^((o=((o+=(r^(i|~n))+e[14]-1416354905|0)<<15|o>>>17)+i|0)|~r))+e[5]-57434055|0)<<21|n>>>11)+o|0,n=((n+=((i=((i+=(n^((r=((r+=(o^(n|~i))+e[12]+1700485571|0)<<6|r>>>26)+n|0)|~o))+e[3]-1894986606|0)<<10|i>>>22)+r|0)^((o=((o+=(r^(i|~n))+e[10]-1051523|0)<<15|o>>>17)+i|0)|~r))+e[1]-2054922799|0)<<21|n>>>11)+o|0,n=((n+=((i=((i+=(n^((r=((r+=(o^(n|~i))+e[8]+1873313359|0)<<6|r>>>26)+n|0)|~o))+e[15]-30611744|0)<<10|i>>>22)+r|0)^((o=((o+=(r^(i|~n))+e[6]-1560198380|0)<<15|o>>>17)+i|0)|~r))+e[13]+1309151649|0)<<21|n>>>11)+o|0,n=((n+=((i=((i+=(n^((r=((r+=(o^(n|~i))+e[4]-145523070|0)<<6|r>>>26)+n|0)|~o))+e[11]-1120210379|0)<<10|i>>>22)+r|0)^((o=((o+=(r^(i|~n))+e[2]+718787259|0)<<15|o>>>17)+i|0)|~r))+e[9]-343485551|0)<<21|n>>>11)+o|0,t[0]=r+t[0]|0,t[1]=n+t[1]|0,t[2]=o+t[2]|0,t[3]=i+t[3]|0},t.prototype.start=function(){return this._dataLength=0,this._bufferLength=0,this._state.set(t.stateIdentity),this},t.prototype.appendStr=function(e){var r,n,o=this._buffer8,i=this._buffer32,a=this._bufferLength;for(n=0;n<e.length;n+=1){if((r=e.charCodeAt(n))<128)o[a++]=r;else if(r<2048)o[a++]=192+(r>>>6),o[a++]=63&r|128;else if(r<55296||r>56319)o[a++]=224+(r>>>12),o[a++]=r>>>6&63|128,o[a++]=63&r|128;else{if((r=1024*(r-55296)+(e.charCodeAt(++n)-56320)+65536)>1114111)throw new Error("Unicode standard supports code points up to U+10FFFF");o[a++]=240+(r>>>18),o[a++]=r>>>12&63|128,o[a++]=r>>>6&63|128,o[a++]=63&r|128}a>=64&&(this._dataLength+=64,t._md5cycle(this._state,i),a-=64,i[0]=i[16])}return this._bufferLength=a,this},t.prototype.appendAsciiStr=function(e){for(var r,n=this._buffer8,o=this._buffer32,i=this._bufferLength,a=0;;){for(r=Math.min(e.length-a,64-i);r--;)n[i++]=e.charCodeAt(a++);if(i<64)break;this._dataLength+=64,t._md5cycle(this._state,o),i=0}return this._bufferLength=i,this},t.prototype.appendByteArray=function(e){for(var r,n=this._buffer8,o=this._buffer32,i=this._bufferLength,a=0;;){for(r=Math.min(e.length-a,64-i);r--;)n[i++]=e[a++];if(i<64)break;this._dataLength+=64,t._md5cycle(this._state,o),i=0}return this._bufferLength=i,this},t.prototype.getState=function(){var t=this,e=t._state;return{buffer:String.fromCharCode.apply(null,t._buffer8),buflen:t._bufferLength,length:t._dataLength,state:[e[0],e[1],e[2],e[3]]}},t.prototype.setState=function(t){var e,r=t.buffer,n=t.state,o=this._state;for(this._dataLength=t.length,this._bufferLength=t.buflen,o[0]=n[0],o[1]=n[1],o[2]=n[2],o[3]=n[3],e=0;e<r.length;e+=1)this._buffer8[e]=r.charCodeAt(e)},t.prototype.end=function(e){void 0===e&&(e=!1);var r,n=this._bufferLength,o=this._buffer8,i=this._buffer32,a=1+(n>>2);if(this._dataLength+=n,o[n]=128,o[n+1]=o[n+2]=o[n+3]=0,i.set(t.buffer32Identity.subarray(a),a),n>55&&(t._md5cycle(this._state,i),i.set(t.buffer32Identity)),(r=8*this._dataLength)<=4294967295)i[14]=r;else{var u=r.toString(16).match(/(.*?)(.{0,8})$/);if(null===u)return;var s=parseInt(u[2],16),c=parseInt(u[1],16)||0;i[14]=s,i[15]=c}return t._md5cycle(this._state,i),e?this._state:t._hex(this._state)},t.stateIdentity=new Int32Array([1732584193,-271733879,-1732584194,271733878]),t.buffer32Identity=new Int32Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]),t.hexChars="0123456789abcdef",t.hexOut=[],t.onePassHasher=new t,t}();e.V=r,"5d41402abc4b2a76b9719d911017c592"!==r.hashStr("hello")&&console.error("Md5 self test failed.")},72:(t,e,r)=>{function n(t){try{if(!r.g.localStorage)return!1}catch(t){return!1}var e=r.g.localStorage[t];return null!=e&&"true"===String(e).toLowerCase()}t.exports=function(t,e){if(n("noDeprecation"))return t;var r=!1;return function(){if(!r){if(n("throwDeprecation"))throw new Error(e);n("traceDeprecation")?console.trace(e):console.warn(e),r=!0}return t.apply(this,arguments)}}},769:t=>{t.exports=function(t){if("function"!=typeof t)throw TypeError(String(t)+" is not a function");return t}},8143:(t,e,r)=>{var n=r(6944);t.exports=function(t){if(!n(t)&&null!==t)throw TypeError("Can't set "+String(t)+" as a prototype");return t}},9611:(t,e,r)=>{var n=r(3706),o=r(2361),i=r(3376),a=n("unscopables"),u=Array.prototype;null==u[a]&&i.f(u,a,{configurable:!0,value:o(null)}),t.exports=function(t){u[a][t]=!0}},1866:(t,e,r)=>{"use strict";var n=r(6174).charAt;t.exports=function(t,e,r){return e+(r?n(t,e).length:1)}},2482:t=>{t.exports=function(t,e,r){if(!(t instanceof e))throw TypeError("Incorrect "+(r?r+" ":"")+"invocation");return t}},47:(t,e,r)=>{var n=r(6944);t.exports=function(t){if(!n(t))throw TypeError(String(t)+" is not an object");return t}},6321:t=>{t.exports="undefined"!=typeof ArrayBuffer&&"undefined"!=typeof DataView},2211:(t,e,r)=>{"use strict";var n,o,i,a=r(6321),u=r(5542),s=r(6874),c=r(6944),f=r(5884),l=r(8753),p=r(4791),h=r(1249),d=r(3376).f,y=r(8186),v=r(2686),b=r(3706),m=r(8435),g=s.Int8Array,w=g&&g.prototype,_=s.Uint8ClampedArray,S=_&&_.prototype,E=g&&y(g),O=w&&y(w),x=Object.prototype,R=x.isPrototypeOf,T=b("toStringTag"),k=m("TYPED_ARRAY_TAG"),P=m("TYPED_ARRAY_CONSTRUCTOR"),j=a&&!!v&&"Opera"!==l(s.opera),A=!1,C={Int8Array:1,Uint8Array:1,Uint8ClampedArray:1,Int16Array:2,Uint16Array:2,Int32Array:4,Uint32Array:4,Float32Array:4,Float64Array:8},I={BigInt64Array:8,BigUint64Array:8},L=function(t){if(!c(t))return!1;var e=l(t);return f(C,e)||f(I,e)};for(n in C)(i=(o=s[n])&&o.prototype)?p(i,P,o):j=!1;for(n in I)(i=(o=s[n])&&o.prototype)&&p(i,P,o);if((!j||"function"!=typeof E||E===Function.prototype)&&(E=function(){throw TypeError("Incorrect invocation")},j))for(n in C)s[n]&&v(s[n],E);if((!j||!O||O===x)&&(O=E.prototype,j))for(n in C)s[n]&&v(s[n].prototype,O);if(j&&y(S)!==O&&v(S,O),u&&!f(O,T))for(n in A=!0,d(O,T,{get:function(){return c(this)?this[k]:void 0}}),C)s[n]&&p(s[n],k,n);t.exports={NATIVE_ARRAY_BUFFER_VIEWS:j,TYPED_ARRAY_CONSTRUCTOR:P,TYPED_ARRAY_TAG:A&&k,aTypedArray:function(t){if(L(t))return t;throw TypeError("Target is not a typed array")},aTypedArrayConstructor:function(t){if(v&&!R.call(E,t))throw TypeError("Target is not a typed array constructor");return t},exportTypedArrayMethod:function(t,e,r){if(u){if(r)for(var n in C){var o=s[n];if(o&&f(o.prototype,t))try{delete o.prototype[t]}catch(t){}}O[t]&&!r||h(O,t,r?e:j&&w[t]||e)}},exportTypedArrayStaticMethod:function(t,e,r){var n,o;if(u){if(v){if(r)for(n in C)if((o=s[n])&&f(o,t))try{delete o[t]}catch(t){}if(E[t]&&!r)return;try{return h(E,t,r?e:j&&E[t]||e)}catch(t){}}for(n in C)!(o=s[n])||o[t]&&!r||h(o,t,e)}},isView:function(t){if(!c(t))return!1;var e=l(t);return"DataView"===e||f(C,e)||f(I,e)},isTypedArray:L,TypedArray:E,TypedArrayPrototype:O}},6594:(t,e,r)=>{"use strict";var n=r(6874),o=r(5542),i=r(6321),a=r(4791),u=r(7490),s=r(7841),c=r(2482),f=r(7896),l=r(4954),p=r(5513),h=r(6227),d=r(8186),y=r(2686),v=r(8401).f,b=r(3376).f,m=r(7515),g=r(9400),w=r(6619),_=w.get,S=w.set,E="ArrayBuffer",O="DataView",x="Wrong index",R=n.ArrayBuffer,T=R,k=n.DataView,P=k&&k.prototype,j=Object.prototype,A=n.RangeError,C=h.pack,I=h.unpack,L=function(t){return[255&t]},B=function(t){return[255&t,t>>8&255]},M=function(t){return[255&t,t>>8&255,t>>16&255,t>>24&255]},U=function(t){return t[3]<<24|t[2]<<16|t[1]<<8|t[0]},N=function(t){return C(t,23,4)},D=function(t){return C(t,52,8)},F=function(t,e){b(t.prototype,e,{get:function(){return _(this)[e]}})},q=function(t,e,r,n){var o=p(r),i=_(t);if(o+e>i.byteLength)throw A(x);var a=_(i.buffer).bytes,u=o+i.byteOffset,s=a.slice(u,u+e);return n?s:s.reverse()},H=function(t,e,r,n,o,i){var a=p(r),u=_(t);if(a+e>u.byteLength)throw A(x);for(var s=_(u.buffer).bytes,c=a+u.byteOffset,f=n(+o),l=0;l<e;l++)s[c+l]=f[i?l:e-l-1]};if(i){if(!s((function(){R(1)}))||!s((function(){new R(-1)}))||s((function(){return new R,new R(1.5),new R(NaN),R.name!=E}))){for(var W,z=(T=function(t){return c(this,T),new R(p(t))}).prototype=R.prototype,V=v(R),G=0;V.length>G;)(W=V[G++])in T||a(T,W,R[W]);z.constructor=T}y&&d(P)!==j&&y(P,j);var $=new k(new T(2)),Y=P.setInt8;$.setInt8(0,2147483648),$.setInt8(1,2147483649),!$.getInt8(0)&&$.getInt8(1)||u(P,{setInt8:function(t,e){Y.call(this,t,e<<24>>24)},setUint8:function(t,e){Y.call(this,t,e<<24>>24)}},{unsafe:!0})}else T=function(t){c(this,T,E);var e=p(t);S(this,{bytes:m.call(new Array(e),0),byteLength:e}),o||(this.byteLength=e)},k=function(t,e,r){c(this,k,O),c(t,T,O);var n=_(t).byteLength,i=f(e);if(i<0||i>n)throw A("Wrong offset");if(i+(r=void 0===r?n-i:l(r))>n)throw A("Wrong length");S(this,{buffer:t,byteLength:r,byteOffset:i}),o||(this.buffer=t,this.byteLength=r,this.byteOffset=i)},o&&(F(T,"byteLength"),F(k,"buffer"),F(k,"byteLength"),F(k,"byteOffset")),u(k.prototype,{getInt8:function(t){return q(this,1,t)[0]<<24>>24},getUint8:function(t){return q(this,1,t)[0]},getInt16:function(t){var e=q(this,2,t,arguments.length>1?arguments[1]:void 0);return(e[1]<<8|e[0])<<16>>16},getUint16:function(t){var e=q(this,2,t,arguments.length>1?arguments[1]:void 0);return e[1]<<8|e[0]},getInt32:function(t){return U(q(this,4,t,arguments.length>1?arguments[1]:void 0))},getUint32:function(t){return U(q(this,4,t,arguments.length>1?arguments[1]:void 0))>>>0},getFloat32:function(t){return I(q(this,4,t,arguments.length>1?arguments[1]:void 0),23)},getFloat64:function(t){return I(q(this,8,t,arguments.length>1?arguments[1]:void 0),52)},setInt8:function(t,e){H(this,1,t,L,e)},setUint8:function(t,e){H(this,1,t,L,e)},setInt16:function(t,e){H(this,2,t,B,e,arguments.length>2?arguments[2]:void 0)},setUint16:function(t,e){H(this,2,t,B,e,arguments.length>2?arguments[2]:void 0)},setInt32:function(t,e){H(this,4,t,M,e,arguments.length>2?arguments[2]:void 0)},setUint32:function(t,e){H(this,4,t,M,e,arguments.length>2?arguments[2]:void 0)},setFloat32:function(t,e){H(this,4,t,N,e,arguments.length>2?arguments[2]:void 0)},setFloat64:function(t,e){H(this,8,t,D,e,arguments.length>2?arguments[2]:void 0)}});g(T,E),g(k,O),t.exports={ArrayBuffer:T,DataView:k}},2116:(t,e,r)=>{"use strict";var n=r(4680),o=r(2145),i=r(4954),a=Math.min;t.exports=[].copyWithin||function(t,e){var r=n(this),u=i(r.length),s=o(t,u),c=o(e,u),f=arguments.length>2?arguments[2]:void 0,l=a((void 0===f?u:o(f,u))-c,u-s),p=1;for(c<s&&s<c+l&&(p=-1,c+=l-1,s+=l-1);l-- >0;)c in r?r[s]=r[c]:delete r[s],s+=p,c+=p;return r}},7515:(t,e,r)=>{"use strict";var n=r(4680),o=r(2145),i=r(4954);t.exports=function(t){for(var e=n(this),r=i(e.length),a=arguments.length,u=o(a>1?arguments[1]:void 0,r),s=a>2?arguments[2]:void 0,c=void 0===s?r:o(s,r);c>u;)e[u++]=t;return e}},1244:(t,e,r)=>{"use strict";var n=r(6374).forEach,o=r(622)("forEach");t.exports=o?[].forEach:function(t){return n(this,t,arguments.length>1?arguments[1]:void 0)}},4413:t=>{t.exports=function(t,e){for(var r=0,n=e.length,o=new t(n);n>r;)o[r]=e[r++];return o}},1774:(t,e,r)=>{"use strict";var n=r(4833),o=r(4680),i=r(3960),a=r(1008),u=r(4954),s=r(2076),c=r(3126);t.exports=function(t){var e,r,f,l,p,h,d=o(t),y="function"==typeof this?this:Array,v=arguments.length,b=v>1?arguments[1]:void 0,m=void 0!==b,g=c(d),w=0;if(m&&(b=n(b,v>2?arguments[2]:void 0,2)),null==g||y==Array&&a(g))for(r=new y(e=u(d.length));e>w;w++)h=m?b(d[w],w):d[w],s(r,w,h);else for(p=(l=g.call(d)).next,r=new y;!(f=p.call(l)).done;w++)h=m?i(l,b,[f.value,w],!0):f.value,s(r,w,h);return r.length=w,r}},1270:(t,e,r)=>{var n=r(8852),o=r(4954),i=r(2145),a=function(t){return function(e,r,a){var u,s=n(e),c=o(s.length),f=i(a,c);if(t&&r!=r){for(;c>f;)if((u=s[f++])!=u)return!0}else for(;c>f;f++)if((t||f in s)&&s[f]===r)return t||f||0;return!t&&-1}};t.exports={includes:a(!0),indexOf:a(!1)}},6374:(t,e,r)=>{var n=r(4833),o=r(7361),i=r(4680),a=r(4954),u=r(68),s=[].push,c=function(t){var e=1==t,r=2==t,c=3==t,f=4==t,l=6==t,p=7==t,h=5==t||l;return function(d,y,v,b){for(var m,g,w=i(d),_=o(w),S=n(y,v,3),E=a(_.length),O=0,x=b||u,R=e?x(d,E):r||p?x(d,0):void 0;E>O;O++)if((h||O in _)&&(g=S(m=_[O],O,w),t))if(e)R[O]=g;else if(g)switch(t){case 3:return!0;case 5:return m;case 6:return O;case 2:s.call(R,m)}else switch(t){case 4:return!1;case 7:s.call(R,m)}return l?-1:c||f?f:R}};t.exports={forEach:c(0),map:c(1),filter:c(2),some:c(3),every:c(4),find:c(5),findIndex:c(6),filterReject:c(7)}},16:(t,e,r)=>{"use strict";var n=r(8852),o=r(7896),i=r(4954),a=r(622),u=Math.min,s=[].lastIndexOf,c=!!s&&1/[1].lastIndexOf(1,-0)<0,f=a("lastIndexOf"),l=c||!f;t.exports=l?function(t){if(c)return s.apply(this,arguments)||0;var e=n(this),r=i(e.length),a=r-1;for(arguments.length>1&&(a=u(a,o(arguments[1]))),a<0&&(a=r+a);a>=0;a--)if(a in e&&e[a]===t)return a||0;return-1}:s},6937:(t,e,r)=>{var n=r(7841),o=r(3706),i=r(579),a=o("species");t.exports=function(t){return i>=51||!n((function(){var e=[];return(e.constructor={})[a]=function(){return{foo:1}},1!==e[t](Boolean).foo}))}},622:(t,e,r)=>{"use strict";var n=r(7841);t.exports=function(t,e){var r=[][t];return!!r&&n((function(){r.call(null,e||function(){throw 1},1)}))}},9553:(t,e,r)=>{var n=r(769),o=r(4680),i=r(7361),a=r(4954),u=function(t){return function(e,r,u,s){n(r);var c=o(e),f=i(c),l=a(c.length),p=t?l-1:0,h=t?-1:1;if(u<2)for(;;){if(p in f){s=f[p],p+=h;break}if(p+=h,t?p<0:l<=p)throw TypeError("Reduce of empty array with no initial value")}for(;t?p>=0:l>p;p+=h)p in f&&(s=r(s,f[p],p,c));return s}};t.exports={left:u(!1),right:u(!0)}},7921:t=>{var e=Math.floor,r=function(t,i){var a=t.length,u=e(a/2);return a<8?n(t,i):o(r(t.slice(0,u),i),r(t.slice(u),i),i)},n=function(t,e){for(var r,n,o=t.length,i=1;i<o;){for(n=i,r=t[i];n&&e(t[n-1],r)>0;)t[n]=t[--n];n!==i++&&(t[n]=r)}return t},o=function(t,e,r){for(var n=t.length,o=e.length,i=0,a=0,u=[];i<n||a<o;)i<n&&a<o?u.push(r(t[i],e[a])<=0?t[i++]:e[a++]):u.push(i<n?t[i++]:e[a++]);return u};t.exports=r},7082:(t,e,r)=>{var n=r(6944),o=r(7828),i=r(3706)("species");t.exports=function(t){var e;return o(t)&&("function"!=typeof(e=t.constructor)||e!==Array&&!o(e.prototype)?n(e)&&null===(e=e[i])&&(e=void 0):e=void 0),void 0===e?Array:e}},68:(t,e,r)=>{var n=r(7082);t.exports=function(t,e){return new(n(t))(0===e?0:e)}},3960:(t,e,r)=>{var n=r(47),o=r(2608);t.exports=function(t,e,r,i){try{return i?e(n(r)[0],r[1]):e(r)}catch(e){throw o(t),e}}},4585:(t,e,r)=>{var n=r(3706)("iterator"),o=!1;try{var i=0,a={next:function(){return{done:!!i++}},return:function(){o=!0}};a[n]=function(){return this},Array.from(a,(function(){throw 2}))}catch(t){}t.exports=function(t,e){if(!e&&!o)return!1;var r=!1;try{var i={};i[n]=function(){return{next:function(){return{done:r=!0}}}},t(i)}catch(t){}return r}},3565:t=>{var e={}.toString;t.exports=function(t){return e.call(t).slice(8,-1)}},8753:(t,e,r)=>{var n=r(939),o=r(3565),i=r(3706)("toStringTag"),a="Arguments"==o(function(){return arguments}());t.exports=n?o:function(t){var e,r,n;return void 0===t?"Undefined":null===t?"Null":"string"==typeof(r=function(t,e){try{return t[e]}catch(t){}}(e=Object(t),i))?r:a?o(e):"Object"==(n=o(e))&&"function"==typeof e.callee?"Arguments":n}},6955:(t,e,r)=>{"use strict";var n=r(3376).f,o=r(2361),i=r(7490),a=r(4833),u=r(2482),s=r(7093),c=r(3131),f=r(8802),l=r(5542),p=r(28).fastKey,h=r(6619),d=h.set,y=h.getterFor;t.exports={getConstructor:function(t,e,r,c){var f=t((function(t,n){u(t,f,e),d(t,{type:e,index:o(null),first:void 0,last:void 0,size:0}),l||(t.size=0),null!=n&&s(n,t[c],{that:t,AS_ENTRIES:r})})),h=y(e),v=function(t,e,r){var n,o,i=h(t),a=b(t,e);return a?a.value=r:(i.last=a={index:o=p(e,!0),key:e,value:r,previous:n=i.last,next:void 0,removed:!1},i.first||(i.first=a),n&&(n.next=a),l?i.size++:t.size++,"F"!==o&&(i.index[o]=a)),t},b=function(t,e){var r,n=h(t),o=p(e);if("F"!==o)return n.index[o];for(r=n.first;r;r=r.next)if(r.key==e)return r};return i(f.prototype,{clear:function(){for(var t=h(this),e=t.index,r=t.first;r;)r.removed=!0,r.previous&&(r.previous=r.previous.next=void 0),delete e[r.index],r=r.next;t.first=t.last=void 0,l?t.size=0:this.size=0},delete:function(t){var e=this,r=h(e),n=b(e,t);if(n){var o=n.next,i=n.previous;delete r.index[n.index],n.removed=!0,i&&(i.next=o),o&&(o.previous=i),r.first==n&&(r.first=o),r.last==n&&(r.last=i),l?r.size--:e.size--}return!!n},forEach:function(t){for(var e,r=h(this),n=a(t,arguments.length>1?arguments[1]:void 0,3);e=e?e.next:r.first;)for(n(e.value,e.key,this);e&&e.removed;)e=e.previous},has:function(t){return!!b(this,t)}}),i(f.prototype,r?{get:function(t){var e=b(this,t);return e&&e.value},set:function(t,e){return v(this,0===t?0:t,e)}}:{add:function(t){return v(this,t=0===t?0:t,t)}}),l&&n(f.prototype,"size",{get:function(){return h(this).size}}),f},setStrong:function(t,e,r){var n=e+" Iterator",o=y(e),i=y(n);c(t,e,(function(t,e){d(this,{type:n,target:t,state:o(t),kind:e,last:void 0})}),(function(){for(var t=i(this),e=t.kind,r=t.last;r&&r.removed;)r=r.previous;return t.target&&(t.last=r=r?r.next:t.state.first)?"keys"==e?{value:r.key,done:!1}:"values"==e?{value:r.value,done:!1}:{value:[r.key,r.value],done:!1}:(t.target=void 0,{value:void 0,done:!0})}),r?"entries":"values",!r,!0),f(e)}}},6935:(t,e,r)=>{"use strict";var n=r(1082),o=r(6874),i=r(2350),a=r(1249),u=r(28),s=r(7093),c=r(2482),f=r(6944),l=r(7841),p=r(4585),h=r(9400),d=r(4029);t.exports=function(t,e,r){var y=-1!==t.indexOf("Map"),v=-1!==t.indexOf("Weak"),b=y?"set":"add",m=o[t],g=m&&m.prototype,w=m,_={},S=function(t){var e=g[t];a(g,t,"add"==t?function(t){return e.call(this,0===t?0:t),this}:"delete"==t?function(t){return!(v&&!f(t))&&e.call(this,0===t?0:t)}:"get"==t?function(t){return v&&!f(t)?void 0:e.call(this,0===t?0:t)}:"has"==t?function(t){return!(v&&!f(t))&&e.call(this,0===t?0:t)}:function(t,r){return e.call(this,0===t?0:t,r),this})};if(i(t,"function"!=typeof m||!(v||g.forEach&&!l((function(){(new m).entries().next()})))))w=r.getConstructor(e,t,y,b),u.enable();else if(i(t,!0)){var E=new w,O=E[b](v?{}:-0,1)!=E,x=l((function(){E.has(1)})),R=p((function(t){new m(t)})),T=!v&&l((function(){for(var t=new m,e=5;e--;)t[b](e,e);return!t.has(-0)}));R||((w=e((function(e,r){c(e,w,t);var n=d(new m,e,w);return null!=r&&s(r,n[b],{that:n,AS_ENTRIES:y}),n}))).prototype=g,g.constructor=w),(x||T)&&(S("delete"),S("has"),y&&S("get")),(T||O)&&S(b),v&&g.clear&&delete g.clear}return _[t]=w,n({global:!0,forced:w!=m},_),h(w,t),v||r.setStrong(w,t,y),w}},7918:(t,e,r)=>{var n=r(5884),o=r(8204),i=r(7825),a=r(3376);t.exports=function(t,e){for(var r=o(e),u=a.f,s=i.f,c=0;c<r.length;c++){var f=r[c];n(t,f)||u(t,f,s(e,f))}}},6870:(t,e,r)=>{var n=r(3706)("match");t.exports=function(t){var e=/./;try{"/./"[t](e)}catch(r){try{return e[n]=!1,"/./"[t](e)}catch(t){}}return!1}},9241:(t,e,r)=>{var n=r(7841);t.exports=!n((function(){function t(){}return t.prototype.constructor=null,Object.getPrototypeOf(new t)!==t.prototype}))},9670:(t,e,r)=>{"use strict";var n=r(888).IteratorPrototype,o=r(2361),i=r(976),a=r(9400),u=r(873),s=function(){return this};t.exports=function(t,e,r){var c=e+" Iterator";return t.prototype=o(n,{next:i(1,r)}),a(t,c,!1,!0),u[c]=s,t}},4791:(t,e,r)=>{var n=r(5542),o=r(3376),i=r(976);t.exports=n?function(t,e,r){return o.f(t,e,i(1,r))}:function(t,e,r){return t[e]=r,t}},976:t=>{t.exports=function(t,e){return{enumerable:!(1&t),configurable:!(2&t),writable:!(4&t),value:e}}},2076:(t,e,r)=>{"use strict";var n=r(2694),o=r(3376),i=r(976);t.exports=function(t,e,r){var a=n(e);a in t?o.f(t,a,i(0,r)):t[a]=r}},3131:(t,e,r)=>{"use strict";var n=r(1082),o=r(9670),i=r(8186),a=r(2686),u=r(9400),s=r(4791),c=r(1249),f=r(3706),l=r(6852),p=r(873),h=r(888),d=h.IteratorPrototype,y=h.BUGGY_SAFARI_ITERATORS,v=f("iterator"),b="keys",m="values",g="entries",w=function(){return this};t.exports=function(t,e,r,f,h,_,S){o(r,e,f);var E,O,x,R=function(t){if(t===h&&A)return A;if(!y&&t in P)return P[t];switch(t){case b:case m:case g:return function(){return new r(this,t)}}return function(){return new r(this)}},T=e+" Iterator",k=!1,P=t.prototype,j=P[v]||P["@@iterator"]||h&&P[h],A=!y&&j||R(h),C="Array"==e&&P.entries||j;if(C&&(E=i(C.call(new t)),d!==Object.prototype&&E.next&&(l||i(E)===d||(a?a(E,d):"function"!=typeof E[v]&&s(E,v,w)),u(E,T,!0,!0),l&&(p[T]=w))),h==m&&j&&j.name!==m&&(k=!0,A=function(){return j.call(this)}),l&&!S||P[v]===A||s(P,v,A),p[e]=A,h)if(O={values:R(m),keys:_?A:R(b),entries:R(g)},S)for(x in O)(y||k||!(x in P))&&c(P,x,O[x]);else n({target:e,proto:!0,forced:y||k},O);return O}},1578:(t,e,r)=>{var n=r(2067),o=r(5884),i=r(8403),a=r(3376).f;t.exports=function(t){var e=n.Symbol||(n.Symbol={});o(e,t)||a(e,t,{value:i.f(t)})}},5542:(t,e,r)=>{var n=r(7841);t.exports=!n((function(){return 7!=Object.defineProperty({},1,{get:function(){return 7}})[1]}))},3879:(t,e,r)=>{var n=r(6874),o=r(6944),i=n.document,a=o(i)&&o(i.createElement);t.exports=function(t){return a?i.createElement(t):{}}},8956:t=>{t.exports={CSSRuleList:0,CSSStyleDeclaration:0,CSSValueList:0,ClientRectList:0,DOMRectList:0,DOMStringList:0,DOMTokenList:1,DataTransferItemList:0,FileList:0,HTMLAllCollection:0,HTMLCollection:0,HTMLFormElement:0,HTMLSelectElement:0,MediaList:0,MimeTypeArray:0,NamedNodeMap:0,NodeList:1,PaintRequestList:0,Plugin:0,PluginArray:0,SVGLengthList:0,SVGNumberList:0,SVGPathSegList:0,SVGPointList:0,SVGStringList:0,SVGTransformList:0,SourceBufferList:0,StyleSheetList:0,TextTrackCueList:0,TextTrackList:0,TouchList:0}},6817:(t,e,r)=>{var n=r(4229).match(/firefox\/(\d+)/i);t.exports=!!n&&+n[1]},206:t=>{t.exports="object"==typeof window},6264:(t,e,r)=>{var n=r(4229);t.exports=/MSIE|Trident/.test(n)},2389:(t,e,r)=>{var n=r(4229),o=r(6874);t.exports=/ipad|iphone|ipod/i.test(n)&&void 0!==o.Pebble},3359:(t,e,r)=>{var n=r(4229);t.exports=/(?:ipad|iphone|ipod).*applewebkit/i.test(n)},8723:(t,e,r)=>{var n=r(3565),o=r(6874);t.exports="process"==n(o.process)},4306:(t,e,r)=>{var n=r(4229);t.exports=/web0s(?!.*chrome)/i.test(n)},4229:(t,e,r)=>{var n=r(4578);t.exports=n("navigator","userAgent")||""},579:(t,e,r)=>{var n,o,i=r(6874),a=r(4229),u=i.process,s=i.Deno,c=u&&u.versions||s&&s.version,f=c&&c.v8;f?o=(n=f.split("."))[0]<4?1:n[0]+n[1]:a&&(!(n=a.match(/Edge\/(\d+)/))||n[1]>=74)&&(n=a.match(/Chrome\/(\d+)/))&&(o=n[1]),t.exports=o&&+o},9736:(t,e,r)=>{var n=r(4229).match(/AppleWebKit\/(\d+)\./);t.exports=!!n&&+n[1]},9752:t=>{t.exports=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"]},1082:(t,e,r)=>{var n=r(6874),o=r(7825).f,i=r(4791),a=r(1249),u=r(1278),s=r(7918),c=r(2350);t.exports=function(t,e){var r,f,l,p,h,d=t.target,y=t.global,v=t.stat;if(r=y?n:v?n[d]||u(d,{}):(n[d]||{}).prototype)for(f in e){if(p=e[f],l=t.noTargetGet?(h=o(r,f))&&h.value:r[f],!c(y?f:d+(v?".":"#")+f,t.forced)&&void 0!==l){if(typeof p==typeof l)continue;s(p,l)}(t.sham||l&&l.sham)&&i(p,"sham",!0),a(r,f,p,t)}}},7841:t=>{t.exports=function(t){try{return!!t()}catch(t){return!0}}},6918:(t,e,r)=>{"use strict";r(1818);var n=r(1249),o=r(1144),i=r(7841),a=r(3706),u=r(4791),s=a("species"),c=RegExp.prototype;t.exports=function(t,e,r,f){var l=a(t),p=!i((function(){var e={};return e[l]=function(){return 7},7!=""[t](e)})),h=p&&!i((function(){var e=!1,r=/a/;return"split"===t&&((r={}).constructor={},r.constructor[s]=function(){return r},r.flags="",r[l]=/./[l]),r.exec=function(){return e=!0,null},r[l](""),!e}));if(!p||!h||r){var d=/./[l],y=e(l,""[t],(function(t,e,r,n,i){var a=e.exec;return a===o||a===c.exec?p&&!i?{done:!0,value:d.call(e,r,n)}:{done:!0,value:t.call(r,e,n)}:{done:!1}}));n(String.prototype,t,y[0]),n(c,l,y[1])}f&&u(c[l],"sham",!0)}},2009:(t,e,r)=>{var n=r(7841);t.exports=!n((function(){return Object.isExtensible(Object.preventExtensions({}))}))},4833:(t,e,r)=>{var n=r(769);t.exports=function(t,e,r){if(n(t),void 0===e)return t;switch(r){case 0:return function(){return t.call(e)};case 1:return function(r){return t.call(e,r)};case 2:return function(r,n){return t.call(e,r,n)};case 3:return function(r,n,o){return t.call(e,r,n,o)}}return function(){return t.apply(e,arguments)}}},5462:(t,e,r)=>{"use strict";var n=r(769),o=r(6944),i=[].slice,a={},u=function(t,e,r){if(!(e in a)){for(var n=[],o=0;o<e;o++)n[o]="a["+o+"]";a[e]=Function("C,a","return new C("+n.join(",")+")")}return a[e](t,r)};t.exports=Function.bind||function(t){var e=n(this),r=i.call(arguments,1),a=function(){var n=r.concat(i.call(arguments));return this instanceof a?u(e,n.length,n):e.apply(t,n)};return o(e.prototype)&&(a.prototype=e.prototype),a}},4578:(t,e,r)=>{var n=r(6874),o=function(t){return"function"==typeof t?t:void 0};t.exports=function(t,e){return arguments.length<2?o(n[t]):n[t]&&n[t][e]}},3126:(t,e,r)=>{var n=r(8753),o=r(873),i=r(3706)("iterator");t.exports=function(t){if(null!=t)return t[i]||t["@@iterator"]||o[n(t)]}},7053:(t,e,r)=>{var n=r(47),o=r(3126);t.exports=function(t){var e=o(t);if("function"!=typeof e)throw TypeError(String(t)+" is not iterable");return n(e.call(t))}},9:(t,e,r)=>{var n=r(4680),o=Math.floor,i="".replace,a=/\$([$&'`]|\d{1,2}|<[^>]*>)/g,u=/\$([$&'`]|\d{1,2})/g;t.exports=function(t,e,r,s,c,f){var l=r+t.length,p=s.length,h=u;return void 0!==c&&(c=n(c),h=a),i.call(f,h,(function(n,i){var a;switch(i.charAt(0)){case"$":return"$";case"&":return t;case"`":return e.slice(0,r);case"'":return e.slice(l);case"<":a=c[i.slice(1,-1)];break;default:var u=+i;if(0===u)return n;if(u>p){var f=o(u/10);return 0===f?n:f<=p?void 0===s[f-1]?i.charAt(1):s[f-1]+i.charAt(1):n}a=s[u-1]}return void 0===a?"":a}))}},6874:(t,e,r)=>{var n=function(t){return t&&t.Math==Math&&t};t.exports=n("object"==typeof globalThis&&globalThis)||n("object"==typeof window&&window)||n("object"==typeof self&&self)||n("object"==typeof r.g&&r.g)||function(){return this}()||Function("return this")()},5884:(t,e,r)=>{var n=r(4680),o={}.hasOwnProperty;t.exports=Object.hasOwn||function(t,e){return o.call(n(t),e)}},5644:t=>{t.exports={}},1250:(t,e,r)=>{var n=r(6874);t.exports=function(t,e){var r=n.console;r&&r.error&&(1===arguments.length?r.error(t):r.error(t,e))}},7666:(t,e,r)=>{var n=r(4578);t.exports=n("document","documentElement")},6056:(t,e,r)=>{var n=r(5542),o=r(7841),i=r(3879);t.exports=!n&&!o((function(){return 7!=Object.defineProperty(i("div"),"a",{get:function(){return 7}}).a}))},6227:t=>{var e=Math.abs,r=Math.pow,n=Math.floor,o=Math.log,i=Math.LN2;t.exports={pack:function(t,a,u){var s,c,f,l=new Array(u),p=8*u-a-1,h=(1<<p)-1,d=h>>1,y=23===a?r(2,-24)-r(2,-77):0,v=t<0||0===t&&1/t<0?1:0,b=0;for((t=e(t))!=t||t===1/0?(c=t!=t?1:0,s=h):(s=n(o(t)/i),t*(f=r(2,-s))<1&&(s--,f*=2),(t+=s+d>=1?y/f:y*r(2,1-d))*f>=2&&(s++,f/=2),s+d>=h?(c=0,s=h):s+d>=1?(c=(t*f-1)*r(2,a),s+=d):(c=t*r(2,d-1)*r(2,a),s=0));a>=8;l[b++]=255&c,c/=256,a-=8);for(s=s<<a|c,p+=a;p>0;l[b++]=255&s,s/=256,p-=8);return l[--b]|=128*v,l},unpack:function(t,e){var n,o=t.length,i=8*o-e-1,a=(1<<i)-1,u=a>>1,s=i-7,c=o-1,f=t[c--],l=127&f;for(f>>=7;s>0;l=256*l+t[c],c--,s-=8);for(n=l&(1<<-s)-1,l>>=-s,s+=e;s>0;n=256*n+t[c],c--,s-=8);if(0===l)l=1-u;else{if(l===a)return n?NaN:f?-1/0:1/0;n+=r(2,e),l-=u}return(f?-1:1)*n*r(2,l-e)}}},7361:(t,e,r)=>{var n=r(7841),o=r(3565),i="".split;t.exports=n((function(){return!Object("z").propertyIsEnumerable(0)}))?function(t){return"String"==o(t)?i.call(t,""):Object(t)}:Object},4029:(t,e,r)=>{var n=r(6944),o=r(2686);t.exports=function(t,e,r){var i,a;return o&&"function"==typeof(i=e.constructor)&&i!==r&&n(a=i.prototype)&&a!==r.prototype&&o(t,a),t}},6090:(t,e,r)=>{var n=r(4925),o=Function.toString;"function"!=typeof n.inspectSource&&(n.inspectSource=function(t){return o.call(t)}),t.exports=n.inspectSource},28:(t,e,r)=>{var n=r(1082),o=r(5644),i=r(6944),a=r(5884),u=r(3376).f,s=r(8401),c=r(3866),f=r(8435),l=r(2009),p=!1,h=f("meta"),d=0,y=Object.isExtensible||function(){return!0},v=function(t){u(t,h,{value:{objectID:"O"+d++,weakData:{}}})},b=t.exports={enable:function(){b.enable=function(){},p=!0;var t=s.f,e=[].splice,r={};r[h]=1,t(r).length&&(s.f=function(r){for(var n=t(r),o=0,i=n.length;o<i;o++)if(n[o]===h){e.call(n,o,1);break}return n},n({target:"Object",stat:!0,forced:!0},{getOwnPropertyNames:c.f}))},fastKey:function(t,e){if(!i(t))return"symbol"==typeof t?t:("string"==typeof t?"S":"P")+t;if(!a(t,h)){if(!y(t))return"F";if(!e)return"E";v(t)}return t[h].objectID},getWeakData:function(t,e){if(!a(t,h)){if(!y(t))return!0;if(!e)return!1;v(t)}return t[h].weakData},onFreeze:function(t){return l&&p&&y(t)&&!a(t,h)&&v(t),t}};o[h]=!0},6619:(t,e,r)=>{var n,o,i,a=r(9957),u=r(6874),s=r(6944),c=r(4791),f=r(5884),l=r(4925),p=r(8698),h=r(5644),d="Object already initialized",y=u.WeakMap;if(a||l.state){var v=l.state||(l.state=new y),b=v.get,m=v.has,g=v.set;n=function(t,e){if(m.call(v,t))throw new TypeError(d);return e.facade=t,g.call(v,t,e),e},o=function(t){return b.call(v,t)||{}},i=function(t){return m.call(v,t)}}else{var w=p("state");h[w]=!0,n=function(t,e){if(f(t,w))throw new TypeError(d);return e.facade=t,c(t,w,e),e},o=function(t){return f(t,w)?t[w]:{}},i=function(t){return f(t,w)}}t.exports={set:n,get:o,has:i,enforce:function(t){return i(t)?o(t):n(t,{})},getterFor:function(t){return function(e){var r;if(!s(e)||(r=o(e)).type!==t)throw TypeError("Incompatible receiver, "+t+" required");return r}}}},1008:(t,e,r)=>{var n=r(3706),o=r(873),i=n("iterator"),a=Array.prototype;t.exports=function(t){return void 0!==t&&(o.Array===t||a[i]===t)}},7828:(t,e,r)=>{var n=r(3565);t.exports=Array.isArray||function(t){return"Array"==n(t)}},2350:(t,e,r)=>{var n=r(7841),o=/#|\.prototype\./,i=function(t,e){var r=u[a(t)];return r==c||r!=s&&("function"==typeof e?n(e):!!e)},a=i.normalize=function(t){return String(t).replace(o,".").toLowerCase()},u=i.data={},s=i.NATIVE="N",c=i.POLYFILL="P";t.exports=i},3614:(t,e,r)=>{var n=r(6944),o=Math.floor;t.exports=function(t){return!n(t)&&isFinite(t)&&o(t)===t}},6944:t=>{t.exports=function(t){return"object"==typeof t?null!==t:"function"==typeof t}},6852:t=>{t.exports=!1},2399:(t,e,r)=>{var n=r(6944),o=r(3565),i=r(3706)("match");t.exports=function(t){var e;return n(t)&&(void 0!==(e=t[i])?!!e:"RegExp"==o(t))}},8377:(t,e,r)=>{var n=r(4578),o=r(4587);t.exports=o?function(t){return"symbol"==typeof t}:function(t){var e=n("Symbol");return"function"==typeof e&&Object(t)instanceof e}},7093:(t,e,r)=>{var n=r(47),o=r(1008),i=r(4954),a=r(4833),u=r(3126),s=r(2608),c=function(t,e){this.stopped=t,this.result=e};t.exports=function(t,e,r){var f,l,p,h,d,y,v,b=r&&r.that,m=!(!r||!r.AS_ENTRIES),g=!(!r||!r.IS_ITERATOR),w=!(!r||!r.INTERRUPTED),_=a(e,b,1+m+w),S=function(t){return f&&s(f),new c(!0,t)},E=function(t){return m?(n(t),w?_(t[0],t[1],S):_(t[0],t[1])):w?_(t,S):_(t)};if(g)f=t;else{if("function"!=typeof(l=u(t)))throw TypeError("Target is not iterable");if(o(l)){for(p=0,h=i(t.length);h>p;p++)if((d=E(t[p]))&&d instanceof c)return d;return new c(!1)}f=l.call(t)}for(y=f.next;!(v=y.call(f)).done;){try{d=E(v.value)}catch(t){throw s(f),t}if("object"==typeof d&&d&&d instanceof c)return d}return new c(!1)}},2608:(t,e,r)=>{var n=r(47);t.exports=function(t){var e=t.return;if(void 0!==e)return n(e.call(t)).value}},888:(t,e,r)=>{"use strict";var n,o,i,a=r(7841),u=r(8186),s=r(4791),c=r(5884),f=r(3706),l=r(6852),p=f("iterator"),h=!1;[].keys&&("next"in(i=[].keys())?(o=u(u(i)))!==Object.prototype&&(n=o):h=!0);var d=null==n||a((function(){var t={};return n[p].call(t)!==t}));d&&(n={}),l&&!d||c(n,p)||s(n,p,(function(){return this})),t.exports={IteratorPrototype:n,BUGGY_SAFARI_ITERATORS:h}},873:t=>{t.exports={}},6309:(t,e,r)=>{var n,o,i,a,u,s,c,f,l=r(6874),p=r(7825).f,h=r(998).set,d=r(3359),y=r(2389),v=r(4306),b=r(8723),m=l.MutationObserver||l.WebKitMutationObserver,g=l.document,w=l.process,_=l.Promise,S=p(l,"queueMicrotask"),E=S&&S.value;E||(n=function(){var t,e;for(b&&(t=w.domain)&&t.exit();o;){e=o.fn,o=o.next;try{e()}catch(t){throw o?a():i=void 0,t}}i=void 0,t&&t.enter()},d||b||v||!m||!g?!y&&_&&_.resolve?((c=_.resolve(void 0)).constructor=_,f=c.then,a=function(){f.call(c,n)}):a=b?function(){w.nextTick(n)}:function(){h.call(l,n)}:(u=!0,s=g.createTextNode(""),new m(n).observe(s,{characterData:!0}),a=function(){s.data=u=!u})),t.exports=E||function(t){var e={fn:t,next:void 0};i&&(i.next=e),o||(o=e,a()),i=e}},6838:(t,e,r)=>{var n=r(6874);t.exports=n.Promise},1453:(t,e,r)=>{var n=r(579),o=r(7841);t.exports=!!Object.getOwnPropertySymbols&&!o((function(){var t=Symbol();return!String(t)||!(Object(t)instanceof Symbol)||!Symbol.sham&&n&&n<41}))},1781:(t,e,r)=>{var n=r(7841),o=r(3706),i=r(6852),a=o("iterator");t.exports=!n((function(){var t=new URL("b?a=1&b=2&c=3","http://a"),e=t.searchParams,r="";return t.pathname="c%20d",e.forEach((function(t,n){e.delete("b"),r+=n+t})),i&&!t.toJSON||!e.sort||"http://a/c%20d?a=1&c=3"!==t.href||"3"!==e.get("c")||"a=1"!==String(new URLSearchParams("?a=1"))||!e[a]||"a"!==new URL("https://a@b").username||"b"!==new URLSearchParams(new URLSearchParams("a=b")).get("a")||"xn--e1aybc"!==new URL("http://").host||"#%D0%B1"!==new URL("http://a#").hash||"a1c3"!==r||"x"!==new URL("http://x",void 0).host}))},9957:(t,e,r)=>{var n=r(6874),o=r(6090),i=n.WeakMap;t.exports="function"==typeof i&&/native code/.test(o(i))},7529:(t,e,r)=>{"use strict";var n=r(769),o=function(t){var e,r;this.promise=new t((function(t,n){if(void 0!==e||void 0!==r)throw TypeError("Bad Promise constructor");e=t,r=n})),this.resolve=n(e),this.reject=n(r)};t.exports.f=function(t){return new o(t)}},4315:(t,e,r)=>{var n=r(2399);t.exports=function(t){if(n(t))throw TypeError("The method doesn't accept regular expressions");return t}},5277:(t,e,r)=>{"use strict";var n=r(5542),o=r(7841),i=r(965),a=r(1913),u=r(3626),s=r(4680),c=r(7361),f=Object.assign,l=Object.defineProperty;t.exports=!f||o((function(){if(n&&1!==f({b:1},f(l({},"a",{enumerable:!0,get:function(){l(this,"b",{value:3,enumerable:!1})}}),{b:2})).b)return!0;var t={},e={},r=Symbol(),o="abcdefghijklmnopqrst";return t[r]=7,o.split("").forEach((function(t){e[t]=t})),7!=f({},t)[r]||i(f({},e)).join("")!=o}))?function(t,e){for(var r=s(t),o=arguments.length,f=1,l=a.f,p=u.f;o>f;)for(var h,d=c(arguments[f++]),y=l?i(d).concat(l(d)):i(d),v=y.length,b=0;v>b;)h=y[b++],n&&!p.call(d,h)||(r[h]=d[h]);return r}:f},2361:(t,e,r)=>{var n,o=r(47),i=r(7852),a=r(9752),u=r(5644),s=r(7666),c=r(3879),f=r(8698)("IE_PROTO"),l=function(){},p=function(t){return"<script>"+t+"<\/script>"},h=function(t){t.write(p("")),t.close();var e=t.parentWindow.Object;return t=null,e},d=function(){try{n=new ActiveXObject("htmlfile")}catch(t){}var t,e;d="undefined"!=typeof document?document.domain&&n?h(n):((e=c("iframe")).style.display="none",s.appendChild(e),e.src=String("javascript:"),(t=e.contentWindow.document).open(),t.write(p("document.F=Object")),t.close(),t.F):h(n);for(var r=a.length;r--;)delete d.prototype[a[r]];return d()};u[f]=!0,t.exports=Object.create||function(t,e){var r;return null!==t?(l.prototype=o(t),r=new l,l.prototype=null,r[f]=t):r=d(),void 0===e?r:i(r,e)}},7852:(t,e,r)=>{var n=r(5542),o=r(3376),i=r(47),a=r(965);t.exports=n?Object.defineProperties:function(t,e){i(t);for(var r,n=a(e),u=n.length,s=0;u>s;)o.f(t,r=n[s++],e[r]);return t}},3376:(t,e,r)=>{var n=r(5542),o=r(6056),i=r(47),a=r(2694),u=Object.defineProperty;e.f=n?u:function(t,e,r){if(i(t),e=a(e),i(r),o)try{return u(t,e,r)}catch(t){}if("get"in r||"set"in r)throw TypeError("Accessors not supported");return"value"in r&&(t[e]=r.value),t}},7825:(t,e,r)=>{var n=r(5542),o=r(3626),i=r(976),a=r(8852),u=r(2694),s=r(5884),c=r(6056),f=Object.getOwnPropertyDescriptor;e.f=n?f:function(t,e){if(t=a(t),e=u(e),c)try{return f(t,e)}catch(t){}if(s(t,e))return i(!o.f.call(t,e),t[e])}},3866:(t,e,r)=>{var n=r(8852),o=r(8401).f,i={}.toString,a="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[];t.exports.f=function(t){return a&&"[object Window]"==i.call(t)?function(t){try{return o(t)}catch(t){return a.slice()}}(t):o(n(t))}},8401:(t,e,r)=>{var n=r(8104),o=r(9752).concat("length","prototype");e.f=Object.getOwnPropertyNames||function(t){return n(t,o)}},1913:(t,e)=>{e.f=Object.getOwnPropertySymbols},8186:(t,e,r)=>{var n=r(5884),o=r(4680),i=r(8698),a=r(9241),u=i("IE_PROTO"),s=Object.prototype;t.exports=a?Object.getPrototypeOf:function(t){return t=o(t),n(t,u)?t[u]:"function"==typeof t.constructor&&t instanceof t.constructor?t.constructor.prototype:t instanceof Object?s:null}},8104:(t,e,r)=>{var n=r(5884),o=r(8852),i=r(1270).indexOf,a=r(5644);t.exports=function(t,e){var r,u=o(t),s=0,c=[];for(r in u)!n(a,r)&&n(u,r)&&c.push(r);for(;e.length>s;)n(u,r=e[s++])&&(~i(c,r)||c.push(r));return c}},965:(t,e,r)=>{var n=r(8104),o=r(9752);t.exports=Object.keys||function(t){return n(t,o)}},3626:(t,e)=>{"use strict";var r={}.propertyIsEnumerable,n=Object.getOwnPropertyDescriptor,o=n&&!r.call({1:2},1);e.f=o?function(t){var e=n(this,t);return!!e&&e.enumerable}:r},2686:(t,e,r)=>{var n=r(47),o=r(8143);t.exports=Object.setPrototypeOf||("__proto__"in{}?function(){var t,e=!1,r={};try{(t=Object.getOwnPropertyDescriptor(Object.prototype,"__proto__").set).call(r,[]),e=r instanceof Array}catch(t){}return function(r,i){return n(r),o(i),e?t.call(r,i):r.__proto__=i,r}}():void 0)},8686:(t,e,r)=>{var n=r(5542),o=r(965),i=r(8852),a=r(3626).f,u=function(t){return function(e){for(var r,u=i(e),s=o(u),c=s.length,f=0,l=[];c>f;)r=s[f++],n&&!a.call(u,r)||l.push(t?[r,u[r]]:u[r]);return l}};t.exports={entries:u(!0),values:u(!1)}},1851:(t,e,r)=>{"use strict";var n=r(939),o=r(8753);t.exports=n?{}.toString:function(){return"[object "+o(this)+"]"}},2392:(t,e,r)=>{var n=r(6944);t.exports=function(t,e){var r,o;if("string"===e&&"function"==typeof(r=t.toString)&&!n(o=r.call(t)))return o;if("function"==typeof(r=t.valueOf)&&!n(o=r.call(t)))return o;if("string"!==e&&"function"==typeof(r=t.toString)&&!n(o=r.call(t)))return o;throw TypeError("Can't convert object to primitive value")}},8204:(t,e,r)=>{var n=r(4578),o=r(8401),i=r(1913),a=r(47);t.exports=n("Reflect","ownKeys")||function(t){var e=o.f(a(t)),r=i.f;return r?e.concat(r(t)):e}},2067:(t,e,r)=>{var n=r(6874);t.exports=n},7105:t=>{t.exports=function(t){try{return{error:!1,value:t()}}catch(t){return{error:!0,value:t}}}},4022:(t,e,r)=>{var n=r(47),o=r(6944),i=r(7529);t.exports=function(t,e){if(n(t),o(e)&&e.constructor===t)return e;var r=i.f(t);return(0,r.resolve)(e),r.promise}},7490:(t,e,r)=>{var n=r(1249);t.exports=function(t,e,r){for(var o in e)n(t,o,e[o],r);return t}},1249:(t,e,r)=>{var n=r(6874),o=r(4791),i=r(5884),a=r(1278),u=r(6090),s=r(6619),c=s.get,f=s.enforce,l=String(String).split("String");(t.exports=function(t,e,r,u){var s,c=!!u&&!!u.unsafe,p=!!u&&!!u.enumerable,h=!!u&&!!u.noTargetGet;"function"==typeof r&&("string"!=typeof e||i(r,"name")||o(r,"name",e),(s=f(r)).source||(s.source=l.join("string"==typeof e?e:""))),t!==n?(c?!h&&t[e]&&(p=!0):delete t[e],p?t[e]=r:o(t,e,r)):p?t[e]=r:a(e,r)})(Function.prototype,"toString",(function(){return"function"==typeof this&&c(this).source||u(this)}))},3915:(t,e,r)=>{var n=r(3565),o=r(1144);t.exports=function(t,e){var r=t.exec;if("function"==typeof r){var i=r.call(t,e);if("object"!=typeof i)throw TypeError("RegExp exec method returned something other than an Object or null");return i}if("RegExp"!==n(t))throw TypeError("RegExp#exec called on incompatible receiver");return o.call(t,e)}},1144:(t,e,r)=>{"use strict";var n,o,i=r(401),a=r(9262),u=r(768),s=r(3215),c=r(2361),f=r(6619).get,l=r(1972),p=r(5876),h=RegExp.prototype.exec,d=s("native-string-replace",String.prototype.replace),y=h,v=(n=/a/,o=/b*/g,h.call(n,"a"),h.call(o,"a"),0!==n.lastIndex||0!==o.lastIndex),b=u.UNSUPPORTED_Y||u.BROKEN_CARET,m=void 0!==/()??/.exec("")[1];(v||m||b||l||p)&&(y=function(t){var e,r,n,o,u,s,l,p=this,g=f(p),w=i(t),_=g.raw;if(_)return _.lastIndex=p.lastIndex,e=y.call(_,w),p.lastIndex=_.lastIndex,e;var S=g.groups,E=b&&p.sticky,O=a.call(p),x=p.source,R=0,T=w;if(E&&(-1===(O=O.replace("y","")).indexOf("g")&&(O+="g"),T=w.slice(p.lastIndex),p.lastIndex>0&&(!p.multiline||p.multiline&&"\n"!==w.charAt(p.lastIndex-1))&&(x="(?: "+x+")",T=" "+T,R++),r=new RegExp("^(?:"+x+")",O)),m&&(r=new RegExp("^"+x+"$(?!\\s)",O)),v&&(n=p.lastIndex),o=h.call(E?r:p,T),E?o?(o.input=o.input.slice(R),o[0]=o[0].slice(R),o.index=p.lastIndex,p.lastIndex+=o[0].length):p.lastIndex=0:v&&o&&(p.lastIndex=p.global?o.index+o[0].length:n),m&&o&&o.length>1&&d.call(o[0],r,(function(){for(u=1;u<arguments.length-2;u++)void 0===arguments[u]&&(o[u]=void 0)})),o&&S)for(o.groups=s=c(null),u=0;u<S.length;u++)s[(l=S[u])[0]]=o[l[1]];return o}),t.exports=y},9262:(t,e,r)=>{"use strict";var n=r(47);t.exports=function(){var t=n(this),e="";return t.global&&(e+="g"),t.ignoreCase&&(e+="i"),t.multiline&&(e+="m"),t.dotAll&&(e+="s"),t.unicode&&(e+="u"),t.sticky&&(e+="y"),e}},768:(t,e,r)=>{var n=r(7841),o=r(6874).RegExp;e.UNSUPPORTED_Y=n((function(){var t=o("a","y");return t.lastIndex=2,null!=t.exec("abcd")})),e.BROKEN_CARET=n((function(){var t=o("^r","gy");return t.lastIndex=2,null!=t.exec("str")}))},1972:(t,e,r)=>{var n=r(7841),o=r(6874).RegExp;t.exports=n((function(){var t=o(".","s");return!(t.dotAll&&t.exec("\n")&&"s"===t.flags)}))},5876:(t,e,r)=>{var n=r(7841),o=r(6874).RegExp;t.exports=n((function(){var t=o("(?<a>b)","g");return"b"!==t.exec("b").groups.a||"bc"!=="b".replace(t,"$<a>c")}))},164:t=>{t.exports=function(t){if(null==t)throw TypeError("Can't call method on "+t);return t}},1278:(t,e,r)=>{var n=r(6874);t.exports=function(t,e){try{Object.defineProperty(n,t,{value:e,configurable:!0,writable:!0})}catch(r){n[t]=e}return e}},8802:(t,e,r)=>{"use strict";var n=r(4578),o=r(3376),i=r(3706),a=r(5542),u=i("species");t.exports=function(t){var e=n(t),r=o.f;a&&e&&!e[u]&&r(e,u,{configurable:!0,get:function(){return this}})}},9400:(t,e,r)=>{var n=r(3376).f,o=r(5884),i=r(3706)("toStringTag");t.exports=function(t,e,r){t&&!o(t=r?t:t.prototype,i)&&n(t,i,{configurable:!0,value:e})}},8698:(t,e,r)=>{var n=r(3215),o=r(8435),i=n("keys");t.exports=function(t){return i[t]||(i[t]=o(t))}},4925:(t,e,r)=>{var n=r(6874),o=r(1278),i="__core-js_shared__",a=n[i]||o(i,{});t.exports=a},3215:(t,e,r)=>{var n=r(6852),o=r(4925);(t.exports=function(t,e){return o[t]||(o[t]=void 0!==e?e:{})})("versions",[]).push({version:"3.16.2",mode:n?"pure":"global",copyright:" 2021 Denis Pushkarev (zloirock.ru)"})},2004:(t,e,r)=>{var n=r(47),o=r(769),i=r(3706)("species");t.exports=function(t,e){var r,a=n(t).constructor;return void 0===a||null==(r=n(a)[i])?e:o(r)}},6174:(t,e,r)=>{var n=r(7896),o=r(401),i=r(164),a=function(t){return function(e,r){var a,u,s=o(i(e)),c=n(r),f=s.length;return c<0||c>=f?t?"":void 0:(a=s.charCodeAt(c))<55296||a>56319||c+1===f||(u=s.charCodeAt(c+1))<56320||u>57343?t?s.charAt(c):a:t?s.slice(c,c+2):u-56320+(a-55296<<10)+65536}};t.exports={codeAt:a(!1),charAt:a(!0)}},4931:(t,e,r)=>{var n=r(4229);t.exports=/Version\/10(?:\.\d+){1,2}(?: [\w./]+)?(?: Mobile\/\w+)? Safari\//.test(n)},9534:(t,e,r)=>{var n=r(4954),o=r(401),i=r(6640),a=r(164),u=Math.ceil,s=function(t){return function(e,r,s){var c,f,l=o(a(e)),p=l.length,h=void 0===s?" ":o(s),d=n(r);return d<=p||""==h?l:(c=d-p,(f=i.call(h,u(c/h.length))).length>c&&(f=f.slice(0,c)),t?l+f:f+l)}};t.exports={start:s(!1),end:s(!0)}},8:t=>{"use strict";var e=2147483647,r=/[^\0-\u007E]/,n=/[.\u3002\uFF0E\uFF61]/g,o="Overflow: input needs wider integers to process",i=Math.floor,a=String.fromCharCode,u=function(t){return t+22+75*(t<26)},s=function(t,e,r){var n=0;for(t=r?i(t/700):t>>1,t+=i(t/e);t>455;n+=36)t=i(t/35);return i(n+36*t/(t+38))},c=function(t){var r,n,c=[],f=(t=function(t){for(var e=[],r=0,n=t.length;r<n;){var o=t.charCodeAt(r++);if(o>=55296&&o<=56319&&r<n){var i=t.charCodeAt(r++);56320==(64512&i)?e.push(((1023&o)<<10)+(1023&i)+65536):(e.push(o),r--)}else e.push(o)}return e}(t)).length,l=128,p=0,h=72;for(r=0;r<t.length;r++)(n=t[r])<128&&c.push(a(n));var d=c.length,y=d;for(d&&c.push("-");y<f;){var v=e;for(r=0;r<t.length;r++)(n=t[r])>=l&&n<v&&(v=n);var b=y+1;if(v-l>i((e-p)/b))throw RangeError(o);for(p+=(v-l)*b,l=v,r=0;r<t.length;r++){if((n=t[r])<l&&++p>e)throw RangeError(o);if(n==l){for(var m=p,g=36;;g+=36){var w=g<=h?1:g>=h+26?26:g-h;if(m<w)break;var _=m-w,S=36-w;c.push(a(u(w+_%S))),m=i(_/S)}c.push(a(u(m))),h=s(p,b,y==d),p=0,++y}}++p,++l}return c.join("")};t.exports=function(t){var e,o,i=[],a=t.toLowerCase().replace(n,".").split(".");for(e=0;e<a.length;e++)o=a[e],i.push(r.test(o)?"xn--"+c(o):o);return i.join(".")}},6640:(t,e,r)=>{"use strict";var n=r(7896),o=r(401),i=r(164);t.exports=function(t){var e=o(i(this)),r="",a=n(t);if(a<0||a==1/0)throw RangeError("Wrong number of repetitions");for(;a>0;(a>>>=1)&&(e+=e))1&a&&(r+=e);return r}},5206:(t,e,r)=>{var n=r(7841),o=r(9458);t.exports=function(t){return n((function(){return!!o[t]()||""!=""[t]()||o[t].name!==t}))}},7753:(t,e,r)=>{var n=r(164),o=r(401),i="["+r(9458)+"]",a=RegExp("^"+i+i+"*"),u=RegExp(i+i+"*$"),s=function(t){return function(e){var r=o(n(e));return 1&t&&(r=r.replace(a,"")),2&t&&(r=r.replace(u,"")),r}};t.exports={start:s(1),end:s(2),trim:s(3)}},998:(t,e,r)=>{var n,o,i,a,u=r(6874),s=r(7841),c=r(4833),f=r(7666),l=r(3879),p=r(3359),h=r(8723),d=u.setImmediate,y=u.clearImmediate,v=u.process,b=u.MessageChannel,m=u.Dispatch,g=0,w={};try{n=u.location}catch(t){}var _=function(t){if(w.hasOwnProperty(t)){var e=w[t];delete w[t],e()}},S=function(t){return function(){_(t)}},E=function(t){_(t.data)},O=function(t){u.postMessage(String(t),n.protocol+"//"+n.host)};d&&y||(d=function(t){for(var e=[],r=arguments.length,n=1;r>n;)e.push(arguments[n++]);return w[++g]=function(){("function"==typeof t?t:Function(t)).apply(void 0,e)},o(g),g},y=function(t){delete w[t]},h?o=function(t){v.nextTick(S(t))}:m&&m.now?o=function(t){m.now(S(t))}:b&&!p?(a=(i=new b).port2,i.port1.onmessage=E,o=c(a.postMessage,a,1)):u.addEventListener&&"function"==typeof postMessage&&!u.importScripts&&n&&"file:"!==n.protocol&&!s(O)?(o=O,u.addEventListener("message",E,!1)):o="onreadystatechange"in l("script")?function(t){f.appendChild(l("script")).onreadystatechange=function(){f.removeChild(this),_(t)}}:function(t){setTimeout(S(t),0)}),t.exports={set:d,clear:y}},7347:(t,e,r)=>{var n=r(3565);t.exports=function(t){if("number"!=typeof t&&"Number"!=n(t))throw TypeError("Incorrect invocation");return+t}},2145:(t,e,r)=>{var n=r(7896),o=Math.max,i=Math.min;t.exports=function(t,e){var r=n(t);return r<0?o(r+e,0):i(r,e)}},5513:(t,e,r)=>{var n=r(7896),o=r(4954);t.exports=function(t){if(void 0===t)return 0;var e=n(t),r=o(e);if(e!==r)throw RangeError("Wrong length or index");return r}},8852:(t,e,r)=>{var n=r(7361),o=r(164);t.exports=function(t){return n(o(t))}},7896:t=>{var e=Math.ceil,r=Math.floor;t.exports=function(t){return isNaN(t=+t)?0:(t>0?r:e)(t)}},4954:(t,e,r)=>{var n=r(7896),o=Math.min;t.exports=function(t){return t>0?o(n(t),9007199254740991):0}},4680:(t,e,r)=>{var n=r(164);t.exports=function(t){return Object(n(t))}},6189:(t,e,r)=>{var n=r(3096);t.exports=function(t,e){var r=n(t);if(r%e)throw RangeError("Wrong offset");return r}},3096:(t,e,r)=>{var n=r(7896);t.exports=function(t){var e=n(t);if(e<0)throw RangeError("The argument can't be less than 0");return e}},2034:(t,e,r)=>{var n=r(6944),o=r(8377),i=r(2392),a=r(3706)("toPrimitive");t.exports=function(t,e){if(!n(t)||o(t))return t;var r,u=t[a];if(void 0!==u){if(void 0===e&&(e="default"),r=u.call(t,e),!n(r)||o(r))return r;throw TypeError("Can't convert object to primitive value")}return void 0===e&&(e="number"),i(t,e)}},2694:(t,e,r)=>{var n=r(2034),o=r(8377);t.exports=function(t){var e=n(t,"string");return o(e)?e:String(e)}},939:(t,e,r)=>{var n={};n[r(3706)("toStringTag")]="z",t.exports="[object z]"===String(n)},401:(t,e,r)=>{var n=r(8377);t.exports=function(t){if(n(t))throw TypeError("Cannot convert a Symbol value to a string");return String(t)}},3151:(t,e,r)=>{"use strict";var n=r(1082),o=r(6874),i=r(5542),a=r(6178),u=r(2211),s=r(6594),c=r(2482),f=r(976),l=r(4791),p=r(3614),h=r(4954),d=r(5513),y=r(6189),v=r(2694),b=r(5884),m=r(8753),g=r(6944),w=r(8377),_=r(2361),S=r(2686),E=r(8401).f,O=r(9782),x=r(6374).forEach,R=r(8802),T=r(3376),k=r(7825),P=r(6619),j=r(4029),A=P.get,C=P.set,I=T.f,L=k.f,B=Math.round,M=o.RangeError,U=s.ArrayBuffer,N=s.DataView,D=u.NATIVE_ARRAY_BUFFER_VIEWS,F=u.TYPED_ARRAY_CONSTRUCTOR,q=u.TYPED_ARRAY_TAG,H=u.TypedArray,W=u.TypedArrayPrototype,z=u.aTypedArrayConstructor,V=u.isTypedArray,G="BYTES_PER_ELEMENT",$="Wrong length",Y=function(t,e){for(var r=0,n=e.length,o=new(z(t))(n);n>r;)o[r]=e[r++];return o},J=function(t,e){I(t,e,{get:function(){return A(this)[e]}})},K=function(t){var e;return t instanceof U||"ArrayBuffer"==(e=m(t))||"SharedArrayBuffer"==e},X=function(t,e){return V(t)&&!w(e)&&e in t&&p(+e)&&e>=0},Z=function(t,e){return e=v(e),X(t,e)?f(2,t[e]):L(t,e)},Q=function(t,e,r){return e=v(e),!(X(t,e)&&g(r)&&b(r,"value"))||b(r,"get")||b(r,"set")||r.configurable||b(r,"writable")&&!r.writable||b(r,"enumerable")&&!r.enumerable?I(t,e,r):(t[e]=r.value,t)};i?(D||(k.f=Z,T.f=Q,J(W,"buffer"),J(W,"byteOffset"),J(W,"byteLength"),J(W,"length")),n({target:"Object",stat:!0,forced:!D},{getOwnPropertyDescriptor:Z,defineProperty:Q}),t.exports=function(t,e,r){var i=t.match(/\d+$/)[0]/8,u=t+(r?"Clamped":"")+"Array",s="get"+t,f="set"+t,p=o[u],v=p,b=v&&v.prototype,m={},w=function(t,e){I(t,e,{get:function(){return function(t,e){var r=A(t);return r.view[s](e*i+r.byteOffset,!0)}(this,e)},set:function(t){return function(t,e,n){var o=A(t);r&&(n=(n=B(n))<0?0:n>255?255:255&n),o.view[f](e*i+o.byteOffset,n,!0)}(this,e,t)},enumerable:!0})};D?a&&(v=e((function(t,e,r,n){return c(t,v,u),j(g(e)?K(e)?void 0!==n?new p(e,y(r,i),n):void 0!==r?new p(e,y(r,i)):new p(e):V(e)?Y(v,e):O.call(v,e):new p(d(e)),t,v)})),S&&S(v,H),x(E(p),(function(t){t in v||l(v,t,p[t])})),v.prototype=b):(v=e((function(t,e,r,n){c(t,v,u);var o,a,s,f=0,l=0;if(g(e)){if(!K(e))return V(e)?Y(v,e):O.call(v,e);o=e,l=y(r,i);var p=e.byteLength;if(void 0===n){if(p%i)throw M($);if((a=p-l)<0)throw M($)}else if((a=h(n)*i)+l>p)throw M($);s=a/i}else s=d(e),o=new U(a=s*i);for(C(t,{buffer:o,byteOffset:l,byteLength:a,length:s,view:new N(o)});f<s;)w(t,f++)})),S&&S(v,H),b=v.prototype=_(W)),b.constructor!==v&&l(b,"constructor",v),l(b,F,v),q&&l(b,q,u),m[u]=v,n({global:!0,forced:v!=p,sham:!D},m),G in v||l(v,G,i),G in b||l(b,G,i),R(u)}):t.exports=function(){}},6178:(t,e,r)=>{var n=r(6874),o=r(7841),i=r(4585),a=r(2211).NATIVE_ARRAY_BUFFER_VIEWS,u=n.ArrayBuffer,s=n.Int8Array;t.exports=!a||!o((function(){s(1)}))||!o((function(){new s(-1)}))||!i((function(t){new s,new s(null),new s(1.5),new s(t)}),!0)||o((function(){return 1!==new s(new u(2),1,void 0).length}))},6696:(t,e,r)=>{var n=r(4413),o=r(5751);t.exports=function(t,e){return n(o(t),e)}},9782:(t,e,r)=>{var n=r(4680),o=r(4954),i=r(3126),a=r(1008),u=r(4833),s=r(2211).aTypedArrayConstructor;t.exports=function(t){var e,r,c,f,l,p,h=n(t),d=arguments.length,y=d>1?arguments[1]:void 0,v=void 0!==y,b=i(h);if(null!=b&&!a(b))for(p=(l=b.call(h)).next,h=[];!(f=p.call(l)).done;)h.push(f.value);for(v&&d>2&&(y=u(y,arguments[2],2)),r=o(h.length),c=new(s(this))(r),e=0;r>e;e++)c[e]=v?y(h[e],e):h[e];return c}},5751:(t,e,r)=>{var n=r(2211),o=r(2004),i=n.TYPED_ARRAY_CONSTRUCTOR,a=n.aTypedArrayConstructor;t.exports=function(t){return a(o(t,t[i]))}},8435:t=>{var e=0,r=Math.random();t.exports=function(t){return"Symbol("+String(void 0===t?"":t)+")_"+(++e+r).toString(36)}},4587:(t,e,r)=>{var n=r(1453);t.exports=n&&!Symbol.sham&&"symbol"==typeof Symbol.iterator},8403:(t,e,r)=>{var n=r(3706);e.f=n},3706:(t,e,r)=>{var n=r(6874),o=r(3215),i=r(5884),a=r(8435),u=r(1453),s=r(4587),c=o("wks"),f=n.Symbol,l=s?f:f&&f.withoutSetter||a;t.exports=function(t){return i(c,t)&&(u||"string"==typeof c[t])||(u&&i(f,t)?c[t]=f[t]:c[t]=l("Symbol."+t)),c[t]}},9458:t=>{t.exports="\t\n\v\f\r \u2028\u2029\ufeff"},9722:(t,e,r)=>{"use strict";var n=r(1082),o=r(7841),i=r(6594),a=r(47),u=r(2145),s=r(4954),c=r(2004),f=i.ArrayBuffer,l=i.DataView,p=f.prototype.slice;n({target:"ArrayBuffer",proto:!0,unsafe:!0,forced:o((function(){return!new f(2).slice(1,void 0).byteLength}))},{slice:function(t,e){if(void 0!==p&&void 0===e)return p.call(a(this),t);for(var r=a(this).byteLength,n=u(t,r),o=u(void 0===e?r:e,r),i=new(c(this,f))(s(o-n)),h=new l(this),d=new l(i),y=0;n<o;)d.setUint8(y++,h.getUint8(n++));return i}})},6218:(t,e,r)=>{"use strict";var n=r(1082),o=r(7841),i=r(7828),a=r(6944),u=r(4680),s=r(4954),c=r(2076),f=r(68),l=r(6937),p=r(3706),h=r(579),d=p("isConcatSpreadable"),y=9007199254740991,v="Maximum allowed index exceeded",b=h>=51||!o((function(){var t=[];return t[d]=!1,t.concat()[0]!==t})),m=l("concat"),g=function(t){if(!a(t))return!1;var e=t[d];return void 0!==e?!!e:i(t)};n({target:"Array",proto:!0,forced:!b||!m},{concat:function(t){var e,r,n,o,i,a=u(this),l=f(a,0),p=0;for(e=-1,n=arguments.length;e<n;e++)if(g(i=-1===e?a:arguments[e])){if(p+(o=s(i.length))>y)throw TypeError(v);for(r=0;r<o;r++,p++)r in i&&c(l,p,i[r])}else{if(p>=y)throw TypeError(v);c(l,p++,i)}return l.length=p,l}})},8544:(t,e,r)=>{var n=r(1082),o=r(7515),i=r(9611);n({target:"Array",proto:!0},{fill:o}),i("fill")},3324:(t,e,r)=>{"use strict";var n=r(1082),o=r(6374).filter;n({target:"Array",proto:!0,forced:!r(6937)("filter")},{filter:function(t){return o(this,t,arguments.length>1?arguments[1]:void 0)}})},6582:(t,e,r)=>{"use strict";var n=r(1082),o=r(6374).find,i=r(9611),a="find",u=!0;a in[]&&Array(1).find((function(){u=!1})),n({target:"Array",proto:!0,forced:u},{find:function(t){return o(this,t,arguments.length>1?arguments[1]:void 0)}}),i(a)},1917:(t,e,r)=>{var n=r(1082),o=r(1774);n({target:"Array",stat:!0,forced:!r(4585)((function(t){Array.from(t)}))},{from:o})},4270:(t,e,r)=>{"use strict";var n=r(1082),o=r(1270).includes,i=r(9611);n({target:"Array",proto:!0},{includes:function(t){return o(this,t,arguments.length>1?arguments[1]:void 0)}}),i("includes")},2837:(t,e,r)=>{"use strict";var n=r(8852),o=r(9611),i=r(873),a=r(6619),u=r(3131),s="Array Iterator",c=a.set,f=a.getterFor(s);t.exports=u(Array,"Array",(function(t,e){c(this,{type:s,target:n(t),index:0,kind:e})}),(function(){var t=f(this),e=t.target,r=t.kind,n=t.index++;return!e||n>=e.length?(t.target=void 0,{value:void 0,done:!0}):"keys"==r?{value:n,done:!1}:"values"==r?{value:e[n],done:!1}:{value:[n,e[n]],done:!1}}),"values"),i.Arguments=i.Array,o("keys"),o("values"),o("entries")},5691:(t,e,r)=>{"use strict";var n=r(1082),o=r(7361),i=r(8852),a=r(622),u=[].join,s=o!=Object,c=a("join",",");n({target:"Array",proto:!0,forced:s||!c},{join:function(t){return u.call(i(this),void 0===t?",":t)}})},7316:(t,e,r)=>{"use strict";var n=r(1082),o=r(6374).map;n({target:"Array",proto:!0,forced:!r(6937)("map")},{map:function(t){return o(this,t,arguments.length>1?arguments[1]:void 0)}})},1122:(t,e,r)=>{"use strict";var n=r(1082),o=r(6944),i=r(7828),a=r(2145),u=r(4954),s=r(8852),c=r(2076),f=r(3706),l=r(6937)("slice"),p=f("species"),h=[].slice,d=Math.max;n({target:"Array",proto:!0,forced:!l},{slice:function(t,e){var r,n,f,l=s(this),y=u(l.length),v=a(t,y),b=a(void 0===e?y:e,y);if(i(l)&&("function"!=typeof(r=l.constructor)||r!==Array&&!i(r.prototype)?o(r)&&null===(r=r[p])&&(r=void 0):r=void 0,r===Array||void 0===r))return h.call(l,v,b);for(n=new(void 0===r?Array:r)(d(b-v,0)),f=0;v<b;v++,f++)v in l&&c(n,f,l[v]);return n.length=f,n}})},2656:(t,e,r)=>{var n=r(5542),o=r(3376).f,i=Function.prototype,a=i.toString,u=/^\s*function ([^ (]*)/,s="name";n&&!(s in i)&&o(i,s,{configurable:!0,get:function(){try{return a.call(this).match(u)[1]}catch(t){return""}}})},7775:(t,e,r)=>{"use strict";var n=r(6935),o=r(6955);t.exports=n("Map",(function(t){return function(){return t(this,arguments.length?arguments[0]:void 0)}}),o)},3729:(t,e,r)=>{"use strict";var n=r(5542),o=r(6874),i=r(2350),a=r(1249),u=r(5884),s=r(3565),c=r(4029),f=r(8377),l=r(2034),p=r(7841),h=r(2361),d=r(8401).f,y=r(7825).f,v=r(3376).f,b=r(7753).trim,m="Number",g=o.Number,w=g.prototype,_=s(h(w))==m,S=function(t){if(f(t))throw TypeError("Cannot convert a Symbol value to a number");var e,r,n,o,i,a,u,s,c=l(t,"number");if("string"==typeof c&&c.length>2)if(43===(e=(c=b(c)).charCodeAt(0))||45===e){if(88===(r=c.charCodeAt(2))||120===r)return NaN}else if(48===e){switch(c.charCodeAt(1)){case 66:case 98:n=2,o=49;break;case 79:case 111:n=8,o=55;break;default:return+c}for(a=(i=c.slice(2)).length,u=0;u<a;u++)if((s=i.charCodeAt(u))<48||s>o)return NaN;return parseInt(i,n)}return+c};if(i(m,!g(" 0o1")||!g("0b1")||g("+0x1"))){for(var E,O=function(t){var e=arguments.length<1?0:t,r=this;return r instanceof O&&(_?p((function(){w.valueOf.call(r)})):s(r)!=m)?c(new g(S(e)),r,O):S(e)},x=n?d(g):"MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger,fromString,range".split(","),R=0;x.length>R;R++)u(g,E=x[R])&&!u(O,E)&&v(O,E,y(g,E));O.prototype=w,w.constructor=O,a(o,m,O)}},5957:(t,e,r)=>{"use strict";var n=r(1082),o=r(7896),i=r(7347),a=r(6640),u=r(7841),s=1..toFixed,c=Math.floor,f=function(t,e,r){return 0===e?r:e%2==1?f(t,e-1,r*t):f(t*t,e/2,r)},l=function(t,e,r){for(var n=-1,o=r;++n<6;)o+=e*t[n],t[n]=o%1e7,o=c(o/1e7)},p=function(t,e){for(var r=6,n=0;--r>=0;)n+=t[r],t[r]=c(n/e),n=n%e*1e7},h=function(t){for(var e=6,r="";--e>=0;)if(""!==r||0===e||0!==t[e]){var n=String(t[e]);r=""===r?n:r+a.call("0",7-n.length)+n}return r};n({target:"Number",proto:!0,forced:s&&("0.000"!==8e-5.toFixed(3)||"1"!==.9.toFixed(0)||"1.25"!==1.255.toFixed(2)||"1000000000000000128"!==(0xde0b6b3a7640080).toFixed(0))||!u((function(){s.call({})}))},{toFixed:function(t){var e,r,n,u,s=i(this),c=o(t),d=[0,0,0,0,0,0],y="",v="0";if(c<0||c>20)throw RangeError("Incorrect fraction digits");if(s!=s)return"NaN";if(s<=-1e21||s>=1e21)return String(s);if(s<0&&(y="-",s=-s),s>1e-21)if(r=(e=function(t){for(var e=0,r=t;r>=4096;)e+=12,r/=4096;for(;r>=2;)e+=1,r/=2;return e}(s*f(2,69,1))-69)<0?s*f(2,-e,1):s/f(2,e,1),r*=4503599627370496,(e=52-e)>0){for(l(d,0,r),n=c;n>=7;)l(d,1e7,0),n-=7;for(l(d,f(10,n,1),0),n=e-1;n>=23;)p(d,1<<23),n-=23;p(d,1<<n),l(d,1,1),p(d,2),v=h(d)}else l(d,0,r),l(d,1<<-e,0),v=h(d)+a.call("0",c);return c>0?y+((u=v.length)<=c?"0."+a.call("0",c-u)+v:v.slice(0,u-c)+"."+v.slice(u-c)):y+v}})},5940:(t,e,r)=>{var n=r(1082),o=r(5277);n({target:"Object",stat:!0,forced:Object.assign!==o},{assign:o})},5916:(t,e,r)=>{var n=r(1082),o=r(8686).entries;n({target:"Object",stat:!0},{entries:function(t){return o(t)}})},2512:(t,e,r)=>{var n=r(1082),o=r(7841),i=r(8852),a=r(7825).f,u=r(5542),s=o((function(){a(1)}));n({target:"Object",stat:!0,forced:!u||s,sham:!u},{getOwnPropertyDescriptor:function(t,e){return a(i(t),e)}})},8574:(t,e,r)=>{var n=r(1082),o=r(5542),i=r(8204),a=r(8852),u=r(7825),s=r(2076);n({target:"Object",stat:!0,sham:!o},{getOwnPropertyDescriptors:function(t){for(var e,r,n=a(t),o=u.f,c=i(n),f={},l=0;c.length>l;)void 0!==(r=o(n,e=c[l++]))&&s(f,e,r);return f}})},8400:(t,e,r)=>{var n=r(1082),o=r(7841),i=r(4680),a=r(8186),u=r(9241);n({target:"Object",stat:!0,forced:o((function(){a(1)})),sham:!u},{getPrototypeOf:function(t){return a(i(t))}})},9835:(t,e,r)=>{var n=r(1082),o=r(4680),i=r(965);n({target:"Object",stat:!0,forced:r(7841)((function(){i(1)}))},{keys:function(t){return i(o(t))}})},1511:(t,e,r)=>{r(1082)({target:"Object",stat:!0},{setPrototypeOf:r(2686)})},74:(t,e,r)=>{var n=r(939),o=r(1249),i=r(1851);n||o(Object.prototype,"toString",i,{unsafe:!0})},1337:(t,e,r)=>{"use strict";var n,o,i,a,u=r(1082),s=r(6852),c=r(6874),f=r(4578),l=r(6838),p=r(1249),h=r(7490),d=r(2686),y=r(9400),v=r(8802),b=r(6944),m=r(769),g=r(2482),w=r(6090),_=r(7093),S=r(4585),E=r(2004),O=r(998).set,x=r(6309),R=r(4022),T=r(1250),k=r(7529),P=r(7105),j=r(6619),A=r(2350),C=r(3706),I=r(206),L=r(8723),B=r(579),M=C("species"),U="Promise",N=j.get,D=j.set,F=j.getterFor(U),q=l&&l.prototype,H=l,W=q,z=c.TypeError,V=c.document,G=c.process,$=k.f,Y=$,J=!!(V&&V.createEvent&&c.dispatchEvent),K="function"==typeof PromiseRejectionEvent,X="unhandledrejection",Z=!1,Q=A(U,(function(){var t=w(H),e=t!==String(H);if(!e&&66===B)return!0;if(s&&!W.finally)return!0;if(B>=51&&/native code/.test(t))return!1;var r=new H((function(t){t(1)})),n=function(t){t((function(){}),(function(){}))};return(r.constructor={})[M]=n,!(Z=r.then((function(){}))instanceof n)||!e&&I&&!K})),tt=Q||!S((function(t){H.all(t).catch((function(){}))})),et=function(t){var e;return!(!b(t)||"function"!=typeof(e=t.then))&&e},rt=function(t,e){if(!t.notified){t.notified=!0;var r=t.reactions;x((function(){for(var n=t.value,o=1==t.state,i=0;r.length>i;){var a,u,s,c=r[i++],f=o?c.ok:c.fail,l=c.resolve,p=c.reject,h=c.domain;try{f?(o||(2===t.rejection&&at(t),t.rejection=1),!0===f?a=n:(h&&h.enter(),a=f(n),h&&(h.exit(),s=!0)),a===c.promise?p(z("Promise-chain cycle")):(u=et(a))?u.call(a,l,p):l(a)):p(n)}catch(t){h&&!s&&h.exit(),p(t)}}t.reactions=[],t.notified=!1,e&&!t.rejection&&ot(t)}))}},nt=function(t,e,r){var n,o;J?((n=V.createEvent("Event")).promise=e,n.reason=r,n.initEvent(t,!1,!0),c.dispatchEvent(n)):n={promise:e,reason:r},!K&&(o=c["on"+t])?o(n):t===X&&T("Unhandled promise rejection",r)},ot=function(t){O.call(c,(function(){var e,r=t.facade,n=t.value;if(it(t)&&(e=P((function(){L?G.emit("unhandledRejection",n,r):nt(X,r,n)})),t.rejection=L||it(t)?2:1,e.error))throw e.value}))},it=function(t){return 1!==t.rejection&&!t.parent},at=function(t){O.call(c,(function(){var e=t.facade;L?G.emit("rejectionHandled",e):nt("rejectionhandled",e,t.value)}))},ut=function(t,e,r){return function(n){t(e,n,r)}},st=function(t,e,r){t.done||(t.done=!0,r&&(t=r),t.value=e,t.state=2,rt(t,!0))},ct=function(t,e,r){if(!t.done){t.done=!0,r&&(t=r);try{if(t.facade===e)throw z("Promise can't be resolved itself");var n=et(e);n?x((function(){var r={done:!1};try{n.call(e,ut(ct,r,t),ut(st,r,t))}catch(e){st(r,e,t)}})):(t.value=e,t.state=1,rt(t,!1))}catch(e){st({done:!1},e,t)}}};if(Q&&(W=(H=function(t){g(this,H,U),m(t),n.call(this);var e=N(this);try{t(ut(ct,e),ut(st,e))}catch(t){st(e,t)}}).prototype,(n=function(t){D(this,{type:U,done:!1,notified:!1,parent:!1,reactions:[],rejection:!1,state:0,value:void 0})}).prototype=h(W,{then:function(t,e){var r=F(this),n=$(E(this,H));return n.ok="function"!=typeof t||t,n.fail="function"==typeof e&&e,n.domain=L?G.domain:void 0,r.parent=!0,r.reactions.push(n),0!=r.state&&rt(r,!1),n.promise},catch:function(t){return this.then(void 0,t)}}),o=function(){var t=new n,e=N(t);this.promise=t,this.resolve=ut(ct,e),this.reject=ut(st,e)},k.f=$=function(t){return t===H||t===i?new o(t):Y(t)},!s&&"function"==typeof l&&q!==Object.prototype)){a=q.then,Z||(p(q,"then",(function(t,e){var r=this;return new H((function(t,e){a.call(r,t,e)})).then(t,e)}),{unsafe:!0}),p(q,"catch",W.catch,{unsafe:!0}));try{delete q.constructor}catch(t){}d&&d(q,W)}u({global:!0,wrap:!0,forced:Q},{Promise:H}),y(H,U,!1,!0),v(U),i=f(U),u({target:U,stat:!0,forced:Q},{reject:function(t){var e=$(this);return e.reject.call(void 0,t),e.promise}}),u({target:U,stat:!0,forced:s||Q},{resolve:function(t){return R(s&&this===i?H:this,t)}}),u({target:U,stat:!0,forced:tt},{all:function(t){var e=this,r=$(e),n=r.resolve,o=r.reject,i=P((function(){var r=m(e.resolve),i=[],a=0,u=1;_(t,(function(t){var s=a++,c=!1;i.push(void 0),u++,r.call(e,t).then((function(t){c||(c=!0,i[s]=t,--u||n(i))}),o)})),--u||n(i)}));return i.error&&o(i.value),r.promise},race:function(t){var e=this,r=$(e),n=r.reject,o=P((function(){var o=m(e.resolve);_(t,(function(t){o.call(e,t).then(r.resolve,n)}))}));return o.error&&n(o.value),r.promise}})},6259:(t,e,r)=>{var n=r(1082),o=r(4578),i=r(769),a=r(47),u=r(6944),s=r(2361),c=r(5462),f=r(7841),l=o("Reflect","construct"),p=f((function(){function t(){}return!(l((function(){}),[],t)instanceof t)})),h=!f((function(){l((function(){}))})),d=p||h;n({target:"Reflect",stat:!0,forced:d,sham:d},{construct:function(t,e){i(t),a(e);var r=arguments.length<3?t:i(arguments[2]);if(h&&!p)return l(t,e,r);if(t==r){switch(e.length){case 0:return new t;case 1:return new t(e[0]);case 2:return new t(e[0],e[1]);case 3:return new t(e[0],e[1],e[2]);case 4:return new t(e[0],e[1],e[2],e[3])}var n=[null];return n.push.apply(n,e),new(c.apply(t,n))}var o=r.prototype,f=s(u(o)?o:Object.prototype),d=Function.apply.call(t,f,e);return u(d)?d:f}})},1818:(t,e,r)=>{"use strict";var n=r(1082),o=r(1144);n({target:"RegExp",proto:!0,forced:/./.exec!==o},{exec:o})},5699:(t,e,r)=>{"use strict";var n=r(1249),o=r(47),i=r(401),a=r(7841),u=r(9262),s="toString",c=RegExp.prototype,f=c.toString,l=a((function(){return"/a/b"!=f.call({source:"a",flags:"b"})})),p=f.name!=s;(l||p)&&n(RegExp.prototype,s,(function(){var t=o(this),e=i(t.source),r=t.flags;return"/"+e+"/"+i(void 0===r&&t instanceof RegExp&&!("flags"in c)?u.call(t):r)}),{unsafe:!0})},461:(t,e,r)=>{"use strict";var n=r(6935),o=r(6955);t.exports=n("Set",(function(t){return function(){return t(this,arguments.length?arguments[0]:void 0)}}),o)},6837:(t,e,r)=>{"use strict";var n=r(1082),o=r(4315),i=r(164),a=r(401);n({target:"String",proto:!0,forced:!r(6870)("includes")},{includes:function(t){return!!~a(i(this)).indexOf(a(o(t)),arguments.length>1?arguments[1]:void 0)}})},6949:(t,e,r)=>{"use strict";var n=r(6174).charAt,o=r(401),i=r(6619),a=r(3131),u="String Iterator",s=i.set,c=i.getterFor(u);a(String,"String",(function(t){s(this,{type:u,string:o(t),index:0})}),(function(){var t,e=c(this),r=e.string,o=e.index;return o>=r.length?{value:void 0,done:!0}:(t=n(r,o),e.index+=t.length,{value:t,done:!1})}))},7505:(t,e,r)=>{"use strict";var n=r(6918),o=r(47),i=r(4954),a=r(401),u=r(164),s=r(1866),c=r(3915);n("match",(function(t,e,r){return[function(e){var r=u(this),n=null==e?void 0:e[t];return void 0!==n?n.call(e,r):new RegExp(e)[t](a(r))},function(t){var n=o(this),u=a(t),f=r(e,n,u);if(f.done)return f.value;if(!n.global)return c(n,u);var l=n.unicode;n.lastIndex=0;for(var p,h=[],d=0;null!==(p=c(n,u));){var y=a(p[0]);h[d]=y,""===y&&(n.lastIndex=s(u,i(n.lastIndex),l)),d++}return 0===d?null:h}]}))},3292:(t,e,r)=>{"use strict";var n=r(1082),o=r(9534).start;n({target:"String",proto:!0,forced:r(4931)},{padStart:function(t){return o(this,t,arguments.length>1?arguments[1]:void 0)}})},4750:(t,e,r)=>{r(1082)({target:"String",proto:!0},{repeat:r(6640)})},4449:(t,e,r)=>{"use strict";var n=r(6918),o=r(7841),i=r(47),a=r(7896),u=r(4954),s=r(401),c=r(164),f=r(1866),l=r(9),p=r(3915),h=r(3706)("replace"),d=Math.max,y=Math.min,v="$0"==="a".replace(/./,"$0"),b=!!/./[h]&&""===/./[h]("a","$0");n("replace",(function(t,e,r){var n=b?"$":"$0";return[function(t,r){var n=c(this),o=null==t?void 0:t[h];return void 0!==o?o.call(t,n,r):e.call(s(n),t,r)},function(t,o){var c=i(this),h=s(t);if("string"==typeof o&&-1===o.indexOf(n)&&-1===o.indexOf("$<")){var v=r(e,c,h,o);if(v.done)return v.value}var b="function"==typeof o;b||(o=s(o));var m=c.global;if(m){var g=c.unicode;c.lastIndex=0}for(var w=[];;){var _=p(c,h);if(null===_)break;if(w.push(_),!m)break;""===s(_[0])&&(c.lastIndex=f(h,u(c.lastIndex),g))}for(var S,E="",O=0,x=0;x<w.length;x++){_=w[x];for(var R=s(_[0]),T=d(y(a(_.index),h.length),0),k=[],P=1;P<_.length;P++)k.push(void 0===(S=_[P])?S:String(S));var j=_.groups;if(b){var A=[R].concat(k,T,h);void 0!==j&&A.push(j);var C=s(o.apply(void 0,A))}else C=l(R,h,T,k,j,o);T>=O&&(E+=h.slice(O,T)+C,O=T+R.length)}return E+h.slice(O)}]}),!!o((function(){var t=/./;return t.exec=function(){var t=[];return t.groups={a:"7"},t},"7"!=="".replace(t,"$<a>")}))||!v||b)},1661:(t,e,r)=>{"use strict";var n=r(6918),o=r(2399),i=r(47),a=r(164),u=r(2004),s=r(1866),c=r(4954),f=r(401),l=r(3915),p=r(1144),h=r(768),d=r(7841),y=h.UNSUPPORTED_Y,v=[].push,b=Math.min,m=4294967295;n("split",(function(t,e,r){var n;return n="c"=="abbc".split(/(b)*/)[1]||4!="test".split(/(?:)/,-1).length||2!="ab".split(/(?:ab)*/).length||4!=".".split(/(.?)(.?)/).length||".".split(/()()/).length>1||"".split(/.?/).length?function(t,r){var n=f(a(this)),i=void 0===r?m:r>>>0;if(0===i)return[];if(void 0===t)return[n];if(!o(t))return e.call(n,t,i);for(var u,s,c,l=[],h=(t.ignoreCase?"i":"")+(t.multiline?"m":"")+(t.unicode?"u":"")+(t.sticky?"y":""),d=0,y=new RegExp(t.source,h+"g");(u=p.call(y,n))&&!((s=y.lastIndex)>d&&(l.push(n.slice(d,u.index)),u.length>1&&u.index<n.length&&v.apply(l,u.slice(1)),c=u[0].length,d=s,l.length>=i));)y.lastIndex===u.index&&y.lastIndex++;return d===n.length?!c&&y.test("")||l.push(""):l.push(n.slice(d)),l.length>i?l.slice(0,i):l}:"0".split(void 0,0).length?function(t,r){return void 0===t&&0===r?[]:e.call(this,t,r)}:e,[function(e,r){var o=a(this),i=null==e?void 0:e[t];return void 0!==i?i.call(e,o,r):n.call(f(o),e,r)},function(t,o){var a=i(this),p=f(t),h=r(n,a,p,o,n!==e);if(h.done)return h.value;var d=u(a,RegExp),v=a.unicode,g=(a.ignoreCase?"i":"")+(a.multiline?"m":"")+(a.unicode?"u":"")+(y?"g":"y"),w=new d(y?"^(?:"+a.source+")":a,g),_=void 0===o?m:o>>>0;if(0===_)return[];if(0===p.length)return null===l(w,p)?[p]:[];for(var S=0,E=0,O=[];E<p.length;){w.lastIndex=y?0:E;var x,R=l(w,y?p.slice(E):p);if(null===R||(x=b(c(w.lastIndex+(y?E:0)),p.length))===S)E=s(p,E,v);else{if(O.push(p.slice(S,E)),O.length===_)return O;for(var T=1;T<=R.length-1;T++)if(O.push(R[T]),O.length===_)return O;E=S=x}}return O.push(p.slice(S)),O}]}),!!d((function(){var t=/(?:)/,e=t.exec;t.exec=function(){return e.apply(this,arguments)};var r="ab".split(t);return 2!==r.length||"a"!==r[0]||"b"!==r[1]})),y)},9340:(t,e,r)=>{"use strict";var n=r(1082),o=r(7753).trim;n({target:"String",proto:!0,forced:r(5206)("trim")},{trim:function(){return o(this)}})},8787:(t,e,r)=>{"use strict";var n=r(1082),o=r(5542),i=r(6874),a=r(5884),u=r(6944),s=r(3376).f,c=r(7918),f=i.Symbol;if(o&&"function"==typeof f&&(!("description"in f.prototype)||void 0!==f().description)){var l={},p=function(){var t=arguments.length<1||void 0===arguments[0]?void 0:String(arguments[0]),e=this instanceof p?new f(t):void 0===t?f():f(t);return""===t&&(l[e]=!0),e};c(p,f);var h=p.prototype=f.prototype;h.constructor=p;var d=h.toString,y="Symbol(test)"==String(f("test")),v=/^Symbol\((.*)\)[^)]+$/;s(h,"description",{configurable:!0,get:function(){var t=u(this)?this.valueOf():this,e=d.call(t);if(a(l,t))return"";var r=y?e.slice(7,-1):e.replace(v,"$1");return""===r?void 0:r}}),n({global:!0,forced:!0},{Symbol:p})}},5753:(t,e,r)=>{r(1578)("iterator")},7404:(t,e,r)=>{"use strict";var n=r(1082),o=r(6874),i=r(4578),a=r(6852),u=r(5542),s=r(1453),c=r(7841),f=r(5884),l=r(7828),p=r(6944),h=r(8377),d=r(47),y=r(4680),v=r(8852),b=r(2694),m=r(401),g=r(976),w=r(2361),_=r(965),S=r(8401),E=r(3866),O=r(1913),x=r(7825),R=r(3376),T=r(3626),k=r(4791),P=r(1249),j=r(3215),A=r(8698),C=r(5644),I=r(8435),L=r(3706),B=r(8403),M=r(1578),U=r(9400),N=r(6619),D=r(6374).forEach,F=A("hidden"),q="Symbol",H=L("toPrimitive"),W=N.set,z=N.getterFor(q),V=Object.prototype,G=o.Symbol,$=i("JSON","stringify"),Y=x.f,J=R.f,K=E.f,X=T.f,Z=j("symbols"),Q=j("op-symbols"),tt=j("string-to-symbol-registry"),et=j("symbol-to-string-registry"),rt=j("wks"),nt=o.QObject,ot=!nt||!nt.prototype||!nt.prototype.findChild,it=u&&c((function(){return 7!=w(J({},"a",{get:function(){return J(this,"a",{value:7}).a}})).a}))?function(t,e,r){var n=Y(V,e);n&&delete V[e],J(t,e,r),n&&t!==V&&J(V,e,n)}:J,at=function(t,e){var r=Z[t]=w(G.prototype);return W(r,{type:q,tag:t,description:e}),u||(r.description=e),r},ut=function(t,e,r){t===V&&ut(Q,e,r),d(t);var n=b(e);return d(r),f(Z,n)?(r.enumerable?(f(t,F)&&t[F][n]&&(t[F][n]=!1),r=w(r,{enumerable:g(0,!1)})):(f(t,F)||J(t,F,g(1,{})),t[F][n]=!0),it(t,n,r)):J(t,n,r)},st=function(t,e){d(t);var r=v(e),n=_(r).concat(pt(r));return D(n,(function(e){u&&!ct.call(r,e)||ut(t,e,r[e])})),t},ct=function(t){var e=b(t),r=X.call(this,e);return!(this===V&&f(Z,e)&&!f(Q,e))&&(!(r||!f(this,e)||!f(Z,e)||f(this,F)&&this[F][e])||r)},ft=function(t,e){var r=v(t),n=b(e);if(r!==V||!f(Z,n)||f(Q,n)){var o=Y(r,n);return!o||!f(Z,n)||f(r,F)&&r[F][n]||(o.enumerable=!0),o}},lt=function(t){var e=K(v(t)),r=[];return D(e,(function(t){f(Z,t)||f(C,t)||r.push(t)})),r},pt=function(t){var e=t===V,r=K(e?Q:v(t)),n=[];return D(r,(function(t){!f(Z,t)||e&&!f(V,t)||n.push(Z[t])})),n};s||(P((G=function(){if(this instanceof G)throw TypeError("Symbol is not a constructor");var t=arguments.length&&void 0!==arguments[0]?m(arguments[0]):void 0,e=I(t),r=function(t){this===V&&r.call(Q,t),f(this,F)&&f(this[F],e)&&(this[F][e]=!1),it(this,e,g(1,t))};return u&&ot&&it(V,e,{configurable:!0,set:r}),at(e,t)}).prototype,"toString",(function(){return z(this).tag})),P(G,"withoutSetter",(function(t){return at(I(t),t)})),T.f=ct,R.f=ut,x.f=ft,S.f=E.f=lt,O.f=pt,B.f=function(t){return at(L(t),t)},u&&(J(G.prototype,"description",{configurable:!0,get:function(){return z(this).description}}),a||P(V,"propertyIsEnumerable",ct,{unsafe:!0}))),n({global:!0,wrap:!0,forced:!s,sham:!s},{Symbol:G}),D(_(rt),(function(t){M(t)})),n({target:q,stat:!0,forced:!s},{for:function(t){var e=m(t);if(f(tt,e))return tt[e];var r=G(e);return tt[e]=r,et[r]=e,r},keyFor:function(t){if(!h(t))throw TypeError(t+" is not a symbol");if(f(et,t))return et[t]},useSetter:function(){ot=!0},useSimple:function(){ot=!1}}),n({target:"Object",stat:!0,forced:!s,sham:!u},{create:function(t,e){return void 0===e?w(t):st(w(t),e)},defineProperty:ut,defineProperties:st,getOwnPropertyDescriptor:ft}),n({target:"Object",stat:!0,forced:!s},{getOwnPropertyNames:lt,getOwnPropertySymbols:pt}),n({target:"Object",stat:!0,forced:c((function(){O.f(1)}))},{getOwnPropertySymbols:function(t){return O.f(y(t))}}),$&&n({target:"JSON",stat:!0,forced:!s||c((function(){var t=G();return"[null]"!=$([t])||"{}"!=$({a:t})||"{}"!=$(Object(t))}))},{stringify:function(t,e,r){for(var n,o=[t],i=1;arguments.length>i;)o.push(arguments[i++]);if(n=e,(p(e)||void 0!==t)&&!h(t))return l(e)||(e=function(t,e){if("function"==typeof n&&(e=n.call(this,t,e)),!h(e))return e}),o[1]=e,$.apply(null,o)}}),G.prototype[H]||k(G.prototype,H,G.prototype.valueOf),U(G,q),C[F]=!0},77:(t,e,r)=>{"use strict";var n=r(2211),o=r(2116),i=n.aTypedArray;(0,n.exportTypedArrayMethod)("copyWithin",(function(t,e){return o.call(i(this),t,e,arguments.length>2?arguments[2]:void 0)}))},9038:(t,e,r)=>{"use strict";var n=r(2211),o=r(6374).every,i=n.aTypedArray;(0,n.exportTypedArrayMethod)("every",(function(t){return o(i(this),t,arguments.length>1?arguments[1]:void 0)}))},7522:(t,e,r)=>{"use strict";var n=r(2211),o=r(7515),i=n.aTypedArray;(0,n.exportTypedArrayMethod)("fill",(function(t){return o.apply(i(this),arguments)}))},6534:(t,e,r)=>{"use strict";var n=r(2211),o=r(6374).filter,i=r(6696),a=n.aTypedArray;(0,n.exportTypedArrayMethod)("filter",(function(t){var e=o(a(this),t,arguments.length>1?arguments[1]:void 0);return i(this,e)}))},1888:(t,e,r)=>{"use strict";var n=r(2211),o=r(6374).findIndex,i=n.aTypedArray;(0,n.exportTypedArrayMethod)("findIndex",(function(t){return o(i(this),t,arguments.length>1?arguments[1]:void 0)}))},538:(t,e,r)=>{"use strict";var n=r(2211),o=r(6374).find,i=n.aTypedArray;(0,n.exportTypedArrayMethod)("find",(function(t){return o(i(this),t,arguments.length>1?arguments[1]:void 0)}))},1613:(t,e,r)=>{"use strict";var n=r(2211),o=r(6374).forEach,i=n.aTypedArray;(0,n.exportTypedArrayMethod)("forEach",(function(t){o(i(this),t,arguments.length>1?arguments[1]:void 0)}))},2744:(t,e,r)=>{"use strict";var n=r(2211),o=r(1270).includes,i=n.aTypedArray;(0,n.exportTypedArrayMethod)("includes",(function(t){return o(i(this),t,arguments.length>1?arguments[1]:void 0)}))},5066:(t,e,r)=>{"use strict";var n=r(2211),o=r(1270).indexOf,i=n.aTypedArray;(0,n.exportTypedArrayMethod)("indexOf",(function(t){return o(i(this),t,arguments.length>1?arguments[1]:void 0)}))},2315:(t,e,r)=>{"use strict";var n=r(6874),o=r(2211),i=r(2837),a=r(3706)("iterator"),u=n.Uint8Array,s=i.values,c=i.keys,f=i.entries,l=o.aTypedArray,p=o.exportTypedArrayMethod,h=u&&u.prototype[a],d=!!h&&("values"==h.name||null==h.name),y=function(){return s.call(l(this))};p("entries",(function(){return f.call(l(this))})),p("keys",(function(){return c.call(l(this))})),p("values",y,!d),p(a,y,!d)},5288:(t,e,r)=>{"use strict";var n=r(2211),o=n.aTypedArray,i=n.exportTypedArrayMethod,a=[].join;i("join",(function(t){return a.apply(o(this),arguments)}))},5503:(t,e,r)=>{"use strict";var n=r(2211),o=r(16),i=n.aTypedArray;(0,n.exportTypedArrayMethod)("lastIndexOf",(function(t){return o.apply(i(this),arguments)}))},9969:(t,e,r)=>{"use strict";var n=r(2211),o=r(6374).map,i=r(5751),a=n.aTypedArray;(0,n.exportTypedArrayMethod)("map",(function(t){return o(a(this),t,arguments.length>1?arguments[1]:void 0,(function(t,e){return new(i(t))(e)}))}))},1587:(t,e,r)=>{"use strict";var n=r(2211),o=r(9553).right,i=n.aTypedArray;(0,n.exportTypedArrayMethod)("reduceRight",(function(t){return o(i(this),t,arguments.length,arguments.length>1?arguments[1]:void 0)}))},2103:(t,e,r)=>{"use strict";var n=r(2211),o=r(9553).left,i=n.aTypedArray;(0,n.exportTypedArrayMethod)("reduce",(function(t){return o(i(this),t,arguments.length,arguments.length>1?arguments[1]:void 0)}))},5109:(t,e,r)=>{"use strict";var n=r(2211),o=n.aTypedArray,i=n.exportTypedArrayMethod,a=Math.floor;i("reverse",(function(){for(var t,e=this,r=o(e).length,n=a(r/2),i=0;i<n;)t=e[i],e[i++]=e[--r],e[r]=t;return e}))},1418:(t,e,r)=>{"use strict";var n=r(2211),o=r(4954),i=r(6189),a=r(4680),u=r(7841),s=n.aTypedArray;(0,n.exportTypedArrayMethod)("set",(function(t){s(this);var e=i(arguments.length>1?arguments[1]:void 0,1),r=this.length,n=a(t),u=o(n.length),c=0;if(u+e>r)throw RangeError("Wrong length");for(;c<u;)this[e+c]=n[c++]}),u((function(){new Int8Array(1).set({})})))},9760:(t,e,r)=>{"use strict";var n=r(2211),o=r(5751),i=r(7841),a=n.aTypedArray,u=n.exportTypedArrayMethod,s=[].slice;u("slice",(function(t,e){for(var r=s.call(a(this),t,e),n=o(this),i=0,u=r.length,c=new n(u);u>i;)c[i]=r[i++];return c}),i((function(){new Int8Array(1).slice()})))},4948:(t,e,r)=>{"use strict";var n=r(2211),o=r(6374).some,i=n.aTypedArray;(0,n.exportTypedArrayMethod)("some",(function(t){return o(i(this),t,arguments.length>1?arguments[1]:void 0)}))},727:(t,e,r)=>{"use strict";var n=r(2211),o=r(6874),i=r(7841),a=r(769),u=r(4954),s=r(7921),c=r(6817),f=r(6264),l=r(579),p=r(9736),h=n.aTypedArray,d=n.exportTypedArrayMethod,y=o.Uint16Array,v=y&&y.prototype.sort,b=!!v&&!i((function(){var t=new y(2);t.sort(null),t.sort({})})),m=!!v&&!i((function(){if(l)return l<74;if(c)return c<67;if(f)return!0;if(p)return p<602;var t,e,r=new y(516),n=Array(516);for(t=0;t<516;t++)e=t%4,r[t]=515-t,n[t]=t-2*e+3;for(r.sort((function(t,e){return(t/4|0)-(e/4|0)})),t=0;t<516;t++)if(r[t]!==n[t])return!0}));d("sort",(function(t){var e=this;if(void 0!==t&&a(t),m)return v.call(e,t);h(e);var r,n=u(e.length),o=Array(n);for(r=0;r<n;r++)o[r]=e[r];for(o=s(e,function(t){return function(e,r){return void 0!==t?+t(e,r)||0:r!=r?-1:e!=e?1:0===e&&0===r?1/e>0&&1/r<0?1:-1:e>r}}(t)),r=0;r<n;r++)e[r]=o[r];return e}),!m||b)},5448:(t,e,r)=>{"use strict";var n=r(2211),o=r(4954),i=r(2145),a=r(5751),u=n.aTypedArray;(0,n.exportTypedArrayMethod)("subarray",(function(t,e){var r=u(this),n=r.length,s=i(t,n);return new(a(r))(r.buffer,r.byteOffset+s*r.BYTES_PER_ELEMENT,o((void 0===e?n:i(e,n))-s))}))},6179:(t,e,r)=>{"use strict";var n=r(6874),o=r(2211),i=r(7841),a=n.Int8Array,u=o.aTypedArray,s=o.exportTypedArrayMethod,c=[].toLocaleString,f=[].slice,l=!!a&&i((function(){c.call(new a(1))}));s("toLocaleString",(function(){return c.apply(l?f.call(u(this)):u(this),arguments)}),i((function(){return[1,2].toLocaleString()!=new a([1,2]).toLocaleString()}))||!i((function(){a.prototype.toLocaleString.call([1,2])})))},5694:(t,e,r)=>{"use strict";var n=r(2211).exportTypedArrayMethod,o=r(7841),i=r(6874).Uint8Array,a=i&&i.prototype||{},u=[].toString,s=[].join;o((function(){u.call({})}))&&(u=function(){return s.call(this)});var c=a.toString!=u;n("toString",u,c)},6747:(t,e,r)=>{r(3151)("Uint8",(function(t){return function(e,r,n){return t(this,e,r,n)}}))},31:(t,e,r)=>{var n=r(6874),o=r(8956),i=r(1244),a=r(4791);for(var u in o){var s=n[u],c=s&&s.prototype;if(c&&c.forEach!==i)try{a(c,"forEach",i)}catch(t){c.forEach=i}}},9773:(t,e,r)=>{var n=r(6874),o=r(8956),i=r(2837),a=r(4791),u=r(3706),s=u("iterator"),c=u("toStringTag"),f=i.values;for(var l in o){var p=n[l],h=p&&p.prototype;if(h){if(h[s]!==f)try{a(h,s,f)}catch(t){h[s]=f}if(h[c]||a(h,c,l),o[l])for(var d in i)if(h[d]!==i[d])try{a(h,d,i[d])}catch(t){h[d]=i[d]}}}},2303:(t,e,r)=>{"use strict";r(2837);var n=r(1082),o=r(4578),i=r(1781),a=r(1249),u=r(7490),s=r(9400),c=r(9670),f=r(6619),l=r(2482),p=r(5884),h=r(4833),d=r(8753),y=r(47),v=r(6944),b=r(401),m=r(2361),g=r(976),w=r(7053),_=r(3126),S=r(3706),E=o("fetch"),O=o("Request"),x=O&&O.prototype,R=o("Headers"),T=S("iterator"),k="URLSearchParams",P="URLSearchParamsIterator",j=f.set,A=f.getterFor(k),C=f.getterFor(P),I=/\+/g,L=Array(4),B=function(t){return L[t-1]||(L[t-1]=RegExp("((?:%[\\da-f]{2}){"+t+"})","gi"))},M=function(t){try{return decodeURIComponent(t)}catch(e){return t}},U=function(t){var e=t.replace(I," "),r=4;try{return decodeURIComponent(e)}catch(t){for(;r;)e=e.replace(B(r--),M);return e}},N=/[!'()~]|%20/g,D={"!":"%21","'":"%27","(":"%28",")":"%29","~":"%7E","%20":"+"},F=function(t){return D[t]},q=function(t){return encodeURIComponent(t).replace(N,F)},H=function(t,e){if(e)for(var r,n,o=e.split("&"),i=0;i<o.length;)(r=o[i++]).length&&(n=r.split("="),t.push({key:U(n.shift()),value:U(n.join("="))}))},W=function(t){this.entries.length=0,H(this.entries,t)},z=function(t,e){if(t<e)throw TypeError("Not enough arguments")},V=c((function(t,e){j(this,{type:P,iterator:w(A(t).entries),kind:e})}),"Iterator",(function(){var t=C(this),e=t.kind,r=t.iterator.next(),n=r.value;return r.done||(r.value="keys"===e?n.key:"values"===e?n.value:[n.key,n.value]),r})),G=function(){l(this,G,k);var t,e,r,n,o,i,a,u,s,c=arguments.length>0?arguments[0]:void 0,f=this,h=[];if(j(f,{type:k,entries:h,updateURL:function(){},updateSearchParams:W}),void 0!==c)if(v(c))if("function"==typeof(t=_(c)))for(r=(e=t.call(c)).next;!(n=r.call(e)).done;){if((a=(i=(o=w(y(n.value))).next).call(o)).done||(u=i.call(o)).done||!i.call(o).done)throw TypeError("Expected sequence with length 2");h.push({key:b(a.value),value:b(u.value)})}else for(s in c)p(c,s)&&h.push({key:s,value:b(c[s])});else H(h,"string"==typeof c?"?"===c.charAt(0)?c.slice(1):c:b(c))},$=G.prototype;if(u($,{append:function(t,e){z(arguments.length,2);var r=A(this);r.entries.push({key:b(t),value:b(e)}),r.updateURL()},delete:function(t){z(arguments.length,1);for(var e=A(this),r=e.entries,n=b(t),o=0;o<r.length;)r[o].key===n?r.splice(o,1):o++;e.updateURL()},get:function(t){z(arguments.length,1);for(var e=A(this).entries,r=b(t),n=0;n<e.length;n++)if(e[n].key===r)return e[n].value;return null},getAll:function(t){z(arguments.length,1);for(var e=A(this).entries,r=b(t),n=[],o=0;o<e.length;o++)e[o].key===r&&n.push(e[o].value);return n},has:function(t){z(arguments.length,1);for(var e=A(this).entries,r=b(t),n=0;n<e.length;)if(e[n++].key===r)return!0;return!1},set:function(t,e){z(arguments.length,1);for(var r,n=A(this),o=n.entries,i=!1,a=b(t),u=b(e),s=0;s<o.length;s++)(r=o[s]).key===a&&(i?o.splice(s--,1):(i=!0,r.value=u));i||o.push({key:a,value:u}),n.updateURL()},sort:function(){var t,e,r,n=A(this),o=n.entries,i=o.slice();for(o.length=0,r=0;r<i.length;r++){for(t=i[r],e=0;e<r;e++)if(o[e].key>t.key){o.splice(e,0,t);break}e===r&&o.push(t)}n.updateURL()},forEach:function(t){for(var e,r=A(this).entries,n=h(t,arguments.length>1?arguments[1]:void 0,3),o=0;o<r.length;)n((e=r[o++]).value,e.key,this)},keys:function(){return new V(this,"keys")},values:function(){return new V(this,"values")},entries:function(){return new V(this,"entries")}},{enumerable:!0}),a($,T,$.entries),a($,"toString",(function(){for(var t,e=A(this).entries,r=[],n=0;n<e.length;)t=e[n++],r.push(q(t.key)+"="+q(t.value));return r.join("&")}),{enumerable:!0}),s(G,k),n({global:!0,forced:!i},{URLSearchParams:G}),!i&&"function"==typeof R){var Y=function(t){if(v(t)){var e,r=t.body;if(d(r)===k)return(e=t.headers?new R(t.headers):new R).has("content-type")||e.set("content-type","application/x-www-form-urlencoded;charset=UTF-8"),m(t,{body:g(0,String(r)),headers:g(0,e)})}return t};if("function"==typeof E&&n({global:!0,enumerable:!0,forced:!0},{fetch:function(t){return E(t,arguments.length>1?Y(arguments[1]):{})}}),"function"==typeof O){var J=function(t){return l(this,J,"Request"),new O(t,arguments.length>1?Y(arguments[1]):{})};x.constructor=J,J.prototype=x,n({global:!0,forced:!0},{Request:J})}}t.exports={URLSearchParams:G,getState:A}},2743:(t,e,r)=>{"use strict";r(6949);var n,o=r(1082),i=r(5542),a=r(1781),u=r(6874),s=r(7852),c=r(1249),f=r(2482),l=r(5884),p=r(5277),h=r(1774),d=r(6174).codeAt,y=r(8),v=r(401),b=r(9400),m=r(2303),g=r(6619),w=u.URL,_=m.URLSearchParams,S=m.getState,E=g.set,O=g.getterFor("URL"),x=Math.floor,R=Math.pow,T="Invalid scheme",k="Invalid host",P="Invalid port",j=/[A-Za-z]/,A=/[\d+-.A-Za-z]/,C=/\d/,I=/^0x/i,L=/^[0-7]+$/,B=/^\d+$/,M=/^[\dA-Fa-f]+$/,U=/[\0\t\n\r #%/:<>?@[\\\]^|]/,N=/[\0\t\n\r #/:<>?@[\\\]^|]/,D=/^[\u0000-\u0020]+|[\u0000-\u0020]+$/g,F=/[\t\n\r]/g,q=function(t,e){var r,n,o;if("["==e.charAt(0)){if("]"!=e.charAt(e.length-1))return k;if(!(r=W(e.slice(1,-1))))return k;t.host=r}else if(X(t)){if(e=y(e),U.test(e))return k;if(null===(r=H(e)))return k;t.host=r}else{if(N.test(e))return k;for(r="",n=h(e),o=0;o<n.length;o++)r+=J(n[o],V);t.host=r}},H=function(t){var e,r,n,o,i,a,u,s=t.split(".");if(s.length&&""==s[s.length-1]&&s.pop(),(e=s.length)>4)return t;for(r=[],n=0;n<e;n++){if(""==(o=s[n]))return t;if(i=10,o.length>1&&"0"==o.charAt(0)&&(i=I.test(o)?16:8,o=o.slice(8==i?1:2)),""===o)a=0;else{if(!(10==i?B:8==i?L:M).test(o))return t;a=parseInt(o,i)}r.push(a)}for(n=0;n<e;n++)if(a=r[n],n==e-1){if(a>=R(256,5-e))return null}else if(a>255)return null;for(u=r.pop(),n=0;n<r.length;n++)u+=r[n]*R(256,3-n);return u},W=function(t){var e,r,n,o,i,a,u,s=[0,0,0,0,0,0,0,0],c=0,f=null,l=0,p=function(){return t.charAt(l)};if(":"==p()){if(":"!=t.charAt(1))return;l+=2,f=++c}for(;p();){if(8==c)return;if(":"!=p()){for(e=r=0;r<4&&M.test(p());)e=16*e+parseInt(p(),16),l++,r++;if("."==p()){if(0==r)return;if(l-=r,c>6)return;for(n=0;p();){if(o=null,n>0){if(!("."==p()&&n<4))return;l++}if(!C.test(p()))return;for(;C.test(p());){if(i=parseInt(p(),10),null===o)o=i;else{if(0==o)return;o=10*o+i}if(o>255)return;l++}s[c]=256*s[c]+o,2!=++n&&4!=n||c++}if(4!=n)return;break}if(":"==p()){if(l++,!p())return}else if(p())return;s[c++]=e}else{if(null!==f)return;l++,f=++c}}if(null!==f)for(a=c-f,c=7;0!=c&&a>0;)u=s[c],s[c--]=s[f+a-1],s[f+--a]=u;else if(8!=c)return;return s},z=function(t){var e,r,n,o;if("number"==typeof t){for(e=[],r=0;r<4;r++)e.unshift(t%256),t=x(t/256);return e.join(".")}if("object"==typeof t){for(e="",n=function(t){for(var e=null,r=1,n=null,o=0,i=0;i<8;i++)0!==t[i]?(o>r&&(e=n,r=o),n=null,o=0):(null===n&&(n=i),++o);return o>r&&(e=n,r=o),e}(t),r=0;r<8;r++)o&&0===t[r]||(o&&(o=!1),n===r?(e+=r?":":"::",o=!0):(e+=t[r].toString(16),r<7&&(e+=":")));return"["+e+"]"}return t},V={},G=p({},V,{" ":1,'"':1,"<":1,">":1,"`":1}),$=p({},G,{"#":1,"?":1,"{":1,"}":1}),Y=p({},$,{"/":1,":":1,";":1,"=":1,"@":1,"[":1,"\\":1,"]":1,"^":1,"|":1}),J=function(t,e){var r=d(t,0);return r>32&&r<127&&!l(e,t)?t:encodeURIComponent(t)},K={ftp:21,file:null,http:80,https:443,ws:80,wss:443},X=function(t){return l(K,t.scheme)},Z=function(t){return""!=t.username||""!=t.password},Q=function(t){return!t.host||t.cannotBeABaseURL||"file"==t.scheme},tt=function(t,e){var r;return 2==t.length&&j.test(t.charAt(0))&&(":"==(r=t.charAt(1))||!e&&"|"==r)},et=function(t){var e;return t.length>1&&tt(t.slice(0,2))&&(2==t.length||"/"===(e=t.charAt(2))||"\\"===e||"?"===e||"#"===e)},rt=function(t){var e=t.path,r=e.length;!r||"file"==t.scheme&&1==r&&tt(e[0],!0)||e.pop()},nt=function(t){return"."===t||"%2e"===t.toLowerCase()},ot={},it={},at={},ut={},st={},ct={},ft={},lt={},pt={},ht={},dt={},yt={},vt={},bt={},mt={},gt={},wt={},_t={},St={},Et={},Ot={},xt=function(t,e,r,o){var i,a,u,s,c,f=r||ot,p=0,d="",y=!1,v=!1,b=!1;for(r||(t.scheme="",t.username="",t.password="",t.host=null,t.port=null,t.path=[],t.query=null,t.fragment=null,t.cannotBeABaseURL=!1,e=e.replace(D,"")),e=e.replace(F,""),i=h(e);p<=i.length;){switch(a=i[p],f){case ot:if(!a||!j.test(a)){if(r)return T;f=at;continue}d+=a.toLowerCase(),f=it;break;case it:if(a&&(A.test(a)||"+"==a||"-"==a||"."==a))d+=a.toLowerCase();else{if(":"!=a){if(r)return T;d="",f=at,p=0;continue}if(r&&(X(t)!=l(K,d)||"file"==d&&(Z(t)||null!==t.port)||"file"==t.scheme&&!t.host))return;if(t.scheme=d,r)return void(X(t)&&K[t.scheme]==t.port&&(t.port=null));d="","file"==t.scheme?f=bt:X(t)&&o&&o.scheme==t.scheme?f=ut:X(t)?f=lt:"/"==i[p+1]?(f=st,p++):(t.cannotBeABaseURL=!0,t.path.push(""),f=St)}break;case at:if(!o||o.cannotBeABaseURL&&"#"!=a)return T;if(o.cannotBeABaseURL&&"#"==a){t.scheme=o.scheme,t.path=o.path.slice(),t.query=o.query,t.fragment="",t.cannotBeABaseURL=!0,f=Ot;break}f="file"==o.scheme?bt:ct;continue;case ut:if("/"!=a||"/"!=i[p+1]){f=ct;continue}f=pt,p++;break;case st:if("/"==a){f=ht;break}f=_t;continue;case ct:if(t.scheme=o.scheme,a==n)t.username=o.username,t.password=o.password,t.host=o.host,t.port=o.port,t.path=o.path.slice(),t.query=o.query;else if("/"==a||"\\"==a&&X(t))f=ft;else if("?"==a)t.username=o.username,t.password=o.password,t.host=o.host,t.port=o.port,t.path=o.path.slice(),t.query="",f=Et;else{if("#"!=a){t.username=o.username,t.password=o.password,t.host=o.host,t.port=o.port,t.path=o.path.slice(),t.path.pop(),f=_t;continue}t.username=o.username,t.password=o.password,t.host=o.host,t.port=o.port,t.path=o.path.slice(),t.query=o.query,t.fragment="",f=Ot}break;case ft:if(!X(t)||"/"!=a&&"\\"!=a){if("/"!=a){t.username=o.username,t.password=o.password,t.host=o.host,t.port=o.port,f=_t;continue}f=ht}else f=pt;break;case lt:if(f=pt,"/"!=a||"/"!=d.charAt(p+1))continue;p++;break;case pt:if("/"!=a&&"\\"!=a){f=ht;continue}break;case ht:if("@"==a){y&&(d="%40"+d),y=!0,u=h(d);for(var m=0;m<u.length;m++){var g=u[m];if(":"!=g||b){var w=J(g,Y);b?t.password+=w:t.username+=w}else b=!0}d=""}else if(a==n||"/"==a||"?"==a||"#"==a||"\\"==a&&X(t)){if(y&&""==d)return"Invalid authority";p-=h(d).length+1,d="",f=dt}else d+=a;break;case dt:case yt:if(r&&"file"==t.scheme){f=gt;continue}if(":"!=a||v){if(a==n||"/"==a||"?"==a||"#"==a||"\\"==a&&X(t)){if(X(t)&&""==d)return k;if(r&&""==d&&(Z(t)||null!==t.port))return;if(s=q(t,d))return s;if(d="",f=wt,r)return;continue}"["==a?v=!0:"]"==a&&(v=!1),d+=a}else{if(""==d)return k;if(s=q(t,d))return s;if(d="",f=vt,r==yt)return}break;case vt:if(!C.test(a)){if(a==n||"/"==a||"?"==a||"#"==a||"\\"==a&&X(t)||r){if(""!=d){var _=parseInt(d,10);if(_>65535)return P;t.port=X(t)&&_===K[t.scheme]?null:_,d=""}if(r)return;f=wt;continue}return P}d+=a;break;case bt:if(t.scheme="file","/"==a||"\\"==a)f=mt;else{if(!o||"file"!=o.scheme){f=_t;continue}if(a==n)t.host=o.host,t.path=o.path.slice(),t.query=o.query;else if("?"==a)t.host=o.host,t.path=o.path.slice(),t.query="",f=Et;else{if("#"!=a){et(i.slice(p).join(""))||(t.host=o.host,t.path=o.path.slice(),rt(t)),f=_t;continue}t.host=o.host,t.path=o.path.slice(),t.query=o.query,t.fragment="",f=Ot}}break;case mt:if("/"==a||"\\"==a){f=gt;break}o&&"file"==o.scheme&&!et(i.slice(p).join(""))&&(tt(o.path[0],!0)?t.path.push(o.path[0]):t.host=o.host),f=_t;continue;case gt:if(a==n||"/"==a||"\\"==a||"?"==a||"#"==a){if(!r&&tt(d))f=_t;else if(""==d){if(t.host="",r)return;f=wt}else{if(s=q(t,d))return s;if("localhost"==t.host&&(t.host=""),r)return;d="",f=wt}continue}d+=a;break;case wt:if(X(t)){if(f=_t,"/"!=a&&"\\"!=a)continue}else if(r||"?"!=a)if(r||"#"!=a){if(a!=n&&(f=_t,"/"!=a))continue}else t.fragment="",f=Ot;else t.query="",f=Et;break;case _t:if(a==n||"/"==a||"\\"==a&&X(t)||!r&&("?"==a||"#"==a)){if(".."===(c=(c=d).toLowerCase())||"%2e."===c||".%2e"===c||"%2e%2e"===c?(rt(t),"/"==a||"\\"==a&&X(t)||t.path.push("")):nt(d)?"/"==a||"\\"==a&&X(t)||t.path.push(""):("file"==t.scheme&&!t.path.length&&tt(d)&&(t.host&&(t.host=""),d=d.charAt(0)+":"),t.path.push(d)),d="","file"==t.scheme&&(a==n||"?"==a||"#"==a))for(;t.path.length>1&&""===t.path[0];)t.path.shift();"?"==a?(t.query="",f=Et):"#"==a&&(t.fragment="",f=Ot)}else d+=J(a,$);break;case St:"?"==a?(t.query="",f=Et):"#"==a?(t.fragment="",f=Ot):a!=n&&(t.path[0]+=J(a,V));break;case Et:r||"#"!=a?a!=n&&("'"==a&&X(t)?t.query+="%27":t.query+="#"==a?"%23":J(a,V)):(t.fragment="",f=Ot);break;case Ot:a!=n&&(t.fragment+=J(a,G))}p++}},Rt=function(t){var e,r,n=f(this,Rt,"URL"),o=arguments.length>1?arguments[1]:void 0,a=v(t),u=E(n,{type:"URL"});if(void 0!==o)if(o instanceof Rt)e=O(o);else if(r=xt(e={},v(o)))throw TypeError(r);if(r=xt(u,a,null,e))throw TypeError(r);var s=u.searchParams=new _,c=S(s);c.updateSearchParams(u.query),c.updateURL=function(){u.query=String(s)||null},i||(n.href=kt.call(n),n.origin=Pt.call(n),n.protocol=jt.call(n),n.username=At.call(n),n.password=Ct.call(n),n.host=It.call(n),n.hostname=Lt.call(n),n.port=Bt.call(n),n.pathname=Mt.call(n),n.search=Ut.call(n),n.searchParams=Nt.call(n),n.hash=Dt.call(n))},Tt=Rt.prototype,kt=function(){var t=O(this),e=t.scheme,r=t.username,n=t.password,o=t.host,i=t.port,a=t.path,u=t.query,s=t.fragment,c=e+":";return null!==o?(c+="//",Z(t)&&(c+=r+(n?":"+n:"")+"@"),c+=z(o),null!==i&&(c+=":"+i)):"file"==e&&(c+="//"),c+=t.cannotBeABaseURL?a[0]:a.length?"/"+a.join("/"):"",null!==u&&(c+="?"+u),null!==s&&(c+="#"+s),c},Pt=function(){var t=O(this),e=t.scheme,r=t.port;if("blob"==e)try{return new Rt(e.path[0]).origin}catch(t){return"null"}return"file"!=e&&X(t)?e+"://"+z(t.host)+(null!==r?":"+r:""):"null"},jt=function(){return O(this).scheme+":"},At=function(){return O(this).username},Ct=function(){return O(this).password},It=function(){var t=O(this),e=t.host,r=t.port;return null===e?"":null===r?z(e):z(e)+":"+r},Lt=function(){var t=O(this).host;return null===t?"":z(t)},Bt=function(){var t=O(this).port;return null===t?"":String(t)},Mt=function(){var t=O(this),e=t.path;return t.cannotBeABaseURL?e[0]:e.length?"/"+e.join("/"):""},Ut=function(){var t=O(this).query;return t?"?"+t:""},Nt=function(){return O(this).searchParams},Dt=function(){var t=O(this).fragment;return t?"#"+t:""},Ft=function(t,e){return{get:t,set:e,configurable:!0,enumerable:!0}};if(i&&s(Tt,{href:Ft(kt,(function(t){var e=O(this),r=v(t),n=xt(e,r);if(n)throw TypeError(n);S(e.searchParams).updateSearchParams(e.query)})),origin:Ft(Pt),protocol:Ft(jt,(function(t){var e=O(this);xt(e,v(t)+":",ot)})),username:Ft(At,(function(t){var e=O(this),r=h(v(t));if(!Q(e)){e.username="";for(var n=0;n<r.length;n++)e.username+=J(r[n],Y)}})),password:Ft(Ct,(function(t){var e=O(this),r=h(v(t));if(!Q(e)){e.password="";for(var n=0;n<r.length;n++)e.password+=J(r[n],Y)}})),host:Ft(It,(function(t){var e=O(this);e.cannotBeABaseURL||xt(e,v(t),dt)})),hostname:Ft(Lt,(function(t){var e=O(this);e.cannotBeABaseURL||xt(e,v(t),yt)})),port:Ft(Bt,(function(t){var e=O(this);Q(e)||(""==(t=v(t))?e.port=null:xt(e,t,vt))})),pathname:Ft(Mt,(function(t){var e=O(this);e.cannotBeABaseURL||(e.path=[],xt(e,v(t),wt))})),search:Ft(Ut,(function(t){var e=O(this);""==(t=v(t))?e.query=null:("?"==t.charAt(0)&&(t=t.slice(1)),e.query="",xt(e,t,Et)),S(e.searchParams).updateSearchParams(e.query)})),searchParams:Ft(Nt),hash:Ft(Dt,(function(t){var e=O(this);""!=(t=v(t))?("#"==t.charAt(0)&&(t=t.slice(1)),e.fragment="",xt(e,t,Ot)):e.fragment=null}))}),c(Tt,"toJSON",(function(){return kt.call(this)}),{enumerable:!0}),c(Tt,"toString",(function(){return kt.call(this)}),{enumerable:!0}),w){var qt=w.createObjectURL,Ht=w.revokeObjectURL;qt&&c(Rt,"createObjectURL",(function(t){return qt.apply(w,arguments)})),Ht&&c(Rt,"revokeObjectURL",(function(t){return Ht.apply(w,arguments)}))}b(Rt,"URL"),o({global:!0,forced:!a,sham:!i},{URL:Rt})},462:()=>{},6029:()=>{}},e={};function r(n){var o=e[n];if(void 0!==o)return o.exports;var i=e[n]={exports:{}};return t[n](i,i.exports,r),i.exports}r.n=t=>{var e=t&&t.__esModule?()=>t.default:()=>t;return r.d(e,{a:e}),e},r.d=(t,e)=>{for(var n in e)r.o(e,n)&&!r.o(t,n)&&Object.defineProperty(t,n,{enumerable:!0,get:e[n]})},r.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(t){if("object"==typeof window)return window}}(),r.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),r.r=t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})};var n={};return(()=>{"use strict";r.r(n),r.d(n,{AACDepay:()=>G,BasicDepay:()=>Z,CanvasSink:()=>dt,H264Depay:()=>Pt,Html5CanvasPipeline:()=>Li,Html5VideoMetadataPipeline:()=>Yi,Html5VideoPipeline:()=>Wi,HttpMsePipeline:()=>Ia,HttpSource:()=>Ft,Inspector:()=>Gt,JPEGDepay:()=>Oe,MessageType:()=>w,MetadataPipeline:()=>na,Mp4Capture:()=>Be,Mp4Muxer:()=>Fr,MseSink:()=>yn,ONVIFDepay:()=>Sn,Pipeline:()=>Wo,RTCPPacketType:()=>Dr,RTSPResponseError:()=>Ro,RTSP_METHOD:()=>co,RtspMjpegPipeline:()=>ci,RtspMp4Pipeline:()=>oi,RtspParser:()=>no,RtspPipeline:()=>Ko,RtspSession:()=>To,SDESItem:()=>zr,SR:()=>$r,Scheduler:()=>it,Sink:()=>O,Source:()=>S,Tube:()=>E,WSSource:()=>Do,WsSdpPipeline:()=>ha,addRTSPRetry:()=>La,bodyOffset:()=>Yn,cSrc:()=>M,cSrcCount:()=>j,components:()=>t,connectionEnded:()=>Gn,contentBase:()=>zn,contentLocation:()=>Vn,createTransform:()=>F,extHeader:()=>N,extHeaderLength:()=>U,extension:()=>P,extractHeaderValue:()=>Dn,extractURIs:()=>Mn,getTime:()=>uo,isRtcpApp:()=>on,isRtcpBye:()=>rn,isRtcpRR:()=>Zr,isRtcpSDES:()=>tn,isRtcpSR:()=>Kr,marker:()=>A,messageFromBuffer:()=>Nn,padding:()=>k,parse:()=>Un,parseRtcp:()=>Vr,payload:()=>D,payloadType:()=>C,pipelines:()=>e,range:()=>$n,rtcpMessageFromBuffer:()=>Gr,sSrc:()=>B,sequence:()=>Fn,sequenceNumber:()=>I,sessionId:()=>qn,sessionTimeout:()=>Hn,statusCode:()=>Wn,timestamp:()=>L,utils:()=>o,version:()=>T});var t={};r.r(t),r.d(t,{AACDepay:()=>G,BasicDepay:()=>Z,CanvasSink:()=>dt,H264Depay:()=>Pt,HttpSource:()=>Ft,Inspector:()=>Gt,JPEGDepay:()=>Oe,MessageType:()=>w,Mp4Capture:()=>Be,Mp4Muxer:()=>Fr,MseSink:()=>yn,ONVIFDepay:()=>Sn,RTSPResponseError:()=>Ro,RTSP_METHOD:()=>co,RtspParser:()=>no,RtspSession:()=>To,Sink:()=>O,Source:()=>S,Tube:()=>E,WSSource:()=>Do,createTransform:()=>F});var e={};r.r(e),r.d(e,{Html5CanvasPipeline:()=>Li,Html5VideoMetadataPipeline:()=>Yi,Html5VideoPipeline:()=>Wi,HttpMsePipeline:()=>Ia,MetadataPipeline:()=>na,Pipeline:()=>Wo,RtspMjpegPipeline:()=>ci,RtspMp4Pipeline:()=>oi,RtspPipeline:()=>Ko,WsSdpPipeline:()=>ha});var o={};r.r(o),r.d(o,{RTCPPacketType:()=>Dr,SDESItem:()=>zr,SR:()=>$r,Scheduler:()=>it,addRTSPRetry:()=>La,bodyOffset:()=>Yn,cSrc:()=>M,cSrcCount:()=>j,connectionEnded:()=>Gn,contentBase:()=>zn,contentLocation:()=>Vn,extHeader:()=>N,extHeaderLength:()=>U,extension:()=>P,extractHeaderValue:()=>Dn,extractURIs:()=>Mn,getTime:()=>uo,isRtcpApp:()=>on,isRtcpBye:()=>rn,isRtcpRR:()=>Zr,isRtcpSDES:()=>tn,isRtcpSR:()=>Kr,marker:()=>A,messageFromBuffer:()=>Nn,padding:()=>k,parse:()=>Un,parseRtcp:()=>Vr,payload:()=>D,payloadType:()=>C,range:()=>$n,rtcpMessageFromBuffer:()=>Gr,sSrc:()=>B,sequence:()=>Fn,sequenceNumber:()=>I,sessionId:()=>qn,sessionTimeout:()=>Hn,statusCode:()=>Wn,timestamp:()=>L,version:()=>T}),r(1511),r(8400),r(6259),r(7404),r(8787),r(74),r(5753),r(2837),r(6949),r(9773);var i=r(8981),a=(r(5940),r(5699),r(7866).Buffer);function u(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}var s=function(){function t(){!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,t)}var e,r;return e=t,r=[{key:"consumer",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:function(){};return new i.Writable({objectMode:!0,write:function(e,r,n){t(e),n()}})}},{key:"peeker",value:function(t){if("function"!=typeof t)throw new Error("you must supply a function");return new i.Transform({objectMode:!0,transform:function(e,r,n){t(e),n(void 0,e)}})}},{key:"producer",value:function(t){var e=0;return new i.Readable({objectMode:!0,read:function(){void 0!==t&&(e<t.length?this.push(t[e++]):this.push(null))}})}},{key:"recorder",value:function(t,e){return new i.Transform({objectMode:!0,transform:function(r,n,o){var i=Date.now(),a=Object.assign({},r,{data:r.data.toString("base64")});e.write(JSON.stringify({type:t,timestamp:i,message:a},null,2)),e.write(",\n"),o(void 0,r)}})}},{key:"replayer",value:function(t){var e=0,r=t[0].timestamp;return new i.Readable({objectMode:!0,read:function(){var n=t[e++];if(n){var o=n.type,i=n.timestamp,u=n.message,s=i-r;if(r=i,u){var c=u.data?a.from(u.data,"base64"):a.alloc(0),f=Object.assign({},u,{data:c});this.push({type:o,delay:s,msg:f})}else this.push({type:o,delay:s,msg:null})}else this.push(null)}})}}],null&&u(e.prototype,null),r&&u(e,r),t}();function c(t){return(c="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function f(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}function l(t,e,r){return e&&f(t.prototype,e),r&&f(t,r),t}function p(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&h(t,e)}function h(t,e){return(h=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}function d(t){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var r,n=b(t);if(e){var o=b(this).constructor;r=Reflect.construct(n,arguments,o)}else r=n.apply(this,arguments);return y(this,r)}}function y(t,e){return!e||"object"!==c(e)&&"function"!=typeof e?v(t):e}function v(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}function b(t){return(b=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}function m(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function g(t,e,r){return e in t?Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[e]=r,t}var w,_=function t(){m(this,t),g(this,"incoming",void 0),g(this,"outgoing",void 0),g(this,"next",void 0),g(this,"prev",void 0),g(this,"_incomingErrorHandler",void 0),g(this,"_outgoingErrorHandler",void 0)},S=function(t){p(r,t);var e=d(r);function r(){var t,n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new i.Readable({objectMode:!0}),o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new i.Writable({objectMode:!0});return m(this,r),g(v(t=e.call(this)),"incoming",void 0),g(v(t),"outgoing",void 0),g(v(t),"next",void 0),g(v(t),"prev",void 0),t.incoming=n,t.outgoing=o,t.next=null,t.prev=null,t}return l(r,[{key:"connect",value:function(t){var e=this;if(null===t)return this;if(null!==this.next||null!==t.prev)throw new Error("connection failed: component(s) already connected");if(!this.incoming.readable||!this.outgoing.writable)throw new Error("connection failed: this component not compatible");if(!t.incoming.writable||!t.outgoing.readable)throw new Error("connection failed: next component not compatible");try{this.incoming.pipe(t.incoming),t.outgoing.pipe(this.outgoing)}catch(t){throw new Error("connection failed: ".concat(t.message))}var r=function(t){e.incoming.emit("error",t)};t.incoming.on("error",r);var n=function(e){t.outgoing.emit("error",e)};return this.outgoing.on("error",n),this.next=t,t.prev=this,this._incomingErrorHandler=r,this._outgoingErrorHandler=n,t}},{key:"disconnect",value:function(){var t=this.next;return null!==t&&(this.incoming.unpipe(t.incoming),t.outgoing.unpipe(this.outgoing),void 0!==this._incomingErrorHandler&&t.incoming.removeListener("error",this._incomingErrorHandler),void 0!==this._outgoingErrorHandler&&this.outgoing.removeListener("error",this._outgoingErrorHandler),this.next=null,t.prev=null,delete this._incomingErrorHandler,delete this._outgoingErrorHandler),this}}],[{key:"fromMessages",value:function(t){return new r(s.producer(t),s.consumer())}}]),r}(_),E=function(t){p(r,t);var e=d(r);function r(){var t,n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new i.PassThrough({objectMode:!0}),o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new i.PassThrough({objectMode:!0});return m(this,r),g(v(t=e.call(this,n,o)),"incoming",void 0),g(v(t),"outgoing",void 0),t.incoming=n,t.outgoing=o,t}return l(r,null,[{key:"fromHandlers",value:function(t,e){return new r(t?s.peeker(t):void 0,e?s.peeker(e):void 0)}}]),r}(S),O=function(t){p(r,t);var e=d(r);function r(){var t,n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new i.Writable({objectMode:!0}),o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new i.Readable({objectMode:!0});return m(this,r),g(v(t=e.call(this)),"incoming",void 0),g(v(t),"outgoing",void 0),g(v(t),"next",void 0),g(v(t),"prev",void 0),t.incoming=n,t.outgoing=o,t.next=null,t.prev=null,t}return l(r,[{key:"connect",value:function(){throw new Error("connection failed: attempting to connect after a sink")}},{key:"disconnect",value:function(){return this}}],[{key:"fromHandler",value:function(t){var e=new r(s.consumer(t),s.producer(void 0));return e.incoming.on("finish",(function(){e.outgoing.push(null)})),e}}]),r}(_),x=(r(3729),r(1122),r(2656),r(1917),[128,64,32,16,8,4,2,1]),R=r(7866).Buffer,T=function(t){return t[0]>>>6},k=function(t){return!!(t[0]&x[2])},P=function(t){return!!(t[0]&x[3])},j=function(t){return 15&t[0]},A=function(t){return!!(t[1]&x[0])},C=function(t){return 127&t[1]},I=function(t){return t.readUInt16BE(2)},L=function(t){return t.readUInt32BE(4)},B=function(t){return t.readUInt32BE(8)},M=function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return j(t)>e?t.readUInt32BE(12+4*e):0},U=function(t){return P(t)?t.readUInt16BE(12+4*j(t)+2):0},N=function(t){return 0===U(t)?R.from([]):t.slice(12+4*j(t),12+4*j(t)+4+4*U(t))},D=function(t){return P(t)?t.slice(12+4*j(t)+4+4*U(t)):t.slice(12+4*j(t))};!function(t){t[t.UNKNOWN=0]="UNKNOWN",t[t.RAW=1]="RAW",t[t.RTP=2]="RTP",t[t.RTCP=3]="RTCP",t[t.RTSP=4]="RTSP",t[t.SDP=5]="SDP",t[t.ELEMENTARY=6]="ELEMENTARY",t[t.H264=7]="H264",t[t.ISOM=8]="ISOM",t[t.XML=9]="XML",t[t.JPEG=10]="JPEG"}(w||(w={}));var F=function(t){return new i.Transform({objectMode:!0,transform:t})};function q(t){return(q="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function H(t,e){(null==e||e>t.length)&&(e=t.length);for(var r=0,n=new Array(e);r<e;r++)n[r]=t[r];return n}function W(t,e){return(W=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}function z(t,e){return!e||"object"!==q(e)&&"function"!=typeof e?function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t):e}function V(t){return(V=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}var G=function(t){!function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&W(t,e)}(o,t);var e,r,n=(e=o,r=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}(),function(){var t,n=V(e);if(r){var o=V(this).constructor;t=Reflect.construct(n,arguments,o)}else t=n.apply(this,arguments);return z(this,t)});function o(){var t,e;!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,o);var r=F((function(r,n,o){if(r.type===w.SDP){var i,a,u=function(t,e){var r="undefined"!=typeof Symbol&&t[Symbol.iterator]||t["@@iterator"];if(!r){if(Array.isArray(t)||(r=function(t,e){if(t){if("string"==typeof t)return H(t,e);var r=Object.prototype.toString.call(t).slice(8,-1);return"Object"===r&&t.constructor&&(r=t.constructor.name),"Map"===r||"Set"===r?Array.from(t):"Arguments"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)?H(t,e):void 0}}(t))||e&&t&&"number"==typeof t.length){r&&(t=r);var n=0,o=function(){};return{s:o,n:function(){return n>=t.length?{done:!0}:{done:!1,value:t[n++]}},e:function(t){throw t},f:o}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var i,a=!0,u=!1;return{s:function(){r=r.call(t)},n:function(){var t=r.next();return a=t.done,t},e:function(t){u=!0,i=t},f:function(){try{a||null==r.return||r.return()}finally{if(u)throw i}}}}(r.sdp.media);try{for(u.s();!(a=u.n()).done;){var s=a.value;"audio"===s.type&&s.fmtp&&s.fmtp.parameters&&"AAC-hbr"===s.fmtp.parameters.mode&&(i=s)}}catch(t){u.e(t)}finally{u.f()}if(i&&void 0!==i.rtpmap){t=Number(i.rtpmap.payloadType);var c=i.fmtp.parameters,f=Number(c.sizelength)||0,l=Number(c.indexlength)||0,p=Number(c.indexdeltalength)||0,h=Number(c.ctsdeltalength)||0,d=Number(c.dtsdeltalength)||0,y=Number(c.randomaccessindication)||0,v=Number(c.streamstateindication)||0,b=Number(c.auxiliarydatasizelength)||0;e=f+Math.max(l,p)+h+d+y+v+b>0}o(void 0,r)}else r.type===w.RTP&&C(r.data)===t?(function(t,e,r){var n=D(t.data),o=0;if(e){var i=n.readUInt16BE(0);o=2+(i+i%8)/8}r({type:w.ELEMENTARY,data:n.slice(o),payloadType:C(t.data),timestamp:L(t.data),ntpTimestamp:t.ntpTimestamp})}(r,e,this.push.bind(this)),o()):o(void 0,r)}));return n.call(this,r)}return o}(E),$=(r(6218),r(7866).Buffer);function Y(t){return(Y="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function J(t,e){return(J=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}function K(t,e){return!e||"object"!==Y(e)&&"function"!=typeof e?function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t):e}function X(t){return(X=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}var Z=function(t){!function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&J(t,e)}(o,t);var e,r,n=(e=o,r=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}(),function(){var t,n=X(e);if(r){var o=X(this).constructor;t=Reflect.construct(n,arguments,o)}else t=n.apply(this,arguments);return K(this,t)});function o(t){if(function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,o),void 0===t)throw new Error("you must supply a payload type to BasicDepayComponent");var e=$.alloc(0),r=F((function(r,n,o){if(r.type===w.RTP&&C(r.data)===t){var i=D(r.data);e=$.concat([e,i]),A(r.data)&&(e.length>0&&this.push({data:e,timestamp:L(r.data),ntpTimestamp:r.ntpTimestamp,payloadType:C(r.data),type:w.ELEMENTARY}),e=$.alloc(0)),o()}else o(void 0,r)}));return n.call(this,r)}return o}(E);function Q(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}function tt(t,e,r){return e in t?Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[e]=r,t}r(2743),r(6582);var et=function(){function t(){!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,t),tt(this,"started",void 0),tt(this,"stopped",void 0),tt(this,"elapsed",void 0),this.elapsed=0,this.started=0,this.stopped=!0}var e,r;return e=t,(r=[{key:"start",value:function(){this.stopped&&(this.started=window.performance.now(),this.stopped=!1)}},{key:"stop",value:function(){this.stopped||(this.elapsed=this.now(),this.stopped=!0)}},{key:"reset",value:function(){this.elapsed=0,this.started=0,this.stopped=!0}},{key:"now",value:function(){return this.stopped?this.elapsed:this.elapsed+(window.performance.now()-this.started)}},{key:"play",value:function(){this.start()}},{key:"pause",value:function(){this.stop()}},{key:"currentTime",get:function(){return this.now()/1e3}}])&&Q(e.prototype,r),t}();function rt(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function nt(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}function ot(t,e,r){return e in t?Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[e]=r,t}var it=function(){function t(e,r){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:10;rt(this,t),ot(this,"_clock",void 0),ot(this,"_handler",void 0),ot(this,"_tolerance",void 0),ot(this,"_nextRun",void 0),ot(this,"_nextPlay",void 0),ot(this,"_fifo",void 0),ot(this,"_ntpPresentationTime",void 0),ot(this,"_suspended",void 0),this._clock=e,this._handler=r,this._tolerance=n,this._nextRun=0,this._nextPlay=0,this._fifo=[],this._ntpPresentationTime=0,this._suspended=!1}var e,r;return e=t,(r=[{key:"reset",value:function(){clearTimeout(this._nextRun),clearTimeout(this._nextPlay),this._fifo=[],this._ntpPresentationTime=0,this._suspended=!1}},{key:"init",value:function(t){this._ntpPresentationTime=t}},{key:"suspend",value:function(){clearTimeout(this._nextPlay),this._suspended=!0}},{key:"resume",value:function(){this._suspended=!1,this.run(void 0)}},{key:"run",value:function(t){var e=this;if(clearTimeout(this._nextRun),void 0!==this._ntpPresentationTime&&(void 0!==t&&this._fifo.push(t),!this._suspended&&0!==this._fifo.length)){var r,n=0;do{var o=this._fifo.shift();if(void 0===o)throw new Error("internal error: message should never be undefined");var i=(r=o).ntpTimestamp;void 0!==i&&(n=i-this._ntpPresentationTime-1e3*this._clock.currentTime,Math.abs(n)<this._tolerance&&this._handler&&this._handler(r))}while(n<this._tolerance&&this._fifo.length>0);n<-this._tolerance?(clearTimeout(this._nextPlay),this._clock.pause(),this._nextPlay=window.setTimeout((function(){return e._clock.play()}),-n)):n>this._tolerance&&(this._fifo.unshift(r),this._nextRun=window.setTimeout((function(){return e.run(void 0)}),n))}}}])&&nt(e.prototype,r),t}();function at(t){return(at="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function ut(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}function st(t,e){return(st=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}function ct(t,e){return!e||"object"!==at(e)&&"function"!=typeof e?ft(t):e}function ft(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}function lt(t){return(lt=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}function pt(t,e,r){return e in t?Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[e]=r,t}var ht,dt=function(t){!function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&st(t,e)}(u,t);var e,r,n,o,a=(n=u,o=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}(),function(){var t,e=lt(n);if(o){var r=lt(this).constructor;t=Reflect.construct(e,arguments,r)}else t=e.apply(this,arguments);return ct(this,t)});function u(t){var e;if(function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,u),void 0===t)throw new Error("canvas element argument missing");var r,n,o=0,s=0,c=0,f={bitrate:0,framerate:0,renderedFrames:0},l=null;if(void 0!==window.createImageBitmap&&(l=t.getContext("bitmaprenderer")),null===l&&(l=t.getContext("2d")),null===l)n=function(){};else if("transferFromImageBitmap"in l){var p=l;n=function(t){var e=t.blob;f.renderedFrames++,window.createImageBitmap(e).then((function(t){p.transferFromImageBitmap(t)})).catch((function(){}))}}else{var h=l,d=new Image;d.onload=function(){h.drawImage(d,0,0)},n=function(t){var e=t.blob;f.renderedFrames++;var r=window.URL.createObjectURL(e);d.src=r}}var y=new et,v=new it(y,n),b=0,m=new i.Writable({objectMode:!0,write:function(n,i,a){if(n.type===w.SDP){y.reset(),v.reset(),o=0;var u=n.sdp.media.find((function(t){return"video"===t.type&&void 0!==t.rtpmap&&"JPEG"===t.rtpmap.encodingName}));void 0!==u&&void 0!==u.rtpmap&&(c=u.rtpmap.clockrate,function(t){t.bitrate=0,t.framerate=0,t.renderedFrames=0}(f),r=function(t){var e=0,r=0,n=0;return function(o,i){var a=i.byteLength,u=i.duration;if(e+=a,n++,(r+=u)>=t){var s=8*e,c=n,f=r/t;o.bitrate=s/f,o.framerate=c/f,e=0,r=0,n=0}}}(c)),a()}else if(n.type===w.JPEG){var l=n.timestamp,p=n.ntpTimestamp;if(!o){o=l,s=l;var h=n.framesize,d=h.width,m=h.height;t.width=d,t.height=m,v.init(0)}var g=1e3*(l-o)/c,_=new window.Blob([n.data],{type:"image/jpeg"});!b&&p&&function(t){e.onSync&&e.onSync(t)}(b=p-g),v.run({ntpTimestamp:g,blob:_}),l===o&&e.onCanplay&&e.onCanplay(),r(f,{byteLength:n.data.length,duration:l-s}),s=l,a()}else a()}}),g=new i.Readable({objectMode:!0,read:function(){}});return g.on("error",(function(){console.warn("outgoing stream broke somewhere")})),pt(ft(e=a.call(this,m,g)),"onCanplay",void 0),pt(ft(e),"onSync",void 0),pt(ft(e),"_clock",void 0),pt(ft(e),"_scheduler",void 0),pt(ft(e),"_info",void 0),e._clock=y,e._scheduler=v,e._info=f,e.onCanplay=void 0,e.onSync=void 0,e}return e=u,(r=[{key:"currentTime",get:function(){return this._clock.currentTime}},{key:"pause",value:function(){this._scheduler.suspend(),this._clock.pause()}},{key:"play",value:function(){this._clock.play(),this._scheduler.resume()}},{key:"bitrate",get:function(){return this._info.bitrate}},{key:"framerate",get:function(){return this._info.framerate}}])&&ut(e.prototype,r),u}(O),yt=(r(9835),r(3324),r(2512),r(31),r(8574),r(7997)),vt=r.n(yt),bt=r(7866).Buffer;function mt(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}!function(t){t[t.UNSPECIFIED=0]="UNSPECIFIED",t[t.NON_IDR_PICTURE=1]="NON_IDR_PICTURE",t[t.IDR_PICTURE=5]="IDR_PICTURE",t[t.SPS=7]="SPS",t[t.PPS=8]="PPS"}(ht||(ht={}));var gt=vt()("msl:h264depay"),wt=function(){function t(){var e,r;!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,t),r=void 0,(e="_buffer")in this?Object.defineProperty(this,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):this[e]=r,this._buffer=bt.alloc(0)}var e,r;return e=t,(r=[{key:"parse",value:function(t){var e=D(t.data),r=31&e[0];if(28===r){var n=e[0],o=e[1],i=31&o,a=224&n|i,u=64&o;if(o>>7)return this._buffer=bt.concat([bt.from([0,0,0,0,a]),e.slice(2)]),null;if(u){var s=bt.concat([this._buffer,e.slice(2)]);s.writeUInt32BE(s.length-4,0);var c={data:s,type:w.H264,timestamp:L(t.data),ntpTimestamp:t.ntpTimestamp,payloadType:C(t.data),nalType:i};return this._buffer=bt.alloc(0),c}return this._buffer=bt.concat([this._buffer,e.slice(2)]),null}if(r!==ht.NON_IDR_PICTURE&&r!==ht.IDR_PICTURE||0!==this._buffer.length)return gt("H264depayComponent can only extract types 1,5 and 28, got ".concat(r)),this._buffer=bt.alloc(0),null;var f=bt.concat([bt.from([0,0,0,0]),e]);f.writeUInt32BE(f.length-4,0);var l={data:f,type:w.H264,timestamp:L(t.data),ntpTimestamp:t.ntpTimestamp,payloadType:C(t.data),nalType:r};return this._buffer=bt.alloc(0),l}}])&&mt(e.prototype,r),t}(),_t=r(7866).Buffer;function St(t){return(St="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function Et(t,e){var r=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),r.push.apply(r,n)}return r}function Ot(t){for(var e=1;e<arguments.length;e++){var r=null!=arguments[e]?arguments[e]:{};e%2?Et(Object(r),!0).forEach((function(e){xt(t,e,r[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(r)):Et(Object(r)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(r,e))}))}return t}function xt(t,e,r){return e in t?Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[e]=r,t}function Rt(t,e){return(Rt=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}function Tt(t,e){return!e||"object"!==St(e)&&"function"!=typeof e?function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t):e}function kt(t){return(kt=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}var Pt=function(t){!function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&Rt(t,e)}(o,t);var e,r,n=(e=o,r=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}(),function(){var t,n=kt(e);if(r){var o=kt(this).constructor;t=Reflect.construct(n,arguments,o)}else t=n.apply(this,arguments);return Tt(this,t)});function o(){var t;!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,o);var e=!1,r=[],a=new wt,u=new i.Transform({objectMode:!0,transform:function(n,o,i){if(n.type===w.SDP){var u=n.sdp.media.find((function(t){return"video"===t.type&&void 0!==t.rtpmap&&"H264"===t.rtpmap.encodingName}));void 0!==u&&void 0!==u.rtpmap&&(t=u.rtpmap.payloadType),i(void 0,n)}else if(n.type===w.RTP&&C(n.data)===t){var s=A(n.data),c=a.parse(n);if(null===c||!e&&c.nalType!==ht.IDR_PICTURE)return void i();e=!0,r.push(c.data),s&&(this.push(Ot(Ot({},c),{},{data:1===r.length?r[0]:_t.concat(r)})),r=[]),i()}else i(void 0,n)}});return n.call(this,u)}return o}(E),jt=(r(1337),r(7866).Buffer);function At(t){return(At="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function Ct(t,e){var r=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),r.push.apply(r,n)}return r}function It(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}function Lt(t,e){return(Lt=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}function Bt(t,e){return!e||"object"!==At(e)&&"function"!=typeof e?Mt(t):e}function Mt(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}function Ut(t){return(Ut=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}function Nt(t,e,r){return e in t?Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[e]=r,t}var Dt=vt()("msl:http-source"),Ft=function(t){!function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&Lt(t,e)}(u,t);var e,r,n,o,a=(n=u,o=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}(),function(){var t,e=Ut(n);if(o){var r=Ut(this).constructor;t=Reflect.construct(e,arguments,r)}else t=e.apply(this,arguments);return Bt(this,t)});function u(t){var e;!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,u);var r=t.uri,n=t.options,o=new i.Readable({objectMode:!0,read:function(){}});return o.on("error",(function(t){console.warn("closing socket due to incoming error",t),e._reader&&e._reader.cancel()})),Nt(Mt(e=a.call(this,o)),"uri",void 0),Nt(Mt(e),"options",void 0),Nt(Mt(e),"length",void 0),Nt(Mt(e),"onHeaders",void 0),Nt(Mt(e),"onServerClose",void 0),Nt(Mt(e),"_reader",void 0),Nt(Mt(e),"_abortController",void 0),Nt(Mt(e),"_allDone",void 0),o._read=function(){e._pull()},e.uri=r,e.options=n,e._allDone=!1,e}return e=u,(r=[{key:"play",value:function(){var t=this;if(void 0===this.uri)throw new Error("cannot start playing when there is no URI");this._abortController=new AbortController,this.length=0,fetch(this.uri,function(t){for(var e=1;e<arguments.length;e++){var r=null!=arguments[e]?arguments[e]:{};e%2?Ct(Object(r),!0).forEach((function(e){Nt(t,e,r[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(r)):Ct(Object(r)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(r,e))}))}return t}({credentials:"include",signal:this._abortController.signal},this.options)).then((function(e){if(null===e.body)throw new Error("empty response body");t.onHeaders&&t.onHeaders(e.headers),t._reader=e.body.getReader(),t._pull()})).catch((function(t){console.error("http-source: fetch failed: ",t)}))}},{key:"abort",value:function(){this._reader&&this._reader.cancel().catch((function(t){console.log("http-source: cancel reader failed: ",t)})),this._abortController&&this._abortController.abort()}},{key:"_isClosed",value:function(){return this._allDone}},{key:"_close",value:function(){var t;this._reader=void 0,this._allDone=!0,this.incoming.push(null),null===(t=this.onServerClose)||void 0===t||t.call(this)}},{key:"_pull",value:function(){var t=this;void 0!==this._reader&&this._reader.read().then((function(e){var r=e.done,n=e.value;if(r)t._isClosed()||(Dt("fetch completed, total downloaded: ",t.length," bytes"),t._close());else{if(void 0===n)throw new Error("expected value to be defined");if(void 0===t.length)throw new Error("expected length to be defined");t.length+=n.length;var o=jt.from(n);t.incoming.push({data:o,type:w.RAW})?t._pull():Dt("downstream back pressure: pausing read")}})).catch((function(e){Dt("http-source: read failed: ",e),t._isClosed()||t._close()}))}}])&&It(e.prototype,r),u}(S);function qt(t){return(qt="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function Ht(t,e){return(Ht=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}function Wt(t,e){return!e||"object"!==qt(e)&&"function"!=typeof e?function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t):e}function zt(t){return(zt=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}var Vt=function(t,e){var r=Date.now(),n=function(e){var n=Date.now();console.log("".concat(t,": +").concat(n-r,"ms"),e),r=n};return void 0===e?n:function(t){return t.type===e&&n(t)}},Gt=function(t){!function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&Ht(t,e)}(o,t);var e,r,n=(e=o,r=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}(),function(){var t,n=zt(e);if(r){var o=zt(this).constructor;t=Reflect.construct(n,arguments,o)}else t=n.apply(this,arguments);return Wt(this,t)});function o(t){!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,o);var e=Vt("incoming",t),r=new i.Transform({objectMode:!0,transform:function(t,r,n){e(t),n(void 0,t)}}),a=Vt("outgoing",t),u=new i.Transform({objectMode:!0,transform:function(t,e,r){a(t),r(void 0,t)}});return n.call(this,r,u)}return o}(E),$t=(r(7316),r(7866).Buffer);function Yt(t){return function(t){if(Array.isArray(t))return Jt(t)}(t)||function(t){if("undefined"!=typeof Symbol&&null!=t[Symbol.iterator]||null!=t["@@iterator"])return Array.from(t)}(t)||function(t,e){if(t){if("string"==typeof t)return Jt(t,e);var r=Object.prototype.toString.call(t).slice(8,-1);return"Object"===r&&t.constructor&&(r=t.constructor.name),"Map"===r||"Set"===r?Array.from(t):"Arguments"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)?Jt(t,e):void 0}}(t)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function Jt(t,e){(null==e||e>t.length)&&(e=t.length);for(var r=0,n=new Array(e);r<e;r++)n[r]=t[r];return n}function Kt(){return $t.from([255,216])}function Xt(t,e){var r=1&t?128:64,n=2&t?128:64;if(e.length!==r+n)throw new Error("invalid quantization table");var o=$t.from([255,219,0,r+3,0]),i=$t.from([255,219,0,n+3,1]);return $t.concat([o,e.slice(0,r),i,e.slice(r)])}function Zt(t,e,r){return $t.from([255,192,0,17,8,e>>8,e,t>>8,t,3,0,0===r?33:34,0,1,17,1,2,17,1])}var Qt=[0,1,5,1,1,1,1,1,1,0,0,0,0,0,0,0],te=[0,1,2,3,4,5,6,7,8,9,10,11],ee=[0,2,1,3,3,2,4,3,5,5,4,4,0,0,1,125],re=[1,2,3,0,4,17,5,18,33,49,65,6,19,81,97,7,34,113,20,50,129,145,161,8,35,66,177,193,21,82,209,240,36,51,98,114,130,9,10,22,23,24,25,26,37,38,39,40,41,42,52,53,54,55,56,57,58,67,68,69,70,71,72,73,74,83,84,85,86,87,88,89,90,99,100,101,102,103,104,105,106,115,116,117,118,119,120,121,122,131,132,133,134,135,136,137,138,146,147,148,149,150,151,152,153,154,162,163,164,165,166,167,168,169,170,178,179,180,181,182,183,184,185,186,194,195,196,197,198,199,200,201,202,210,211,212,213,214,215,216,217,218,225,226,227,228,229,230,231,232,233,234,241,242,243,244,245,246,247,248,249,250],ne=[0,3,1,1,1,1,1,1,1,1,1,0,0,0,0,0],oe=[0,1,2,3,4,5,6,7,8,9,10,11],ie=[0,2,1,2,4,4,3,4,7,5,4,4,0,1,2,119],ae=[0,1,2,3,17,4,5,33,49,6,18,65,81,7,97,113,19,34,50,129,8,20,66,145,161,177,193,9,35,51,82,240,21,98,114,209,10,22,36,52,225,37,241,23,24,25,26,38,39,40,41,42,53,54,55,56,57,58,67,68,69,70,71,72,73,74,83,84,85,86,87,88,89,90,99,100,101,102,103,104,105,106,115,116,117,118,119,120,121,122,130,131,132,133,134,135,136,137,138,146,147,148,149,150,151,152,153,154,162,163,164,165,166,167,168,169,170,178,179,180,181,182,183,184,185,186,194,195,196,197,198,199,200,201,202,210,211,212,213,214,215,216,217,218,226,227,228,229,230,231,232,233,234,242,243,244,245,246,247,248,249,250];function ue(){var t=[[255,196,0,3+Qt.length+te.length,0],Qt,te],e=[[255,196,0,3+ee.length+re.length,16],ee,re],r=[[255,196,0,3+ne.length+oe.length,1],ne,oe],n=[[255,196,0,3+ie.length+ae.length,17],ie,ae];return $t.concat([].concat(Yt(t.map($t.from)),Yt(e.map($t.from)),Yt(r.map($t.from)),Yt(n.map($t.from))))}function se(){return $t.from([255,218,0,12,3,0,0,1,17,2,17,0,63,0])}function ce(t){return $t.from([255,221,0,4,t>>8,255&t])}function fe(t,e,r){return t>r?r:t<e?e:t}var le=r(7866).Buffer,pe=[16,11,12,14,12,10,16,14,13,14,18,17,16,19,24,40,26,24,22,22,24,49,35,37,29,40,58,51,61,60,57,51,56,55,64,72,92,78,64,68,87,69,55,56,80,109,81,87,95,98,103,104,103,62,77,113,121,112,100,120,92,101,103,99],he=[17,18,18,24,21,24,47,26,26,47,99,66,56,66,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99];function de(t){for(var e=fe(t,1,99),r=le.alloc(128),n=t<50?Math.floor(5e3/e):200-2*e,o=0;o<64;o++){var i=Math.floor((pe[o]*n+50)/100),a=Math.floor((he[o]*n+50)/100);r.writeUInt8(fe(i,1,255),o),r.writeUInt8(fe(a,1,255),o+64)}return r}var ye=r(7866).Buffer;function ve(t,e){var r="undefined"!=typeof Symbol&&t[Symbol.iterator]||t["@@iterator"];if(!r){if(Array.isArray(t)||(r=function(t,e){if(t){if("string"==typeof t)return be(t,e);var r=Object.prototype.toString.call(t).slice(8,-1);return"Object"===r&&t.constructor&&(r=t.constructor.name),"Map"===r||"Set"===r?Array.from(t):"Arguments"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)?be(t,e):void 0}}(t))||e&&t&&"number"==typeof t.length){r&&(t=r);var n=0,o=function(){};return{s:o,n:function(){return n>=t.length?{done:!0}:{done:!1,value:t[n++]}},e:function(t){throw t},f:o}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var i,a=!0,u=!1;return{s:function(){r=r.call(t)},n:function(){var t=r.next();return a=t.done,t},e:function(t){u=!0,i=t},f:function(){try{a||null==r.return||r.return()}finally{if(u)throw i}}}}function be(t,e){(null==e||e>t.length)&&(e=t.length);for(var r=0,n=new Array(e);r<e;r++)n[r]=t[r];return n}function me(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,r=Kt(),n=ue(),o=se();return function(i){var a,u,s=[],c=ve(i);try{for(c.s();!(u=c.n()).done;){var f=u.value,l=D(f),p=l.readUInt8(0),h=l.readUInt8(1)<<16|l.readUInt8(2)<<8|l.readUInt8(3),d=l.readUInt8(4),y=l.readUInt8(5),v=8*l.readUInt8(6)||t,b=8*l.readUInt8(7)||e;l=l.slice(8);var m=0;if(d>=64&&d<=127&&(m=l.readUInt16BE(0),l=l.slice(4)),y>=128&&0===h){var g=l.readUInt8(1),w=l.readUInt16BE(2);a={typeSpecific:p,type:d,width:v,height:b,DRI:m,precision:g,qTable:l.slice(4,4+w)},l=l.slice(4+w)}else y<128&&0===h&&(a={typeSpecific:p,type:d,width:v,height:b,DRI:m,precision:0,qTable:de(y)});s.push(l)}}catch(t){c.e(t)}finally{c.f()}if(void 0===a)throw new Error("no quantization header present");var _=a,S=_.precision,E=_.qTable,O=_.type,x=_.width,R=_.height,T=Xt(S,E),k=0===a.DRI?ye.alloc(0):ce(a.DRI),P=Zt(x,R,O);return{size:{width:x,height:R},data:ye.concat([r,T,k,P,n,o].concat(s))}}}function ge(t){return(ge="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function we(t,e){(null==e||e>t.length)&&(e=t.length);for(var r=0,n=new Array(e);r<e;r++)n[r]=t[r];return n}function _e(t,e){return(_e=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}function Se(t,e){return!e||"object"!==ge(e)&&"function"!=typeof e?function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t):e}function Ee(t){return(Ee=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}var Oe=function(t){!function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&_e(t,e)}(o,t);var e,r,n=(e=o,r=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}(),function(){var t,n=Ee(e);if(r){var o=Ee(this).constructor;t=Reflect.construct(n,arguments,o)}else t=n.apply(this,arguments);return Se(this,t)});function o(){var t;!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,o);var e,r=[],a=new i.Transform({objectMode:!0,transform:function(n,o,i){if(n.type===w.SDP){var a=n.sdp.media.find((function(t){return"video"===t.type&&void 0!==t.rtpmap&&"JPEG"===t.rtpmap.encodingName}));if(void 0!==a&&void 0!==a.rtpmap){t=Number(a.rtpmap.payloadType);var u=a.framesize;if(void 0!==u){var s=(h=2,function(t){if(Array.isArray(t))return t}(p=u)||function(t,e){var r=null==t?null:"undefined"!=typeof Symbol&&t[Symbol.iterator]||t["@@iterator"];if(null!=r){var n,o,i=[],a=!0,u=!1;try{for(r=r.call(t);!(a=(n=r.next()).done)&&(i.push(n.value),!e||i.length!==e);a=!0);}catch(t){u=!0,o=t}finally{try{a||null==r.return||r.return()}finally{if(u)throw o}}return i}}(p,h)||function(t,e){if(t){if("string"==typeof t)return we(t,e);var r=Object.prototype.toString.call(t).slice(8,-1);return"Object"===r&&t.constructor&&(r=t.constructor.name),"Map"===r||"Set"===r?Array.from(t):"Arguments"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)?we(t,e):void 0}}(p,h)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()),c=s[0],f=s[1];e=me(c,f)}else e=me()}i(void 0,n)}else if(n.type===w.RTP&&C(n.data)===t){if(r.push(n.data),A(n.data)&&r.length>0){var l=e(r);this.push({timestamp:L(n.data),ntpTimestamp:n.ntpTimestamp,payloadType:C(n.data),data:l.data,framesize:l.size,type:w.JPEG}),r=[]}i()}else i(void 0,n);var p,h}});return n.call(this,a)}return o}(E),xe=r(7866).Buffer;function Re(t){return(Re="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function Te(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function ke(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}function Pe(t,e){return(Pe=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}function je(t,e){return!e||"object"!==Re(e)&&"function"!=typeof e?Ae(t):e}function Ae(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}function Ce(t){return(Ce=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}function Ie(t,e,r){return e in t?Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[e]=r,t}var Le=225e6,Be=function(t){!function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&Pe(t,e)}(u,t);var e,r,n,o,a=(n=u,o=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}(),function(){var t,e=Ce(n);if(o){var r=Ce(this).constructor;t=Reflect.construct(e,arguments,r)}else t=e.apply(this,arguments);return je(this,t)});function u(){var t,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Le;Te(this,u);var r=new i.Transform({objectMode:!0,transform:function(e,r,n){t._active&&e.type===w.ISOM&&void 0!==e.tracks&&(t._capture=!0),t._capture&&e.type===w.ISOM&&(t._bufferOffset<t._buffer.byteLength-e.data.byteLength?(e.data.copy(t._buffer,t._bufferOffset),t._bufferOffset+=e.data.byteLength):t.stop()),n(void 0,e)}});return r.on("finish",(function(){t.stop()})),Ie(Ae(t=a.call(this,r)),"_active",void 0),Ie(Ae(t),"_capture",void 0),Ie(Ae(t),"_captureCallback",void 0),Ie(Ae(t),"_bufferOffset",void 0),Ie(Ae(t),"_bufferSize",void 0),Ie(Ae(t),"_buffer",void 0),t._buffer=xe.allocUnsafe(0),t._bufferSize=e,t._bufferOffset=0,t._active=!1,t._capture=!1,t._captureCallback=function(){},t}return e=u,(r=[{key:"start",value:function(t){this._active||(vt()("msl:capture:start")(t),this._captureCallback=t,this._buffer=xe.allocUnsafe(this._bufferSize),this._bufferOffset=0,this._active=!0)}},{key:"stop",value:function(){if(this._active){vt()("msl:capture:stop")("captured bytes: ".concat(this._bufferOffset));try{this._captureCallback(this._buffer.slice(0,this._bufferOffset))}catch(t){console.error(t)}this._buffer=xe.allocUnsafe(0),this._bufferOffset=0,this._active=!1,this._capture=!1}}}])&&ke(e.prototype,r),u}(E),Me=(r(8544),r(7775),r(4750),r(5691),r(3292),r(7866).Buffer);function Ue(t){return(Ue="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function Ne(t,e){return function(t){if(Array.isArray(t))return t}(t)||function(t,e){var r=null==t?null:"undefined"!=typeof Symbol&&t[Symbol.iterator]||t["@@iterator"];if(null!=r){var n,o,i=[],a=!0,u=!1;try{for(r=r.call(t);!(a=(n=r.next()).done)&&(i.push(n.value),!e||i.length!==e);a=!0);}catch(t){u=!0,o=t}finally{try{a||null==r.return||r.return()}finally{if(u)throw o}}return i}}(t,e)||Fe(t,e)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function De(t,e){var r="undefined"!=typeof Symbol&&t[Symbol.iterator]||t["@@iterator"];if(!r){if(Array.isArray(t)||(r=Fe(t))||e&&t&&"number"==typeof t.length){r&&(t=r);var n=0,o=function(){};return{s:o,n:function(){return n>=t.length?{done:!0}:{done:!1,value:t[n++]}},e:function(t){throw t},f:o}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var i,a=!0,u=!1;return{s:function(){r=r.call(t)},n:function(){var t=r.next();return a=t.done,t},e:function(t){u=!0,i=t},f:function(){try{a||null==r.return||r.return()}finally{if(u)throw i}}}}function Fe(t,e){if(t){if("string"==typeof t)return qe(t,e);var r=Object.prototype.toString.call(t).slice(8,-1);return"Object"===r&&t.constructor&&(r=t.constructor.name),"Map"===r||"Set"===r?Array.from(t):"Arguments"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)?qe(t,e):void 0}}function qe(t,e){(null==e||e>t.length)&&(e=t.length);for(var r=0,n=new Array(e);r<e;r++)n[r]=t[r];return n}function He(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}function We(t,e,r){return e&&He(t.prototype,e),r&&He(t,r),t}function ze(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&Ve(t,e)}function Ve(t,e){return(Ve=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}function Ge(t){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var r,n=Je(t);if(e){var o=Je(this).constructor;r=Reflect.construct(n,arguments,o)}else r=n.apply(this,arguments);return $e(this,r)}}function $e(t,e){return!e||"object"!==Ue(e)&&"function"!=typeof e?Ye(t):e}function Ye(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}function Je(t){return(Je=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}function Ke(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function Xe(t,e,r){return e in t?Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[e]=r,t}var Ze=Math.pow(2,32),Qe=function t(e){Ke(this,t),Xe(this,"byteLength",void 0),Xe(this,"value",void 0),this.byteLength=e},tr=function(t){ze(r,t);var e=Ge(r);function r(){var t,n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return Ke(this,r),Xe(Ye(t=e.call(this,n)),"copy",(function(e,r){e.fill(0,r,r+t.byteLength)})),t}return We(r,[{key:"load",value:function(){}}]),r}(Qe),er=function(t){ze(r,t);var e=Ge(r);function r(t){var n;return Ke(this,r),Xe(Ye(n=e.call(this,t.length)),"value",void 0),Xe(Ye(n),"copy",(function(t,e){for(var r=0;r<n.byteLength;r+=1)t[e+r]=n.value.charCodeAt(r)})),Xe(Ye(n),"load",(function(t,e){n.value=t.slice(e,e+n.byteLength).toString("ascii")})),n.value=t,n}return r}(Qe),rr=function(t){ze(r,t);var e=Ge(r);function r(){var t,n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return Ke(this,r),Xe(Ye(t=e.call(this,1)),"value",void 0),Xe(Ye(t),"copy",(function(e,r){e.writeUInt8(t.value,r)})),Xe(Ye(t),"load",(function(e,r){t.value=e.readUInt8(r)})),t.value=n,t}return r}(Qe),nr=function(t){ze(r,t);var e=Ge(r);function r(t){var n;return Ke(this,r),Xe(Ye(n=e.call(this,t.length)),"value",void 0),Xe(Ye(n),"copy",(function(t,e){for(var r=0;r<n.value.length;++r)t.writeUInt8(n.value[r],e+r)})),Xe(Ye(n),"load",(function(t,e){for(var r=0;r<n.value.length;++r)n.value[r]=t.readUInt8(e+r)})),n.value=t,n}return r}(Qe),or=function(t){ze(r,t);var e=Ge(r);function r(){var t,n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return Ke(this,r),Xe(Ye(t=e.call(this,2)),"value",void 0),Xe(Ye(t),"copy",(function(e,r){e.writeUInt16BE(t.value,r)})),Xe(Ye(t),"load",(function(e,r){t.value=e.readUInt16BE(r)})),t.value=n,t}return r}(Qe),ir=function(t){ze(r,t);var e=Ge(r);function r(){var t,n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return Ke(this,r),Xe(Ye(t=e.call(this,3)),"value",void 0),Xe(Ye(t),"copy",(function(e,r){e.writeUInt8(t.value>>16&255,r),e.writeUInt8(t.value>>8&255,r+1),e.writeUInt8(255&t.value,r+2)})),Xe(Ye(t),"load",(function(e,r){t.value=e.readUInt8(r)<<16+e.readUInt8(r+1)<<8+e.readUInt8(r+2)})),t.value=n,t}return r}(Qe),ar=function(t){ze(r,t);var e=Ge(r);function r(t){var n;return Ke(this,r),Xe(Ye(n=e.call(this,2*t.length)),"value",void 0),Xe(Ye(n),"copy",(function(t,e){for(var r=0;r<n.value.length;++r)t.writeUInt16BE(n.value[r],e+2*r)})),Xe(Ye(n),"load",(function(t,e){for(var r=0;r<n.value.length;++r)n.value[r]=t.readUInt16BE(e+2*r)})),n.value=t,n}return r}(Qe),ur=function(t){ze(r,t);var e=Ge(r);function r(){var t,n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return Ke(this,r),Xe(Ye(t=e.call(this,4)),"value",void 0),Xe(Ye(t),"copy",(function(e,r){e.writeUInt32BE(t.value,r)})),Xe(Ye(t),"load",(function(e,r){t.value=e.readUInt32BE(r)})),t.value=n,t}return r}(Qe),sr=function(t){ze(r,t);var e=Ge(r);function r(t){var n;return Ke(this,r),Xe(Ye(n=e.call(this,4*t.length)),"value",void 0),Xe(Ye(n),"copy",(function(t,e){for(var r=0;r<n.value.length;++r)t.writeUInt32BE(n.value[r],e+4*r)})),Xe(Ye(n),"load",(function(t,e){for(var r=0;r<n.value.length;++r)n.value[r]=t.readUInt32BE(e+4*r)})),n.value=t,n}return r}(Qe),cr=function(t){ze(r,t);var e=Ge(r);function r(){var t,n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return Ke(this,r),Xe(Ye(t=e.call(this,8)),"value",void 0),Xe(Ye(t),"copy",(function(e,r){var n=t.value/Ze|0,o=t.value-n*Ze;e.writeUInt32BE(n,r),e.writeUInt32BE(o,r+4)})),Xe(Ye(t),"load",(function(e,r){var n=e.readUInt32BE(r),o=e.readUInt32BE(r+4);t.value=n*Ze+o})),t.value=n,t}return r}(Qe),fr=function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return function(e){ze(n,e);var r=Ge(n);function n(e){var o;return Ke(this,n),Xe(Ye(o=r.call(this,0)),"value",void 0),Xe(Ye(o),"copy",(function(t,e){var r,n=0,i=De(o.value);try{for(i.s();!(r=i.n()).done;){var a=r.value;a.copy(t,e+n),n+=a.byteLength}}catch(t){i.e(t)}finally{i.f()}})),Xe(Ye(o),"load",(function(){})),o.value=e.reduce((function(t,e){return t.concat(new or(e.length),new nr(e))}),[new rr(t|e.length)]),o.byteLength=o.value.reduce((function(t,e){return t+e.byteLength}),0),o}return n}(Qe)},lr={ftyp:{container:"file",mandatory:!0,quantity:"one",box:"Box",is_container:!0,body:[["major_brand",er,"isom"],["minor_version",ur,0],["compatible_brands",er,"mp41"]]},moov:{container:"file",mandatory:!0,quantity:"one",box:"Box",is_container:!0},mdat:{container:"file",mandatory:!1,quantity:"any",box:"Box",is_container:!1,body:[]},mvhd:{container:"moov",mandatory:!0,quantity:"one",box:"FullBox",is_container:!1,body:[["creation_time",ur,0],["modification_time",ur,0],["timescale",ur,1e3],["duration",ur,4294967295],["rate",ur,65536],["volume",or,256],["reserved",tr,10],["matrix",sr,[65536,0,0,0,65536,0,0,0,1073741824]],["pre_defined",tr,24],["next_track_ID",ur,4294967295]]},trak:{container:"moov",mandatory:!0,quantity:"one+",box:"Box",is_container:!0},tkhd:{container:"trak",mandatory:!0,quantity:"one",box:"FullBox",is_container:!1,config:{flags:3},body:[["creation_time",ur,0],["modification_time",ur,0],["track_ID",ur,1],["reserved",tr,4],["duration",ur,0],["reserved2",tr,8],["layer",or,0],["alternate_group",or,0],["volume",or,256],["reserved3",tr,2],["matrix",sr,[65536,0,0,0,65536,0,0,0,1073741824]],["width",ur,0],["height",ur,0]]},tref:{container:"trak",mandatory:!1,quantity:"one-",box:"Box",is_container:!1},mdia:{container:"trak",mandatory:!1,quantity:"one",box:"Box",is_container:!0},mdhd:{container:"mdia",mandatory:!1,quantity:"one",box:"FullBox",is_container:!1,body:[["creation_time",ur,0],["modification_time",ur,0],["timescale",ur,1e3],["duration",ur,4294967295],["language",or,0],["pre_defined",or,0]]},hdlr:{container:"mdia",mandatory:!0,quantity:"one",box:"FullBox",is_container:!1,body:[["predefined",ur,0],["handler_type",er,"vide"],["reserved",tr,12],["name",er,"VideoHandler\0"]]},minf:{container:"mdia",mandatory:!0,quantity:"one",box:"Box",is_container:!0},vmhd:{container:"minf",mandatory:!0,quantity:"one",box:"FullBox",is_container:!1,config:{flags:1},body:[["graphicsmode",or,0],["opcolor",ar,[0,0,0]]]},smhd:{container:"minf",mandatory:!0,quantity:"one",box:"FullBox",is_container:!1,body:[["balance",or,0],["reserved",or]]},dinf:{container:"minf",mandatory:!0,quantity:"one",box:"Box",is_container:!0},dref:{container:"dinf",mandatory:!0,quantity:"one",box:"FullBox",is_container:!0,body:[["entry_count",ur,0]]},"url ":{container:"dref",mandatory:!0,quantity:"one+",box:"FullBox",is_container:!1,config:{flags:1},body:[]},stbl:{container:"minf",mandatory:!0,quantity:"one",box:"Box",is_container:!0},stts:{container:"stbl",mandatory:!0,quantity:"one",box:"FullBox",is_container:!1,body:[["entry_count",ur,0]]},stsd:{container:"stbl",mandatory:!0,quantity:"one",box:"FullBox",is_container:!0,body:[["entry_count",ur,1]]},avc1:{container:"stsd",mandatory:!1,quantity:"one",box:"Box",is_container:!0,body:[["reserved",tr,6],["data_reference_index",or,1],["pre_defined",or,0],["reserved2",tr,2],["pre_defined2",sr,[0,0,0]],["width",or,1920],["height",or,1080],["horizresolution",ur,4718592],["vertresolution",ur,4718592],["reserved3",ur,0],["frame_count",or,1],["compressorname",nr,Me.alloc(32)],["depth",or,24],["pre_defined3",or,65535]]},avcC:{container:"avc1",mandatory:!1,quantity:"one",box:"Box",is_container:!1,body:[["configurationVersion",rr,1],["AVCProfileIndication",rr,77],["profile_compatibility",rr,0],["AVCLevelIndication",rr,41],["lengthSizeMinusOne",rr,255],["sequenceParameterSets",fr(224),[]],["pictureParameterSets",fr(),[]]]},mp4a:{container:"stsd",mandatory:!1,quantity:"one",box:"Box",is_container:!0,body:[["reserved",tr,6],["data_reference_index",or,1],["reserved2",sr,[0,0]],["channelcount",or,2],["samplesize",or,16],["pre_defined",or,0],["reserved3",or,0],["samplerate",ur,0]]},esds:{container:"mp4a",mandatory:!1,quantity:"one",box:"FullBox",is_container:!1,body:[["ES_DescrTag",rr,3],["ES_DescrLength",rr,25],["ES_ID",or,1],["flagsAndStreamPriority",rr,0],["DecoderConfigDescrTag",rr,4],["DecoderConfigDescrLength",rr,17],["objectProfileIndication",rr,64],["streamTypeUpstreamReserved",rr,21],["bufferSizeDB",nr,[0,0,0]],["maxBitRate",ur,0],["avgBitRate",ur,0],["DecSpecificInfoShortTag",rr,5],["DecSpecificInfoShortLength",rr,2],["audioConfigBytes",or,0],["SLConfigDescrTag",rr,6],["SLConfigDescrLength",rr,1],["SLConfigDescrPredefined",rr,2]]},stsz:{container:"stbl",mandatory:!0,quantity:"one",box:"FullBox",is_container:!1,body:[["sample_size",ur,0],["sample_count",ur,0]]},stsc:{container:"stbl",mandatory:!0,quantity:"one",box:"FullBox",is_container:!1,body:[["entry_count",ur,0]]},stco:{container:"stbl",mandatory:!0,quantity:"one",box:"FullBox",is_container:!1,body:[["entry_count",ur,0]]},stss:{container:"stbl",mandatory:!1,quantity:"one-",box:"FullBox",is_container:!1,body:[["entry_count",ur,0]]},edts:{container:"trak",mandatory:!1,quantity:"one-",box:"Box",is_container:!0},elst:{container:"edts",mandatory:!1,quantity:"one-",box:"FullBox",is_container:!1,body:[["entry_count",ur,1],["segment_duration",ur,0],["media_time",ur,4294967295],["media_rate_integer",or,1],["media_rate_fraction",or,0]]},mvex:{container:"moov",mandatory:!1,quantity:"one-",box:"Box",is_container:!0},mehd:{container:"mvex",mandatory:!1,quantity:"one-",box:"FullBox",is_container:!1,body:[["fragment_duration",ur,0]]},trex:{container:"mvex",mandatory:!0,quantity:"one+",box:"FullBox",is_container:!1,body:[["track_ID",ur,1],["default_sample_description_index",ur,1],["default_sample_duration",ur,0],["default_sample_size",ur,0],["default_sample_flags",ur,0]]},moof:{container:"file",mandatory:!1,quantity:"zero+",box:"Box",is_container:!1},mfhd:{container:"moof",mandatory:!0,quantity:"one",box:"FullBox",is_container:!1,body:[["sequence_number",ur,0]]},traf:{container:"moof",mandatory:!1,quantity:"zero+",box:"Box",is_container:!0},tfhd:{container:"traf",mandatory:!0,quantity:"one",box:"FullBox",is_container:!1,config:{flags:32},body:[["track_ID",ur,1],["default_sample_flags",ur,0]]},tfdt:{container:"traf",mandatory:!1,quantity:"one-",box:"FullBox",is_container:!1,config:{version:1},body:[["baseMediaDecodeTime",cr,0]]},trun:{container:"traf",mandatory:!1,quantity:"zero+",box:"FullBox",is_container:!1,config:{flags:773},body:[["sample_count",ur,1],["data_offset",ur,0],["first_sample_flags",ur,0],["sample_duration",ur,0],["sample_size",ur,0]]},"....":{box:"Box",is_container:!1,body:[]},file:{box:"None",is_container:!0,mandatory:!0,quantity:"one"}},pr=function(){function t(){Ke(this,t)}return We(t,null,[{key:"None",value:function(){return[]}},{key:"Box",value:function(t){return[["size",ur,0],["type",er,t]]}},{key:"FullBox",value:function(t){return[].concat(this.Box(t),[["version",rr,0],["flags",ir,0]])}}]),t}(),hr=function(t){ze(r,t);var e=Ge(r);function r(t,n){var o;Ke(this,r),Xe(Ye(o=e.call(this,0)),"type",void 0),Xe(Ye(o),"config",void 0),Xe(Ye(o),"struct",void 0),o.type=t;var i=lr[o.type];if(void 0===i)throw new Error("unknown box type: ".concat(t));o.config=Object.assign({},i.config,n);var a=pr[i.box](o.type),u=i.body||[];o.struct=new Map;var s,c=0,f=De([].concat(a,u));try{for(f.s();!(s=f.n()).done;){var l=Ne(s.value,3),p=l[0],h=l[1],d=l[2];if(o.has(p))throw new Error("Trying to add existing key");var y=d;o.config[p]&&(y=o.config[p]);var v=new h(y);o.struct.set(p,{offset:c,element:v}),c+=v.byteLength}}catch(t){f.e(t)}finally{f.f()}return o.byteLength=c,o}return We(r,[{key:"element",value:function(t){var e=this.struct.get(t);if(void 0===e)throw new Error("invalid key");return e.element}},{key:"set",value:function(t,e){this.element(t).value=e}},{key:"get",value:function(t){return this.element(t).value}},{key:"offset",value:function(t){var e=this.struct.get(t);if(void 0===e)throw new Error("invalid key");return e.offset}},{key:"has",value:function(t){return this.struct.has(t)}},{key:"add",value:function(t,e){if(this.has(t))throw new Error("Trying to add existing key");return this.struct.set(t,{offset:this.byteLength,element:e}),this.byteLength+=e.byteLength,this}},{key:"buffer",value:function(){var t=Me.allocUnsafe(this.byteLength);return this.copy(t),t}},{key:"copy",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;this.set("size",this.byteLength);var r,n=De(this.struct.values());try{for(n.s();!(r=n.n()).done;){var o=r.value;o.element.copy(t,e+o.offset)}}catch(t){n.e(t)}finally{n.f()}}},{key:"load",value:function(t){var e,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=De(this.struct.values());try{for(n.s();!(e=n.n()).done;){var o=e.value;void 0!==o.element.load&&o.element.load(t,r+o.offset)}}catch(t){n.e(t)}finally{n.f()}}},{key:"format",value:function(){var t,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=[" ".repeat(e)+"[".concat(this.type,"] (").concat(this.byteLength,")")],n=De(this.struct);try{for(n.s();!(t=n.n()).done;){var o=Ne(t.value,2),i=o[0],a=o[1],u=a.element;void 0!==u.format?r.push(u.format(e+2)):r.push(" ".repeat(e+2)+"".concat(i," = ").concat(u.value," (").concat(u.byteLength,")"))}}catch(t){n.e(t)}finally{n.f()}return r.join("\n")}},{key:"print",value:function(t){console.warn(this.format(t))}}]),r}(Qe),dr=function(t){ze(r,t);var e=Ge(r);function r(t,n){var o,i;Ke(this,r),Xe(Ye(i=e.call(this,t,n)),"boxSize",void 0),i.boxSize=0;for(var a=arguments.length,u=new Array(a>2?a-2:0),s=2;s<a;s++)u[s-2]=arguments[s];return(o=i).append.apply(o,u),i}return We(r,[{key:"append",value:function(){for(var t=arguments.length,e=new Array(t),r=0;r<t;r++)e[r]=arguments[r];for(var n=0,o=e;n<o.length;n++){var i=o[n];this.add("box_".concat(this.boxSize++),i)}return this}},{key:"parse",value:function(t){for(var e=[];t.byteLength>0;){var n=new er("....");n.load(t,4);var o=n.value,i=lr[o],a=void 0;if(void 0!==i){if(i.is_container){(a=new r(o)).load(t);var u=a.parse(t.slice(a.byteLength,a.get("size")));e.push.apply(e,function(t){if(Array.isArray(t))return qe(t)}(p=u)||function(t){if("undefined"!=typeof Symbol&&null!=t[Symbol.iterator]||null!=t["@@iterator"])return Array.from(t)}(p)||Fe(p)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}())}else if((a=new hr(o)).load(t),"avcC"===o){var s=a.element("AVCProfileIndication").value.toString(16).padStart(2,0),c=a.element("profile_compatibility").value.toString(16).padStart(2,0),f=a.element("AVCLevelIndication").value.toString(16).padStart(2,0);e.push({type:"video",mime:"avc1.".concat(s).concat(c).concat(f)})}else if("esds"===o){var l=a.element("audioConfigBytes").value>>>11&31;e.push({type:"audio",mime:"mp4a.40.".concat(l)})}}else(a=new hr("....")).load(t),a.type=a.get("type");this.append(a),t=t.slice(a.get("size"))}var p;return e}}]),r}(hr),yr={1:"AAC Main",2:"AAC LC"},vr={0:"96 kHz",1:"88.2 kHz",2:"64 kHz",3:"48 kHz",4:"44.1 kHz",5:"32 kHz",6:"24 kHz",7:"22.05 kHz",8:"16 kHz",9:"12 kHz",10:"11.025 kHz",11:"8 kHz",12:"7.35 kHz"},br={1:"Mono",2:"Stereo"},mr=function(t){var e=t>>>11&31,r=t>>>7&15,n=t>>>3&15;return{coding:yr[e]||"AAC (".concat(e,")"),samplingRate:vr[r]||"unknown",channels:br[n]||n.toString()}};function gr(t,e){for(var r,n,o,i=t.replace(/[^A-Za-z0-9+/]/g,""),a=i.length,u=e?Math.ceil((3*a+1>>2)/e)*e:3*a+1>>2,s=new Uint8Array(u),c=0,f=0,l=0;l<a;l++)if(n=3&l,c|=((o=i.charCodeAt(l))>64&&o<91?o-65:o>96&&o<123?o-71:o>47&&o<58?o+4:43===o?62:47===o?63:0)<<18-6*n,3===n||a-l==1){for(r=0;r<3&&f<u;r++,f++)s[f]=c>>>(16>>>r&24)&255;c=0}return s}function wr(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}function _r(t,e,r){return e in t?Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[e]=r,t}r(5957),r(1818),r(1661),r(4449),r(9722),r(6747),r(77),r(9038),r(7522),r(6534),r(538),r(1888),r(1613),r(2744),r(5066),r(2315),r(5288),r(5503),r(9969),r(2103),r(1587),r(5109),r(1418),r(9760),r(4948),r(727),r(5448),r(6179),r(5694),r(4270);var Sr=function(){function t(e){!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,t),_r(this,"_buffer",void 0),_r(this,"_dataView",void 0),_r(this,"_offset",void 0),_r(this,"_bitpos",void 0),_r(this,"_byte",void 0),this._buffer=e,this._dataView=new DataView(this._buffer),this._offset=0,this._bitpos=0,this._byte=0}var e,r;return e=t,(r=[{key:"readUint8",value:function(t){return this._dataView.getUint8(t)}},{key:"readUint16",value:function(t){return this._dataView.getUint16(t)}},{key:"readUint32",value:function(t){return this._dataView.getUint32(t)}},{key:"readNext",value:function(){var t=this.readUint8(this._offset);return this._offset+=1,t}},{key:"readBits",value:function(t){if(t>32||0===t)throw new Error("length has to be between 0 - 31 bits");for(var e=0,r=1;r<=t;++r)0===this._bitpos&&(this._byte=this.readNext()),e=e<<1|this._byte>>8-++this._bitpos&1,this._bitpos%=8;return e}},{key:"readUnsignedExpGolomb",value:function(){for(var t=0;1!==this.readBits(1);)t++;if(0===t)return 0;if(t>=31)throw new Error("read unsigned exponential Golomb: internal error");var e=this.readBits(t);return(e|=1<<t)-1}},{key:"readSignedExpGolomb",value:function(){var t=this.readUnsignedExpGolomb();return 1&t?t+1>>1:-(t>>1)}},{key:"size",value:function(){return this._buffer.byteLength}},{key:"getUint8Array",value:function(){return new Uint8Array(this._buffer)}},{key:"getArrayBuffer",value:function(){return this._buffer}}])&&wr(e.prototype,r),t}();function Er(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}var Or=function(){function t(e){var r,n;!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,t),n=void 0,(r="reader")in this?Object.defineProperty(this,r,{value:n,enumerable:!0,configurable:!0,writable:!0}):this[r]=n,this.reader=new Sr(e)}var e,r;return e=t,(r=[{key:"parse",value:function(){this.reader.readNext();var t=this.reader.readNext();this.reader.readNext();var e=this.reader.readNext();if(this.reader.readUnsignedExpGolomb(),[100,110,122,244,44,83,86,118].includes(t)){var r=this.reader.readUnsignedExpGolomb();if(3===r&&this.reader.readBits(1),this.reader.readUnsignedExpGolomb(),this.reader.readUnsignedExpGolomb(),this.reader.readBits(1),this.reader.readBits(1))for(var n=0;n<(3!==r?8:12);n++)this.reader.readBits(1)}this.reader.readUnsignedExpGolomb();var o=this.reader.readUnsignedExpGolomb();if(0===o)this.reader.readUnsignedExpGolomb();else if(1===o){var i;this.reader.readBits(1),this.reader.readSignedExpGolomb(),this.reader.readSignedExpGolomb(),i=this.reader.readUnsignedExpGolomb();for(var a=0;a<i;a++)this.reader.readSignedExpGolomb()}this.reader.readUnsignedExpGolomb(),this.reader.readBits(1);var u=this.reader.readUnsignedExpGolomb(),s=this.reader.readUnsignedExpGolomb(),c=this.reader.readBits(1);this.reader.readBits(1);var f=this.reader.readBits(1);return{profile:t,level:e/10,width:16*(u+1)-2*(f?this.reader.readUnsignedExpGolomb():0)-2*(f?this.reader.readUnsignedExpGolomb():0),height:(2-c)*(s+1)*16-2*(f?this.reader.readUnsignedExpGolomb():0)-2*(f?this.reader.readUnsignedExpGolomb():0)}}}])&&Er(e.prototype,r),t}(),xr={66:"Baseline",77:"Main",100:"High"},Rr=function(t){var e=parseInt(t.substr(0,2),16),r=parseInt(t.substr(4,2),16);return{coding:"H.264",profile:xr[e]||e.toString(),level:(r/10).toFixed(1)}};function Tr(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}function kr(t,e,r){return e in t?Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[e]=r,t}var Pr={"MPEG4-GENERIC":function(t,e,r){var n=Number(t.fmtp.parameters.bitrate)||32e4,o=parseInt(t.fmtp.parameters.config,16),i=o>>>11&31;return{tkhd:{track_ID:r,creation_time:e,modification_time:e,width:0,height:0,volume:1},mdhd:{timescale:Number(t.rtpmap.clockrate),creation_time:e,modification_time:e,duration:0},hdlr:{handler_type:"soun",name:"SoundHandler\0"},mediaHeaderBox:new hr("smhd"),sampleEntryBox:new dr("mp4a",{samplerate:t.rtpmap.clockrate<<16>>>0},new hr("esds",{audioConfigBytes:o,maxBitRate:n,avgBitRate:n})),defaultFrameDuration:1024,mime:"mp4a.40.".concat(i),codec:mr(o)}},H264:function(t,e,r){var n=t.fmtp.parameters["profile-level-id"],o=t.fmtp.parameters["sprop-parameter-sets"].split(",").map(gr),i=o.slice(0,1),a=o.slice(1),u=new Or(i[0].buffer).parse();return{mediaHeaderBox:new hr("vmhd"),sampleEntryBox:new dr("avc1",{width:u.width,height:u.height},new hr("avcC",{AVCProfileIndication:i[0][1],profile_compatibility:i[0][2],AVCLevelIndication:i[0][3],sequenceParameterSets:i,pictureParameterSets:a})),tkhd:{track_ID:r,creation_time:e,modification_time:e,width:u.width<<16,height:u.height<<16,volume:0},hdlr:{},mdhd:{timescale:t.rtpmap.clockrate,creation_time:e,modification_time:e,duration:0},defaultFrameDuration:void 0!==t.framerate&&t.framerate>0&&Number(t.rtpmap.clockrate)/Number(t.framerate)||3600,mime:"avc1.".concat(n),codec:Rr(n)}}},jr=function(){function t(){!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,t),kr(this,"trackIdMap",void 0),kr(this,"sequenceNumber",void 0),kr(this,"ntpPresentationTime",void 0),kr(this,"trackData",void 0),kr(this,"videoTrackId",void 0),this.trackIdMap={},this.sequenceNumber=0,this.ntpPresentationTime=0,this.trackData=[]}var e,r;return e=t,(r=[{key:"trak",value:function(t){var e=new dr("trak"),r=new dr("mdia"),n=new dr("minf"),o=new dr("dinf"),i=new dr("dref"),a=new dr("stbl");return i.set("entry_count",1),e.append(new hr("tkhd",t.tkhd),r.append(new hr("mdhd",t.mdhd),new hr("hdlr",t.hdlr),n.append(t.mediaHeaderBox,o.append(i.append(new hr("url "))),a.append(new dr("stsd",void 0,t.sampleEntryBox),new hr("stts"),new hr("stsc"),new hr("stco"),new hr("stsz"),new hr("stss"))))),e}},{key:"moov",value:function(t,e){var r=this,n=new dr("moov");n.append(new hr("mvhd",{creation_time:e,modification_time:e,duration:0}));var o=new dr("mvex");this.trackIdMap={},this.sequenceNumber=0,this.ntpPresentationTime=0;var i=0;return this.trackData=[],t.media.forEach((function(t){if(void 0!==t.rtpmap){var a=t.rtpmap.payloadType,u=t.rtpmap.encodingName;if(void 0!==Pr[u]){r.trackIdMap[a]=++i,"video"===t.type.toLowerCase()&&(r.videoTrackId=i);var s=Pr[u](t,e,i);t.mime=s.mime,t.codec=s.codec;var c={lastTimestamp:0,baseMediaDecodeTime:0,defaultFrameDuration:0,clockrate:0,bitrate:0,framerate:0,cumulativeByteLength:0,cumulativeDuration:0,cumulativeFrames:0};c.clockrate=t.rtpmap.clockrate,c.defaultFrameDuration=s.defaultFrameDuration,r.trackData.push(c);var f=r.trak(s);n.append(f),o.append(new hr("trex",{track_ID:i}))}}})),n.append(o),n}},{key:"moof",value:function(t){var e=t.trackId,r=t.timestamp,n=t.byteLength,o=e-1,i=this.trackData[o],a=0!==i.lastTimestamp?r-i.lastTimestamp|0:i.defaultFrameDuration;i.lastTimestamp=r;var u=new dr("moof"),s=new dr("traf"),c=new hr("trun",{sample_duration:a,sample_size:n,first_sample_flags:64});return u.append(new hr("mfhd",{sequence_number:this.sequenceNumber++}),s.append(new hr("tfhd",{track_ID:e}),new hr("tfdt",{baseMediaDecodeTime:i.baseMediaDecodeTime}),c)),i.baseMediaDecodeTime+=a,c.set("data_offset",u.byteLength+8),function(t,e){var r=e.byteLength,n=e.duration;if(t.cumulativeByteLength+=r,t.cumulativeDuration+=n,t.cumulativeFrames++,t.cumulativeDuration>=t.clockrate){var o=8*t.cumulativeByteLength,i=t.cumulativeFrames,a=t.cumulativeDuration/t.clockrate;t.bitrate=o/a,t.framerate=i/a,t.cumulativeByteLength=0,t.cumulativeDuration=0,t.cumulativeFrames=0}}(i,{byteLength:n,duration:a}),u}},{key:"mdat",value:function(t){var e=new hr("mdat");return e.add("data",t),e}},{key:"setPresentationTime",value:function(t,e){if(!this.ntpPresentationTime&&e&&t===this.videoTrackId){var r=t-1,n=this.trackData[r];this.ntpPresentationTime=e-n.baseMediaDecodeTime/n.clockrate*1e3}}}])&&Tr(e.prototype,r),t}(),Ar=r(7866).Buffer;function Cr(t){return(Cr="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function Ir(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}function Lr(t,e){return(Lr=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}function Br(t,e){return!e||"object"!==Cr(e)&&"function"!=typeof e?Mr(t):e}function Mr(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}function Ur(t){return(Ur=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}function Nr(t,e,r){return e in t?Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[e]=r,t}var Dr,Fr=function(t){!function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&Lr(t,e)}(u,t);var e,r,n,o,a=(n=u,o=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}(),function(){var t,e=Ur(n);if(o){var r=Ur(this).constructor;t=Reflect.construct(e,arguments,r)}else t=e.apply(this,arguments);return Br(this,t)});function u(){var t;!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,u);var e=new jr,r=new i.Transform({objectMode:!0,transform:function(r,n,o){if(r.type===w.SDP){var i=Math.floor((new Date).getTime()/1e3+2082852e3),a=new hr("ftyp"),u=e.moov(r.sdp,i),s=Ar.allocUnsafe(a.byteLength+u.byteLength);a.copy(s,0),u.copy(s,a.byteLength),vt()("msl:mp4:isom")("ftyp: ".concat(a.format())),vt()("msl:mp4:isom")("moov: ".concat(u.format()));var c=r.sdp.media.map((function(t){return{type:t.type,encoding:t.rtpmap&&t.rtpmap.encodingName,mime:t.mime,codec:t.codec}}));this.push({type:w.ISOM,data:s,tracks:c,ftyp:a,moov:u})}else if(r.type===w.ELEMENTARY||r.type===w.H264){var f=r.payloadType,l=r.timestamp,p=r.ntpTimestamp,h=e.trackIdMap[f];if(h){var d;e.ntpPresentationTime||(e.setPresentationTime(h,p),e.ntpPresentationTime&&(_=e.ntpPresentationTime,t.onSync&&t.onSync(_)));var y=r.type===w.H264?r.nalType===ht.IDR_PICTURE:void 0;e.ntpPresentationTime&&y&&void 0!==r.ntpTimestamp&&(d=(r.ntpTimestamp-e.ntpPresentationTime)/1e3);var v=r.data.byteLength,b=e.moof({trackId:h,timestamp:l,byteLength:v}),m=e.mdat(r.data),g=Ar.allocUnsafe(b.byteLength+m.byteLength);b.copy(g,0),m.copy(g,b.byteLength),this.push({type:w.ISOM,data:g,moof:b,mdat:m,ntpTimestamp:p,checkpointTime:d})}}else this.push(r);var _;o()}});return Nr(Mr(t=a.call(this,r)),"boxBuilder",void 0),Nr(Mr(t),"onSync",void 0),t.boxBuilder=e,t}return e=u,(r=[{key:"bitrate",get:function(){return this.boxBuilder.trackData&&this.boxBuilder.trackData.map((function(t){return t.bitrate}))}},{key:"framerate",get:function(){return this.boxBuilder.trackData&&this.boxBuilder.trackData.map((function(t){return t.framerate}))}},{key:"ntpPresentationTime",get:function(){return this.boxBuilder.ntpPresentationTime}}])&&Ir(e.prototype,r),u}(E);function qr(t,e){var r=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),r.push.apply(r,n)}return r}function Hr(t){for(var e=1;e<arguments.length;e++){var r=null!=arguments[e]?arguments[e]:{};e%2?qr(Object(r),!0).forEach((function(e){Wr(t,e,r[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(r)):qr(Object(r)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(r,e))}))}return t}function Wr(t,e,r){return e in t?Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[e]=r,t}r(9210),function(t){t[t.SR=200]="SR",t[t.RR=201]="RR",t[t.SDES=202]="SDES",t[t.BYE=203]="BYE",t[t.APP=204]="APP"}(Dr||(Dr={}));var zr,Vr=function(t){var e=function(t){return{version:t[0]>>>6,padding:!!(t[0]&x[2]),count:31&t[0],packetType:t.readUInt8(1),length:t.readUInt16BE(2)}}(t);switch(e.packetType){case Dr.SR:return Jr(t,e);case Dr.RR:return Xr(t,e);case Dr.SDES:return Qr(t,e);case Dr.BYE:return en(t,e);case Dr.APP:return nn(t,e);default:return e}},Gr=function(t,e){return{type:w.RTCP,data:e,channel:t,rtcp:Vr(e)}},$r={packetType:200},Yr=function(t,e,r){for(var n=[],o=0;o<t;o++){var i=r+24*o;n.push({syncSource:e.readUInt32BE(i+0),fractionLost:e.readUInt8(i+4),cumulativeNumberOfPacketsLost:e.readUIntBE(i+5,3),extendedHighestSequenceNumberReceived:e.readUInt32BE(i+8),interarrivalJitter:e.readUInt32BE(i+12),lastSRTimestamp:e.readUInt32BE(i+16),delaySinceLastSR:e.readUInt32BE(i+20)})}return n},Jr=function(t,e){return Hr(Hr({},e),{},{syncSource:t.readUInt32BE(4),ntpMost:t.readUInt32BE(8),ntpLeast:t.readUInt32BE(12),rtpTimestamp:t.readUInt32BE(16),sendersPacketCount:t.readUInt32BE(20),sendersOctetCount:t.readUInt32BE(24),reports:Yr(e.count,t,28)})},Kr=function(t){return t.packetType===Dr.SR},Xr=function(t,e){return Hr(Hr({},e),{},{syncSource:t.readUInt32BE(4),reports:Yr(e.count,t,8)})},Zr=function(t){return t.packetType===Dr.RR};!function(t){t[t.CNAME=1]="CNAME",t[t.NAME=2]="NAME",t[t.EMAIL=3]="EMAIL",t[t.PHONE=4]="PHONE",t[t.LOC=5]="LOC",t[t.TOOL=6]="TOOL",t[t.NOTE=7]="NOTE",t[t.PRIV=8]="PRIV"}(zr||(zr={}));var Qr=function(t,e){for(var r=[],n=4,o=0;o<e.count;o++){var i={source:t.readUInt32BE(n),items:[]};for(n+=4;;){var a=t.readUInt8(n++);if(0===a){n%4!=0&&(n+=4-n%4);break}var u=t.readUInt8(n++);if(a===zr.PRIV){var s=t.readUInt8(n),c=t.toString("utf8",n+1,n+1+s),f=t.toString("utf8",n+1+s,n+u);i.items.push([zr.PRIV,c,f])}else{var l=t.toString("utf8",n,n+u);i.items.push([a,l])}n+=u}r.push(i)}return Hr(Hr({},e),{},{syncSource:t.readUInt32BE(4),sourceDescriptions:r})},tn=function(t){return t.packetType===Dr.SDES},en=function(t,e){for(var r,n=[],o=0;o<e.count;o++)n.push(t.readUInt32BE(4+4*o));if(e.length>e.count){var i=4+4*e.count,a=t.readUInt8(i);r=t.toString("utf-8",i+1,i+1+a)}return Hr(Hr({},e),{},{sources:n,reason:r})},rn=function(t){return t.packetType===Dr.BYE},nn=function(t,e){return Hr(Hr({},e),{},{subtype:e.count,source:t.readUInt32BE(4),name:t.toString("ascii",8,12),data:t.slice(12)})},on=function(t){return t.packetType===Dr.APP};function an(t){return(an="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function un(t,e,r,n,o,i,a){try{var u=t[i](a),s=u.value}catch(t){return void r(t)}u.done?e(s):Promise.resolve(s).then(n,o)}function sn(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}function cn(t,e){return(cn=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}function fn(t,e){return!e||"object"!==an(e)&&"function"!=typeof e?ln(t):e}function ln(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}function pn(t){return(pn=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}function hn(t,e,r){return e in t?Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[e]=r,t}var dn=vt()("msl:mse"),yn=function(t){!function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&cn(t,e)}(c,t);var e,r,n,o,a,u,s=(a=c,u=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}(),function(){var t,e=pn(a);if(u){var r=pn(this).constructor;t=Reflect.construct(e,arguments,r)}else t=e.apply(this,arguments);return fn(this,t)});function c(t){var e,r,n;if(function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,c),void 0===t)throw new Error("video element argument missing");var o=new i.Writable({objectMode:!0,write:function(i,a,u){if(i.type===w.ISOM)if(e._done=u,void 0!==i.tracks||void 0!==i.mime){var s,c,f=null!==(s=i.tracks)&&void 0!==s?s:[],l=f.map((function(t){return t.mime})).filter((function(t){return t})),p=0!==l.length?l.join(", "):"avc1.640029, mp4a.40.2",h=null!==(c=i.mime)&&void 0!==c?c:'video/mp4; codecs="'.concat(p,'"');if(!MediaSource.isTypeSupported(h))return void o.emit("error","unsupported media type: ".concat(h));e._lastCheckpointTime=0,r=new MediaSource,t.src=window.URL.createObjectURL(r),r.addEventListener("sourceopen",(function a(){if(void 0!==r){window.URL.revokeObjectURL(t.src),r.removeEventListener("sourceopen",a),e.onSourceOpen&&e.onSourceOpen(r,f),(n=e.addSourceBuffer(t,r,h)).onerror=function(t){console.error("error on SourceBuffer: ",t),o.emit("error")};try{n.appendBuffer(i.data)}catch(t){dn("failed to append to SourceBuffer: ",t,i)}}else o.emit("error","no MediaSource instance")}))}else{e._lastCheckpointTime=void 0!==i.checkpointTime?i.checkpointTime:e._lastCheckpointTime;try{var d;null===(d=n)||void 0===d||d.appendBuffer(i.data)}catch(t){dn("failed to append to SourceBuffer: ",t,i)}}else if(i.type===w.RTCP){var y;rn(i.rtcp)&&"open"===(null===(y=r)||void 0===y?void 0:y.readyState)&&r.endOfStream(),u()}else u()}});o.on("finish",(function(){console.warn("incoming stream finished: end stream"),r&&"open"===r.readyState&&r.endOfStream()})),o.on("error",(function(t){var e;console.error("error on incoming stream: ",t),n&&n.updating?n.addEventListener("updateend",(function(){var t;"open"===(null===(t=r)||void 0===t?void 0:t.readyState)&&r.endOfStream()})):"open"===(null===(e=r)||void 0===e?void 0:e.readyState)&&r.endOfStream()}));var a=new i.Readable({objectMode:!0,read:function(){}});return a.on("error",(function(){console.warn("outgoing stream broke somewhere")})),hn(ln(e=s.call(this,o,a)),"_videoEl",void 0),hn(ln(e),"_done",void 0),hn(ln(e),"_lastCheckpointTime",void 0),hn(ln(e),"onSourceOpen",void 0),e._videoEl=t,e._lastCheckpointTime=0,e}return e=c,(r=[{key:"addSourceBuffer",value:function(t,e,r){var n=this,o=e.addSourceBuffer(r),i=0;return o.addEventListener("updateend",(function(){if(++i>100&&o.buffered.length){i=0;var e=o.buffered.length-1,r=o.buffered.start(e),a=Math.min(t.currentTime,n._lastCheckpointTime)-10;try{if(a>r)return void o.remove(r,a)}catch(t){console.warn(t)}}n._done&&n._done()})),o}},{key:"currentTime",get:function(){return this._videoEl.currentTime}},{key:"play",value:(n=regeneratorRuntime.mark((function t(){return regeneratorRuntime.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:return t.next=2,this._videoEl.play();case 2:return t.abrupt("return",t.sent);case 3:case"end":return t.stop()}}),t,this)})),o=function(){var t=this,e=arguments;return new Promise((function(r,o){var i=n.apply(t,e);function a(t){un(i,r,o,a,u,"next",t)}function u(t){un(i,r,o,a,u,"throw",t)}a(void 0)}))},function(){return o.apply(this,arguments)})},{key:"pause",value:function(){return this._videoEl.pause()}}])&&sn(e.prototype,r),c}(O),vn=r(7866).Buffer;function bn(t){return(bn="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function mn(t,e){(null==e||e>t.length)&&(e=t.length);for(var r=0,n=new Array(e);r<e;r++)n[r]=t[r];return n}function gn(t,e){return(gn=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}function wn(t,e){return!e||"object"!==bn(e)&&"function"!=typeof e?function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t):e}function _n(t){return(_n=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}var Sn=function(t){!function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&gn(t,e)}(o,t);var e,r,n=(e=o,r=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}(),function(){var t,n=_n(e);if(r){var o=_n(this).constructor;t=Reflect.construct(n,arguments,o)}else t=n.apply(this,arguments);return wn(this,t)});function o(){var t;!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,o);var e=[],r=new i.Transform({objectMode:!0,transform:function(r,n,o){if(r.type===w.SDP){var i,a,u=function(t,e){var r="undefined"!=typeof Symbol&&t[Symbol.iterator]||t["@@iterator"];if(!r){if(Array.isArray(t)||(r=function(t,e){if(t){if("string"==typeof t)return mn(t,e);var r=Object.prototype.toString.call(t).slice(8,-1);return"Object"===r&&t.constructor&&(r=t.constructor.name),"Map"===r||"Set"===r?Array.from(t):"Arguments"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)?mn(t,e):void 0}}(t))||e&&t&&"number"==typeof t.length){r&&(t=r);var n=0,o=function(){};return{s:o,n:function(){return n>=t.length?{done:!0}:{done:!1,value:t[n++]}},e:function(t){throw t},f:o}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var i,a=!0,u=!1;return{s:function(){r=r.call(t)},n:function(){var t=r.next();return a=t.done,t},e:function(t){u=!0,i=t},f:function(){try{a||null==r.return||r.return()}finally{if(u)throw i}}}}(r.sdp.media);try{for(u.s();!(a=u.n()).done;){var s=a.value;"application"===s.type&&s.rtpmap&&"VND.ONVIF.METADATA"===s.rtpmap.encodingName&&(i=s)}}catch(t){u.e(t)}finally{u.f()}i&&i.rtpmap&&(t=Number(i.rtpmap.payloadType)),o(void 0,r)}else if(r.type===w.RTP&&C(r.data)===t){if(e.push(D(r.data)),A(r.data)&&e.length>0)return o(void 0,{timestamp:L(r.data),ntpTimestamp:r.ntpTimestamp,payloadType:C(r.data),data:vn.concat(e),type:w.XML}),void(e=[]);o()}else o(void 0,r)}});return n.call(this,r)}return o}(E),En=(r(5916),r(7866).Buffer);function On(t,e){(null==e||e>t.length)&&(e=t.length);for(var r=0,n=new Array(e);r<e;r++)n[r]=t[r];return n}function xn(t,e,r){return e in t?Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[e]=r,t}function Rn(t,e){return jn(t)||function(t,e){var r=null==t?null:"undefined"!=typeof Symbol&&t[Symbol.iterator]||t["@@iterator"];if(null!=r){var n,o,i=[],a=!0,u=!1;try{for(r=r.call(t);!(a=(n=r.next()).done)&&(i.push(n.value),!e||i.length!==e);a=!0);}catch(t){u=!0,o=t}finally{try{a||null==r.return||r.return()}finally{if(u)throw o}}return i}}(t,e)||kn(t,e)||Tn()}function Tn(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}function kn(t,e){if(t){if("string"==typeof t)return Pn(t,e);var r=Object.prototype.toString.call(t).slice(8,-1);return"Object"===r&&t.constructor&&(r=t.constructor.name),"Map"===r||"Set"===r?Array.from(t):"Arguments"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)?Pn(t,e):void 0}}function Pn(t,e){(null==e||e>t.length)&&(e=t.length);for(var r=0,n=new Array(e);r<e;r++)n[r]=t[r];return n}function jn(t){if(Array.isArray(t))return t}r(9340),r(7505);var An,Cn=function(t){return t.match(/^m=/)},In=function(t,e){var r=e.indexOf(t);return r<0?[e.slice(0)]:[e.slice(0,r),e.slice(r+1)]},Ln={fmtp:function(t){var e=Rn(In(" ",t),2),r=e[0],n=e[1].trim().split(";"),o={};return n.forEach((function(t){var e=Rn(In("=",t),2),r=e[0],n=e[1],i=r.trim().toLowerCase();""!==i&&(o[i]=n.trim())})),{format:r,parameters:o}},framerate:Number,rtpmap:function(t){var e=Rn(In(" ",t),2),r=e[0],n=Rn(e[1].toUpperCase().split("/"),3),o=n[0],i=n[1],a=n[2];return void 0===a?{payloadType:Number(r),encodingName:o,clockrate:Number(i)}:{payloadType:Number(r),encodingName:o,clockrate:Number(i),encodingParameters:a}},transform:function(t){return t.split(";").map((function(t){return t.split(",").map(Number)}))},"x-sensor-transform":function(t){return t.split(";").map((function(t){return t.split(",").map(Number)}))},framesize:function(t){return t.split(" ")[1].split("-").map(Number)}},Bn=function(t){var e,r=t.slice(0,1),n=t.slice(2);switch(r){case"v":return{version:n};case"o":var o=Rn(n.split(" "),6),i=o[0],a=o[1],u=o[2],s=o[3];return{origin:{addrType:o[4],netType:s,sessionId:a,sessionVersion:u,unicastAddress:o[5],username:i}};case"s":return{sessionName:n};case"i":return{sessionInformation:n};case"u":return{uri:n};case"e":return{email:n};case"p":return{phone:n};case"c":var c=Rn(n.split(" "),3),f=c[0];return{connectionData:{addrType:c[1],connectionAddress:c[2],netType:f}};case"b":var l=Rn(n.split(":"),2);return{bwtype:l[0],bandwidth:l[1]};case"t":var p=Rn(n.split(" ").map(Number),2);return{time:{startTime:p[0],stopTime:p[1]}};case"r":var h=jn(e=n.split(" ").map(Number))||function(t){if("undefined"!=typeof Symbol&&null!=t[Symbol.iterator]||null!=t["@@iterator"])return Array.from(t)}(e)||kn(e)||Tn();return{repeatTimes:{repeatInterval:h[0],activeDuration:h[1],offsets:h.slice(2)}};case"z":case"k":return;case"a":return function(t){var e=Rn(In(":",t),2),r=e[0],n=e[1];return void 0===n?xn({},r,!0):void 0!==Ln[r]?xn({},r,Ln[r](n)):xn({},r,n)}(n);case"m":var d=Rn(n.split(" "),4),y=d[0],v=d[1],b=d[2],m=d[3];return{type:y,port:Number(v),protocol:b,fmt:Number(m)}}},Mn=function(t){var e=t.indexOf("\nm=");return function(t,e){var r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,n="\n".concat(e);r=t.indexOf(n,r);for(var o=0,i=[];r>=0;)o=t.indexOf("\n",r+n.length),i.push(t.toString("ascii",r+n.length,o).trim()),r=t.indexOf(n,o);return i}(t,"a=control:",e)},Un=function(t){var e,r=t.toString("ascii").split("\n").map((function(t){return t.trim()})),n={session:{},media:[]},o=0,i=n.session,a=function(t,e){var r="undefined"!=typeof Symbol&&t[Symbol.iterator]||t["@@iterator"];if(!r){if(Array.isArray(t)||(r=kn(t))){r&&(t=r);var n=0,o=function(){};return{s:o,n:function(){return n>=t.length?{done:!0}:{done:!1,value:t[n++]}},e:function(t){throw t},f:o}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var i,a=!0,u=!1;return{s:function(){r=r.call(t)},n:function(){var t=r.next();return a=t.done,t},e:function(t){u=!0,i=t},f:function(){try{a||null==r.return||r.return()}finally{if(u)throw i}}}}(r);try{for(a.s();!(e=a.n()).done;){var u=e.value;Cn(u)&&(n.media[o]={},i=n.media[o],++o),i=Object.assign(i,Bn(u))}}catch(t){a.e(t)}finally{a.f()}return n},Nn=function(t){return{type:w.SDP,data:t,sdp:Un(t)}},Dn=function(t,e){var r="\n".concat(e.toLowerCase(),": "),n=t.toString().toLowerCase().indexOf(r);if(n>=0){var o=t.indexOf("\n",n+r.length);return t.toString("ascii",n+r.length,o).trim()}return null},Fn=function(t){var e=Dn(t,"CSeq");return null!==e?Number(e):null},qn=function(t){var e=Dn(t,"Session");return e?e.split(";")[0]:null},Hn=function(t){var e=Dn(t,"Session");if(null===e)return null;var r="timeout=",n=e.toLowerCase().indexOf(r);if(-1!==n){var o=e.substring(n+r.length);o=o.split(";")[0];var i=parseInt(o);return isNaN(i)?60:i}return 60},Wn=function(t){return Number(t.toString("ascii",9,12))},zn=function(t){return Dn(t,"Content-Base")},Vn=function(t){return Dn(t,"Content-Location")},Gn=function(t){var e=Dn(t,"Connection");return null!==e&&"close"===e.toLowerCase()},$n=function(t){var e=Dn(t,"Range");if(null!==e)return e.split("=")[1].split("-")},Yn=function(t){var e=["\n\n","\r\r","\r\n\r\n"].map((function(e){var r=t.indexOf(e);return-1!==r?r+e.length:r})).filter((function(t){return-1!==t}));return e.length>0?e.reduce((function(t,e){return Math.min(t,e)})):-1},Jn=r(7866).Buffer;function Kn(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}function Xn(t,e,r){return e in t?Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[e]=r,t}!function(t){t[t.IDLE=0]="IDLE",t[t.INTERLEAVED=1]="INTERLEAVED",t[t.RTSP=2]="RTSP"}(An||(An={}));var Zn=function(){function t(){!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,t),Xn(this,"_chunks",[]),Xn(this,"_length",0),Xn(this,"_state",An.IDLE),Xn(this,"_packet",void 0),this._init()}var e,r;return e=t,(r=[{key:"_init",value:function(){this._chunks=[],this._length=0,this._state=An.IDLE}},{key:"_push",value:function(t){this._chunks.push(t),this._length+=t.length}},{key:"_parseRtsp",value:function(){var t=[],e=Jn.concat(this._chunks),r=Yn(e);if(-1===r)return t;var n=r,o=Dn(e,"Content-Length");if(o&&parseInt(o)>e.length-n)return t;if(this._init(),n===e.length||36===e[n]){var i=e.slice(0,n);t.push({type:w.RTSP,data:i});var a=e.slice(n);this._push(a)}else{var u=e,s=e.slice(n);t.push({type:w.RTSP,data:u}),t.push(Nn(s))}return t}},{key:"_parseInterleaved",value:function(){var t=[];if(this._length<4)return t;if(this._packet||(this._packet=function(t){for(var e=Jn.alloc(4),r=0,n=0;n<e.length;){var o=t[r++],i=Math.min(o.length,e.length-n);o.copy(e,n,0,i),n+=i}var a=e[1],u=e.length;return{channel:a,begin:u,end:u+e.readUInt16BE(2)}}(this._chunks)),this._length<this._packet.end)return t;var e=Jn.concat(this._chunks),r=e.slice(this._packet.begin,this._packet.end),n=e.slice(this._packet.end),o=this._packet.channel;if(delete this._packet,this._init(),this._push(n),o%2==0)t.push({type:w.RTP,data:r,channel:o});else{var i=r;do{var a=4*i.readUInt16BE(2)+4;t.push(Gr(o,i.slice(0,a))),i=i.slice(a)}while(i.length>0)}return t}},{key:"_setState",value:function(){for(;this._chunks.length>0&&0===this._chunks[0].length;)this._chunks.shift();var t=this._chunks[0];if(0===this._chunks.length)this._state=An.IDLE;else if(36===t[0])this._state=An.INTERLEAVED;else{if("RTSP"!==t.toString("ascii",0,4))throw new Error("Unknown chunk of length ".concat(t.length));this._state=An.RTSP}}},{key:"parse",value:function(t){this._push(t),this._state===An.IDLE&&this._setState();for(var e=[],r=!1;!r;){var n=[];switch(this._state){case An.IDLE:break;case An.INTERLEAVED:n=this._parseInterleaved();break;case An.RTSP:n=this._parseRtsp();break;default:throw new Error("internal error: unknown state")}n.length>0?e=e.concat(n):r=!0,this._setState()}return e}}])&&Kn(e.prototype,r),t}();function Qn(t){return(Qn="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function to(t,e){return(to=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}function eo(t,e){return!e||"object"!==Qn(e)&&"function"!=typeof e?function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t):e}function ro(t){return(ro=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}var no=function(t){!function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&to(t,e)}(o,t);var e,r,n=(e=o,r=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}(),function(){var t,n=ro(e);if(r){var o=ro(this).constructor;t=Reflect.construct(n,arguments,o)}else t=n.apply(this,arguments);return eo(this,t)});function o(){!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,o);var t=new Zn,e=new i.Transform({objectMode:!0,transform:function(r,n,o){if(r.type===w.RAW)try{t.parse(r.data).forEach((function(t){return e.push(t)})),o()}catch(t){o(t)}else o(void 0,r)}}),r=new i.Transform({objectMode:!0,transform:function(t,e,r){if(t.type===w.RTSP){var n=function(t){if(!t.method||!t.uri)throw new Error("message needs to contain a method and a uri");var e=t.protocol||"RTSP/1.0",r=t.headers||{},n=["".concat(t.method," ").concat(t.uri," ").concat(e),Object.entries(r).map((function(t){var e,r,n=(r=2,function(t){if(Array.isArray(t))return t}(e=t)||function(t,e){var r=null==t?null:"undefined"!=typeof Symbol&&t[Symbol.iterator]||t["@@iterator"];if(null!=r){var n,o,i=[],a=!0,u=!1;try{for(r=r.call(t);!(a=(n=r.next()).done)&&(i.push(n.value),!e||i.length!==e);a=!0);}catch(t){u=!0,o=t}finally{try{a||null==r.return||r.return()}finally{if(u)throw o}}return i}}(e,r)||function(t,e){if(t){if("string"==typeof t)return On(t,e);var r=Object.prototype.toString.call(t).slice(8,-1);return"Object"===r&&t.constructor&&(r=t.constructor.name),"Map"===r||"Set"===r?Array.from(t):"Arguments"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)?On(t,e):void 0}}(e,r)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}());return n[0]+": "+n[1]})).join("\r\n"),"\r\n"].join("\r\n");return vt()("msl:rtsp:outgoing")(n),En.from(n)}(t);r(void 0,{type:w.RAW,data:n})}else r(void 0,t)}});return n.call(this,e,r)}return o}(E);function oo(t){return(oo="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}var io=function(t,e){var r;if(void 0!==e){if("object"!==oo(e))throw new Error("merge expects override to be an object!");r=Object.keys(e).reduce((function(t,r){return void 0!==e[r]&&(t[r]=e[r]),t}),{})}return Object.assign({},t,r)},ao=Date.UTC(1900,0,1);function uo(t,e){return ao+1e3*(t+e/4294967296)}var so,co,fo=r(7866).Buffer;function lo(t){return(lo="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function po(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}function ho(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function yo(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&So(t,e)}function vo(t){var e=_o();return function(){var r,n=Eo(t);if(e){var o=Eo(this).constructor;r=Reflect.construct(n,arguments,o)}else r=n.apply(this,arguments);return bo(this,r)}}function bo(t,e){return!e||"object"!==lo(e)&&"function"!=typeof e?mo(t):e}function mo(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}function go(t){var e="function"==typeof Map?new Map:void 0;return(go=function(t){if(null===t||(r=t,-1===Function.toString.call(r).indexOf("[native code]")))return t;var r;if("function"!=typeof t)throw new TypeError("Super expression must either be null or a function");if(void 0!==e){if(e.has(t))return e.get(t);e.set(t,n)}function n(){return wo(t,arguments,Eo(this).constructor)}return n.prototype=Object.create(t.prototype,{constructor:{value:n,enumerable:!1,writable:!0,configurable:!0}}),So(n,t)})(t)}function wo(t,e,r){return(wo=_o()?Reflect.construct:function(t,e,r){var n=[null];n.push.apply(n,e);var o=new(Function.bind.apply(t,n));return r&&So(o,r.prototype),o}).apply(null,arguments)}function _o(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}function So(t,e){return(So=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}function Eo(t){return(Eo=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}function Oo(t,e,r){return e in t?Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[e]=r,t}!function(t){t.IDLE="idle",t.PLAYING="playing",t.PAUSED="paused"}(so||(so={})),function(t){t.OPTIONS="OPTIONS",t.DESCRIBE="DESCRIBE",t.SETUP="SETUP",t.PLAY="PLAY",t.PAUSE="PAUSE",t.TEARDOWN="TEARDOWN"}(co||(co={}));var xo=function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"undefined"==typeof window?"":window.location.hostname,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],r=e.length>0?"rtsp://".concat(t,"/axis-media/media.amp?").concat(e.join("&")):"rtsp://".concat(t,"/axis-media/media.amp");return{uri:r}},Ro=function(t){yo(r,t);var e=vo(r);function r(t,n){var o;return ho(this,r),Oo(mo(o=e.call(this,t)),"code",void 0),o.name="RTSPResponseError",o.code=n,o}return r}(go(Error)),To=function(t){yo(o,t);var e,r,n=vo(o);function o(){var t,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};ho(this,o);var r=io(xo(e.hostname,e.parameters),e),a=r.uri,u=r.headers,s=r.defaultHeaders,c=new i.Transform({objectMode:!0,transform:function(e,r,n){e.type===w.RTSP?(t._onRtsp(e),n()):e.type===w.RTCP?(t._onRtcp(e),t.onRtcp&&t.onRtcp(e.rtcp),n(void 0,e)):e.type===w.RTP?(t._onRtp(e),n(void 0,e)):e.type===w.SDP?(t._onSdp(e),t.onSdp&&t.onSdp(e.sdp),n(void 0,e)):n(void 0,e)}});return c.on("end",(function(){t._outgoingClosed=!0})),Oo(mo(t=n.call(this,c)),"uri",void 0),Oo(mo(t),"headers",void 0),Oo(mo(t),"defaultHeaders",void 0),Oo(mo(t),"t0",void 0),Oo(mo(t),"n0",void 0),Oo(mo(t),"clockrates",void 0),Oo(mo(t),"startTime",void 0),Oo(mo(t),"onRtcp",void 0),Oo(mo(t),"onSdp",void 0),Oo(mo(t),"onError",void 0),Oo(mo(t),"onPlay",void 0),Oo(mo(t),"retry",void 0),Oo(mo(t),"_outgoingClosed",void 0),Oo(mo(t),"_sequence",void 0),Oo(mo(t),"_callStack",void 0),Oo(mo(t),"_callHistory",void 0),Oo(mo(t),"_state",void 0),Oo(mo(t),"_waiting",void 0),Oo(mo(t),"_contentBase",void 0),Oo(mo(t),"_contentLocation",void 0),Oo(mo(t),"_sessionId",void 0),Oo(mo(t),"_sessionControlURL",void 0),Oo(mo(t),"_renewSessionInterval",void 0),t._outgoingClosed=!1,t._reset(),t.update(a,u,s),t._sessionControlURL=t._controlURL(),t}return e=o,(r=[{key:"update",value:function(t){var e,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(void 0===t)throw new Error("You must supply an uri when creating a RtspSessionComponent");this.uri=t,this.defaultHeaders=n,this.headers=Object.assign((Oo(e={},co.OPTIONS,{}),Oo(e,co.PLAY,{}),Oo(e,co.SETUP,{Blocksize:"64000"}),Oo(e,co.DESCRIBE,{Accept:"application/sdp"}),Oo(e,co.PAUSE,{}),e),r)}},{key:"_reset",value:function(){this._sequence=1,this.retry=function(){return console.error("No request sent, can't retry")},this._callStack=[],this._callHistory=[],this._state=so.IDLE,this._waiting=!1,this._contentBase=null,this._sessionId=null,null!==this._renewSessionInterval&&clearInterval(this._renewSessionInterval),this._renewSessionInterval=null,this.t0=void 0,this.n0=void 0,this.clockrates=void 0}},{key:"_controlURL",value:function(t){var e,r;if(void 0!==t&&/^[^:]+:\/\//.test(t))return t;var n=null!==(e=null!==(r=this._contentBase)&&void 0!==r?r:this._contentLocation)&&void 0!==e?e:this.uri;if(null==n)throw new Error("relative or missing control attribute but no base URL available");return void 0===t||"*"===t?n:new URL(t,n).href}},{key:"_onRtsp",value:function(t){var e=this;this._waiting=!1;var r=Wn(t.data),n=Gn(t.data),o=Fn(t.data);if(null===o)throw new Error("rtsp: expected sequence number");if(void 0===this._callHistory)throw new Error("rtsp: internal error");var i=this._callHistory[o-1];if(vt()("msl:rtsp:incoming")("".concat(t.data)),!this._sessionId&&!n){this._sessionId=qn(t.data);var a=Hn(t.data);null!==a&&(null!==this._renewSessionInterval&&clearInterval(this._renewSessionInterval),this._renewSessionInterval=setInterval((function(){e._enqueue({method:co.OPTIONS}),e._dequeue()}),1e3*Math.max(5,a-5)))}this._contentBase||(this._contentBase=zn(t.data)),this._contentLocation||(this._contentLocation=Vn(t.data)),r>=400&&this.onError&&this.onError(new Ro(t.data.toString("ascii"),r)),i===co.PLAY&&this.onPlay&&this.onPlay($n(t.data)),n&&(vt()("msl:rtsp:incoming")("RTSP Session ".concat(this._sessionId," ended with statusCode: ").concat(r)),this._sessionId=null),this._dequeue()}},{key:"_onRtcp",value:function(t){if(void 0===this.t0||void 0===this.n0)throw new Error("rtsp: internal error");if(Kr(t.rtcp)){var e=t.channel-1;this.t0[e]=t.rtcp.rtpTimestamp,this.n0[e]=uo(t.rtcp.ntpMost,t.rtcp.ntpLeast)}}},{key:"_onRtp",value:function(t){if(void 0===this.t0||void 0===this.n0||void 0===this.clockrates)throw new Error("rtsp: internal error");var e=t.channel,r=this.t0[e],n=this.n0[e];if(void 0!==r&&void 0!==n){var o=this.clockrates[e],i=L(t.data)-r|0;t.ntpTimestamp=i/o*1e3+n}}},{key:"_onSdp",value:function(t){var e=this;this.n0={},this.t0={},this.clockrates={},this._sessionControlURL=this._controlURL(t.sdp.session.control),t.sdp.media.forEach((function(t,r){if(void 0!==t.rtpmap){var n=t.rtpmap.clockrate,o=2*r,i=o+1,a=void 0===t.control?e._sessionControlURL:e._controlURL(t.control);e._enqueue({method:co.SETUP,headers:{Transport:"RTP/AVP/TCP;unicast;interleaved="+o+"-"+i},uri:a}),void 0!==e.clockrates&&(e.clockrates[o]=n)}})),this._state===so.PLAYING&&this._enqueue({method:co.PLAY,headers:{Range:"npt=".concat(this.startTime||0,"-")},uri:this._sessionControlURL}),this._dequeue()}},{key:"play",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;if(this._state===so.IDLE)this.startTime=Number(t)||0,this._enqueue({method:co.OPTIONS}),this._enqueue({method:co.DESCRIBE});else if(this._state===so.PAUSED){if(null===this._sessionId||void 0===this._sessionId)throw new Error("rtsp: internal error");this._enqueue({method:co.PLAY,headers:{Session:this._sessionId},uri:this._sessionControlURL})}this._state=so.PLAYING,this._dequeue()}},{key:"pause",value:function(){this._enqueue({method:co.PAUSE}),this._state=so.PAUSED,this._dequeue()}},{key:"stop",value:function(){this._sessionId?this._enqueue({method:co.TEARDOWN}):this._callStack=[],this._state=so.IDLE,null!==this._renewSessionInterval&&(clearInterval(this._renewSessionInterval),this._renewSessionInterval=null),this._dequeue()}},{key:"send",value:function(t){var e=t.method,r=t.headers,n=t.uri;if(void 0===e)throw new Error("missing method when send request");if(this._waiting=!0,this.retry=this.send.bind(this,t),void 0===this._sequence||void 0===this.headers||void 0===this._callHistory)throw new Error("rtsp: internal error");var o=Object.assign({type:w.RTSP,uri:n||this._sessionControlURL,data:fo.alloc(0)},{method:e,headers:r},{headers:Object.assign({CSeq:this._sequence++},this.defaultHeaders,this.headers[e],r)});this._sessionId&&(o.headers.Session=this._sessionId),this._callHistory.push(e),this._outgoingClosed?vt()("msl:rtsp:outgoing")("Unable to send ".concat(e,", connection closed")):this.outgoing.push(o)}},{key:"_enqueue",value:function(t){if(void 0===this._callStack)throw new Error("rtsp: internal error");this._callStack.push(t)}},{key:"_dequeue",value:function(){if(void 0===this._callStack)throw new Error("rtsp: internal error");if(!this._waiting&&this._callStack.length>0){var t=this._callStack.shift();void 0!==t&&this.send(t)}}}])&&po(e.prototype,r),o}(E);function ko(t,e,r,n,o,i,a){try{var u=t[i](a),s=u.value}catch(t){return void r(t)}u.done?e(s):Promise.resolve(s).then(n,o)}var Po=function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:window.location.host,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:window.location.protocol,r="https:"===e?"wss:":"ws:";return{uri:"".concat(r,"//").concat(t,"/rtsp-over-websocket"),tokenUri:"".concat(e,"//").concat(t,"/axis-cgi/rtspwssession.cgi"),protocol:"binary",timeout:10007}},jo=function(){var t,e=(t=regeneratorRuntime.mark((function t(){var e,r,n,o,i,a,u=arguments;return regeneratorRuntime.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:if(e=u.length>0&&void 0!==u[0]?u[0]:{},r=io(Po(e.host,e.scheme),e),n=r.uri,o=r.tokenUri,i=r.protocol,a=r.timeout,void 0!==n){t.next=4;break}throw new Error("ws: internal error");case 4:return t.next=6,new Promise((function(t,e){try{var r=new WebSocket(n,i),u=setTimeout((function(){clearTimeout(u),r.readyState===WebSocket.CONNECTING&&(r.onerror=null,e(new Error("websocket connection timed out")))}),a);r.binaryType="arraybuffer",r.onerror=function(r){clearTimeout(u);var a=new XMLHttpRequest;a.addEventListener("load",(function(){if(this.status>=400)return console.warn("failed to load token",this.status,this.responseText),void e(r);var o=this.responseText.trim(),a="".concat(n,"?rtspwssession=").concat(o),u=new WebSocket(a,i);u.binaryType="arraybuffer",u.onerror=function(t){e(t)},u.onopen=function(){return t(u)}})),a.addEventListener("error",(function(t){console.warn("failed to get token"),e(t)})),a.addEventListener("abort",(function(){return e(r)})),a.open("GET","".concat(o,"?").concat(Date.now()));try{a.send()}catch(t){e(r)}},r.onopen=function(){clearTimeout(u),t(r)}}catch(t){e(t)}}));case 6:return t.abrupt("return",t.sent);case 7:case"end":return t.stop()}}),t)})),function(){var e=this,r=arguments;return new Promise((function(n,o){var i=t.apply(e,r);function a(t){ko(i,n,o,a,u,"next",t)}function u(t){ko(i,n,o,a,u,"throw",t)}a(void 0)}))});return function(){return e.apply(this,arguments)}}(),Ao=r(7866).Buffer;function Co(t){return(Co="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function Io(t,e,r,n,o,i,a){try{var u=t[i](a),s=u.value}catch(t){return void r(t)}u.done?e(s):Promise.resolve(s).then(n,o)}function Lo(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}function Bo(t,e){return(Bo=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}function Mo(t,e){return!e||"object"!==Co(e)&&"function"!=typeof e?Uo(t):e}function Uo(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}function No(t){return(No=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}var Do=function(t){!function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&Bo(t,e)}(c,t);var e,r,n,o,a,u,s=(a=c,u=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}(),function(){var t,e=No(a);if(u){var r=No(this).constructor;t=Reflect.construct(e,arguments,r)}else t=e.apply(this,arguments);return Mo(this,t)});function c(t){var e;if(function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,c),void 0===t)throw new Error("socket argument missing");var r=new i.Readable({objectMode:!0,read:function(){}});t.onmessage=function(e){var n=Ao.from(e.data);r.push({data:n,type:w.RAW})||t.readyState===WebSocket.OPEN&&(vt()("msl:websocket:incoming")("downstream frozen"),t.close())},r.on("error",(function(e){console.warn("closing socket due to incoming error",e),t.close()}));var n,o,a,u=new i.Writable({objectMode:!0,write:function(e,r,n){try{t.send(e.data)}catch(t){console.warn("message lost during send:",e)}n()}});return u.on("error",(function(t){console.warn("error during websocket send, ignoring:",t)})),u.on("finish",(function(){vt()("msl:websocket:outgoing")("finish"),t.readyState!==WebSocket.CLOSED&&t.close()})),t.onclose=function(t){vt()("msl:websocket:close")("".concat(t.code)),1001===t.code&&e.onServerClose&&e.onServerClose(),r.push(null),u.end()},a=void 0,(o="onServerClose")in(n=Uo(e=s.call(this,r,u)))?Object.defineProperty(n,o,{value:a,enumerable:!0,configurable:!0,writable:!0}):n[o]=a,e}return e=c,null,(r=[{key:"open",value:(n=regeneratorRuntime.mark((function t(e){return regeneratorRuntime.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:return t.next=2,jo(e).then((function(t){return new c(t)}));case 2:return t.abrupt("return",t.sent);case 3:case"end":return t.stop()}}),t)})),o=function(){var t=this,e=arguments;return new Promise((function(r,o){var i=n.apply(t,e);function a(t){Io(i,r,o,a,u,"next",t)}function u(t){Io(i,r,o,a,u,"throw",t)}a(void 0)}))},function(t){return o.apply(this,arguments)})}])&&Lo(e,r),c}(S);function Fo(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function qo(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}function Ho(t,e,r){return e in t?Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[e]=r,t}r(461);var Wo=function(){function t(){Fo(this,t),Ho(this,"firstComponent",void 0),Ho(this,"lastComponent",void 0),Ho(this,"_set",void 0);for(var e=arguments.length,r=new Array(e),n=0;n<e;n++)r[n]=arguments[n];var o=r[0],i=r.slice(1);this._set=new Set(r),this.firstComponent=o,this.lastComponent=i.reduce((function(t,e){return t.connect(e)}),o)}var e,r;return e=t,(r=[{key:"init",value:function(){for(var t=arguments.length,e=new Array(t),r=0;r<t;r++)e[r]=arguments[r];var n=e[0],o=e.slice(1);this._set=new Set(e),this.firstComponent=n,this.lastComponent=o.reduce((function(t,e){return t.connect(e)}),n)}},{key:"insertAfter",value:function(t,e){if(!this._set.has(t))throw new Error("insertion point not part of pipeline");if(this._set.has(e))throw new Error("new component already in the pipeline");var r=t.next;return null===r?(t.connect(e),this.lastComponent=e):(t.disconnect(),t.connect(e).connect(r)),this._set.add(e),this}},{key:"insertBefore",value:function(t,e){if(!this._set.has(t))throw new Error("insertion point not part of pipeline");if(this._set.has(e))throw new Error("new component already in the pipeline");var r=t.prev;return null===r?(e.connect(t),this.firstComponent=e):(r.disconnect(),r.connect(e).connect(t)),this._set.add(e),this}},{key:"remove",value:function(t){if(!this._set.has(t))throw new Error("component not part of pipeline");var e=t.prev,r=t.next;if(null===e&&null===r)throw new Error("cannot remove last component");return null===e&&null!==r?(t.disconnect(),this.firstComponent=r):null!==e&&null===r?(e.disconnect(),this.lastComponent=e):null!==e&&null!==r&&(e.disconnect(),t.disconnect(),e.connect(r)),this._set.delete(t),this}},{key:"append",value:function(){for(var t=this,e=arguments.length,r=new Array(e),n=0;n<e;n++)r[n]=arguments[n];return r.forEach((function(e){t.insertAfter(t.lastComponent,e)})),this}},{key:"prepend",value:function(){for(var t=this,e=arguments.length,r=new Array(e),n=0;n<e;n++)r[n]=arguments[n];return r.forEach((function(e){t.insertBefore(t.firstComponent,e)})),this}}])&&qo(e.prototype,r),t}();function zo(t){return(zo="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function Vo(t,e){return(Vo=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}function Go(t,e){return!e||"object"!==zo(e)&&"function"!=typeof e?$o(t):e}function $o(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}function Yo(t){return(Yo=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}function Jo(t,e,r){return e in t?Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[e]=r,t}var Ko=function(t){!function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&Vo(t,e)}(o,t);var e,r,n=(e=o,r=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}(),function(){var t,n=Yo(e);if(r){var o=Yo(this).constructor;t=Reflect.construct(n,arguments,o)}else t=n.apply(this,arguments);return Go(this,t)});function o(t){var e;!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,o);var r=new no,i=new To(t);return i.onSdp=function(t){e.onSdp&&e.onSdp(t)},i.onPlay=function(t){e.onPlay&&e.onPlay(t)},Jo($o(e=n.call(this,r,i)),"onSdp",void 0),Jo($o(e),"onPlay",void 0),Jo($o(e),"rtsp",void 0),e.rtsp=i,e}return o}(Wo);function Xo(t){return(Xo="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function Zo(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}function Qo(t,e){return(Qo=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}function ti(t,e){return!e||"object"!==Xo(e)&&"function"!=typeof e?ei(t):e}function ei(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}function ri(t){return(ri=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}function ni(t,e,r){return e in t?Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[e]=r,t}var oi=function(t){!function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&Qo(t,e)}(a,t);var e,r,n,o,i=(n=a,o=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}(),function(){var t,e=ri(n);if(o){var r=ri(this).constructor;t=Reflect.construct(e,arguments,r)}else t=e.apply(this,arguments);return ti(this,t)});function a(t){var e;!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,a),ni(ei(e=i.call(this,t)),"onSync",void 0),ni(ei(e),"_mp4Muxer",void 0);var r=new Pt,n=new G,o=new Fr;return o.onSync=function(t){e.onSync&&e.onSync(t)},e.append(r,n,o),e._mp4Muxer=o,e}return e=a,(r=[{key:"bitrate",get:function(){return this._mp4Muxer.bitrate}},{key:"framerate",get:function(){return this._mp4Muxer.framerate}}])&&Zo(e.prototype,r),a}(Ko);function ii(t){return(ii="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function ai(t,e){return(ai=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}function ui(t,e){return!e||"object"!==ii(e)&&"function"!=typeof e?function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t):e}function si(t){return(si=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}var ci=function(t){!function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&ai(t,e)}(o,t);var e,r,n=(e=o,r=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}(),function(){var t,n=si(e);if(r){var o=si(this).constructor;t=Reflect.construct(n,arguments,o)}else t=n.apply(this,arguments);return ui(this,t)});function o(t){var e;!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,o),e=n.call(this,t);var r=new Oe;return e.append(r),e}return o}(Ko),fi=r(2993);function li(t,e,r){return e in t?Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[e]=r,t}var pi=function t(e,r,n){var o=this;!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,t),li(this,"realm",void 0),li(this,"nonce",void 0),li(this,"opaque",void 0),li(this,"algorithm",void 0),li(this,"qop",void 0),li(this,"username",void 0),li(this,"ha1Base",void 0),li(this,"count",void 0),li(this,"nc",(function(){return++o.count,o.count.toString(16).padStart(8,"0")})),li(this,"cnonce",(function(){return new Array(4).fill(0).map((function(){return Math.floor(256*Math.random())})).map((function(t){return t.toString(16)})).join("")})),li(this,"ha1",(function(t){var e=o.ha1Base;return"md5-sess"===o.algorithm&&(e=(new fi.V).appendStr("".concat(e,":").concat(o.nonce,":").concat(t)).end().toString()),e})),li(this,"ha2",(function(t,e){var r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"",n=(new fi.V).appendStr("".concat(t,":").concat(e)).end().toString();if("md5-sess"===o.algorithm){var i=(new fi.V).appendStr(r).end().toString();n=(new fi.V).appendStr("".concat(t,":").concat(e,":").concat(i)).end().toString()}return n})),li(this,"authorization",(function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"GET",e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"",r=arguments.length>2?arguments[2]:void 0,n=o.nc(),i=o.cnonce(),a=o.ha1(i),u=o.ha2(t,e,r),s=void 0===o.qop?(new fi.V).appendStr("".concat(a,":").concat(o.nonce,":").concat(u)).end().toString():(new fi.V).appendStr("".concat(a,":").concat(o.nonce,":").concat(n,":").concat(i,":").concat(o.qop,":").concat(u)).end().toString(),c=[];return c.push('username="'.concat(o.username,'"')),c.push('realm="'.concat(o.realm,'"')),c.push('nonce="'.concat(o.nonce,'"')),c.push('uri="'.concat(e,'"')),void 0!==o.qop&&(c.push("qop=".concat(o.qop)),c.push("nc=".concat(n)),c.push('cnonce="'.concat(i,'"'))),c.push('response="'.concat(s,'"')),void 0!==o.opaque&&c.push('opaque="'.concat(o.opaque,'"')),"Digest ".concat(c.join(", "))}));var i=e.get("realm");if(void 0===i)throw new Error("no realm in digest challenge");this.realm=i,this.ha1Base=(new fi.V).appendStr("".concat(r,":").concat(i,":").concat(n)).end().toString();var a=e.get("nonce");if(void 0===a)throw new Error("no nonce in digest challenge");this.nonce=a,this.opaque=e.get("opaque");var u=e.get("algorithm");void 0!==u?"md5"===u?this.algorithm="md5":"md5-sess"===u&&(this.algorithm="md5-sess"):this.algorithm="md5";var s=e.get("qop");if(void 0!==s){var c=s.split(",").map((function(t){return t.trim()}));c.some((function(t){return"auth"===t}))?this.qop="auth":c.some((function(t){return"auth-int"===t}))&&(this.qop="auth-int")}this.count=0,this.username=r};function hi(t,e){return bi(t)||function(t,e){var r=null==t?null:"undefined"!=typeof Symbol&&t[Symbol.iterator]||t["@@iterator"];if(null!=r){var n,o,i=[],a=!0,u=!1;try{for(r=r.call(t);!(a=(n=r.next()).done)&&(i.push(n.value),!e||i.length!==e);a=!0);}catch(t){u=!0,o=t}finally{try{a||null==r.return||r.return()}finally{if(u)throw o}}return i}}(t,e)||yi(t,e)||di()}function di(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}function yi(t,e){if(t){if("string"==typeof t)return vi(t,e);var r=Object.prototype.toString.call(t).slice(8,-1);return"Object"===r&&t.constructor&&(r=t.constructor.name),"Map"===r||"Set"===r?Array.from(t):"Arguments"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)?vi(t,e):void 0}}function vi(t,e){(null==e||e>t.length)&&(e=t.length);for(var r=0,n=new Array(e);r<e;r++)n[r]=t[r];return n}function bi(t){if(Array.isArray(t))return t}var mi=function(t){var e,r,n=bi(r=t.split(" "))||function(t){if("undefined"!=typeof Symbol&&null!=t[Symbol.iterator]||null!=t["@@iterator"])return Array.from(t)}(r)||yi(r)||di(),o=n[1],i=n.slice(2),a=[],u=/\s*([^=]+)="([^"]*)",?/gm;do{if(null!==(e=u.exec(i.join(" ")))){var s=hi(e,3),c=s[1],f=s[2];a.push([c,f])}}while(null!==e);var l=new Map(a);return{type:o.toLowerCase(),params:l}},gi=r(7866).Buffer;function wi(t){return(wi="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function _i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function Si(t,e){return(Si=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}function Ei(t,e){return!e||"object"!==wi(e)&&"function"!=typeof e?function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t):e}function Oi(t){return(Oi=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}var xi={username:"root",password:"pass"},Ri=function(t){!function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&Si(t,e)}(o,t);var e,r,n=(e=o,r=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}(),function(){var t,n=Oi(e);if(r){var o=Oi(this).constructor;t=Reflect.construct(n,arguments,o)}else t=n.apply(this,arguments);return Ei(this,t)});function o(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};_i(this,o);var e,r,i=io(xi,t),a=i.username,u=i.password;if(void 0===a||void 0===u)throw new Error("need username and password");var s=F((function(t,n,o){t.type===w.RTSP&&(e=t,r&&t.headers&&(t.headers.Authorization=r)),o(void 0,t)})),c=F((function(t,n,o){if(t.type===w.RTSP&&401===Wn(t.data)){var i=t.data.toString().split("\n").find((function(t){return/WWW-Auth/i.test(t)}));if(void 0===i)throw new Error("cannot find WWW-Authenticate header");var c=mi(i);if("basic"===c.type)r="Basic "+gi.from(a+":"+u).toString("base64");else{if("digest"!==c.type)return;var f=new pi(c.params,a,u);r=f.authorization(e.method,e.uri)}s.write(e,(function(){return o()}))}else o(void 0,t)}));return n.call(this,c,s)}return o}(E);function Ti(t){return(Ti="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function ki(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}function Pi(t,e){return(Pi=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}function ji(t,e){return!e||"object"!==Ti(e)&&"function"!=typeof e?Ai(t):e}function Ai(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}function Ci(t){return(Ci=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}function Ii(t,e,r){return e in t?Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[e]=r,t}var Li=function(t){!function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&Pi(t,e)}(a,t);var e,r,n,o,i=(n=a,o=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}(),function(){var t,e=Ci(n);if(o){var r=Ci(this).constructor;t=Reflect.construct(e,arguments,r)}else t=e.apply(this,arguments);return ji(this,t)});function a(t){var e;!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,a);var r=t.ws,n=t.rtsp,o=t.mediaElement,u=t.auth;if(Ii(Ai(e=i.call(this,n)),"onCanplay",void 0),Ii(Ai(e),"onSync",void 0),Ii(Ai(e),"onServerClose",void 0),Ii(Ai(e),"ready",void 0),Ii(Ai(e),"_src",void 0),Ii(Ai(e),"_sink",void 0),u){var s=new Ri(u);e.insertBefore(e.rtsp,s)}var c=new dt(o);c.onCanplay=function(){c.play(),e.onCanplay&&e.onCanplay()},c.onSync=function(t){e.onSync&&e.onSync(t)},e.append(c),e._sink=c;var f=Do.open(r);return e.ready=f.then((function(t){t.onServerClose=function(){e.onServerClose&&e.onServerClose()},e.prepend(t),e._src=t})),e}return e=a,(r=[{key:"close",value:function(){this._src&&this._src.outgoing.end()}},{key:"currentTime",get:function(){return this._sink.currentTime}},{key:"play",value:function(){return this._sink.play()}},{key:"pause",value:function(){return this._sink.pause()}},{key:"bitrate",get:function(){return this._sink.bitrate}},{key:"framerate",get:function(){return this._sink.framerate}}])&&ki(e.prototype,r),a}(ci);function Bi(t){return(Bi="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function Mi(t,e,r,n,o,i,a){try{var u=t[i](a),s=u.value}catch(t){return void r(t)}u.done?e(s):Promise.resolve(s).then(n,o)}function Ui(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}function Ni(t,e){return(Ni=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}function Di(t,e){return!e||"object"!==Bi(e)&&"function"!=typeof e?Fi(t):e}function Fi(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}function qi(t){return(qi=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}function Hi(t,e,r){return e in t?Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[e]=r,t}var Wi=function(t){!function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&Ni(t,e)}(s,t);var e,r,n,o,i,a,u=(i=s,a=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}(),function(){var t,e=qi(i);if(a){var r=qi(this).constructor;t=Reflect.construct(e,arguments,r)}else t=e.apply(this,arguments);return Di(this,t)});function s(t){var e;!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,s);var r=t.ws,n=t.rtsp,o=t.mediaElement,i=t.auth;if(Hi(Fi(e=u.call(this,n)),"onSourceOpen",void 0),Hi(Fi(e),"onServerClose",void 0),Hi(Fi(e),"ready",void 0),Hi(Fi(e),"tracks",void 0),Hi(Fi(e),"_src",void 0),Hi(Fi(e),"_sink",void 0),i){var a=new Ri(i);e.insertBefore(e.rtsp,a)}var c=new yn(o);c.onSourceOpen=function(t,r){e.tracks=r,e.onSourceOpen&&e.onSourceOpen(t,r)},e.append(c),e._sink=c;var f=Do.open(r);return e.ready=f.then((function(t){t.onServerClose=function(){e.onServerClose&&e.onServerClose()},e.prepend(t),e._src=t})),e}return e=s,(r=[{key:"close",value:function(){this._src&&this._src.outgoing.end()}},{key:"currentTime",get:function(){return this._sink.currentTime}},{key:"play",value:(n=regeneratorRuntime.mark((function t(){return regeneratorRuntime.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:return t.next=2,this._sink.play();case 2:return t.abrupt("return",t.sent);case 3:case"end":return t.stop()}}),t,this)})),o=function(){var t=this,e=arguments;return new Promise((function(r,o){var i=n.apply(t,e);function a(t){Mi(i,r,o,a,u,"next",t)}function u(t){Mi(i,r,o,a,u,"throw",t)}a(void 0)}))},function(){return o.apply(this,arguments)})},{key:"pause",value:function(){return this._sink.pause()}}])&&Ui(e.prototype,r),s}(oi);function zi(t){return(zi="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function Vi(t,e){return(Vi=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}function Gi(t,e){return!e||"object"!==zi(e)&&"function"!=typeof e?function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t):e}function $i(t){return($i=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}var Yi=function(t){!function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&Vi(t,e)}(o,t);var e,r,n=(e=o,r=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}(),function(){var t,n=$i(e);if(r){var o=$i(this).constructor;t=Reflect.construct(n,arguments,o)}else t=n.apply(this,arguments);return Gi(this,t)});function o(t){var e;!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,o);var r=t.metadataHandler;e=n.call(this,t);var i=new Sn;e.insertAfter(e.rtsp,i);var a=E.fromHandlers((function(t){t.type===w.XML&&r(t)}),void 0);return e.insertAfter(i,a),e}return o}(Wi);function Ji(t){return(Ji="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function Ki(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}function Xi(t,e){return(Xi=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}function Zi(t,e){return!e||"object"!==Ji(e)&&"function"!=typeof e?Qi(t):e}function Qi(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}function ta(t){return(ta=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}function ea(t,e,r){return e in t?Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[e]=r,t}var ra={parameters:["audio=0","video=0","event=on","ptz=all"]},na=function(t){!function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&Xi(t,e)}(a,t);var e,r,n,o,i=(n=a,o=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}(),function(){var t,e=ta(n);if(o){var r=ta(this).constructor;t=Reflect.construct(e,arguments,r)}else t=e.apply(this,arguments);return Zi(this,t)});function a(t){var e;!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,a);var r=t.ws,n=t.rtsp,o=t.metadataHandler;ea(Qi(e=i.call(this,Object.assign({},ra,n))),"onServerClose",void 0),ea(Qi(e),"ready",void 0),ea(Qi(e),"_src",void 0);var u=new Sn;e.append(u);var s=O.fromHandler((function(t){t.type===w.XML&&o(t)}));e.append(s);var c=Do.open(r);return e.ready=c.then((function(t){t.onServerClose=function(){e.onServerClose&&e.onServerClose()},e.prepend(t),e._src=t})),e}return e=a,(r=[{key:"close",value:function(){this._src&&this._src.outgoing.end()}}])&&Ki(e.prototype,r),a}(Ko);function oa(t){return(oa="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function ia(t,e,r,n,o,i,a){try{var u=t[i](a),s=u.value}catch(t){return void r(t)}u.done?e(s):Promise.resolve(s).then(n,o)}function aa(t){return function(){var e=this,r=arguments;return new Promise((function(n,o){var i=t.apply(e,r);function a(t){ia(i,n,o,a,u,"next",t)}function u(t){ia(i,n,o,a,u,"throw",t)}a(void 0)}))}}function ua(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}function sa(t,e){return(sa=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}function ca(t,e){return!e||"object"!==oa(e)&&"function"!=typeof e?fa(t):e}function fa(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}function la(t){return(la=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}function pa(t,e,r){return e in t?Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[e]=r,t}var ha=function(t){!function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&sa(t,e)}(a,t);var e,r,n,o,i=(n=a,o=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}(),function(){var t,e=la(n);if(o){var r=la(this).constructor;t=Reflect.construct(e,arguments,r)}else t=e.apply(this,arguments);return ca(this,t)});function a(t){var e;!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,a);var r=t.ws,n=t.rtsp,o=t.auth;if(pa(fa(e=i.call(this,n)),"onServerClose",void 0),pa(fa(e),"ready",void 0),pa(fa(e),"_src",void 0),o){var u=new Ri(o);e.insertBefore(e.rtsp,u)}var s=Do.open(r);return e.ready=s.then((function(t){t.onServerClose=function(){e.onServerClose&&e.onServerClose()},e.prepend(t),e._src=t})),e}return e=a,(r=[{key:"close",value:function(){this._src&&this._src.outgoing.end()}},{key:"sdp",get:function(){var t=this;return this.ready.then(aa(regeneratorRuntime.mark((function e(){var r;return regeneratorRuntime.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return r=new Promise((function(e){t.rtsp.onSdp=e})),t.rtsp.send({method:co.DESCRIBE}),t.rtsp.send({method:co.TEARDOWN}),e.abrupt("return",r);case 4:case"end":return e.stop()}}),e)}))))}}])&&ua(e.prototype,r),a}(Ko),da=r(7866).Buffer;function ya(t){return(ya="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function va(t,e){var r=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),r.push.apply(r,n)}return r}function ba(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}function ma(t,e){return(ma=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}function ga(t,e){return!e||"object"!==ya(e)&&"function"!=typeof e?wa(t):e}function wa(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}function _a(t){return(_a=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}function Sa(t,e,r){return e in t?Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[e]=r,t}var Ea=vt()("msl:http-mp4"),Oa=function(t){!function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&ma(t,e)}(u,t);var e,r,n,o,a=(n=u,o=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}(),function(){var t,e=_a(n);if(o){var r=_a(this).constructor;t=Reflect.construct(e,arguments,r)}else t=e.apply(this,arguments);return ga(this,t)});function u(t){var e;!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,u);var r=t.uri,n=t.options,o=new i.Readable({objectMode:!0,read:function(){}});return o.on("error",(function(t){console.warn("closing socket due to incoming error",t),e._reader&&e._reader.cancel()})),Sa(wa(e=a.call(this,o)),"uri",void 0),Sa(wa(e),"options",void 0),Sa(wa(e),"length",void 0),Sa(wa(e),"onHeaders",void 0),Sa(wa(e),"onServerClose",void 0),Sa(wa(e),"_reader",void 0),Sa(wa(e),"_abortController",void 0),Sa(wa(e),"_allDone",void 0),o._read=function(){e._pull()},e.uri=r,e.options=n,e._allDone=!1,e}return e=u,(r=[{key:"play",value:function(){var t=this;if(void 0===this.uri)throw new Error("cannot start playing when there is no URI");this._abortController=new AbortController,this.length=0,fetch(this.uri,function(t){for(var e=1;e<arguments.length;e++){var r=null!=arguments[e]?arguments[e]:{};e%2?va(Object(r),!0).forEach((function(e){Sa(t,e,r[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(r)):va(Object(r)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(r,e))}))}return t}({credentials:"include",signal:this._abortController.signal},this.options)).then((function(e){if(null===e.body)throw new Error("empty response body");var r=e.headers.get("Content-Type");t.incoming.push({data:da.alloc(0),type:w.ISOM,mime:r}),t.onHeaders&&t.onHeaders(e.headers),t._reader=e.body.getReader(),t._pull()})).catch((function(t){console.error("http-source: fetch failed: ",t)}))}},{key:"abort",value:function(){this._reader&&this._reader.cancel().catch((function(t){console.log("http-source: cancel reader failed: ",t)})),this._abortController&&this._abortController.abort()}},{key:"_isClosed",value:function(){return this._allDone}},{key:"_close",value:function(){var t;this._reader=void 0,this._allDone=!0,this.incoming.push(null),null===(t=this.onServerClose)||void 0===t||t.call(this)}},{key:"_pull",value:function(){var t=this;void 0!==this._reader&&this._reader.read().then((function(e){var r=e.done,n=e.value;if(r)t._isClosed()||(Ea("fetch completed, total downloaded: ",t.length," bytes"),t._close());else{if(void 0===n)throw new Error("expected value to be defined");if(void 0===t.length)throw new Error("expected length to be defined");t.length+=n.length;var o=da.from(n);t.incoming.push({data:o,type:w.ISOM})?t._pull():Ea("downstream back pressure: pausing read")}})).catch((function(e){Ea("http-source: read failed: ",e),t._isClosed()||t._close()}))}}])&&ba(e.prototype,r),u}(S);function xa(t){return(xa="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function Ra(t,e,r,n,o,i,a){try{var u=t[i](a),s=u.value}catch(t){return void r(t)}u.done?e(s):Promise.resolve(s).then(n,o)}function Ta(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}function ka(t,e){return(ka=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}function Pa(t,e){return!e||"object"!==xa(e)&&"function"!=typeof e?ja(t):e}function ja(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}function Aa(t){return(Aa=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}function Ca(t,e,r){return e in t?Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[e]=r,t}var Ia=function(t){!function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&ka(t,e)}(s,t);var e,r,n,o,i,a,u=(i=s,a=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}(),function(){var t,e=Aa(i);if(a){var r=Aa(this).constructor;t=Reflect.construct(e,arguments,r)}else t=e.apply(this,arguments);return Pa(this,t)});function s(t){var e;!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,s);var r=t.http,n=t.mediaElement,o=new Oa(r),i=new yn(n);return o.onHeaders=function(t){e.onHeaders&&e.onHeaders(t)},o.onServerClose=function(){var t,r;return null===(t=(r=e).onServerClose)||void 0===t?void 0:t.call(r)},Ca(ja(e=u.call(this,o,i)),"onHeaders",void 0),Ca(ja(e),"onServerClose",void 0),Ca(ja(e),"http",void 0),Ca(ja(e),"_src",void 0),Ca(ja(e),"_sink",void 0),e._src=o,e._sink=i,e.http=o,e}return e=s,(r=[{key:"close",value:function(){this._src&&this._src.abort()}},{key:"currentTime",get:function(){return this._sink.currentTime}},{key:"play",value:(n=regeneratorRuntime.mark((function t(){return regeneratorRuntime.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:return t.next=2,this._sink.play();case 2:return t.abrupt("return",t.sent);case 3:case"end":return t.stop()}}),t,this)})),o=function(){var t=this,e=arguments;return new Promise((function(r,o){var i=n.apply(t,e);function a(t){Ra(i,r,o,a,u,"next",t)}function u(t){Ra(i,r,o,a,u,"throw",t)}a(void 0)}))},function(){return o.apply(this,arguments)})},{key:"pause",value:function(){return this._sink.pause()}}])&&Ta(e.prototype,r),s}(Wo),La=(r(6837),function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{maxRetries:20,errors:[503]},r=e.maxRetries,n=e.errors,o=0,i=t.onError;t.onError=function(e){null==i||i(e),n.includes(e.code)&&((o+=1)>r?console.log("retry, too many",o,r):setTimeout((function(){var e;return null===(e=t.retry)||void 0===e?void 0:e.call(t)}),100*o))}})})(),n})()}));
\ No newline at end of file
+(function webpackUniversalModuleDefinition(root, factory) {
+	if(typeof exports === 'object' && typeof module === 'object')
+		module.exports = factory();
+	else if(typeof define === 'function' && define.amd)
+		define([], factory);
+	else if(typeof exports === 'object')
+		exports["mediaStreamLibrary"] = factory();
+	else
+		root["mediaStreamLibrary"] = factory();
+})(self, function() {
+return /******/ (() => { // webpackBootstrap
+/******/ 	var __webpack_modules__ = ({
+
+/***/ 7997:
+/***/ ((module, exports, __webpack_require__) => {
+
+/* provided dependency */ var process = __webpack_require__(2695);
+/* eslint-env browser */
+
+/**
+ * This is the web browser implementation of `debug()`.
+ */
+
+exports.formatArgs = formatArgs;
+exports.save = save;
+exports.load = load;
+exports.useColors = useColors;
+exports.storage = localstorage();
+exports.destroy = (() => {
+	let warned = false;
+
+	return () => {
+		if (!warned) {
+			warned = true;
+			console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
+		}
+	};
+})();
+
+/**
+ * Colors.
+ */
+
+exports.colors = [
+	'#0000CC',
+	'#0000FF',
+	'#0033CC',
+	'#0033FF',
+	'#0066CC',
+	'#0066FF',
+	'#0099CC',
+	'#0099FF',
+	'#00CC00',
+	'#00CC33',
+	'#00CC66',
+	'#00CC99',
+	'#00CCCC',
+	'#00CCFF',
+	'#3300CC',
+	'#3300FF',
+	'#3333CC',
+	'#3333FF',
+	'#3366CC',
+	'#3366FF',
+	'#3399CC',
+	'#3399FF',
+	'#33CC00',
+	'#33CC33',
+	'#33CC66',
+	'#33CC99',
+	'#33CCCC',
+	'#33CCFF',
+	'#6600CC',
+	'#6600FF',
+	'#6633CC',
+	'#6633FF',
+	'#66CC00',
+	'#66CC33',
+	'#9900CC',
+	'#9900FF',
+	'#9933CC',
+	'#9933FF',
+	'#99CC00',
+	'#99CC33',
+	'#CC0000',
+	'#CC0033',
+	'#CC0066',
+	'#CC0099',
+	'#CC00CC',
+	'#CC00FF',
+	'#CC3300',
+	'#CC3333',
+	'#CC3366',
+	'#CC3399',
+	'#CC33CC',
+	'#CC33FF',
+	'#CC6600',
+	'#CC6633',
+	'#CC9900',
+	'#CC9933',
+	'#CCCC00',
+	'#CCCC33',
+	'#FF0000',
+	'#FF0033',
+	'#FF0066',
+	'#FF0099',
+	'#FF00CC',
+	'#FF00FF',
+	'#FF3300',
+	'#FF3333',
+	'#FF3366',
+	'#FF3399',
+	'#FF33CC',
+	'#FF33FF',
+	'#FF6600',
+	'#FF6633',
+	'#FF9900',
+	'#FF9933',
+	'#FFCC00',
+	'#FFCC33'
+];
+
+/**
+ * Currently only WebKit-based Web Inspectors, Firefox >= v31,
+ * and the Firebug extension (any Firefox version) are known
+ * to support "%c" CSS customizations.
+ *
+ * TODO: add a `localStorage` variable to explicitly enable/disable colors
+ */
+
+// eslint-disable-next-line complexity
+function useColors() {
+	// NB: In an Electron preload script, document will be defined but not fully
+	// initialized. Since we know we're in Chrome, we'll just detect this case
+	// explicitly
+	if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
+		return true;
+	}
+
+	// Internet Explorer and Edge do not support colors.
+	if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
+		return false;
+	}
+
+	// Is webkit? http://stackoverflow.com/a/16459606/376773
+	// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
+	return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
+		// Is firebug? http://stackoverflow.com/a/398120/376773
+		(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
+		// Is firefox >= v31?
+		// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
+		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
+		// Double check webkit in userAgent just in case we are in a worker
+		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
+}
+
+/**
+ * Colorize log arguments if enabled.
+ *
+ * @api public
+ */
+
+function formatArgs(args) {
+	args[0] = (this.useColors ? '%c' : '') +
+		this.namespace +
+		(this.useColors ? ' %c' : ' ') +
+		args[0] +
+		(this.useColors ? '%c ' : ' ') +
+		'+' + module.exports.humanize(this.diff);
+
+	if (!this.useColors) {
+		return;
+	}
+
+	const c = 'color: ' + this.color;
+	args.splice(1, 0, c, 'color: inherit');
+
+	// The final "%c" is somewhat tricky, because there could be other
+	// arguments passed either before or after the %c, so we need to
+	// figure out the correct index to insert the CSS into
+	let index = 0;
+	let lastC = 0;
+	args[0].replace(/%[a-zA-Z%]/g, match => {
+		if (match === '%%') {
+			return;
+		}
+		index++;
+		if (match === '%c') {
+			// We only are interested in the *last* %c
+			// (the user may have provided their own)
+			lastC = index;
+		}
+	});
+
+	args.splice(lastC, 0, c);
+}
+
+/**
+ * Invokes `console.debug()` when available.
+ * No-op when `console.debug` is not a "function".
+ * If `console.debug` is not available, falls back
+ * to `console.log`.
+ *
+ * @api public
+ */
+exports.log = console.debug || console.log || (() => {});
+
+/**
+ * Save `namespaces`.
+ *
+ * @param {String} namespaces
+ * @api private
+ */
+function save(namespaces) {
+	try {
+		if (namespaces) {
+			exports.storage.setItem('debug', namespaces);
+		} else {
+			exports.storage.removeItem('debug');
+		}
+	} catch (error) {
+		// Swallow
+		// XXX (@Qix-) should we be logging these?
+	}
+}
+
+/**
+ * Load `namespaces`.
+ *
+ * @return {String} returns the previously persisted debug modes
+ * @api private
+ */
+function load() {
+	let r;
+	try {
+		r = exports.storage.getItem('debug');
+	} catch (error) {
+		// Swallow
+		// XXX (@Qix-) should we be logging these?
+	}
+
+	// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
+	if (!r && typeof process !== 'undefined' && 'env' in process) {
+		r = process.env.DEBUG;
+	}
+
+	return r;
+}
+
+/**
+ * Localstorage attempts to return the localstorage.
+ *
+ * This is necessary because safari throws
+ * when a user disables cookies/localstorage
+ * and you attempt to access it.
+ *
+ * @return {LocalStorage}
+ * @api private
+ */
+
+function localstorage() {
+	try {
+		// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
+		// The Browser also has localStorage in the global context.
+		return localStorage;
+	} catch (error) {
+		// Swallow
+		// XXX (@Qix-) should we be logging these?
+	}
+}
+
+module.exports = __webpack_require__(4069)(exports);
+
+const {formatters} = module.exports;
+
+/**
+ * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
+ */
+
+formatters.j = function (v) {
+	try {
+		return JSON.stringify(v);
+	} catch (error) {
+		return '[UnexpectedJSONParseError]: ' + error.message;
+	}
+};
+
+
+/***/ }),
+
+/***/ 4069:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+
+/**
+ * This is the common logic for both the Node.js and web browser
+ * implementations of `debug()`.
+ */
+
+function setup(env) {
+	createDebug.debug = createDebug;
+	createDebug.default = createDebug;
+	createDebug.coerce = coerce;
+	createDebug.disable = disable;
+	createDebug.enable = enable;
+	createDebug.enabled = enabled;
+	createDebug.humanize = __webpack_require__(6117);
+	createDebug.destroy = destroy;
+
+	Object.keys(env).forEach(key => {
+		createDebug[key] = env[key];
+	});
+
+	/**
+	* The currently active debug mode names, and names to skip.
+	*/
+
+	createDebug.names = [];
+	createDebug.skips = [];
+
+	/**
+	* Map of special "%n" handling functions, for the debug "format" argument.
+	*
+	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
+	*/
+	createDebug.formatters = {};
+
+	/**
+	* Selects a color for a debug namespace
+	* @param {String} namespace The namespace string for the for the debug instance to be colored
+	* @return {Number|String} An ANSI color code for the given namespace
+	* @api private
+	*/
+	function selectColor(namespace) {
+		let hash = 0;
+
+		for (let i = 0; i < namespace.length; i++) {
+			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
+			hash |= 0; // Convert to 32bit integer
+		}
+
+		return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
+	}
+	createDebug.selectColor = selectColor;
+
+	/**
+	* Create a debugger with the given `namespace`.
+	*
+	* @param {String} namespace
+	* @return {Function}
+	* @api public
+	*/
+	function createDebug(namespace) {
+		let prevTime;
+		let enableOverride = null;
+		let namespacesCache;
+		let enabledCache;
+
+		function debug(...args) {
+			// Disabled?
+			if (!debug.enabled) {
+				return;
+			}
+
+			const self = debug;
+
+			// Set `diff` timestamp
+			const curr = Number(new Date());
+			const ms = curr - (prevTime || curr);
+			self.diff = ms;
+			self.prev = prevTime;
+			self.curr = curr;
+			prevTime = curr;
+
+			args[0] = createDebug.coerce(args[0]);
+
+			if (typeof args[0] !== 'string') {
+				// Anything else let's inspect with %O
+				args.unshift('%O');
+			}
+
+			// Apply any `formatters` transformations
+			let index = 0;
+			args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
+				// If we encounter an escaped % then don't increase the array index
+				if (match === '%%') {
+					return '%';
+				}
+				index++;
+				const formatter = createDebug.formatters[format];
+				if (typeof formatter === 'function') {
+					const val = args[index];
+					match = formatter.call(self, val);
+
+					// Now we need to remove `args[index]` since it's inlined in the `format`
+					args.splice(index, 1);
+					index--;
+				}
+				return match;
+			});
+
+			// Apply env-specific formatting (colors, etc.)
+			createDebug.formatArgs.call(self, args);
+
+			const logFn = self.log || createDebug.log;
+			logFn.apply(self, args);
+		}
+
+		debug.namespace = namespace;
+		debug.useColors = createDebug.useColors();
+		debug.color = createDebug.selectColor(namespace);
+		debug.extend = extend;
+		debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.
+
+		Object.defineProperty(debug, 'enabled', {
+			enumerable: true,
+			configurable: false,
+			get: () => {
+				if (enableOverride !== null) {
+					return enableOverride;
+				}
+				if (namespacesCache !== createDebug.namespaces) {
+					namespacesCache = createDebug.namespaces;
+					enabledCache = createDebug.enabled(namespace);
+				}
+
+				return enabledCache;
+			},
+			set: v => {
+				enableOverride = v;
+			}
+		});
+
+		// Env-specific initialization logic for debug instances
+		if (typeof createDebug.init === 'function') {
+			createDebug.init(debug);
+		}
+
+		return debug;
+	}
+
+	function extend(namespace, delimiter) {
+		const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
+		newDebug.log = this.log;
+		return newDebug;
+	}
+
+	/**
+	* Enables a debug mode by namespaces. This can include modes
+	* separated by a colon and wildcards.
+	*
+	* @param {String} namespaces
+	* @api public
+	*/
+	function enable(namespaces) {
+		createDebug.save(namespaces);
+		createDebug.namespaces = namespaces;
+
+		createDebug.names = [];
+		createDebug.skips = [];
+
+		let i;
+		const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
+		const len = split.length;
+
+		for (i = 0; i < len; i++) {
+			if (!split[i]) {
+				// ignore empty strings
+				continue;
+			}
+
+			namespaces = split[i].replace(/\*/g, '.*?');
+
+			if (namespaces[0] === '-') {
+				createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
+			} else {
+				createDebug.names.push(new RegExp('^' + namespaces + '$'));
+			}
+		}
+	}
+
+	/**
+	* Disable debug output.
+	*
+	* @return {String} namespaces
+	* @api public
+	*/
+	function disable() {
+		const namespaces = [
+			...createDebug.names.map(toNamespace),
+			...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)
+		].join(',');
+		createDebug.enable('');
+		return namespaces;
+	}
+
+	/**
+	* Returns true if the given mode name is enabled, false otherwise.
+	*
+	* @param {String} name
+	* @return {Boolean}
+	* @api public
+	*/
+	function enabled(name) {
+		if (name[name.length - 1] === '*') {
+			return true;
+		}
+
+		let i;
+		let len;
+
+		for (i = 0, len = createDebug.skips.length; i < len; i++) {
+			if (createDebug.skips[i].test(name)) {
+				return false;
+			}
+		}
+
+		for (i = 0, len = createDebug.names.length; i < len; i++) {
+			if (createDebug.names[i].test(name)) {
+				return true;
+			}
+		}
+
+		return false;
+	}
+
+	/**
+	* Convert regexp to namespace
+	*
+	* @param {RegExp} regxep
+	* @return {String} namespace
+	* @api private
+	*/
+	function toNamespace(regexp) {
+		return regexp.toString()
+			.substring(2, regexp.toString().length - 2)
+			.replace(/\.\*\?$/, '*');
+	}
+
+	/**
+	* Coerce `val`.
+	*
+	* @param {Mixed} val
+	* @return {Mixed}
+	* @api private
+	*/
+	function coerce(val) {
+		if (val instanceof Error) {
+			return val.stack || val.message;
+		}
+		return val;
+	}
+
+	/**
+	* XXX DO NOT USE. This is a temporary stub function.
+	* XXX It WILL be removed in the next major release.
+	*/
+	function destroy() {
+		console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
+	}
+
+	createDebug.enable(createDebug.load());
+
+	return createDebug;
+}
+
+module.exports = setup;
+
+
+/***/ }),
+
+/***/ 7378:
+/***/ ((__unused_webpack_module, exports) => {
+
+"use strict";
+
+
+exports.byteLength = byteLength
+exports.toByteArray = toByteArray
+exports.fromByteArray = fromByteArray
+
+var lookup = []
+var revLookup = []
+var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array
+
+var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
+for (var i = 0, len = code.length; i < len; ++i) {
+  lookup[i] = code[i]
+  revLookup[code.charCodeAt(i)] = i
+}
+
+// Support decoding URL-safe base64 strings, as Node.js does.
+// See: https://en.wikipedia.org/wiki/Base64#URL_applications
+revLookup['-'.charCodeAt(0)] = 62
+revLookup['_'.charCodeAt(0)] = 63
+
+function getLens (b64) {
+  var len = b64.length
+
+  if (len % 4 > 0) {
+    throw new Error('Invalid string. Length must be a multiple of 4')
+  }
+
+  // Trim off extra bytes after placeholder bytes are found
+  // See: https://github.com/beatgammit/base64-js/issues/42
+  var validLen = b64.indexOf('=')
+  if (validLen === -1) validLen = len
+
+  var placeHoldersLen = validLen === len
+    ? 0
+    : 4 - (validLen % 4)
+
+  return [validLen, placeHoldersLen]
+}
+
+// base64 is 4/3 + up to two characters of the original data
+function byteLength (b64) {
+  var lens = getLens(b64)
+  var validLen = lens[0]
+  var placeHoldersLen = lens[1]
+  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
+}
+
+function _byteLength (b64, validLen, placeHoldersLen) {
+  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
+}
+
+function toByteArray (b64) {
+  var tmp
+  var lens = getLens(b64)
+  var validLen = lens[0]
+  var placeHoldersLen = lens[1]
+
+  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))
+
+  var curByte = 0
+
+  // if there are placeholders, only get up to the last complete 4 chars
+  var len = placeHoldersLen > 0
+    ? validLen - 4
+    : validLen
+
+  var i
+  for (i = 0; i < len; i += 4) {
+    tmp =
+      (revLookup[b64.charCodeAt(i)] << 18) |
+      (revLookup[b64.charCodeAt(i + 1)] << 12) |
+      (revLookup[b64.charCodeAt(i + 2)] << 6) |
+      revLookup[b64.charCodeAt(i + 3)]
+    arr[curByte++] = (tmp >> 16) & 0xFF
+    arr[curByte++] = (tmp >> 8) & 0xFF
+    arr[curByte++] = tmp & 0xFF
+  }
+
+  if (placeHoldersLen === 2) {
+    tmp =
+      (revLookup[b64.charCodeAt(i)] << 2) |
+      (revLookup[b64.charCodeAt(i + 1)] >> 4)
+    arr[curByte++] = tmp & 0xFF
+  }
+
+  if (placeHoldersLen === 1) {
+    tmp =
+      (revLookup[b64.charCodeAt(i)] << 10) |
+      (revLookup[b64.charCodeAt(i + 1)] << 4) |
+      (revLookup[b64.charCodeAt(i + 2)] >> 2)
+    arr[curByte++] = (tmp >> 8) & 0xFF
+    arr[curByte++] = tmp & 0xFF
+  }
+
+  return arr
+}
+
+function tripletToBase64 (num) {
+  return lookup[num >> 18 & 0x3F] +
+    lookup[num >> 12 & 0x3F] +
+    lookup[num >> 6 & 0x3F] +
+    lookup[num & 0x3F]
+}
+
+function encodeChunk (uint8, start, end) {
+  var tmp
+  var output = []
+  for (var i = start; i < end; i += 3) {
+    tmp =
+      ((uint8[i] << 16) & 0xFF0000) +
+      ((uint8[i + 1] << 8) & 0xFF00) +
+      (uint8[i + 2] & 0xFF)
+    output.push(tripletToBase64(tmp))
+  }
+  return output.join('')
+}
+
+function fromByteArray (uint8) {
+  var tmp
+  var len = uint8.length
+  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
+  var parts = []
+  var maxChunkLength = 16383 // must be multiple of 3
+
+  // go through the array every three bytes, we'll deal with trailing stuff later
+  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
+    parts.push(encodeChunk(
+      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
+    ))
+  }
+
+  // pad the end with zeros, but make sure to not forget the extra bytes
+  if (extraBytes === 1) {
+    tmp = uint8[len - 1]
+    parts.push(
+      lookup[tmp >> 2] +
+      lookup[(tmp << 4) & 0x3F] +
+      '=='
+    )
+  } else if (extraBytes === 2) {
+    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
+    parts.push(
+      lookup[tmp >> 10] +
+      lookup[(tmp >> 4) & 0x3F] +
+      lookup[(tmp << 2) & 0x3F] +
+      '='
+    )
+  }
+
+  return parts.join('')
+}
+
+
+/***/ }),
+
+/***/ 7866:
+/***/ ((__unused_webpack_module, exports, __webpack_require__) => {
+
+"use strict";
+/*!
+ * The buffer module from node.js, for the browser.
+ *
+ * @author   Feross Aboukhadijeh <https://feross.org>
+ * @license  MIT
+ */
+/* eslint-disable no-proto */
+
+
+
+const base64 = __webpack_require__(7378)
+const ieee754 = __webpack_require__(9258)
+const customInspectSymbol =
+  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation
+    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation
+    : null
+
+exports.Buffer = Buffer
+exports.SlowBuffer = SlowBuffer
+exports.INSPECT_MAX_BYTES = 50
+
+const K_MAX_LENGTH = 0x7fffffff
+exports.kMaxLength = K_MAX_LENGTH
+
+/**
+ * If `Buffer.TYPED_ARRAY_SUPPORT`:
+ *   === true    Use Uint8Array implementation (fastest)
+ *   === false   Print warning and recommend using `buffer` v4.x which has an Object
+ *               implementation (most compatible, even IE6)
+ *
+ * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
+ * Opera 11.6+, iOS 4.2+.
+ *
+ * We report that the browser does not support typed arrays if the are not subclassable
+ * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
+ * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
+ * for __proto__ and has a buggy typed array implementation.
+ */
+Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()
+
+if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
+    typeof console.error === 'function') {
+  console.error(
+    'This browser lacks typed array (Uint8Array) support which is required by ' +
+    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
+  )
+}
+
+function typedArraySupport () {
+  // Can typed array instances can be augmented?
+  try {
+    const arr = new Uint8Array(1)
+    const proto = { foo: function () { return 42 } }
+    Object.setPrototypeOf(proto, Uint8Array.prototype)
+    Object.setPrototypeOf(arr, proto)
+    return arr.foo() === 42
+  } catch (e) {
+    return false
+  }
+}
+
+Object.defineProperty(Buffer.prototype, 'parent', {
+  enumerable: true,
+  get: function () {
+    if (!Buffer.isBuffer(this)) return undefined
+    return this.buffer
+  }
+})
+
+Object.defineProperty(Buffer.prototype, 'offset', {
+  enumerable: true,
+  get: function () {
+    if (!Buffer.isBuffer(this)) return undefined
+    return this.byteOffset
+  }
+})
+
+function createBuffer (length) {
+  if (length > K_MAX_LENGTH) {
+    throw new RangeError('The value "' + length + '" is invalid for option "size"')
+  }
+  // Return an augmented `Uint8Array` instance
+  const buf = new Uint8Array(length)
+  Object.setPrototypeOf(buf, Buffer.prototype)
+  return buf
+}
+
+/**
+ * The Buffer constructor returns instances of `Uint8Array` that have their
+ * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
+ * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
+ * and the `Uint8Array` methods. Square bracket notation works as expected -- it
+ * returns a single octet.
+ *
+ * The `Uint8Array` prototype remains unmodified.
+ */
+
+function Buffer (arg, encodingOrOffset, length) {
+  // Common case.
+  if (typeof arg === 'number') {
+    if (typeof encodingOrOffset === 'string') {
+      throw new TypeError(
+        'The "string" argument must be of type string. Received type number'
+      )
+    }
+    return allocUnsafe(arg)
+  }
+  return from(arg, encodingOrOffset, length)
+}
+
+Buffer.poolSize = 8192 // not used by this implementation
+
+function from (value, encodingOrOffset, length) {
+  if (typeof value === 'string') {
+    return fromString(value, encodingOrOffset)
+  }
+
+  if (ArrayBuffer.isView(value)) {
+    return fromArrayView(value)
+  }
+
+  if (value == null) {
+    throw new TypeError(
+      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
+      'or Array-like Object. Received type ' + (typeof value)
+    )
+  }
+
+  if (isInstance(value, ArrayBuffer) ||
+      (value && isInstance(value.buffer, ArrayBuffer))) {
+    return fromArrayBuffer(value, encodingOrOffset, length)
+  }
+
+  if (typeof SharedArrayBuffer !== 'undefined' &&
+      (isInstance(value, SharedArrayBuffer) ||
+      (value && isInstance(value.buffer, SharedArrayBuffer)))) {
+    return fromArrayBuffer(value, encodingOrOffset, length)
+  }
+
+  if (typeof value === 'number') {
+    throw new TypeError(
+      'The "value" argument must not be of type number. Received type number'
+    )
+  }
+
+  const valueOf = value.valueOf && value.valueOf()
+  if (valueOf != null && valueOf !== value) {
+    return Buffer.from(valueOf, encodingOrOffset, length)
+  }
+
+  const b = fromObject(value)
+  if (b) return b
+
+  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
+      typeof value[Symbol.toPrimitive] === 'function') {
+    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)
+  }
+
+  throw new TypeError(
+    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
+    'or Array-like Object. Received type ' + (typeof value)
+  )
+}
+
+/**
+ * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
+ * if value is a number.
+ * Buffer.from(str[, encoding])
+ * Buffer.from(array)
+ * Buffer.from(buffer)
+ * Buffer.from(arrayBuffer[, byteOffset[, length]])
+ **/
+Buffer.from = function (value, encodingOrOffset, length) {
+  return from(value, encodingOrOffset, length)
+}
+
+// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
+// https://github.com/feross/buffer/pull/148
+Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)
+Object.setPrototypeOf(Buffer, Uint8Array)
+
+function assertSize (size) {
+  if (typeof size !== 'number') {
+    throw new TypeError('"size" argument must be of type number')
+  } else if (size < 0) {
+    throw new RangeError('The value "' + size + '" is invalid for option "size"')
+  }
+}
+
+function alloc (size, fill, encoding) {
+  assertSize(size)
+  if (size <= 0) {
+    return createBuffer(size)
+  }
+  if (fill !== undefined) {
+    // Only pay attention to encoding if it's a string. This
+    // prevents accidentally sending in a number that would
+    // be interpreted as a start offset.
+    return typeof encoding === 'string'
+      ? createBuffer(size).fill(fill, encoding)
+      : createBuffer(size).fill(fill)
+  }
+  return createBuffer(size)
+}
+
+/**
+ * Creates a new filled Buffer instance.
+ * alloc(size[, fill[, encoding]])
+ **/
+Buffer.alloc = function (size, fill, encoding) {
+  return alloc(size, fill, encoding)
+}
+
+function allocUnsafe (size) {
+  assertSize(size)
+  return createBuffer(size < 0 ? 0 : checked(size) | 0)
+}
+
+/**
+ * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
+ * */
+Buffer.allocUnsafe = function (size) {
+  return allocUnsafe(size)
+}
+/**
+ * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
+ */
+Buffer.allocUnsafeSlow = function (size) {
+  return allocUnsafe(size)
+}
+
+function fromString (string, encoding) {
+  if (typeof encoding !== 'string' || encoding === '') {
+    encoding = 'utf8'
+  }
+
+  if (!Buffer.isEncoding(encoding)) {
+    throw new TypeError('Unknown encoding: ' + encoding)
+  }
+
+  const length = byteLength(string, encoding) | 0
+  let buf = createBuffer(length)
+
+  const actual = buf.write(string, encoding)
+
+  if (actual !== length) {
+    // Writing a hex string, for example, that contains invalid characters will
+    // cause everything after the first invalid character to be ignored. (e.g.
+    // 'abxxcd' will be treated as 'ab')
+    buf = buf.slice(0, actual)
+  }
+
+  return buf
+}
+
+function fromArrayLike (array) {
+  const length = array.length < 0 ? 0 : checked(array.length) | 0
+  const buf = createBuffer(length)
+  for (let i = 0; i < length; i += 1) {
+    buf[i] = array[i] & 255
+  }
+  return buf
+}
+
+function fromArrayView (arrayView) {
+  if (isInstance(arrayView, Uint8Array)) {
+    const copy = new Uint8Array(arrayView)
+    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)
+  }
+  return fromArrayLike(arrayView)
+}
+
+function fromArrayBuffer (array, byteOffset, length) {
+  if (byteOffset < 0 || array.byteLength < byteOffset) {
+    throw new RangeError('"offset" is outside of buffer bounds')
+  }
+
+  if (array.byteLength < byteOffset + (length || 0)) {
+    throw new RangeError('"length" is outside of buffer bounds')
+  }
+
+  let buf
+  if (byteOffset === undefined && length === undefined) {
+    buf = new Uint8Array(array)
+  } else if (length === undefined) {
+    buf = new Uint8Array(array, byteOffset)
+  } else {
+    buf = new Uint8Array(array, byteOffset, length)
+  }
+
+  // Return an augmented `Uint8Array` instance
+  Object.setPrototypeOf(buf, Buffer.prototype)
+
+  return buf
+}
+
+function fromObject (obj) {
+  if (Buffer.isBuffer(obj)) {
+    const len = checked(obj.length) | 0
+    const buf = createBuffer(len)
+
+    if (buf.length === 0) {
+      return buf
+    }
+
+    obj.copy(buf, 0, 0, len)
+    return buf
+  }
+
+  if (obj.length !== undefined) {
+    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
+      return createBuffer(0)
+    }
+    return fromArrayLike(obj)
+  }
+
+  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
+    return fromArrayLike(obj.data)
+  }
+}
+
+function checked (length) {
+  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
+  // length is NaN (which is otherwise coerced to zero.)
+  if (length >= K_MAX_LENGTH) {
+    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
+                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
+  }
+  return length | 0
+}
+
+function SlowBuffer (length) {
+  if (+length != length) { // eslint-disable-line eqeqeq
+    length = 0
+  }
+  return Buffer.alloc(+length)
+}
+
+Buffer.isBuffer = function isBuffer (b) {
+  return b != null && b._isBuffer === true &&
+    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
+}
+
+Buffer.compare = function compare (a, b) {
+  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
+  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
+  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
+    throw new TypeError(
+      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
+    )
+  }
+
+  if (a === b) return 0
+
+  let x = a.length
+  let y = b.length
+
+  for (let i = 0, len = Math.min(x, y); i < len; ++i) {
+    if (a[i] !== b[i]) {
+      x = a[i]
+      y = b[i]
+      break
+    }
+  }
+
+  if (x < y) return -1
+  if (y < x) return 1
+  return 0
+}
+
+Buffer.isEncoding = function isEncoding (encoding) {
+  switch (String(encoding).toLowerCase()) {
+    case 'hex':
+    case 'utf8':
+    case 'utf-8':
+    case 'ascii':
+    case 'latin1':
+    case 'binary':
+    case 'base64':
+    case 'ucs2':
+    case 'ucs-2':
+    case 'utf16le':
+    case 'utf-16le':
+      return true
+    default:
+      return false
+  }
+}
+
+Buffer.concat = function concat (list, length) {
+  if (!Array.isArray(list)) {
+    throw new TypeError('"list" argument must be an Array of Buffers')
+  }
+
+  if (list.length === 0) {
+    return Buffer.alloc(0)
+  }
+
+  let i
+  if (length === undefined) {
+    length = 0
+    for (i = 0; i < list.length; ++i) {
+      length += list[i].length
+    }
+  }
+
+  const buffer = Buffer.allocUnsafe(length)
+  let pos = 0
+  for (i = 0; i < list.length; ++i) {
+    let buf = list[i]
+    if (isInstance(buf, Uint8Array)) {
+      if (pos + buf.length > buffer.length) {
+        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)
+        buf.copy(buffer, pos)
+      } else {
+        Uint8Array.prototype.set.call(
+          buffer,
+          buf,
+          pos
+        )
+      }
+    } else if (!Buffer.isBuffer(buf)) {
+      throw new TypeError('"list" argument must be an Array of Buffers')
+    } else {
+      buf.copy(buffer, pos)
+    }
+    pos += buf.length
+  }
+  return buffer
+}
+
+function byteLength (string, encoding) {
+  if (Buffer.isBuffer(string)) {
+    return string.length
+  }
+  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
+    return string.byteLength
+  }
+  if (typeof string !== 'string') {
+    throw new TypeError(
+      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
+      'Received type ' + typeof string
+    )
+  }
+
+  const len = string.length
+  const mustMatch = (arguments.length > 2 && arguments[2] === true)
+  if (!mustMatch && len === 0) return 0
+
+  // Use a for loop to avoid recursion
+  let loweredCase = false
+  for (;;) {
+    switch (encoding) {
+      case 'ascii':
+      case 'latin1':
+      case 'binary':
+        return len
+      case 'utf8':
+      case 'utf-8':
+        return utf8ToBytes(string).length
+      case 'ucs2':
+      case 'ucs-2':
+      case 'utf16le':
+      case 'utf-16le':
+        return len * 2
+      case 'hex':
+        return len >>> 1
+      case 'base64':
+        return base64ToBytes(string).length
+      default:
+        if (loweredCase) {
+          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
+        }
+        encoding = ('' + encoding).toLowerCase()
+        loweredCase = true
+    }
+  }
+}
+Buffer.byteLength = byteLength
+
+function slowToString (encoding, start, end) {
+  let loweredCase = false
+
+  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
+  // property of a typed array.
+
+  // This behaves neither like String nor Uint8Array in that we set start/end
+  // to their upper/lower bounds if the value passed is out of range.
+  // undefined is handled specially as per ECMA-262 6th Edition,
+  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
+  if (start === undefined || start < 0) {
+    start = 0
+  }
+  // Return early if start > this.length. Done here to prevent potential uint32
+  // coercion fail below.
+  if (start > this.length) {
+    return ''
+  }
+
+  if (end === undefined || end > this.length) {
+    end = this.length
+  }
+
+  if (end <= 0) {
+    return ''
+  }
+
+  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
+  end >>>= 0
+  start >>>= 0
+
+  if (end <= start) {
+    return ''
+  }
+
+  if (!encoding) encoding = 'utf8'
+
+  while (true) {
+    switch (encoding) {
+      case 'hex':
+        return hexSlice(this, start, end)
+
+      case 'utf8':
+      case 'utf-8':
+        return utf8Slice(this, start, end)
+
+      case 'ascii':
+        return asciiSlice(this, start, end)
+
+      case 'latin1':
+      case 'binary':
+        return latin1Slice(this, start, end)
+
+      case 'base64':
+        return base64Slice(this, start, end)
+
+      case 'ucs2':
+      case 'ucs-2':
+      case 'utf16le':
+      case 'utf-16le':
+        return utf16leSlice(this, start, end)
+
+      default:
+        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
+        encoding = (encoding + '').toLowerCase()
+        loweredCase = true
+    }
+  }
+}
+
+// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
+// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
+// reliably in a browserify context because there could be multiple different
+// copies of the 'buffer' package in use. This method works even for Buffer
+// instances that were created from another copy of the `buffer` package.
+// See: https://github.com/feross/buffer/issues/154
+Buffer.prototype._isBuffer = true
+
+function swap (b, n, m) {
+  const i = b[n]
+  b[n] = b[m]
+  b[m] = i
+}
+
+Buffer.prototype.swap16 = function swap16 () {
+  const len = this.length
+  if (len % 2 !== 0) {
+    throw new RangeError('Buffer size must be a multiple of 16-bits')
+  }
+  for (let i = 0; i < len; i += 2) {
+    swap(this, i, i + 1)
+  }
+  return this
+}
+
+Buffer.prototype.swap32 = function swap32 () {
+  const len = this.length
+  if (len % 4 !== 0) {
+    throw new RangeError('Buffer size must be a multiple of 32-bits')
+  }
+  for (let i = 0; i < len; i += 4) {
+    swap(this, i, i + 3)
+    swap(this, i + 1, i + 2)
+  }
+  return this
+}
+
+Buffer.prototype.swap64 = function swap64 () {
+  const len = this.length
+  if (len % 8 !== 0) {
+    throw new RangeError('Buffer size must be a multiple of 64-bits')
+  }
+  for (let i = 0; i < len; i += 8) {
+    swap(this, i, i + 7)
+    swap(this, i + 1, i + 6)
+    swap(this, i + 2, i + 5)
+    swap(this, i + 3, i + 4)
+  }
+  return this
+}
+
+Buffer.prototype.toString = function toString () {
+  const length = this.length
+  if (length === 0) return ''
+  if (arguments.length === 0) return utf8Slice(this, 0, length)
+  return slowToString.apply(this, arguments)
+}
+
+Buffer.prototype.toLocaleString = Buffer.prototype.toString
+
+Buffer.prototype.equals = function equals (b) {
+  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
+  if (this === b) return true
+  return Buffer.compare(this, b) === 0
+}
+
+Buffer.prototype.inspect = function inspect () {
+  let str = ''
+  const max = exports.INSPECT_MAX_BYTES
+  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
+  if (this.length > max) str += ' ... '
+  return '<Buffer ' + str + '>'
+}
+if (customInspectSymbol) {
+  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect
+}
+
+Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
+  if (isInstance(target, Uint8Array)) {
+    target = Buffer.from(target, target.offset, target.byteLength)
+  }
+  if (!Buffer.isBuffer(target)) {
+    throw new TypeError(
+      'The "target" argument must be one of type Buffer or Uint8Array. ' +
+      'Received type ' + (typeof target)
+    )
+  }
+
+  if (start === undefined) {
+    start = 0
+  }
+  if (end === undefined) {
+    end = target ? target.length : 0
+  }
+  if (thisStart === undefined) {
+    thisStart = 0
+  }
+  if (thisEnd === undefined) {
+    thisEnd = this.length
+  }
+
+  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
+    throw new RangeError('out of range index')
+  }
+
+  if (thisStart >= thisEnd && start >= end) {
+    return 0
+  }
+  if (thisStart >= thisEnd) {
+    return -1
+  }
+  if (start >= end) {
+    return 1
+  }
+
+  start >>>= 0
+  end >>>= 0
+  thisStart >>>= 0
+  thisEnd >>>= 0
+
+  if (this === target) return 0
+
+  let x = thisEnd - thisStart
+  let y = end - start
+  const len = Math.min(x, y)
+
+  const thisCopy = this.slice(thisStart, thisEnd)
+  const targetCopy = target.slice(start, end)
+
+  for (let i = 0; i < len; ++i) {
+    if (thisCopy[i] !== targetCopy[i]) {
+      x = thisCopy[i]
+      y = targetCopy[i]
+      break
+    }
+  }
+
+  if (x < y) return -1
+  if (y < x) return 1
+  return 0
+}
+
+// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
+// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
+//
+// Arguments:
+// - buffer - a Buffer to search
+// - val - a string, Buffer, or number
+// - byteOffset - an index into `buffer`; will be clamped to an int32
+// - encoding - an optional encoding, relevant is val is a string
+// - dir - true for indexOf, false for lastIndexOf
+function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
+  // Empty buffer means no match
+  if (buffer.length === 0) return -1
+
+  // Normalize byteOffset
+  if (typeof byteOffset === 'string') {
+    encoding = byteOffset
+    byteOffset = 0
+  } else if (byteOffset > 0x7fffffff) {
+    byteOffset = 0x7fffffff
+  } else if (byteOffset < -0x80000000) {
+    byteOffset = -0x80000000
+  }
+  byteOffset = +byteOffset // Coerce to Number.
+  if (numberIsNaN(byteOffset)) {
+    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
+    byteOffset = dir ? 0 : (buffer.length - 1)
+  }
+
+  // Normalize byteOffset: negative offsets start from the end of the buffer
+  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
+  if (byteOffset >= buffer.length) {
+    if (dir) return -1
+    else byteOffset = buffer.length - 1
+  } else if (byteOffset < 0) {
+    if (dir) byteOffset = 0
+    else return -1
+  }
+
+  // Normalize val
+  if (typeof val === 'string') {
+    val = Buffer.from(val, encoding)
+  }
+
+  // Finally, search either indexOf (if dir is true) or lastIndexOf
+  if (Buffer.isBuffer(val)) {
+    // Special case: looking for empty string/buffer always fails
+    if (val.length === 0) {
+      return -1
+    }
+    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
+  } else if (typeof val === 'number') {
+    val = val & 0xFF // Search for a byte value [0-255]
+    if (typeof Uint8Array.prototype.indexOf === 'function') {
+      if (dir) {
+        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
+      } else {
+        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
+      }
+    }
+    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
+  }
+
+  throw new TypeError('val must be string, number or Buffer')
+}
+
+function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
+  let indexSize = 1
+  let arrLength = arr.length
+  let valLength = val.length
+
+  if (encoding !== undefined) {
+    encoding = String(encoding).toLowerCase()
+    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
+        encoding === 'utf16le' || encoding === 'utf-16le') {
+      if (arr.length < 2 || val.length < 2) {
+        return -1
+      }
+      indexSize = 2
+      arrLength /= 2
+      valLength /= 2
+      byteOffset /= 2
+    }
+  }
+
+  function read (buf, i) {
+    if (indexSize === 1) {
+      return buf[i]
+    } else {
+      return buf.readUInt16BE(i * indexSize)
+    }
+  }
+
+  let i
+  if (dir) {
+    let foundIndex = -1
+    for (i = byteOffset; i < arrLength; i++) {
+      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
+        if (foundIndex === -1) foundIndex = i
+        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
+      } else {
+        if (foundIndex !== -1) i -= i - foundIndex
+        foundIndex = -1
+      }
+    }
+  } else {
+    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
+    for (i = byteOffset; i >= 0; i--) {
+      let found = true
+      for (let j = 0; j < valLength; j++) {
+        if (read(arr, i + j) !== read(val, j)) {
+          found = false
+          break
+        }
+      }
+      if (found) return i
+    }
+  }
+
+  return -1
+}
+
+Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
+  return this.indexOf(val, byteOffset, encoding) !== -1
+}
+
+Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
+  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
+}
+
+Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
+  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
+}
+
+function hexWrite (buf, string, offset, length) {
+  offset = Number(offset) || 0
+  const remaining = buf.length - offset
+  if (!length) {
+    length = remaining
+  } else {
+    length = Number(length)
+    if (length > remaining) {
+      length = remaining
+    }
+  }
+
+  const strLen = string.length
+
+  if (length > strLen / 2) {
+    length = strLen / 2
+  }
+  let i
+  for (i = 0; i < length; ++i) {
+    const parsed = parseInt(string.substr(i * 2, 2), 16)
+    if (numberIsNaN(parsed)) return i
+    buf[offset + i] = parsed
+  }
+  return i
+}
+
+function utf8Write (buf, string, offset, length) {
+  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
+}
+
+function asciiWrite (buf, string, offset, length) {
+  return blitBuffer(asciiToBytes(string), buf, offset, length)
+}
+
+function base64Write (buf, string, offset, length) {
+  return blitBuffer(base64ToBytes(string), buf, offset, length)
+}
+
+function ucs2Write (buf, string, offset, length) {
+  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
+}
+
+Buffer.prototype.write = function write (string, offset, length, encoding) {
+  // Buffer#write(string)
+  if (offset === undefined) {
+    encoding = 'utf8'
+    length = this.length
+    offset = 0
+  // Buffer#write(string, encoding)
+  } else if (length === undefined && typeof offset === 'string') {
+    encoding = offset
+    length = this.length
+    offset = 0
+  // Buffer#write(string, offset[, length][, encoding])
+  } else if (isFinite(offset)) {
+    offset = offset >>> 0
+    if (isFinite(length)) {
+      length = length >>> 0
+      if (encoding === undefined) encoding = 'utf8'
+    } else {
+      encoding = length
+      length = undefined
+    }
+  } else {
+    throw new Error(
+      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
+    )
+  }
+
+  const remaining = this.length - offset
+  if (length === undefined || length > remaining) length = remaining
+
+  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
+    throw new RangeError('Attempt to write outside buffer bounds')
+  }
+
+  if (!encoding) encoding = 'utf8'
+
+  let loweredCase = false
+  for (;;) {
+    switch (encoding) {
+      case 'hex':
+        return hexWrite(this, string, offset, length)
+
+      case 'utf8':
+      case 'utf-8':
+        return utf8Write(this, string, offset, length)
+
+      case 'ascii':
+      case 'latin1':
+      case 'binary':
+        return asciiWrite(this, string, offset, length)
+
+      case 'base64':
+        // Warning: maxLength not taken into account in base64Write
+        return base64Write(this, string, offset, length)
+
+      case 'ucs2':
+      case 'ucs-2':
+      case 'utf16le':
+      case 'utf-16le':
+        return ucs2Write(this, string, offset, length)
+
+      default:
+        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
+        encoding = ('' + encoding).toLowerCase()
+        loweredCase = true
+    }
+  }
+}
+
+Buffer.prototype.toJSON = function toJSON () {
+  return {
+    type: 'Buffer',
+    data: Array.prototype.slice.call(this._arr || this, 0)
+  }
+}
+
+function base64Slice (buf, start, end) {
+  if (start === 0 && end === buf.length) {
+    return base64.fromByteArray(buf)
+  } else {
+    return base64.fromByteArray(buf.slice(start, end))
+  }
+}
+
+function utf8Slice (buf, start, end) {
+  end = Math.min(buf.length, end)
+  const res = []
+
+  let i = start
+  while (i < end) {
+    const firstByte = buf[i]
+    let codePoint = null
+    let bytesPerSequence = (firstByte > 0xEF)
+      ? 4
+      : (firstByte > 0xDF)
+          ? 3
+          : (firstByte > 0xBF)
+              ? 2
+              : 1
+
+    if (i + bytesPerSequence <= end) {
+      let secondByte, thirdByte, fourthByte, tempCodePoint
+
+      switch (bytesPerSequence) {
+        case 1:
+          if (firstByte < 0x80) {
+            codePoint = firstByte
+          }
+          break
+        case 2:
+          secondByte = buf[i + 1]
+          if ((secondByte & 0xC0) === 0x80) {
+            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
+            if (tempCodePoint > 0x7F) {
+              codePoint = tempCodePoint
+            }
+          }
+          break
+        case 3:
+          secondByte = buf[i + 1]
+          thirdByte = buf[i + 2]
+          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
+            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
+            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
+              codePoint = tempCodePoint
+            }
+          }
+          break
+        case 4:
+          secondByte = buf[i + 1]
+          thirdByte = buf[i + 2]
+          fourthByte = buf[i + 3]
+          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
+            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
+            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
+              codePoint = tempCodePoint
+            }
+          }
+      }
+    }
+
+    if (codePoint === null) {
+      // we did not generate a valid codePoint so insert a
+      // replacement char (U+FFFD) and advance only 1 byte
+      codePoint = 0xFFFD
+      bytesPerSequence = 1
+    } else if (codePoint > 0xFFFF) {
+      // encode to utf16 (surrogate pair dance)
+      codePoint -= 0x10000
+      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
+      codePoint = 0xDC00 | codePoint & 0x3FF
+    }
+
+    res.push(codePoint)
+    i += bytesPerSequence
+  }
+
+  return decodeCodePointsArray(res)
+}
+
+// Based on http://stackoverflow.com/a/22747272/680742, the browser with
+// the lowest limit is Chrome, with 0x10000 args.
+// We go 1 magnitude less, for safety
+const MAX_ARGUMENTS_LENGTH = 0x1000
+
+function decodeCodePointsArray (codePoints) {
+  const len = codePoints.length
+  if (len <= MAX_ARGUMENTS_LENGTH) {
+    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
+  }
+
+  // Decode in chunks to avoid "call stack size exceeded".
+  let res = ''
+  let i = 0
+  while (i < len) {
+    res += String.fromCharCode.apply(
+      String,
+      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
+    )
+  }
+  return res
+}
+
+function asciiSlice (buf, start, end) {
+  let ret = ''
+  end = Math.min(buf.length, end)
+
+  for (let i = start; i < end; ++i) {
+    ret += String.fromCharCode(buf[i] & 0x7F)
+  }
+  return ret
+}
+
+function latin1Slice (buf, start, end) {
+  let ret = ''
+  end = Math.min(buf.length, end)
+
+  for (let i = start; i < end; ++i) {
+    ret += String.fromCharCode(buf[i])
+  }
+  return ret
+}
+
+function hexSlice (buf, start, end) {
+  const len = buf.length
+
+  if (!start || start < 0) start = 0
+  if (!end || end < 0 || end > len) end = len
+
+  let out = ''
+  for (let i = start; i < end; ++i) {
+    out += hexSliceLookupTable[buf[i]]
+  }
+  return out
+}
+
+function utf16leSlice (buf, start, end) {
+  const bytes = buf.slice(start, end)
+  let res = ''
+  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
+  for (let i = 0; i < bytes.length - 1; i += 2) {
+    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
+  }
+  return res
+}
+
+Buffer.prototype.slice = function slice (start, end) {
+  const len = this.length
+  start = ~~start
+  end = end === undefined ? len : ~~end
+
+  if (start < 0) {
+    start += len
+    if (start < 0) start = 0
+  } else if (start > len) {
+    start = len
+  }
+
+  if (end < 0) {
+    end += len
+    if (end < 0) end = 0
+  } else if (end > len) {
+    end = len
+  }
+
+  if (end < start) end = start
+
+  const newBuf = this.subarray(start, end)
+  // Return an augmented `Uint8Array` instance
+  Object.setPrototypeOf(newBuf, Buffer.prototype)
+
+  return newBuf
+}
+
+/*
+ * Need to make sure that buffer isn't trying to write out of bounds.
+ */
+function checkOffset (offset, ext, length) {
+  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
+  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
+}
+
+Buffer.prototype.readUintLE =
+Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
+  offset = offset >>> 0
+  byteLength = byteLength >>> 0
+  if (!noAssert) checkOffset(offset, byteLength, this.length)
+
+  let val = this[offset]
+  let mul = 1
+  let i = 0
+  while (++i < byteLength && (mul *= 0x100)) {
+    val += this[offset + i] * mul
+  }
+
+  return val
+}
+
+Buffer.prototype.readUintBE =
+Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
+  offset = offset >>> 0
+  byteLength = byteLength >>> 0
+  if (!noAssert) {
+    checkOffset(offset, byteLength, this.length)
+  }
+
+  let val = this[offset + --byteLength]
+  let mul = 1
+  while (byteLength > 0 && (mul *= 0x100)) {
+    val += this[offset + --byteLength] * mul
+  }
+
+  return val
+}
+
+Buffer.prototype.readUint8 =
+Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
+  offset = offset >>> 0
+  if (!noAssert) checkOffset(offset, 1, this.length)
+  return this[offset]
+}
+
+Buffer.prototype.readUint16LE =
+Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
+  offset = offset >>> 0
+  if (!noAssert) checkOffset(offset, 2, this.length)
+  return this[offset] | (this[offset + 1] << 8)
+}
+
+Buffer.prototype.readUint16BE =
+Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
+  offset = offset >>> 0
+  if (!noAssert) checkOffset(offset, 2, this.length)
+  return (this[offset] << 8) | this[offset + 1]
+}
+
+Buffer.prototype.readUint32LE =
+Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
+  offset = offset >>> 0
+  if (!noAssert) checkOffset(offset, 4, this.length)
+
+  return ((this[offset]) |
+      (this[offset + 1] << 8) |
+      (this[offset + 2] << 16)) +
+      (this[offset + 3] * 0x1000000)
+}
+
+Buffer.prototype.readUint32BE =
+Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
+  offset = offset >>> 0
+  if (!noAssert) checkOffset(offset, 4, this.length)
+
+  return (this[offset] * 0x1000000) +
+    ((this[offset + 1] << 16) |
+    (this[offset + 2] << 8) |
+    this[offset + 3])
+}
+
+Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {
+  offset = offset >>> 0
+  validateNumber(offset, 'offset')
+  const first = this[offset]
+  const last = this[offset + 7]
+  if (first === undefined || last === undefined) {
+    boundsError(offset, this.length - 8)
+  }
+
+  const lo = first +
+    this[++offset] * 2 ** 8 +
+    this[++offset] * 2 ** 16 +
+    this[++offset] * 2 ** 24
+
+  const hi = this[++offset] +
+    this[++offset] * 2 ** 8 +
+    this[++offset] * 2 ** 16 +
+    last * 2 ** 24
+
+  return BigInt(lo) + (BigInt(hi) << BigInt(32))
+})
+
+Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {
+  offset = offset >>> 0
+  validateNumber(offset, 'offset')
+  const first = this[offset]
+  const last = this[offset + 7]
+  if (first === undefined || last === undefined) {
+    boundsError(offset, this.length - 8)
+  }
+
+  const hi = first * 2 ** 24 +
+    this[++offset] * 2 ** 16 +
+    this[++offset] * 2 ** 8 +
+    this[++offset]
+
+  const lo = this[++offset] * 2 ** 24 +
+    this[++offset] * 2 ** 16 +
+    this[++offset] * 2 ** 8 +
+    last
+
+  return (BigInt(hi) << BigInt(32)) + BigInt(lo)
+})
+
+Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
+  offset = offset >>> 0
+  byteLength = byteLength >>> 0
+  if (!noAssert) checkOffset(offset, byteLength, this.length)
+
+  let val = this[offset]
+  let mul = 1
+  let i = 0
+  while (++i < byteLength && (mul *= 0x100)) {
+    val += this[offset + i] * mul
+  }
+  mul *= 0x80
+
+  if (val >= mul) val -= Math.pow(2, 8 * byteLength)
+
+  return val
+}
+
+Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
+  offset = offset >>> 0
+  byteLength = byteLength >>> 0
+  if (!noAssert) checkOffset(offset, byteLength, this.length)
+
+  let i = byteLength
+  let mul = 1
+  let val = this[offset + --i]
+  while (i > 0 && (mul *= 0x100)) {
+    val += this[offset + --i] * mul
+  }
+  mul *= 0x80
+
+  if (val >= mul) val -= Math.pow(2, 8 * byteLength)
+
+  return val
+}
+
+Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
+  offset = offset >>> 0
+  if (!noAssert) checkOffset(offset, 1, this.length)
+  if (!(this[offset] & 0x80)) return (this[offset])
+  return ((0xff - this[offset] + 1) * -1)
+}
+
+Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
+  offset = offset >>> 0
+  if (!noAssert) checkOffset(offset, 2, this.length)
+  const val = this[offset] | (this[offset + 1] << 8)
+  return (val & 0x8000) ? val | 0xFFFF0000 : val
+}
+
+Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
+  offset = offset >>> 0
+  if (!noAssert) checkOffset(offset, 2, this.length)
+  const val = this[offset + 1] | (this[offset] << 8)
+  return (val & 0x8000) ? val | 0xFFFF0000 : val
+}
+
+Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
+  offset = offset >>> 0
+  if (!noAssert) checkOffset(offset, 4, this.length)
+
+  return (this[offset]) |
+    (this[offset + 1] << 8) |
+    (this[offset + 2] << 16) |
+    (this[offset + 3] << 24)
+}
+
+Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
+  offset = offset >>> 0
+  if (!noAssert) checkOffset(offset, 4, this.length)
+
+  return (this[offset] << 24) |
+    (this[offset + 1] << 16) |
+    (this[offset + 2] << 8) |
+    (this[offset + 3])
+}
+
+Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {
+  offset = offset >>> 0
+  validateNumber(offset, 'offset')
+  const first = this[offset]
+  const last = this[offset + 7]
+  if (first === undefined || last === undefined) {
+    boundsError(offset, this.length - 8)
+  }
+
+  const val = this[offset + 4] +
+    this[offset + 5] * 2 ** 8 +
+    this[offset + 6] * 2 ** 16 +
+    (last << 24) // Overflow
+
+  return (BigInt(val) << BigInt(32)) +
+    BigInt(first +
+    this[++offset] * 2 ** 8 +
+    this[++offset] * 2 ** 16 +
+    this[++offset] * 2 ** 24)
+})
+
+Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {
+  offset = offset >>> 0
+  validateNumber(offset, 'offset')
+  const first = this[offset]
+  const last = this[offset + 7]
+  if (first === undefined || last === undefined) {
+    boundsError(offset, this.length - 8)
+  }
+
+  const val = (first << 24) + // Overflow
+    this[++offset] * 2 ** 16 +
+    this[++offset] * 2 ** 8 +
+    this[++offset]
+
+  return (BigInt(val) << BigInt(32)) +
+    BigInt(this[++offset] * 2 ** 24 +
+    this[++offset] * 2 ** 16 +
+    this[++offset] * 2 ** 8 +
+    last)
+})
+
+Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
+  offset = offset >>> 0
+  if (!noAssert) checkOffset(offset, 4, this.length)
+  return ieee754.read(this, offset, true, 23, 4)
+}
+
+Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
+  offset = offset >>> 0
+  if (!noAssert) checkOffset(offset, 4, this.length)
+  return ieee754.read(this, offset, false, 23, 4)
+}
+
+Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
+  offset = offset >>> 0
+  if (!noAssert) checkOffset(offset, 8, this.length)
+  return ieee754.read(this, offset, true, 52, 8)
+}
+
+Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
+  offset = offset >>> 0
+  if (!noAssert) checkOffset(offset, 8, this.length)
+  return ieee754.read(this, offset, false, 52, 8)
+}
+
+function checkInt (buf, value, offset, ext, max, min) {
+  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
+  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
+  if (offset + ext > buf.length) throw new RangeError('Index out of range')
+}
+
+Buffer.prototype.writeUintLE =
+Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
+  value = +value
+  offset = offset >>> 0
+  byteLength = byteLength >>> 0
+  if (!noAssert) {
+    const maxBytes = Math.pow(2, 8 * byteLength) - 1
+    checkInt(this, value, offset, byteLength, maxBytes, 0)
+  }
+
+  let mul = 1
+  let i = 0
+  this[offset] = value & 0xFF
+  while (++i < byteLength && (mul *= 0x100)) {
+    this[offset + i] = (value / mul) & 0xFF
+  }
+
+  return offset + byteLength
+}
+
+Buffer.prototype.writeUintBE =
+Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
+  value = +value
+  offset = offset >>> 0
+  byteLength = byteLength >>> 0
+  if (!noAssert) {
+    const maxBytes = Math.pow(2, 8 * byteLength) - 1
+    checkInt(this, value, offset, byteLength, maxBytes, 0)
+  }
+
+  let i = byteLength - 1
+  let mul = 1
+  this[offset + i] = value & 0xFF
+  while (--i >= 0 && (mul *= 0x100)) {
+    this[offset + i] = (value / mul) & 0xFF
+  }
+
+  return offset + byteLength
+}
+
+Buffer.prototype.writeUint8 =
+Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
+  value = +value
+  offset = offset >>> 0
+  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
+  this[offset] = (value & 0xff)
+  return offset + 1
+}
+
+Buffer.prototype.writeUint16LE =
+Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
+  value = +value
+  offset = offset >>> 0
+  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
+  this[offset] = (value & 0xff)
+  this[offset + 1] = (value >>> 8)
+  return offset + 2
+}
+
+Buffer.prototype.writeUint16BE =
+Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
+  value = +value
+  offset = offset >>> 0
+  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
+  this[offset] = (value >>> 8)
+  this[offset + 1] = (value & 0xff)
+  return offset + 2
+}
+
+Buffer.prototype.writeUint32LE =
+Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
+  value = +value
+  offset = offset >>> 0
+  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
+  this[offset + 3] = (value >>> 24)
+  this[offset + 2] = (value >>> 16)
+  this[offset + 1] = (value >>> 8)
+  this[offset] = (value & 0xff)
+  return offset + 4
+}
+
+Buffer.prototype.writeUint32BE =
+Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
+  value = +value
+  offset = offset >>> 0
+  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
+  this[offset] = (value >>> 24)
+  this[offset + 1] = (value >>> 16)
+  this[offset + 2] = (value >>> 8)
+  this[offset + 3] = (value & 0xff)
+  return offset + 4
+}
+
+function wrtBigUInt64LE (buf, value, offset, min, max) {
+  checkIntBI(value, min, max, buf, offset, 7)
+
+  let lo = Number(value & BigInt(0xffffffff))
+  buf[offset++] = lo
+  lo = lo >> 8
+  buf[offset++] = lo
+  lo = lo >> 8
+  buf[offset++] = lo
+  lo = lo >> 8
+  buf[offset++] = lo
+  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))
+  buf[offset++] = hi
+  hi = hi >> 8
+  buf[offset++] = hi
+  hi = hi >> 8
+  buf[offset++] = hi
+  hi = hi >> 8
+  buf[offset++] = hi
+  return offset
+}
+
+function wrtBigUInt64BE (buf, value, offset, min, max) {
+  checkIntBI(value, min, max, buf, offset, 7)
+
+  let lo = Number(value & BigInt(0xffffffff))
+  buf[offset + 7] = lo
+  lo = lo >> 8
+  buf[offset + 6] = lo
+  lo = lo >> 8
+  buf[offset + 5] = lo
+  lo = lo >> 8
+  buf[offset + 4] = lo
+  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))
+  buf[offset + 3] = hi
+  hi = hi >> 8
+  buf[offset + 2] = hi
+  hi = hi >> 8
+  buf[offset + 1] = hi
+  hi = hi >> 8
+  buf[offset] = hi
+  return offset + 8
+}
+
+Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {
+  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))
+})
+
+Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {
+  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))
+})
+
+Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
+  value = +value
+  offset = offset >>> 0
+  if (!noAssert) {
+    const limit = Math.pow(2, (8 * byteLength) - 1)
+
+    checkInt(this, value, offset, byteLength, limit - 1, -limit)
+  }
+
+  let i = 0
+  let mul = 1
+  let sub = 0
+  this[offset] = value & 0xFF
+  while (++i < byteLength && (mul *= 0x100)) {
+    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
+      sub = 1
+    }
+    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
+  }
+
+  return offset + byteLength
+}
+
+Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
+  value = +value
+  offset = offset >>> 0
+  if (!noAssert) {
+    const limit = Math.pow(2, (8 * byteLength) - 1)
+
+    checkInt(this, value, offset, byteLength, limit - 1, -limit)
+  }
+
+  let i = byteLength - 1
+  let mul = 1
+  let sub = 0
+  this[offset + i] = value & 0xFF
+  while (--i >= 0 && (mul *= 0x100)) {
+    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
+      sub = 1
+    }
+    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
+  }
+
+  return offset + byteLength
+}
+
+Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
+  value = +value
+  offset = offset >>> 0
+  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
+  if (value < 0) value = 0xff + value + 1
+  this[offset] = (value & 0xff)
+  return offset + 1
+}
+
+Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
+  value = +value
+  offset = offset >>> 0
+  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
+  this[offset] = (value & 0xff)
+  this[offset + 1] = (value >>> 8)
+  return offset + 2
+}
+
+Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
+  value = +value
+  offset = offset >>> 0
+  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
+  this[offset] = (value >>> 8)
+  this[offset + 1] = (value & 0xff)
+  return offset + 2
+}
+
+Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
+  value = +value
+  offset = offset >>> 0
+  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
+  this[offset] = (value & 0xff)
+  this[offset + 1] = (value >>> 8)
+  this[offset + 2] = (value >>> 16)
+  this[offset + 3] = (value >>> 24)
+  return offset + 4
+}
+
+Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
+  value = +value
+  offset = offset >>> 0
+  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
+  if (value < 0) value = 0xffffffff + value + 1
+  this[offset] = (value >>> 24)
+  this[offset + 1] = (value >>> 16)
+  this[offset + 2] = (value >>> 8)
+  this[offset + 3] = (value & 0xff)
+  return offset + 4
+}
+
+Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {
+  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
+})
+
+Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {
+  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
+})
+
+function checkIEEE754 (buf, value, offset, ext, max, min) {
+  if (offset + ext > buf.length) throw new RangeError('Index out of range')
+  if (offset < 0) throw new RangeError('Index out of range')
+}
+
+function writeFloat (buf, value, offset, littleEndian, noAssert) {
+  value = +value
+  offset = offset >>> 0
+  if (!noAssert) {
+    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
+  }
+  ieee754.write(buf, value, offset, littleEndian, 23, 4)
+  return offset + 4
+}
+
+Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
+  return writeFloat(this, value, offset, true, noAssert)
+}
+
+Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
+  return writeFloat(this, value, offset, false, noAssert)
+}
+
+function writeDouble (buf, value, offset, littleEndian, noAssert) {
+  value = +value
+  offset = offset >>> 0
+  if (!noAssert) {
+    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
+  }
+  ieee754.write(buf, value, offset, littleEndian, 52, 8)
+  return offset + 8
+}
+
+Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
+  return writeDouble(this, value, offset, true, noAssert)
+}
+
+Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
+  return writeDouble(this, value, offset, false, noAssert)
+}
+
+// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
+Buffer.prototype.copy = function copy (target, targetStart, start, end) {
+  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
+  if (!start) start = 0
+  if (!end && end !== 0) end = this.length
+  if (targetStart >= target.length) targetStart = target.length
+  if (!targetStart) targetStart = 0
+  if (end > 0 && end < start) end = start
+
+  // Copy 0 bytes; we're done
+  if (end === start) return 0
+  if (target.length === 0 || this.length === 0) return 0
+
+  // Fatal error conditions
+  if (targetStart < 0) {
+    throw new RangeError('targetStart out of bounds')
+  }
+  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
+  if (end < 0) throw new RangeError('sourceEnd out of bounds')
+
+  // Are we oob?
+  if (end > this.length) end = this.length
+  if (target.length - targetStart < end - start) {
+    end = target.length - targetStart + start
+  }
+
+  const len = end - start
+
+  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
+    // Use built-in when available, missing from IE11
+    this.copyWithin(targetStart, start, end)
+  } else {
+    Uint8Array.prototype.set.call(
+      target,
+      this.subarray(start, end),
+      targetStart
+    )
+  }
+
+  return len
+}
+
+// Usage:
+//    buffer.fill(number[, offset[, end]])
+//    buffer.fill(buffer[, offset[, end]])
+//    buffer.fill(string[, offset[, end]][, encoding])
+Buffer.prototype.fill = function fill (val, start, end, encoding) {
+  // Handle string cases:
+  if (typeof val === 'string') {
+    if (typeof start === 'string') {
+      encoding = start
+      start = 0
+      end = this.length
+    } else if (typeof end === 'string') {
+      encoding = end
+      end = this.length
+    }
+    if (encoding !== undefined && typeof encoding !== 'string') {
+      throw new TypeError('encoding must be a string')
+    }
+    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
+      throw new TypeError('Unknown encoding: ' + encoding)
+    }
+    if (val.length === 1) {
+      const code = val.charCodeAt(0)
+      if ((encoding === 'utf8' && code < 128) ||
+          encoding === 'latin1') {
+        // Fast path: If `val` fits into a single byte, use that numeric value.
+        val = code
+      }
+    }
+  } else if (typeof val === 'number') {
+    val = val & 255
+  } else if (typeof val === 'boolean') {
+    val = Number(val)
+  }
+
+  // Invalid ranges are not set to a default, so can range check early.
+  if (start < 0 || this.length < start || this.length < end) {
+    throw new RangeError('Out of range index')
+  }
+
+  if (end <= start) {
+    return this
+  }
+
+  start = start >>> 0
+  end = end === undefined ? this.length : end >>> 0
+
+  if (!val) val = 0
+
+  let i
+  if (typeof val === 'number') {
+    for (i = start; i < end; ++i) {
+      this[i] = val
+    }
+  } else {
+    const bytes = Buffer.isBuffer(val)
+      ? val
+      : Buffer.from(val, encoding)
+    const len = bytes.length
+    if (len === 0) {
+      throw new TypeError('The value "' + val +
+        '" is invalid for argument "value"')
+    }
+    for (i = 0; i < end - start; ++i) {
+      this[i + start] = bytes[i % len]
+    }
+  }
+
+  return this
+}
+
+// CUSTOM ERRORS
+// =============
+
+// Simplified versions from Node, changed for Buffer-only usage
+const errors = {}
+function E (sym, getMessage, Base) {
+  errors[sym] = class NodeError extends Base {
+    constructor () {
+      super()
+
+      Object.defineProperty(this, 'message', {
+        value: getMessage.apply(this, arguments),
+        writable: true,
+        configurable: true
+      })
+
+      // Add the error code to the name to include it in the stack trace.
+      this.name = `${this.name} [${sym}]`
+      // Access the stack to generate the error message including the error code
+      // from the name.
+      this.stack // eslint-disable-line no-unused-expressions
+      // Reset the name to the actual name.
+      delete this.name
+    }
+
+    get code () {
+      return sym
+    }
+
+    set code (value) {
+      Object.defineProperty(this, 'code', {
+        configurable: true,
+        enumerable: true,
+        value,
+        writable: true
+      })
+    }
+
+    toString () {
+      return `${this.name} [${sym}]: ${this.message}`
+    }
+  }
+}
+
+E('ERR_BUFFER_OUT_OF_BOUNDS',
+  function (name) {
+    if (name) {
+      return `${name} is outside of buffer bounds`
+    }
+
+    return 'Attempt to access memory outside buffer bounds'
+  }, RangeError)
+E('ERR_INVALID_ARG_TYPE',
+  function (name, actual) {
+    return `The "${name}" argument must be of type number. Received type ${typeof actual}`
+  }, TypeError)
+E('ERR_OUT_OF_RANGE',
+  function (str, range, input) {
+    let msg = `The value of "${str}" is out of range.`
+    let received = input
+    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
+      received = addNumericalSeparator(String(input))
+    } else if (typeof input === 'bigint') {
+      received = String(input)
+      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
+        received = addNumericalSeparator(received)
+      }
+      received += 'n'
+    }
+    msg += ` It must be ${range}. Received ${received}`
+    return msg
+  }, RangeError)
+
+function addNumericalSeparator (val) {
+  let res = ''
+  let i = val.length
+  const start = val[0] === '-' ? 1 : 0
+  for (; i >= start + 4; i -= 3) {
+    res = `_${val.slice(i - 3, i)}${res}`
+  }
+  return `${val.slice(0, i)}${res}`
+}
+
+// CHECK FUNCTIONS
+// ===============
+
+function checkBounds (buf, offset, byteLength) {
+  validateNumber(offset, 'offset')
+  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {
+    boundsError(offset, buf.length - (byteLength + 1))
+  }
+}
+
+function checkIntBI (value, min, max, buf, offset, byteLength) {
+  if (value > max || value < min) {
+    const n = typeof min === 'bigint' ? 'n' : ''
+    let range
+    if (byteLength > 3) {
+      if (min === 0 || min === BigInt(0)) {
+        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`
+      } else {
+        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +
+                `${(byteLength + 1) * 8 - 1}${n}`
+      }
+    } else {
+      range = `>= ${min}${n} and <= ${max}${n}`
+    }
+    throw new errors.ERR_OUT_OF_RANGE('value', range, value)
+  }
+  checkBounds(buf, offset, byteLength)
+}
+
+function validateNumber (value, name) {
+  if (typeof value !== 'number') {
+    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)
+  }
+}
+
+function boundsError (value, length, type) {
+  if (Math.floor(value) !== value) {
+    validateNumber(value, type)
+    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)
+  }
+
+  if (length < 0) {
+    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()
+  }
+
+  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',
+                                    `>= ${type ? 1 : 0} and <= ${length}`,
+                                    value)
+}
+
+// HELPER FUNCTIONS
+// ================
+
+const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g
+
+function base64clean (str) {
+  // Node takes equal signs as end of the Base64 encoding
+  str = str.split('=')[0]
+  // Node strips out invalid characters like \n and \t from the string, base64-js does not
+  str = str.trim().replace(INVALID_BASE64_RE, '')
+  // Node converts strings with length < 2 to ''
+  if (str.length < 2) return ''
+  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
+  while (str.length % 4 !== 0) {
+    str = str + '='
+  }
+  return str
+}
+
+function utf8ToBytes (string, units) {
+  units = units || Infinity
+  let codePoint
+  const length = string.length
+  let leadSurrogate = null
+  const bytes = []
+
+  for (let i = 0; i < length; ++i) {
+    codePoint = string.charCodeAt(i)
+
+    // is surrogate component
+    if (codePoint > 0xD7FF && codePoint < 0xE000) {
+      // last char was a lead
+      if (!leadSurrogate) {
+        // no lead yet
+        if (codePoint > 0xDBFF) {
+          // unexpected trail
+          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
+          continue
+        } else if (i + 1 === length) {
+          // unpaired lead
+          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
+          continue
+        }
+
+        // valid lead
+        leadSurrogate = codePoint
+
+        continue
+      }
+
+      // 2 leads in a row
+      if (codePoint < 0xDC00) {
+        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
+        leadSurrogate = codePoint
+        continue
+      }
+
+      // valid surrogate pair
+      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
+    } else if (leadSurrogate) {
+      // valid bmp char, but last char was a lead
+      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
+    }
+
+    leadSurrogate = null
+
+    // encode utf8
+    if (codePoint < 0x80) {
+      if ((units -= 1) < 0) break
+      bytes.push(codePoint)
+    } else if (codePoint < 0x800) {
+      if ((units -= 2) < 0) break
+      bytes.push(
+        codePoint >> 0x6 | 0xC0,
+        codePoint & 0x3F | 0x80
+      )
+    } else if (codePoint < 0x10000) {
+      if ((units -= 3) < 0) break
+      bytes.push(
+        codePoint >> 0xC | 0xE0,
+        codePoint >> 0x6 & 0x3F | 0x80,
+        codePoint & 0x3F | 0x80
+      )
+    } else if (codePoint < 0x110000) {
+      if ((units -= 4) < 0) break
+      bytes.push(
+        codePoint >> 0x12 | 0xF0,
+        codePoint >> 0xC & 0x3F | 0x80,
+        codePoint >> 0x6 & 0x3F | 0x80,
+        codePoint & 0x3F | 0x80
+      )
+    } else {
+      throw new Error('Invalid code point')
+    }
+  }
+
+  return bytes
+}
+
+function asciiToBytes (str) {
+  const byteArray = []
+  for (let i = 0; i < str.length; ++i) {
+    // Node's code seems to be doing this and not & 0x7F..
+    byteArray.push(str.charCodeAt(i) & 0xFF)
+  }
+  return byteArray
+}
+
+function utf16leToBytes (str, units) {
+  let c, hi, lo
+  const byteArray = []
+  for (let i = 0; i < str.length; ++i) {
+    if ((units -= 2) < 0) break
+
+    c = str.charCodeAt(i)
+    hi = c >> 8
+    lo = c % 256
+    byteArray.push(lo)
+    byteArray.push(hi)
+  }
+
+  return byteArray
+}
+
+function base64ToBytes (str) {
+  return base64.toByteArray(base64clean(str))
+}
+
+function blitBuffer (src, dst, offset, length) {
+  let i
+  for (i = 0; i < length; ++i) {
+    if ((i + offset >= dst.length) || (i >= src.length)) break
+    dst[i + offset] = src[i]
+  }
+  return i
+}
+
+// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
+// the `instanceof` check but they should be treated as of that type.
+// See: https://github.com/feross/buffer/issues/166
+function isInstance (obj, type) {
+  return obj instanceof type ||
+    (obj != null && obj.constructor != null && obj.constructor.name != null &&
+      obj.constructor.name === type.name)
+}
+function numberIsNaN (obj) {
+  // For IE11 support
+  return obj !== obj // eslint-disable-line no-self-compare
+}
+
+// Create lookup table for `toString('hex')`
+// See: https://github.com/feross/buffer/issues/219
+const hexSliceLookupTable = (function () {
+  const alphabet = '0123456789abcdef'
+  const table = new Array(256)
+  for (let i = 0; i < 16; ++i) {
+    const i16 = i * 16
+    for (let j = 0; j < 16; ++j) {
+      table[i16 + j] = alphabet[i] + alphabet[j]
+    }
+  }
+  return table
+})()
+
+// Return not function with Error if BigInt not supported
+function defineBigIntMethod (fn) {
+  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn
+}
+
+function BufferBigIntNotDefined () {
+  throw new Error('BigInt not supported')
+}
+
+
+/***/ }),
+
+/***/ 488:
+/***/ ((module) => {
+
+"use strict";
+// Copyright Joyent, Inc. and other Node contributors.
+//
+// Permission is hereby granted, free of charge, to any person obtaining a
+// copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to permit
+// persons to whom the Software is furnished to do so, subject to the
+// following conditions:
+//
+// The above copyright notice and this permission notice shall be included
+// in all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
+// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
+// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
+// USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+
+
+var R = typeof Reflect === 'object' ? Reflect : null
+var ReflectApply = R && typeof R.apply === 'function'
+  ? R.apply
+  : function ReflectApply(target, receiver, args) {
+    return Function.prototype.apply.call(target, receiver, args);
+  }
+
+var ReflectOwnKeys
+if (R && typeof R.ownKeys === 'function') {
+  ReflectOwnKeys = R.ownKeys
+} else if (Object.getOwnPropertySymbols) {
+  ReflectOwnKeys = function ReflectOwnKeys(target) {
+    return Object.getOwnPropertyNames(target)
+      .concat(Object.getOwnPropertySymbols(target));
+  };
+} else {
+  ReflectOwnKeys = function ReflectOwnKeys(target) {
+    return Object.getOwnPropertyNames(target);
+  };
+}
+
+function ProcessEmitWarning(warning) {
+  if (console && console.warn) console.warn(warning);
+}
+
+var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
+  return value !== value;
+}
+
+function EventEmitter() {
+  EventEmitter.init.call(this);
+}
+module.exports = EventEmitter;
+module.exports.once = once;
+
+// Backwards-compat with node 0.10.x
+EventEmitter.EventEmitter = EventEmitter;
+
+EventEmitter.prototype._events = undefined;
+EventEmitter.prototype._eventsCount = 0;
+EventEmitter.prototype._maxListeners = undefined;
+
+// By default EventEmitters will print a warning if more than 10 listeners are
+// added to it. This is a useful default which helps finding memory leaks.
+var defaultMaxListeners = 10;
+
+function checkListener(listener) {
+  if (typeof listener !== 'function') {
+    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
+  }
+}
+
+Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
+  enumerable: true,
+  get: function() {
+    return defaultMaxListeners;
+  },
+  set: function(arg) {
+    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
+      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
+    }
+    defaultMaxListeners = arg;
+  }
+});
+
+EventEmitter.init = function() {
+
+  if (this._events === undefined ||
+      this._events === Object.getPrototypeOf(this)._events) {
+    this._events = Object.create(null);
+    this._eventsCount = 0;
+  }
+
+  this._maxListeners = this._maxListeners || undefined;
+};
+
+// Obviously not all Emitters should be limited to 10. This function allows
+// that to be increased. Set to zero for unlimited.
+EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
+  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
+    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
+  }
+  this._maxListeners = n;
+  return this;
+};
+
+function _getMaxListeners(that) {
+  if (that._maxListeners === undefined)
+    return EventEmitter.defaultMaxListeners;
+  return that._maxListeners;
+}
+
+EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
+  return _getMaxListeners(this);
+};
+
+EventEmitter.prototype.emit = function emit(type) {
+  var args = [];
+  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
+  var doError = (type === 'error');
+
+  var events = this._events;
+  if (events !== undefined)
+    doError = (doError && events.error === undefined);
+  else if (!doError)
+    return false;
+
+  // If there is no 'error' event listener then throw.
+  if (doError) {
+    var er;
+    if (args.length > 0)
+      er = args[0];
+    if (er instanceof Error) {
+      // Note: The comments on the `throw` lines are intentional, they show
+      // up in Node's output if this results in an unhandled exception.
+      throw er; // Unhandled 'error' event
+    }
+    // At least give some kind of context to the user
+    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
+    err.context = er;
+    throw err; // Unhandled 'error' event
+  }
+
+  var handler = events[type];
+
+  if (handler === undefined)
+    return false;
+
+  if (typeof handler === 'function') {
+    ReflectApply(handler, this, args);
+  } else {
+    var len = handler.length;
+    var listeners = arrayClone(handler, len);
+    for (var i = 0; i < len; ++i)
+      ReflectApply(listeners[i], this, args);
+  }
+
+  return true;
+};
+
+function _addListener(target, type, listener, prepend) {
+  var m;
+  var events;
+  var existing;
+
+  checkListener(listener);
+
+  events = target._events;
+  if (events === undefined) {
+    events = target._events = Object.create(null);
+    target._eventsCount = 0;
+  } else {
+    // To avoid recursion in the case that type === "newListener"! Before
+    // adding it to the listeners, first emit "newListener".
+    if (events.newListener !== undefined) {
+      target.emit('newListener', type,
+                  listener.listener ? listener.listener : listener);
+
+      // Re-assign `events` because a newListener handler could have caused the
+      // this._events to be assigned to a new object
+      events = target._events;
+    }
+    existing = events[type];
+  }
+
+  if (existing === undefined) {
+    // Optimize the case of one listener. Don't need the extra array object.
+    existing = events[type] = listener;
+    ++target._eventsCount;
+  } else {
+    if (typeof existing === 'function') {
+      // Adding the second element, need to change to array.
+      existing = events[type] =
+        prepend ? [listener, existing] : [existing, listener];
+      // If we've already got an array, just append.
+    } else if (prepend) {
+      existing.unshift(listener);
+    } else {
+      existing.push(listener);
+    }
+
+    // Check for listener leak
+    m = _getMaxListeners(target);
+    if (m > 0 && existing.length > m && !existing.warned) {
+      existing.warned = true;
+      // No error code for this since it is a Warning
+      // eslint-disable-next-line no-restricted-syntax
+      var w = new Error('Possible EventEmitter memory leak detected. ' +
+                          existing.length + ' ' + String(type) + ' listeners ' +
+                          'added. Use emitter.setMaxListeners() to ' +
+                          'increase limit');
+      w.name = 'MaxListenersExceededWarning';
+      w.emitter = target;
+      w.type = type;
+      w.count = existing.length;
+      ProcessEmitWarning(w);
+    }
+  }
+
+  return target;
+}
+
+EventEmitter.prototype.addListener = function addListener(type, listener) {
+  return _addListener(this, type, listener, false);
+};
+
+EventEmitter.prototype.on = EventEmitter.prototype.addListener;
+
+EventEmitter.prototype.prependListener =
+    function prependListener(type, listener) {
+      return _addListener(this, type, listener, true);
+    };
+
+function onceWrapper() {
+  if (!this.fired) {
+    this.target.removeListener(this.type, this.wrapFn);
+    this.fired = true;
+    if (arguments.length === 0)
+      return this.listener.call(this.target);
+    return this.listener.apply(this.target, arguments);
+  }
+}
+
+function _onceWrap(target, type, listener) {
+  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
+  var wrapped = onceWrapper.bind(state);
+  wrapped.listener = listener;
+  state.wrapFn = wrapped;
+  return wrapped;
+}
+
+EventEmitter.prototype.once = function once(type, listener) {
+  checkListener(listener);
+  this.on(type, _onceWrap(this, type, listener));
+  return this;
+};
+
+EventEmitter.prototype.prependOnceListener =
+    function prependOnceListener(type, listener) {
+      checkListener(listener);
+      this.prependListener(type, _onceWrap(this, type, listener));
+      return this;
+    };
+
+// Emits a 'removeListener' event if and only if the listener was removed.
+EventEmitter.prototype.removeListener =
+    function removeListener(type, listener) {
+      var list, events, position, i, originalListener;
+
+      checkListener(listener);
+
+      events = this._events;
+      if (events === undefined)
+        return this;
+
+      list = events[type];
+      if (list === undefined)
+        return this;
+
+      if (list === listener || list.listener === listener) {
+        if (--this._eventsCount === 0)
+          this._events = Object.create(null);
+        else {
+          delete events[type];
+          if (events.removeListener)
+            this.emit('removeListener', type, list.listener || listener);
+        }
+      } else if (typeof list !== 'function') {
+        position = -1;
+
+        for (i = list.length - 1; i >= 0; i--) {
+          if (list[i] === listener || list[i].listener === listener) {
+            originalListener = list[i].listener;
+            position = i;
+            break;
+          }
+        }
+
+        if (position < 0)
+          return this;
+
+        if (position === 0)
+          list.shift();
+        else {
+          spliceOne(list, position);
+        }
+
+        if (list.length === 1)
+          events[type] = list[0];
+
+        if (events.removeListener !== undefined)
+          this.emit('removeListener', type, originalListener || listener);
+      }
+
+      return this;
+    };
+
+EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
+
+EventEmitter.prototype.removeAllListeners =
+    function removeAllListeners(type) {
+      var listeners, events, i;
+
+      events = this._events;
+      if (events === undefined)
+        return this;
+
+      // not listening for removeListener, no need to emit
+      if (events.removeListener === undefined) {
+        if (arguments.length === 0) {
+          this._events = Object.create(null);
+          this._eventsCount = 0;
+        } else if (events[type] !== undefined) {
+          if (--this._eventsCount === 0)
+            this._events = Object.create(null);
+          else
+            delete events[type];
+        }
+        return this;
+      }
+
+      // emit removeListener for all listeners on all events
+      if (arguments.length === 0) {
+        var keys = Object.keys(events);
+        var key;
+        for (i = 0; i < keys.length; ++i) {
+          key = keys[i];
+          if (key === 'removeListener') continue;
+          this.removeAllListeners(key);
+        }
+        this.removeAllListeners('removeListener');
+        this._events = Object.create(null);
+        this._eventsCount = 0;
+        return this;
+      }
+
+      listeners = events[type];
+
+      if (typeof listeners === 'function') {
+        this.removeListener(type, listeners);
+      } else if (listeners !== undefined) {
+        // LIFO order
+        for (i = listeners.length - 1; i >= 0; i--) {
+          this.removeListener(type, listeners[i]);
+        }
+      }
+
+      return this;
+    };
+
+function _listeners(target, type, unwrap) {
+  var events = target._events;
+
+  if (events === undefined)
+    return [];
+
+  var evlistener = events[type];
+  if (evlistener === undefined)
+    return [];
+
+  if (typeof evlistener === 'function')
+    return unwrap ? [evlistener.listener || evlistener] : [evlistener];
+
+  return unwrap ?
+    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
+}
+
+EventEmitter.prototype.listeners = function listeners(type) {
+  return _listeners(this, type, true);
+};
+
+EventEmitter.prototype.rawListeners = function rawListeners(type) {
+  return _listeners(this, type, false);
+};
+
+EventEmitter.listenerCount = function(emitter, type) {
+  if (typeof emitter.listenerCount === 'function') {
+    return emitter.listenerCount(type);
+  } else {
+    return listenerCount.call(emitter, type);
+  }
+};
+
+EventEmitter.prototype.listenerCount = listenerCount;
+function listenerCount(type) {
+  var events = this._events;
+
+  if (events !== undefined) {
+    var evlistener = events[type];
+
+    if (typeof evlistener === 'function') {
+      return 1;
+    } else if (evlistener !== undefined) {
+      return evlistener.length;
+    }
+  }
+
+  return 0;
+}
+
+EventEmitter.prototype.eventNames = function eventNames() {
+  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
+};
+
+function arrayClone(arr, n) {
+  var copy = new Array(n);
+  for (var i = 0; i < n; ++i)
+    copy[i] = arr[i];
+  return copy;
+}
+
+function spliceOne(list, index) {
+  for (; index + 1 < list.length; index++)
+    list[index] = list[index + 1];
+  list.pop();
+}
+
+function unwrapListeners(arr) {
+  var ret = new Array(arr.length);
+  for (var i = 0; i < ret.length; ++i) {
+    ret[i] = arr[i].listener || arr[i];
+  }
+  return ret;
+}
+
+function once(emitter, name) {
+  return new Promise(function (resolve, reject) {
+    function eventListener() {
+      if (errorListener !== undefined) {
+        emitter.removeListener('error', errorListener);
+      }
+      resolve([].slice.call(arguments));
+    };
+    var errorListener;
+
+    // Adding an error listener is not optional because
+    // if an error is thrown on an event emitter we cannot
+    // guarantee that the actual event we are waiting will
+    // be fired. The result could be a silent way to create
+    // memory or file descriptor leaks, which is something
+    // we should avoid.
+    if (name !== 'error') {
+      errorListener = function errorListener(err) {
+        emitter.removeListener(name, eventListener);
+        reject(err);
+      };
+
+      emitter.once('error', errorListener);
+    }
+
+    emitter.once(name, eventListener);
+  });
+}
+
+
+/***/ }),
+
+/***/ 9258:
+/***/ ((__unused_webpack_module, exports) => {
+
+/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
+exports.read = function (buffer, offset, isLE, mLen, nBytes) {
+  var e, m
+  var eLen = (nBytes * 8) - mLen - 1
+  var eMax = (1 << eLen) - 1
+  var eBias = eMax >> 1
+  var nBits = -7
+  var i = isLE ? (nBytes - 1) : 0
+  var d = isLE ? -1 : 1
+  var s = buffer[offset + i]
+
+  i += d
+
+  e = s & ((1 << (-nBits)) - 1)
+  s >>= (-nBits)
+  nBits += eLen
+  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}
+
+  m = e & ((1 << (-nBits)) - 1)
+  e >>= (-nBits)
+  nBits += mLen
+  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}
+
+  if (e === 0) {
+    e = 1 - eBias
+  } else if (e === eMax) {
+    return m ? NaN : ((s ? -1 : 1) * Infinity)
+  } else {
+    m = m + Math.pow(2, mLen)
+    e = e - eBias
+  }
+  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
+}
+
+exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
+  var e, m, c
+  var eLen = (nBytes * 8) - mLen - 1
+  var eMax = (1 << eLen) - 1
+  var eBias = eMax >> 1
+  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
+  var i = isLE ? 0 : (nBytes - 1)
+  var d = isLE ? 1 : -1
+  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0
+
+  value = Math.abs(value)
+
+  if (isNaN(value) || value === Infinity) {
+    m = isNaN(value) ? 1 : 0
+    e = eMax
+  } else {
+    e = Math.floor(Math.log(value) / Math.LN2)
+    if (value * (c = Math.pow(2, -e)) < 1) {
+      e--
+      c *= 2
+    }
+    if (e + eBias >= 1) {
+      value += rt / c
+    } else {
+      value += rt * Math.pow(2, 1 - eBias)
+    }
+    if (value * c >= 2) {
+      e++
+      c /= 2
+    }
+
+    if (e + eBias >= eMax) {
+      m = 0
+      e = eMax
+    } else if (e + eBias >= 1) {
+      m = ((value * c) - 1) * Math.pow(2, mLen)
+      e = e + eBias
+    } else {
+      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
+      e = 0
+    }
+  }
+
+  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}
+
+  e = (e << mLen) | m
+  eLen += mLen
+  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}
+
+  buffer[offset + i - d] |= s * 128
+}
+
+
+/***/ }),
+
+/***/ 3730:
+/***/ ((module) => {
+
+if (typeof Object.create === 'function') {
+  // implementation from standard node.js 'util' module
+  module.exports = function inherits(ctor, superCtor) {
+    if (superCtor) {
+      ctor.super_ = superCtor
+      ctor.prototype = Object.create(superCtor.prototype, {
+        constructor: {
+          value: ctor,
+          enumerable: false,
+          writable: true,
+          configurable: true
+        }
+      })
+    }
+  };
+} else {
+  // old school shim for old browsers
+  module.exports = function inherits(ctor, superCtor) {
+    if (superCtor) {
+      ctor.super_ = superCtor
+      var TempCtor = function () {}
+      TempCtor.prototype = superCtor.prototype
+      ctor.prototype = new TempCtor()
+      ctor.prototype.constructor = ctor
+    }
+  }
+}
+
+
+/***/ }),
+
+/***/ 6117:
+/***/ ((module) => {
+
+/**
+ * Helpers.
+ */
+
+var s = 1000;
+var m = s * 60;
+var h = m * 60;
+var d = h * 24;
+var w = d * 7;
+var y = d * 365.25;
+
+/**
+ * Parse or format the given `val`.
+ *
+ * Options:
+ *
+ *  - `long` verbose formatting [false]
+ *
+ * @param {String|Number} val
+ * @param {Object} [options]
+ * @throws {Error} throw an error if val is not a non-empty string or a number
+ * @return {String|Number}
+ * @api public
+ */
+
+module.exports = function(val, options) {
+  options = options || {};
+  var type = typeof val;
+  if (type === 'string' && val.length > 0) {
+    return parse(val);
+  } else if (type === 'number' && isFinite(val)) {
+    return options.long ? fmtLong(val) : fmtShort(val);
+  }
+  throw new Error(
+    'val is not a non-empty string or a valid number. val=' +
+      JSON.stringify(val)
+  );
+};
+
+/**
+ * Parse the given `str` and return milliseconds.
+ *
+ * @param {String} str
+ * @return {Number}
+ * @api private
+ */
+
+function parse(str) {
+  str = String(str);
+  if (str.length > 100) {
+    return;
+  }
+  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
+    str
+  );
+  if (!match) {
+    return;
+  }
+  var n = parseFloat(match[1]);
+  var type = (match[2] || 'ms').toLowerCase();
+  switch (type) {
+    case 'years':
+    case 'year':
+    case 'yrs':
+    case 'yr':
+    case 'y':
+      return n * y;
+    case 'weeks':
+    case 'week':
+    case 'w':
+      return n * w;
+    case 'days':
+    case 'day':
+    case 'd':
+      return n * d;
+    case 'hours':
+    case 'hour':
+    case 'hrs':
+    case 'hr':
+    case 'h':
+      return n * h;
+    case 'minutes':
+    case 'minute':
+    case 'mins':
+    case 'min':
+    case 'm':
+      return n * m;
+    case 'seconds':
+    case 'second':
+    case 'secs':
+    case 'sec':
+    case 's':
+      return n * s;
+    case 'milliseconds':
+    case 'millisecond':
+    case 'msecs':
+    case 'msec':
+    case 'ms':
+      return n;
+    default:
+      return undefined;
+  }
+}
+
+/**
+ * Short format for `ms`.
+ *
+ * @param {Number} ms
+ * @return {String}
+ * @api private
+ */
+
+function fmtShort(ms) {
+  var msAbs = Math.abs(ms);
+  if (msAbs >= d) {
+    return Math.round(ms / d) + 'd';
+  }
+  if (msAbs >= h) {
+    return Math.round(ms / h) + 'h';
+  }
+  if (msAbs >= m) {
+    return Math.round(ms / m) + 'm';
+  }
+  if (msAbs >= s) {
+    return Math.round(ms / s) + 's';
+  }
+  return ms + 'ms';
+}
+
+/**
+ * Long format for `ms`.
+ *
+ * @param {Number} ms
+ * @return {String}
+ * @api private
+ */
+
+function fmtLong(ms) {
+  var msAbs = Math.abs(ms);
+  if (msAbs >= d) {
+    return plural(ms, msAbs, d, 'day');
+  }
+  if (msAbs >= h) {
+    return plural(ms, msAbs, h, 'hour');
+  }
+  if (msAbs >= m) {
+    return plural(ms, msAbs, m, 'minute');
+  }
+  if (msAbs >= s) {
+    return plural(ms, msAbs, s, 'second');
+  }
+  return ms + ' ms';
+}
+
+/**
+ * Pluralization helper.
+ */
+
+function plural(ms, msAbs, n, name) {
+  var isPlural = msAbs >= n * 1.5;
+  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
+}
+
+
+/***/ }),
+
+/***/ 2695:
+/***/ ((module) => {
+
+// shim for using process in browser
+var process = module.exports = {};
+
+// cached from whatever global is present so that test runners that stub it
+// don't break things.  But we need to wrap it in a try catch in case it is
+// wrapped in strict mode code which doesn't define any globals.  It's inside a
+// function because try/catches deoptimize in certain engines.
+
+var cachedSetTimeout;
+var cachedClearTimeout;
+
+function defaultSetTimout() {
+    throw new Error('setTimeout has not been defined');
+}
+function defaultClearTimeout () {
+    throw new Error('clearTimeout has not been defined');
+}
+(function () {
+    try {
+        if (typeof setTimeout === 'function') {
+            cachedSetTimeout = setTimeout;
+        } else {
+            cachedSetTimeout = defaultSetTimout;
+        }
+    } catch (e) {
+        cachedSetTimeout = defaultSetTimout;
+    }
+    try {
+        if (typeof clearTimeout === 'function') {
+            cachedClearTimeout = clearTimeout;
+        } else {
+            cachedClearTimeout = defaultClearTimeout;
+        }
+    } catch (e) {
+        cachedClearTimeout = defaultClearTimeout;
+    }
+} ())
+function runTimeout(fun) {
+    if (cachedSetTimeout === setTimeout) {
+        //normal enviroments in sane situations
+        return setTimeout(fun, 0);
+    }
+    // if setTimeout wasn't available but was latter defined
+    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
+        cachedSetTimeout = setTimeout;
+        return setTimeout(fun, 0);
+    }
+    try {
+        // when when somebody has screwed with setTimeout but no I.E. maddness
+        return cachedSetTimeout(fun, 0);
+    } catch(e){
+        try {
+            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
+            return cachedSetTimeout.call(null, fun, 0);
+        } catch(e){
+            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
+            return cachedSetTimeout.call(this, fun, 0);
+        }
+    }
+
+
+}
+function runClearTimeout(marker) {
+    if (cachedClearTimeout === clearTimeout) {
+        //normal enviroments in sane situations
+        return clearTimeout(marker);
+    }
+    // if clearTimeout wasn't available but was latter defined
+    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
+        cachedClearTimeout = clearTimeout;
+        return clearTimeout(marker);
+    }
+    try {
+        // when when somebody has screwed with setTimeout but no I.E. maddness
+        return cachedClearTimeout(marker);
+    } catch (e){
+        try {
+            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
+            return cachedClearTimeout.call(null, marker);
+        } catch (e){
+            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
+            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
+            return cachedClearTimeout.call(this, marker);
+        }
+    }
+
+
+
+}
+var queue = [];
+var draining = false;
+var currentQueue;
+var queueIndex = -1;
+
+function cleanUpNextTick() {
+    if (!draining || !currentQueue) {
+        return;
+    }
+    draining = false;
+    if (currentQueue.length) {
+        queue = currentQueue.concat(queue);
+    } else {
+        queueIndex = -1;
+    }
+    if (queue.length) {
+        drainQueue();
+    }
+}
+
+function drainQueue() {
+    if (draining) {
+        return;
+    }
+    var timeout = runTimeout(cleanUpNextTick);
+    draining = true;
+
+    var len = queue.length;
+    while(len) {
+        currentQueue = queue;
+        queue = [];
+        while (++queueIndex < len) {
+            if (currentQueue) {
+                currentQueue[queueIndex].run();
+            }
+        }
+        queueIndex = -1;
+        len = queue.length;
+    }
+    currentQueue = null;
+    draining = false;
+    runClearTimeout(timeout);
+}
+
+process.nextTick = function (fun) {
+    var args = new Array(arguments.length - 1);
+    if (arguments.length > 1) {
+        for (var i = 1; i < arguments.length; i++) {
+            args[i - 1] = arguments[i];
+        }
+    }
+    queue.push(new Item(fun, args));
+    if (queue.length === 1 && !draining) {
+        runTimeout(drainQueue);
+    }
+};
+
+// v8 likes predictible objects
+function Item(fun, array) {
+    this.fun = fun;
+    this.array = array;
+}
+Item.prototype.run = function () {
+    this.fun.apply(null, this.array);
+};
+process.title = 'browser';
+process.browser = true;
+process.env = {};
+process.argv = [];
+process.version = ''; // empty string to avoid regexp issues
+process.versions = {};
+
+function noop() {}
+
+process.on = noop;
+process.addListener = noop;
+process.once = noop;
+process.off = noop;
+process.removeListener = noop;
+process.removeAllListeners = noop;
+process.emit = noop;
+process.prependListener = noop;
+process.prependOnceListener = noop;
+
+process.listeners = function (name) { return [] }
+
+process.binding = function (name) {
+    throw new Error('process.binding is not supported');
+};
+
+process.cwd = function () { return '/' };
+process.chdir = function (dir) {
+    throw new Error('process.chdir is not supported');
+};
+process.umask = function() { return 0; };
+
+
+/***/ }),
+
+/***/ 553:
+/***/ ((module) => {
+
+"use strict";
+
+
+function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }
+
+var codes = {};
+
+function createErrorType(code, message, Base) {
+  if (!Base) {
+    Base = Error;
+  }
+
+  function getMessage(arg1, arg2, arg3) {
+    if (typeof message === 'string') {
+      return message;
+    } else {
+      return message(arg1, arg2, arg3);
+    }
+  }
+
+  var NodeError =
+  /*#__PURE__*/
+  function (_Base) {
+    _inheritsLoose(NodeError, _Base);
+
+    function NodeError(arg1, arg2, arg3) {
+      return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
+    }
+
+    return NodeError;
+  }(Base);
+
+  NodeError.prototype.name = Base.name;
+  NodeError.prototype.code = code;
+  codes[code] = NodeError;
+} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js
+
+
+function oneOf(expected, thing) {
+  if (Array.isArray(expected)) {
+    var len = expected.length;
+    expected = expected.map(function (i) {
+      return String(i);
+    });
+
+    if (len > 2) {
+      return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
+    } else if (len === 2) {
+      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
+    } else {
+      return "of ".concat(thing, " ").concat(expected[0]);
+    }
+  } else {
+    return "of ".concat(thing, " ").concat(String(expected));
+  }
+} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith
+
+
+function startsWith(str, search, pos) {
+  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
+} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith
+
+
+function endsWith(str, search, this_len) {
+  if (this_len === undefined || this_len > str.length) {
+    this_len = str.length;
+  }
+
+  return str.substring(this_len - search.length, this_len) === search;
+} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes
+
+
+function includes(str, search, start) {
+  if (typeof start !== 'number') {
+    start = 0;
+  }
+
+  if (start + search.length > str.length) {
+    return false;
+  } else {
+    return str.indexOf(search, start) !== -1;
+  }
+}
+
+createErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {
+  return 'The value "' + value + '" is invalid for option "' + name + '"';
+}, TypeError);
+createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
+  // determiner: 'must be' or 'must not be'
+  var determiner;
+
+  if (typeof expected === 'string' && startsWith(expected, 'not ')) {
+    determiner = 'must not be';
+    expected = expected.replace(/^not /, '');
+  } else {
+    determiner = 'must be';
+  }
+
+  var msg;
+
+  if (endsWith(name, ' argument')) {
+    // For cases like 'first argument'
+    msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
+  } else {
+    var type = includes(name, '.') ? 'property' : 'argument';
+    msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
+  }
+
+  msg += ". Received type ".concat(typeof actual);
+  return msg;
+}, TypeError);
+createErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');
+createErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {
+  return 'The ' + name + ' method is not implemented';
+});
+createErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');
+createErrorType('ERR_STREAM_DESTROYED', function (name) {
+  return 'Cannot call ' + name + ' after a stream was destroyed';
+});
+createErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
+createErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');
+createErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');
+createErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
+createErrorType('ERR_UNKNOWN_ENCODING', function (arg) {
+  return 'Unknown encoding: ' + arg;
+}, TypeError);
+createErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');
+module.exports.q = codes;
+
+
+/***/ }),
+
+/***/ 673:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+/* provided dependency */ var process = __webpack_require__(2695);
+// Copyright Joyent, Inc. and other Node contributors.
+//
+// Permission is hereby granted, free of charge, to any person obtaining a
+// copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to permit
+// persons to whom the Software is furnished to do so, subject to the
+// following conditions:
+//
+// The above copyright notice and this permission notice shall be included
+// in all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
+// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
+// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
+// USE OR OTHER DEALINGS IN THE SOFTWARE.
+// a duplex stream is just a stream that is both readable and writable.
+// Since JS doesn't have multiple prototypal inheritance, this class
+// prototypally inherits from Readable, and then parasitically from
+// Writable.
+
+/*<replacement>*/
+
+var objectKeys = Object.keys || function (obj) {
+  var keys = [];
+
+  for (var key in obj) {
+    keys.push(key);
+  }
+
+  return keys;
+};
+/*</replacement>*/
+
+
+module.exports = Duplex;
+
+var Readable = __webpack_require__(5006);
+
+var Writable = __webpack_require__(8719);
+
+__webpack_require__(3730)(Duplex, Readable);
+
+{
+  // Allow the keys array to be GC'ed.
+  var keys = objectKeys(Writable.prototype);
+
+  for (var v = 0; v < keys.length; v++) {
+    var method = keys[v];
+    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
+  }
+}
+
+function Duplex(options) {
+  if (!(this instanceof Duplex)) return new Duplex(options);
+  Readable.call(this, options);
+  Writable.call(this, options);
+  this.allowHalfOpen = true;
+
+  if (options) {
+    if (options.readable === false) this.readable = false;
+    if (options.writable === false) this.writable = false;
+
+    if (options.allowHalfOpen === false) {
+      this.allowHalfOpen = false;
+      this.once('end', onend);
+    }
+  }
+}
+
+Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
+  // making it explicit this property is not enumerable
+  // because otherwise some prototype manipulation in
+  // userland will fail
+  enumerable: false,
+  get: function get() {
+    return this._writableState.highWaterMark;
+  }
+});
+Object.defineProperty(Duplex.prototype, 'writableBuffer', {
+  // making it explicit this property is not enumerable
+  // because otherwise some prototype manipulation in
+  // userland will fail
+  enumerable: false,
+  get: function get() {
+    return this._writableState && this._writableState.getBuffer();
+  }
+});
+Object.defineProperty(Duplex.prototype, 'writableLength', {
+  // making it explicit this property is not enumerable
+  // because otherwise some prototype manipulation in
+  // userland will fail
+  enumerable: false,
+  get: function get() {
+    return this._writableState.length;
+  }
+}); // the no-half-open enforcer
+
+function onend() {
+  // If the writable side ended, then we're ok.
+  if (this._writableState.ended) return; // no more data can be written.
+  // But allow more writes to happen in this tick.
+
+  process.nextTick(onEndNT, this);
+}
+
+function onEndNT(self) {
+  self.end();
+}
+
+Object.defineProperty(Duplex.prototype, 'destroyed', {
+  // making it explicit this property is not enumerable
+  // because otherwise some prototype manipulation in
+  // userland will fail
+  enumerable: false,
+  get: function get() {
+    if (this._readableState === undefined || this._writableState === undefined) {
+      return false;
+    }
+
+    return this._readableState.destroyed && this._writableState.destroyed;
+  },
+  set: function set(value) {
+    // we ignore the value if the stream
+    // has not been initialized yet
+    if (this._readableState === undefined || this._writableState === undefined) {
+      return;
+    } // backward compatibility, the user is explicitly
+    // managing destroyed
+
+
+    this._readableState.destroyed = value;
+    this._writableState.destroyed = value;
+  }
+});
+
+/***/ }),
+
+/***/ 4343:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+// Copyright Joyent, Inc. and other Node contributors.
+//
+// Permission is hereby granted, free of charge, to any person obtaining a
+// copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to permit
+// persons to whom the Software is furnished to do so, subject to the
+// following conditions:
+//
+// The above copyright notice and this permission notice shall be included
+// in all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
+// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
+// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
+// USE OR OTHER DEALINGS IN THE SOFTWARE.
+// a passthrough stream.
+// basically just the most minimal sort of Transform stream.
+// Every written chunk gets output as-is.
+
+
+module.exports = PassThrough;
+
+var Transform = __webpack_require__(8597);
+
+__webpack_require__(3730)(PassThrough, Transform);
+
+function PassThrough(options) {
+  if (!(this instanceof PassThrough)) return new PassThrough(options);
+  Transform.call(this, options);
+}
+
+PassThrough.prototype._transform = function (chunk, encoding, cb) {
+  cb(null, chunk);
+};
+
+/***/ }),
+
+/***/ 5006:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+/* provided dependency */ var process = __webpack_require__(2695);
+// Copyright Joyent, Inc. and other Node contributors.
+//
+// Permission is hereby granted, free of charge, to any person obtaining a
+// copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to permit
+// persons to whom the Software is furnished to do so, subject to the
+// following conditions:
+//
+// The above copyright notice and this permission notice shall be included
+// in all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
+// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
+// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
+// USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+
+module.exports = Readable;
+/*<replacement>*/
+
+var Duplex;
+/*</replacement>*/
+
+Readable.ReadableState = ReadableState;
+/*<replacement>*/
+
+var EE = __webpack_require__(488).EventEmitter;
+
+var EElistenerCount = function EElistenerCount(emitter, type) {
+  return emitter.listeners(type).length;
+};
+/*</replacement>*/
+
+/*<replacement>*/
+
+
+var Stream = __webpack_require__(8208);
+/*</replacement>*/
+
+
+var Buffer = __webpack_require__(7866).Buffer;
+
+var OurUint8Array = __webpack_require__.g.Uint8Array || function () {};
+
+function _uint8ArrayToBuffer(chunk) {
+  return Buffer.from(chunk);
+}
+
+function _isUint8Array(obj) {
+  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
+}
+/*<replacement>*/
+
+
+var debugUtil = __webpack_require__(6029);
+
+var debug;
+
+if (debugUtil && debugUtil.debuglog) {
+  debug = debugUtil.debuglog('stream');
+} else {
+  debug = function debug() {};
+}
+/*</replacement>*/
+
+
+var BufferList = __webpack_require__(4506);
+
+var destroyImpl = __webpack_require__(3390);
+
+var _require = __webpack_require__(1111),
+    getHighWaterMark = _require.getHighWaterMark;
+
+var _require$codes = __webpack_require__(553)/* .codes */ .q,
+    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
+    ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,
+    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
+    ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; // Lazy loaded to improve the startup performance.
+
+
+var StringDecoder;
+var createReadableStreamAsyncIterator;
+var from;
+
+__webpack_require__(3730)(Readable, Stream);
+
+var errorOrDestroy = destroyImpl.errorOrDestroy;
+var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];
+
+function prependListener(emitter, event, fn) {
+  // Sadly this is not cacheable as some libraries bundle their own
+  // event emitter implementation with them.
+  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any
+  // userland ones.  NEVER DO THIS. This is here only because this code needs
+  // to continue to work with older versions of Node.js that do not include
+  // the prependListener() method. The goal is to eventually remove this hack.
+
+  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
+}
+
+function ReadableState(options, stream, isDuplex) {
+  Duplex = Duplex || __webpack_require__(673);
+  options = options || {}; // Duplex streams are both readable and writable, but share
+  // the same options object.
+  // However, some cases require setting options to different
+  // values for the readable and the writable sides of the duplex stream.
+  // These options can be provided separately as readableXXX and writableXXX.
+
+  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to
+  // make all the buffer merging and length checks go away
+
+  this.objectMode = !!options.objectMode;
+  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer
+  // Note: 0 is a valid value, means "don't call _read preemptively ever"
+
+  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the
+  // linked list can remove elements from the beginning faster than
+  // array.shift()
+
+  this.buffer = new BufferList();
+  this.length = 0;
+  this.pipes = null;
+  this.pipesCount = 0;
+  this.flowing = null;
+  this.ended = false;
+  this.endEmitted = false;
+  this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted
+  // immediately, or on a later tick.  We set this to true at first, because
+  // any actions that shouldn't happen until "later" should generally also
+  // not happen before the first read call.
+
+  this.sync = true; // whenever we return null, then we set a flag to say
+  // that we're awaiting a 'readable' event emission.
+
+  this.needReadable = false;
+  this.emittedReadable = false;
+  this.readableListening = false;
+  this.resumeScheduled = false;
+  this.paused = true; // Should close be emitted on destroy. Defaults to true.
+
+  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'end' (and potentially 'finish')
+
+  this.autoDestroy = !!options.autoDestroy; // has it been destroyed
+
+  this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string
+  // encoding is 'binary' so we have to make this configurable.
+  // Everything else in the universe uses 'utf8', though.
+
+  this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s
+
+  this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled
+
+  this.readingMore = false;
+  this.decoder = null;
+  this.encoding = null;
+
+  if (options.encoding) {
+    if (!StringDecoder) StringDecoder = __webpack_require__(9481)/* .StringDecoder */ .s;
+    this.decoder = new StringDecoder(options.encoding);
+    this.encoding = options.encoding;
+  }
+}
+
+function Readable(options) {
+  Duplex = Duplex || __webpack_require__(673);
+  if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside
+  // the ReadableState constructor, at least with V8 6.5
+
+  var isDuplex = this instanceof Duplex;
+  this._readableState = new ReadableState(options, this, isDuplex); // legacy
+
+  this.readable = true;
+
+  if (options) {
+    if (typeof options.read === 'function') this._read = options.read;
+    if (typeof options.destroy === 'function') this._destroy = options.destroy;
+  }
+
+  Stream.call(this);
+}
+
+Object.defineProperty(Readable.prototype, 'destroyed', {
+  // making it explicit this property is not enumerable
+  // because otherwise some prototype manipulation in
+  // userland will fail
+  enumerable: false,
+  get: function get() {
+    if (this._readableState === undefined) {
+      return false;
+    }
+
+    return this._readableState.destroyed;
+  },
+  set: function set(value) {
+    // we ignore the value if the stream
+    // has not been initialized yet
+    if (!this._readableState) {
+      return;
+    } // backward compatibility, the user is explicitly
+    // managing destroyed
+
+
+    this._readableState.destroyed = value;
+  }
+});
+Readable.prototype.destroy = destroyImpl.destroy;
+Readable.prototype._undestroy = destroyImpl.undestroy;
+
+Readable.prototype._destroy = function (err, cb) {
+  cb(err);
+}; // Manually shove something into the read() buffer.
+// This returns true if the highWaterMark has not been hit yet,
+// similar to how Writable.write() returns true if you should
+// write() some more.
+
+
+Readable.prototype.push = function (chunk, encoding) {
+  var state = this._readableState;
+  var skipChunkCheck;
+
+  if (!state.objectMode) {
+    if (typeof chunk === 'string') {
+      encoding = encoding || state.defaultEncoding;
+
+      if (encoding !== state.encoding) {
+        chunk = Buffer.from(chunk, encoding);
+        encoding = '';
+      }
+
+      skipChunkCheck = true;
+    }
+  } else {
+    skipChunkCheck = true;
+  }
+
+  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
+}; // Unshift should *always* be something directly out of read()
+
+
+Readable.prototype.unshift = function (chunk) {
+  return readableAddChunk(this, chunk, null, true, false);
+};
+
+function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
+  debug('readableAddChunk', chunk);
+  var state = stream._readableState;
+
+  if (chunk === null) {
+    state.reading = false;
+    onEofChunk(stream, state);
+  } else {
+    var er;
+    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
+
+    if (er) {
+      errorOrDestroy(stream, er);
+    } else if (state.objectMode || chunk && chunk.length > 0) {
+      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
+        chunk = _uint8ArrayToBuffer(chunk);
+      }
+
+      if (addToFront) {
+        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);
+      } else if (state.ended) {
+        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
+      } else if (state.destroyed) {
+        return false;
+      } else {
+        state.reading = false;
+
+        if (state.decoder && !encoding) {
+          chunk = state.decoder.write(chunk);
+          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
+        } else {
+          addChunk(stream, state, chunk, false);
+        }
+      }
+    } else if (!addToFront) {
+      state.reading = false;
+      maybeReadMore(stream, state);
+    }
+  } // We can push more data if we are below the highWaterMark.
+  // Also, if we have no data yet, we can stand some more bytes.
+  // This is to work around cases where hwm=0, such as the repl.
+
+
+  return !state.ended && (state.length < state.highWaterMark || state.length === 0);
+}
+
+function addChunk(stream, state, chunk, addToFront) {
+  if (state.flowing && state.length === 0 && !state.sync) {
+    state.awaitDrain = 0;
+    stream.emit('data', chunk);
+  } else {
+    // update the buffer info.
+    state.length += state.objectMode ? 1 : chunk.length;
+    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
+    if (state.needReadable) emitReadable(stream);
+  }
+
+  maybeReadMore(stream, state);
+}
+
+function chunkInvalid(state, chunk) {
+  var er;
+
+  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
+    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
+  }
+
+  return er;
+}
+
+Readable.prototype.isPaused = function () {
+  return this._readableState.flowing === false;
+}; // backwards compatibility.
+
+
+Readable.prototype.setEncoding = function (enc) {
+  if (!StringDecoder) StringDecoder = __webpack_require__(9481)/* .StringDecoder */ .s;
+  var decoder = new StringDecoder(enc);
+  this._readableState.decoder = decoder; // If setEncoding(null), decoder.encoding equals utf8
+
+  this._readableState.encoding = this._readableState.decoder.encoding; // Iterate over current buffer to convert already stored Buffers:
+
+  var p = this._readableState.buffer.head;
+  var content = '';
+
+  while (p !== null) {
+    content += decoder.write(p.data);
+    p = p.next;
+  }
+
+  this._readableState.buffer.clear();
+
+  if (content !== '') this._readableState.buffer.push(content);
+  this._readableState.length = content.length;
+  return this;
+}; // Don't raise the hwm > 1GB
+
+
+var MAX_HWM = 0x40000000;
+
+function computeNewHighWaterMark(n) {
+  if (n >= MAX_HWM) {
+    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
+    n = MAX_HWM;
+  } else {
+    // Get the next highest power of 2 to prevent increasing hwm excessively in
+    // tiny amounts
+    n--;
+    n |= n >>> 1;
+    n |= n >>> 2;
+    n |= n >>> 4;
+    n |= n >>> 8;
+    n |= n >>> 16;
+    n++;
+  }
+
+  return n;
+} // This function is designed to be inlinable, so please take care when making
+// changes to the function body.
+
+
+function howMuchToRead(n, state) {
+  if (n <= 0 || state.length === 0 && state.ended) return 0;
+  if (state.objectMode) return 1;
+
+  if (n !== n) {
+    // Only flow one buffer at a time
+    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
+  } // If we're asking for more than the current hwm, then raise the hwm.
+
+
+  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
+  if (n <= state.length) return n; // Don't have enough
+
+  if (!state.ended) {
+    state.needReadable = true;
+    return 0;
+  }
+
+  return state.length;
+} // you can override either this method, or the async _read(n) below.
+
+
+Readable.prototype.read = function (n) {
+  debug('read', n);
+  n = parseInt(n, 10);
+  var state = this._readableState;
+  var nOrig = n;
+  if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we
+  // already have a bunch of data in the buffer, then just trigger
+  // the 'readable' event and move on.
+
+  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
+    debug('read: emitReadable', state.length, state.ended);
+    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
+    return null;
+  }
+
+  n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.
+
+  if (n === 0 && state.ended) {
+    if (state.length === 0) endReadable(this);
+    return null;
+  } // All the actual chunk generation logic needs to be
+  // *below* the call to _read.  The reason is that in certain
+  // synthetic stream cases, such as passthrough streams, _read
+  // may be a completely synchronous operation which may change
+  // the state of the read buffer, providing enough data when
+  // before there was *not* enough.
+  //
+  // So, the steps are:
+  // 1. Figure out what the state of things will be after we do
+  // a read from the buffer.
+  //
+  // 2. If that resulting state will trigger a _read, then call _read.
+  // Note that this may be asynchronous, or synchronous.  Yes, it is
+  // deeply ugly to write APIs this way, but that still doesn't mean
+  // that the Readable class should behave improperly, as streams are
+  // designed to be sync/async agnostic.
+  // Take note if the _read call is sync or async (ie, if the read call
+  // has returned yet), so that we know whether or not it's safe to emit
+  // 'readable' etc.
+  //
+  // 3. Actually pull the requested chunks out of the buffer and return.
+  // if we need a readable event, then we need to do some reading.
+
+
+  var doRead = state.needReadable;
+  debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some
+
+  if (state.length === 0 || state.length - n < state.highWaterMark) {
+    doRead = true;
+    debug('length less than watermark', doRead);
+  } // however, if we've ended, then there's no point, and if we're already
+  // reading, then it's unnecessary.
+
+
+  if (state.ended || state.reading) {
+    doRead = false;
+    debug('reading or ended', doRead);
+  } else if (doRead) {
+    debug('do read');
+    state.reading = true;
+    state.sync = true; // if the length is currently zero, then we *need* a readable event.
+
+    if (state.length === 0) state.needReadable = true; // call internal read method
+
+    this._read(state.highWaterMark);
+
+    state.sync = false; // If _read pushed data synchronously, then `reading` will be false,
+    // and we need to re-evaluate how much data we can return to the user.
+
+    if (!state.reading) n = howMuchToRead(nOrig, state);
+  }
+
+  var ret;
+  if (n > 0) ret = fromList(n, state);else ret = null;
+
+  if (ret === null) {
+    state.needReadable = state.length <= state.highWaterMark;
+    n = 0;
+  } else {
+    state.length -= n;
+    state.awaitDrain = 0;
+  }
+
+  if (state.length === 0) {
+    // If we have nothing in the buffer, then we want to know
+    // as soon as we *do* get something into the buffer.
+    if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.
+
+    if (nOrig !== n && state.ended) endReadable(this);
+  }
+
+  if (ret !== null) this.emit('data', ret);
+  return ret;
+};
+
+function onEofChunk(stream, state) {
+  debug('onEofChunk');
+  if (state.ended) return;
+
+  if (state.decoder) {
+    var chunk = state.decoder.end();
+
+    if (chunk && chunk.length) {
+      state.buffer.push(chunk);
+      state.length += state.objectMode ? 1 : chunk.length;
+    }
+  }
+
+  state.ended = true;
+
+  if (state.sync) {
+    // if we are sync, wait until next tick to emit the data.
+    // Otherwise we risk emitting data in the flow()
+    // the readable code triggers during a read() call
+    emitReadable(stream);
+  } else {
+    // emit 'readable' now to make sure it gets picked up.
+    state.needReadable = false;
+
+    if (!state.emittedReadable) {
+      state.emittedReadable = true;
+      emitReadable_(stream);
+    }
+  }
+} // Don't emit readable right away in sync mode, because this can trigger
+// another read() call => stack overflow.  This way, it might trigger
+// a nextTick recursion warning, but that's not so bad.
+
+
+function emitReadable(stream) {
+  var state = stream._readableState;
+  debug('emitReadable', state.needReadable, state.emittedReadable);
+  state.needReadable = false;
+
+  if (!state.emittedReadable) {
+    debug('emitReadable', state.flowing);
+    state.emittedReadable = true;
+    process.nextTick(emitReadable_, stream);
+  }
+}
+
+function emitReadable_(stream) {
+  var state = stream._readableState;
+  debug('emitReadable_', state.destroyed, state.length, state.ended);
+
+  if (!state.destroyed && (state.length || state.ended)) {
+    stream.emit('readable');
+    state.emittedReadable = false;
+  } // The stream needs another readable event if
+  // 1. It is not flowing, as the flow mechanism will take
+  //    care of it.
+  // 2. It is not ended.
+  // 3. It is below the highWaterMark, so we can schedule
+  //    another readable later.
+
+
+  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
+  flow(stream);
+} // at this point, the user has presumably seen the 'readable' event,
+// and called read() to consume some data.  that may have triggered
+// in turn another _read(n) call, in which case reading = true if
+// it's in progress.
+// However, if we're not ended, or reading, and the length < hwm,
+// then go ahead and try to read some more preemptively.
+
+
+function maybeReadMore(stream, state) {
+  if (!state.readingMore) {
+    state.readingMore = true;
+    process.nextTick(maybeReadMore_, stream, state);
+  }
+}
+
+function maybeReadMore_(stream, state) {
+  // Attempt to read more data if we should.
+  //
+  // The conditions for reading more data are (one of):
+  // - Not enough data buffered (state.length < state.highWaterMark). The loop
+  //   is responsible for filling the buffer with enough data if such data
+  //   is available. If highWaterMark is 0 and we are not in the flowing mode
+  //   we should _not_ attempt to buffer any extra data. We'll get more data
+  //   when the stream consumer calls read() instead.
+  // - No data in the buffer, and the stream is in flowing mode. In this mode
+  //   the loop below is responsible for ensuring read() is called. Failing to
+  //   call read here would abort the flow and there's no other mechanism for
+  //   continuing the flow if the stream consumer has just subscribed to the
+  //   'data' event.
+  //
+  // In addition to the above conditions to keep reading data, the following
+  // conditions prevent the data from being read:
+  // - The stream has ended (state.ended).
+  // - There is already a pending 'read' operation (state.reading). This is a
+  //   case where the the stream has called the implementation defined _read()
+  //   method, but they are processing the call asynchronously and have _not_
+  //   called push() with new data. In this case we skip performing more
+  //   read()s. The execution ends in this method again after the _read() ends
+  //   up calling push() with more data.
+  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
+    var len = state.length;
+    debug('maybeReadMore read 0');
+    stream.read(0);
+    if (len === state.length) // didn't get any data, stop spinning.
+      break;
+  }
+
+  state.readingMore = false;
+} // abstract method.  to be overridden in specific implementation classes.
+// call cb(er, data) where data is <= n in length.
+// for virtual (non-string, non-buffer) streams, "length" is somewhat
+// arbitrary, and perhaps not very meaningful.
+
+
+Readable.prototype._read = function (n) {
+  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));
+};
+
+Readable.prototype.pipe = function (dest, pipeOpts) {
+  var src = this;
+  var state = this._readableState;
+
+  switch (state.pipesCount) {
+    case 0:
+      state.pipes = dest;
+      break;
+
+    case 1:
+      state.pipes = [state.pipes, dest];
+      break;
+
+    default:
+      state.pipes.push(dest);
+      break;
+  }
+
+  state.pipesCount += 1;
+  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
+  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
+  var endFn = doEnd ? onend : unpipe;
+  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);
+  dest.on('unpipe', onunpipe);
+
+  function onunpipe(readable, unpipeInfo) {
+    debug('onunpipe');
+
+    if (readable === src) {
+      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
+        unpipeInfo.hasUnpiped = true;
+        cleanup();
+      }
+    }
+  }
+
+  function onend() {
+    debug('onend');
+    dest.end();
+  } // when the dest drains, it reduces the awaitDrain counter
+  // on the source.  This would be more elegant with a .once()
+  // handler in flow(), but adding and removing repeatedly is
+  // too slow.
+
+
+  var ondrain = pipeOnDrain(src);
+  dest.on('drain', ondrain);
+  var cleanedUp = false;
+
+  function cleanup() {
+    debug('cleanup'); // cleanup event handlers once the pipe is broken
+
+    dest.removeListener('close', onclose);
+    dest.removeListener('finish', onfinish);
+    dest.removeListener('drain', ondrain);
+    dest.removeListener('error', onerror);
+    dest.removeListener('unpipe', onunpipe);
+    src.removeListener('end', onend);
+    src.removeListener('end', unpipe);
+    src.removeListener('data', ondata);
+    cleanedUp = true; // if the reader is waiting for a drain event from this
+    // specific writer, then it would cause it to never start
+    // flowing again.
+    // So, if this is awaiting a drain, then we just call it now.
+    // If we don't know, then assume that we are waiting for one.
+
+    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
+  }
+
+  src.on('data', ondata);
+
+  function ondata(chunk) {
+    debug('ondata');
+    var ret = dest.write(chunk);
+    debug('dest.write', ret);
+
+    if (ret === false) {
+      // If the user unpiped during `dest.write()`, it is possible
+      // to get stuck in a permanently paused state if that write
+      // also returned false.
+      // => Check whether `dest` is still a piping destination.
+      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
+        debug('false write response, pause', state.awaitDrain);
+        state.awaitDrain++;
+      }
+
+      src.pause();
+    }
+  } // if the dest has an error, then stop piping into it.
+  // however, don't suppress the throwing behavior for this.
+
+
+  function onerror(er) {
+    debug('onerror', er);
+    unpipe();
+    dest.removeListener('error', onerror);
+    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);
+  } // Make sure our error handler is attached before userland ones.
+
+
+  prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.
+
+  function onclose() {
+    dest.removeListener('finish', onfinish);
+    unpipe();
+  }
+
+  dest.once('close', onclose);
+
+  function onfinish() {
+    debug('onfinish');
+    dest.removeListener('close', onclose);
+    unpipe();
+  }
+
+  dest.once('finish', onfinish);
+
+  function unpipe() {
+    debug('unpipe');
+    src.unpipe(dest);
+  } // tell the dest that it's being piped to
+
+
+  dest.emit('pipe', src); // start the flow if it hasn't been started already.
+
+  if (!state.flowing) {
+    debug('pipe resume');
+    src.resume();
+  }
+
+  return dest;
+};
+
+function pipeOnDrain(src) {
+  return function pipeOnDrainFunctionResult() {
+    var state = src._readableState;
+    debug('pipeOnDrain', state.awaitDrain);
+    if (state.awaitDrain) state.awaitDrain--;
+
+    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
+      state.flowing = true;
+      flow(src);
+    }
+  };
+}
+
+Readable.prototype.unpipe = function (dest) {
+  var state = this._readableState;
+  var unpipeInfo = {
+    hasUnpiped: false
+  }; // if we're not piping anywhere, then do nothing.
+
+  if (state.pipesCount === 0) return this; // just one destination.  most common case.
+
+  if (state.pipesCount === 1) {
+    // passed in one, but it's not the right one.
+    if (dest && dest !== state.pipes) return this;
+    if (!dest) dest = state.pipes; // got a match.
+
+    state.pipes = null;
+    state.pipesCount = 0;
+    state.flowing = false;
+    if (dest) dest.emit('unpipe', this, unpipeInfo);
+    return this;
+  } // slow case. multiple pipe destinations.
+
+
+  if (!dest) {
+    // remove all.
+    var dests = state.pipes;
+    var len = state.pipesCount;
+    state.pipes = null;
+    state.pipesCount = 0;
+    state.flowing = false;
+
+    for (var i = 0; i < len; i++) {
+      dests[i].emit('unpipe', this, {
+        hasUnpiped: false
+      });
+    }
+
+    return this;
+  } // try to find the right one.
+
+
+  var index = indexOf(state.pipes, dest);
+  if (index === -1) return this;
+  state.pipes.splice(index, 1);
+  state.pipesCount -= 1;
+  if (state.pipesCount === 1) state.pipes = state.pipes[0];
+  dest.emit('unpipe', this, unpipeInfo);
+  return this;
+}; // set up data events if they are asked for
+// Ensure readable listeners eventually get something
+
+
+Readable.prototype.on = function (ev, fn) {
+  var res = Stream.prototype.on.call(this, ev, fn);
+  var state = this._readableState;
+
+  if (ev === 'data') {
+    // update readableListening so that resume() may be a no-op
+    // a few lines down. This is needed to support once('readable').
+    state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused
+
+    if (state.flowing !== false) this.resume();
+  } else if (ev === 'readable') {
+    if (!state.endEmitted && !state.readableListening) {
+      state.readableListening = state.needReadable = true;
+      state.flowing = false;
+      state.emittedReadable = false;
+      debug('on readable', state.length, state.reading);
+
+      if (state.length) {
+        emitReadable(this);
+      } else if (!state.reading) {
+        process.nextTick(nReadingNextTick, this);
+      }
+    }
+  }
+
+  return res;
+};
+
+Readable.prototype.addListener = Readable.prototype.on;
+
+Readable.prototype.removeListener = function (ev, fn) {
+  var res = Stream.prototype.removeListener.call(this, ev, fn);
+
+  if (ev === 'readable') {
+    // We need to check if there is someone still listening to
+    // readable and reset the state. However this needs to happen
+    // after readable has been emitted but before I/O (nextTick) to
+    // support once('readable', fn) cycles. This means that calling
+    // resume within the same tick will have no
+    // effect.
+    process.nextTick(updateReadableListening, this);
+  }
+
+  return res;
+};
+
+Readable.prototype.removeAllListeners = function (ev) {
+  var res = Stream.prototype.removeAllListeners.apply(this, arguments);
+
+  if (ev === 'readable' || ev === undefined) {
+    // We need to check if there is someone still listening to
+    // readable and reset the state. However this needs to happen
+    // after readable has been emitted but before I/O (nextTick) to
+    // support once('readable', fn) cycles. This means that calling
+    // resume within the same tick will have no
+    // effect.
+    process.nextTick(updateReadableListening, this);
+  }
+
+  return res;
+};
+
+function updateReadableListening(self) {
+  var state = self._readableState;
+  state.readableListening = self.listenerCount('readable') > 0;
+
+  if (state.resumeScheduled && !state.paused) {
+    // flowing needs to be set to true now, otherwise
+    // the upcoming resume will not flow.
+    state.flowing = true; // crude way to check if we should resume
+  } else if (self.listenerCount('data') > 0) {
+    self.resume();
+  }
+}
+
+function nReadingNextTick(self) {
+  debug('readable nexttick read 0');
+  self.read(0);
+} // pause() and resume() are remnants of the legacy readable stream API
+// If the user uses them, then switch into old mode.
+
+
+Readable.prototype.resume = function () {
+  var state = this._readableState;
+
+  if (!state.flowing) {
+    debug('resume'); // we flow only if there is no one listening
+    // for readable, but we still have to call
+    // resume()
+
+    state.flowing = !state.readableListening;
+    resume(this, state);
+  }
+
+  state.paused = false;
+  return this;
+};
+
+function resume(stream, state) {
+  if (!state.resumeScheduled) {
+    state.resumeScheduled = true;
+    process.nextTick(resume_, stream, state);
+  }
+}
+
+function resume_(stream, state) {
+  debug('resume', state.reading);
+
+  if (!state.reading) {
+    stream.read(0);
+  }
+
+  state.resumeScheduled = false;
+  stream.emit('resume');
+  flow(stream);
+  if (state.flowing && !state.reading) stream.read(0);
+}
+
+Readable.prototype.pause = function () {
+  debug('call pause flowing=%j', this._readableState.flowing);
+
+  if (this._readableState.flowing !== false) {
+    debug('pause');
+    this._readableState.flowing = false;
+    this.emit('pause');
+  }
+
+  this._readableState.paused = true;
+  return this;
+};
+
+function flow(stream) {
+  var state = stream._readableState;
+  debug('flow', state.flowing);
+
+  while (state.flowing && stream.read() !== null) {
+    ;
+  }
+} // wrap an old-style stream as the async data source.
+// This is *not* part of the readable stream interface.
+// It is an ugly unfortunate mess of history.
+
+
+Readable.prototype.wrap = function (stream) {
+  var _this = this;
+
+  var state = this._readableState;
+  var paused = false;
+  stream.on('end', function () {
+    debug('wrapped end');
+
+    if (state.decoder && !state.ended) {
+      var chunk = state.decoder.end();
+      if (chunk && chunk.length) _this.push(chunk);
+    }
+
+    _this.push(null);
+  });
+  stream.on('data', function (chunk) {
+    debug('wrapped data');
+    if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode
+
+    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;
+
+    var ret = _this.push(chunk);
+
+    if (!ret) {
+      paused = true;
+      stream.pause();
+    }
+  }); // proxy all the other methods.
+  // important when wrapping filters and duplexes.
+
+  for (var i in stream) {
+    if (this[i] === undefined && typeof stream[i] === 'function') {
+      this[i] = function methodWrap(method) {
+        return function methodWrapReturnFunction() {
+          return stream[method].apply(stream, arguments);
+        };
+      }(i);
+    }
+  } // proxy certain important events.
+
+
+  for (var n = 0; n < kProxyEvents.length; n++) {
+    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
+  } // when we try to consume some more bytes, simply unpause the
+  // underlying stream.
+
+
+  this._read = function (n) {
+    debug('wrapped _read', n);
+
+    if (paused) {
+      paused = false;
+      stream.resume();
+    }
+  };
+
+  return this;
+};
+
+if (typeof Symbol === 'function') {
+  Readable.prototype[Symbol.asyncIterator] = function () {
+    if (createReadableStreamAsyncIterator === undefined) {
+      createReadableStreamAsyncIterator = __webpack_require__(8187);
+    }
+
+    return createReadableStreamAsyncIterator(this);
+  };
+}
+
+Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
+  // making it explicit this property is not enumerable
+  // because otherwise some prototype manipulation in
+  // userland will fail
+  enumerable: false,
+  get: function get() {
+    return this._readableState.highWaterMark;
+  }
+});
+Object.defineProperty(Readable.prototype, 'readableBuffer', {
+  // making it explicit this property is not enumerable
+  // because otherwise some prototype manipulation in
+  // userland will fail
+  enumerable: false,
+  get: function get() {
+    return this._readableState && this._readableState.buffer;
+  }
+});
+Object.defineProperty(Readable.prototype, 'readableFlowing', {
+  // making it explicit this property is not enumerable
+  // because otherwise some prototype manipulation in
+  // userland will fail
+  enumerable: false,
+  get: function get() {
+    return this._readableState.flowing;
+  },
+  set: function set(state) {
+    if (this._readableState) {
+      this._readableState.flowing = state;
+    }
+  }
+}); // exposed for testing purposes only.
+
+Readable._fromList = fromList;
+Object.defineProperty(Readable.prototype, 'readableLength', {
+  // making it explicit this property is not enumerable
+  // because otherwise some prototype manipulation in
+  // userland will fail
+  enumerable: false,
+  get: function get() {
+    return this._readableState.length;
+  }
+}); // Pluck off n bytes from an array of buffers.
+// Length is the combined lengths of all the buffers in the list.
+// This function is designed to be inlinable, so please take care when making
+// changes to the function body.
+
+function fromList(n, state) {
+  // nothing buffered
+  if (state.length === 0) return null;
+  var ret;
+  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
+    // read it all, truncate the list
+    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);
+    state.buffer.clear();
+  } else {
+    // read part of list
+    ret = state.buffer.consume(n, state.decoder);
+  }
+  return ret;
+}
+
+function endReadable(stream) {
+  var state = stream._readableState;
+  debug('endReadable', state.endEmitted);
+
+  if (!state.endEmitted) {
+    state.ended = true;
+    process.nextTick(endReadableNT, state, stream);
+  }
+}
+
+function endReadableNT(state, stream) {
+  debug('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.
+
+  if (!state.endEmitted && state.length === 0) {
+    state.endEmitted = true;
+    stream.readable = false;
+    stream.emit('end');
+
+    if (state.autoDestroy) {
+      // In case of duplex streams we need a way to detect
+      // if the writable side is ready for autoDestroy as well
+      var wState = stream._writableState;
+
+      if (!wState || wState.autoDestroy && wState.finished) {
+        stream.destroy();
+      }
+    }
+  }
+}
+
+if (typeof Symbol === 'function') {
+  Readable.from = function (iterable, opts) {
+    if (from === undefined) {
+      from = __webpack_require__(3733);
+    }
+
+    return from(Readable, iterable, opts);
+  };
+}
+
+function indexOf(xs, x) {
+  for (var i = 0, l = xs.length; i < l; i++) {
+    if (xs[i] === x) return i;
+  }
+
+  return -1;
+}
+
+/***/ }),
+
+/***/ 8597:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+// Copyright Joyent, Inc. and other Node contributors.
+//
+// Permission is hereby granted, free of charge, to any person obtaining a
+// copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to permit
+// persons to whom the Software is furnished to do so, subject to the
+// following conditions:
+//
+// The above copyright notice and this permission notice shall be included
+// in all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
+// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
+// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
+// USE OR OTHER DEALINGS IN THE SOFTWARE.
+// a transform stream is a readable/writable stream where you do
+// something with the data.  Sometimes it's called a "filter",
+// but that's not a great name for it, since that implies a thing where
+// some bits pass through, and others are simply ignored.  (That would
+// be a valid example of a transform, of course.)
+//
+// While the output is causally related to the input, it's not a
+// necessarily symmetric or synchronous transformation.  For example,
+// a zlib stream might take multiple plain-text writes(), and then
+// emit a single compressed chunk some time in the future.
+//
+// Here's how this works:
+//
+// The Transform stream has all the aspects of the readable and writable
+// stream classes.  When you write(chunk), that calls _write(chunk,cb)
+// internally, and returns false if there's a lot of pending writes
+// buffered up.  When you call read(), that calls _read(n) until
+// there's enough pending readable data buffered up.
+//
+// In a transform stream, the written data is placed in a buffer.  When
+// _read(n) is called, it transforms the queued up data, calling the
+// buffered _write cb's as it consumes chunks.  If consuming a single
+// written chunk would result in multiple output chunks, then the first
+// outputted bit calls the readcb, and subsequent chunks just go into
+// the read buffer, and will cause it to emit 'readable' if necessary.
+//
+// This way, back-pressure is actually determined by the reading side,
+// since _read has to be called to start processing a new chunk.  However,
+// a pathological inflate type of transform can cause excessive buffering
+// here.  For example, imagine a stream where every byte of input is
+// interpreted as an integer from 0-255, and then results in that many
+// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
+// 1kb of data being output.  In this case, you could write a very small
+// amount of input, and end up with a very large amount of output.  In
+// such a pathological inflating mechanism, there'd be no way to tell
+// the system to stop doing the transform.  A single 4MB write could
+// cause the system to run out of memory.
+//
+// However, even in such a pathological case, only a single written chunk
+// would be consumed, and then the rest would wait (un-transformed) until
+// the results of the previous transformed chunk were consumed.
+
+
+module.exports = Transform;
+
+var _require$codes = __webpack_require__(553)/* .codes */ .q,
+    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
+    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
+    ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,
+    ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
+
+var Duplex = __webpack_require__(673);
+
+__webpack_require__(3730)(Transform, Duplex);
+
+function afterTransform(er, data) {
+  var ts = this._transformState;
+  ts.transforming = false;
+  var cb = ts.writecb;
+
+  if (cb === null) {
+    return this.emit('error', new ERR_MULTIPLE_CALLBACK());
+  }
+
+  ts.writechunk = null;
+  ts.writecb = null;
+  if (data != null) // single equals check for both `null` and `undefined`
+    this.push(data);
+  cb(er);
+  var rs = this._readableState;
+  rs.reading = false;
+
+  if (rs.needReadable || rs.length < rs.highWaterMark) {
+    this._read(rs.highWaterMark);
+  }
+}
+
+function Transform(options) {
+  if (!(this instanceof Transform)) return new Transform(options);
+  Duplex.call(this, options);
+  this._transformState = {
+    afterTransform: afterTransform.bind(this),
+    needTransform: false,
+    transforming: false,
+    writecb: null,
+    writechunk: null,
+    writeencoding: null
+  }; // start out asking for a readable event once data is transformed.
+
+  this._readableState.needReadable = true; // we have implemented the _read method, and done the other things
+  // that Readable wants before the first _read call, so unset the
+  // sync guard flag.
+
+  this._readableState.sync = false;
+
+  if (options) {
+    if (typeof options.transform === 'function') this._transform = options.transform;
+    if (typeof options.flush === 'function') this._flush = options.flush;
+  } // When the writable side finishes, then flush out anything remaining.
+
+
+  this.on('prefinish', prefinish);
+}
+
+function prefinish() {
+  var _this = this;
+
+  if (typeof this._flush === 'function' && !this._readableState.destroyed) {
+    this._flush(function (er, data) {
+      done(_this, er, data);
+    });
+  } else {
+    done(this, null, null);
+  }
+}
+
+Transform.prototype.push = function (chunk, encoding) {
+  this._transformState.needTransform = false;
+  return Duplex.prototype.push.call(this, chunk, encoding);
+}; // This is the part where you do stuff!
+// override this function in implementation classes.
+// 'chunk' is an input chunk.
+//
+// Call `push(newChunk)` to pass along transformed output
+// to the readable side.  You may call 'push' zero or more times.
+//
+// Call `cb(err)` when you are done with this chunk.  If you pass
+// an error, then that'll put the hurt on the whole operation.  If you
+// never call cb(), then you'll never get another chunk.
+
+
+Transform.prototype._transform = function (chunk, encoding, cb) {
+  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));
+};
+
+Transform.prototype._write = function (chunk, encoding, cb) {
+  var ts = this._transformState;
+  ts.writecb = cb;
+  ts.writechunk = chunk;
+  ts.writeencoding = encoding;
+
+  if (!ts.transforming) {
+    var rs = this._readableState;
+    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
+  }
+}; // Doesn't matter what the args are here.
+// _transform does all the work.
+// That we got here means that the readable side wants more data.
+
+
+Transform.prototype._read = function (n) {
+  var ts = this._transformState;
+
+  if (ts.writechunk !== null && !ts.transforming) {
+    ts.transforming = true;
+
+    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
+  } else {
+    // mark that we need a transform, so that any data that comes in
+    // will get processed, now that we've asked for it.
+    ts.needTransform = true;
+  }
+};
+
+Transform.prototype._destroy = function (err, cb) {
+  Duplex.prototype._destroy.call(this, err, function (err2) {
+    cb(err2);
+  });
+};
+
+function done(stream, er, data) {
+  if (er) return stream.emit('error', er);
+  if (data != null) // single equals check for both `null` and `undefined`
+    stream.push(data); // TODO(BridgeAR): Write a test for these two error cases
+  // if there's nothing in the write buffer, then that means
+  // that nothing more will ever be provided
+
+  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
+  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
+  return stream.push(null);
+}
+
+/***/ }),
+
+/***/ 8719:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+/* provided dependency */ var process = __webpack_require__(2695);
+// Copyright Joyent, Inc. and other Node contributors.
+//
+// Permission is hereby granted, free of charge, to any person obtaining a
+// copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to permit
+// persons to whom the Software is furnished to do so, subject to the
+// following conditions:
+//
+// The above copyright notice and this permission notice shall be included
+// in all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
+// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
+// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
+// USE OR OTHER DEALINGS IN THE SOFTWARE.
+// A bit simpler than readable streams.
+// Implement an async ._write(chunk, encoding, cb), and it'll handle all
+// the drain event emission and buffering.
+
+
+module.exports = Writable;
+/* <replacement> */
+
+function WriteReq(chunk, encoding, cb) {
+  this.chunk = chunk;
+  this.encoding = encoding;
+  this.callback = cb;
+  this.next = null;
+} // It seems a linked list but it is not
+// there will be only 2 of these for each stream
+
+
+function CorkedRequest(state) {
+  var _this = this;
+
+  this.next = null;
+  this.entry = null;
+
+  this.finish = function () {
+    onCorkedFinish(_this, state);
+  };
+}
+/* </replacement> */
+
+/*<replacement>*/
+
+
+var Duplex;
+/*</replacement>*/
+
+Writable.WritableState = WritableState;
+/*<replacement>*/
+
+var internalUtil = {
+  deprecate: __webpack_require__(72)
+};
+/*</replacement>*/
+
+/*<replacement>*/
+
+var Stream = __webpack_require__(8208);
+/*</replacement>*/
+
+
+var Buffer = __webpack_require__(7866).Buffer;
+
+var OurUint8Array = __webpack_require__.g.Uint8Array || function () {};
+
+function _uint8ArrayToBuffer(chunk) {
+  return Buffer.from(chunk);
+}
+
+function _isUint8Array(obj) {
+  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
+}
+
+var destroyImpl = __webpack_require__(3390);
+
+var _require = __webpack_require__(1111),
+    getHighWaterMark = _require.getHighWaterMark;
+
+var _require$codes = __webpack_require__(553)/* .codes */ .q,
+    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
+    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
+    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
+    ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,
+    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,
+    ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,
+    ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,
+    ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
+
+var errorOrDestroy = destroyImpl.errorOrDestroy;
+
+__webpack_require__(3730)(Writable, Stream);
+
+function nop() {}
+
+function WritableState(options, stream, isDuplex) {
+  Duplex = Duplex || __webpack_require__(673);
+  options = options || {}; // Duplex streams are both readable and writable, but share
+  // the same options object.
+  // However, some cases require setting options to different
+  // values for the readable and the writable sides of the duplex stream,
+  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.
+
+  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream
+  // contains buffers or objects.
+
+  this.objectMode = !!options.objectMode;
+  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false
+  // Note: 0 is a valid value, means that we always return false if
+  // the entire buffer is not flushed immediately on write()
+
+  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex); // if _final has been called
+
+  this.finalCalled = false; // drain event flag.
+
+  this.needDrain = false; // at the start of calling end()
+
+  this.ending = false; // when end() has been called, and returned
+
+  this.ended = false; // when 'finish' is emitted
+
+  this.finished = false; // has it been destroyed
+
+  this.destroyed = false; // should we decode strings into buffers before passing to _write?
+  // this is here so that some node-core streams can optimize string
+  // handling at a lower level.
+
+  var noDecode = options.decodeStrings === false;
+  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string
+  // encoding is 'binary' so we have to make this configurable.
+  // Everything else in the universe uses 'utf8', though.
+
+  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement
+  // of how much we're waiting to get pushed to some underlying
+  // socket or file.
+
+  this.length = 0; // a flag to see when we're in the middle of a write.
+
+  this.writing = false; // when true all writes will be buffered until .uncork() call
+
+  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,
+  // or on a later tick.  We set this to true at first, because any
+  // actions that shouldn't happen until "later" should generally also
+  // not happen before the first write call.
+
+  this.sync = true; // a flag to know if we're processing previously buffered items, which
+  // may call the _write() callback in the same tick, so that we don't
+  // end up in an overlapped onwrite situation.
+
+  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)
+
+  this.onwrite = function (er) {
+    onwrite(stream, er);
+  }; // the callback that the user supplies to write(chunk,encoding,cb)
+
+
+  this.writecb = null; // the amount that is being written when _write is called.
+
+  this.writelen = 0;
+  this.bufferedRequest = null;
+  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks
+  // this must be 0 before 'finish' can be emitted
+
+  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs
+  // This is relevant for synchronous Transform streams
+
+  this.prefinished = false; // True if the error was already emitted and should not be thrown again
+
+  this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.
+
+  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'finish' (and potentially 'end')
+
+  this.autoDestroy = !!options.autoDestroy; // count buffered requests
+
+  this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always
+  // one allocated and free to use, and we maintain at most two
+
+  this.corkedRequestsFree = new CorkedRequest(this);
+}
+
+WritableState.prototype.getBuffer = function getBuffer() {
+  var current = this.bufferedRequest;
+  var out = [];
+
+  while (current) {
+    out.push(current);
+    current = current.next;
+  }
+
+  return out;
+};
+
+(function () {
+  try {
+    Object.defineProperty(WritableState.prototype, 'buffer', {
+      get: internalUtil.deprecate(function writableStateBufferGetter() {
+        return this.getBuffer();
+      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
+    });
+  } catch (_) {}
+})(); // Test _writableState for inheritance to account for Duplex streams,
+// whose prototype chain only points to Readable.
+
+
+var realHasInstance;
+
+if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
+  realHasInstance = Function.prototype[Symbol.hasInstance];
+  Object.defineProperty(Writable, Symbol.hasInstance, {
+    value: function value(object) {
+      if (realHasInstance.call(this, object)) return true;
+      if (this !== Writable) return false;
+      return object && object._writableState instanceof WritableState;
+    }
+  });
+} else {
+  realHasInstance = function realHasInstance(object) {
+    return object instanceof this;
+  };
+}
+
+function Writable(options) {
+  Duplex = Duplex || __webpack_require__(673); // Writable ctor is applied to Duplexes, too.
+  // `realHasInstance` is necessary because using plain `instanceof`
+  // would return false, as no `_writableState` property is attached.
+  // Trying to use the custom `instanceof` for Writable here will also break the
+  // Node.js LazyTransform implementation, which has a non-trivial getter for
+  // `_writableState` that would lead to infinite recursion.
+  // Checking for a Stream.Duplex instance is faster here instead of inside
+  // the WritableState constructor, at least with V8 6.5
+
+  var isDuplex = this instanceof Duplex;
+  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
+  this._writableState = new WritableState(options, this, isDuplex); // legacy.
+
+  this.writable = true;
+
+  if (options) {
+    if (typeof options.write === 'function') this._write = options.write;
+    if (typeof options.writev === 'function') this._writev = options.writev;
+    if (typeof options.destroy === 'function') this._destroy = options.destroy;
+    if (typeof options.final === 'function') this._final = options.final;
+  }
+
+  Stream.call(this);
+} // Otherwise people can pipe Writable streams, which is just wrong.
+
+
+Writable.prototype.pipe = function () {
+  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
+};
+
+function writeAfterEnd(stream, cb) {
+  var er = new ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb
+
+  errorOrDestroy(stream, er);
+  process.nextTick(cb, er);
+} // Checks that a user-supplied chunk is valid, especially for the particular
+// mode the stream is in. Currently this means that `null` is never accepted
+// and undefined/non-string values are only allowed in object mode.
+
+
+function validChunk(stream, state, chunk, cb) {
+  var er;
+
+  if (chunk === null) {
+    er = new ERR_STREAM_NULL_VALUES();
+  } else if (typeof chunk !== 'string' && !state.objectMode) {
+    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);
+  }
+
+  if (er) {
+    errorOrDestroy(stream, er);
+    process.nextTick(cb, er);
+    return false;
+  }
+
+  return true;
+}
+
+Writable.prototype.write = function (chunk, encoding, cb) {
+  var state = this._writableState;
+  var ret = false;
+
+  var isBuf = !state.objectMode && _isUint8Array(chunk);
+
+  if (isBuf && !Buffer.isBuffer(chunk)) {
+    chunk = _uint8ArrayToBuffer(chunk);
+  }
+
+  if (typeof encoding === 'function') {
+    cb = encoding;
+    encoding = null;
+  }
+
+  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
+  if (typeof cb !== 'function') cb = nop;
+  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
+    state.pendingcb++;
+    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
+  }
+  return ret;
+};
+
+Writable.prototype.cork = function () {
+  this._writableState.corked++;
+};
+
+Writable.prototype.uncork = function () {
+  var state = this._writableState;
+
+  if (state.corked) {
+    state.corked--;
+    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
+  }
+};
+
+Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
+  // node::ParseEncoding() requires lower case.
+  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
+  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
+  this._writableState.defaultEncoding = encoding;
+  return this;
+};
+
+Object.defineProperty(Writable.prototype, 'writableBuffer', {
+  // making it explicit this property is not enumerable
+  // because otherwise some prototype manipulation in
+  // userland will fail
+  enumerable: false,
+  get: function get() {
+    return this._writableState && this._writableState.getBuffer();
+  }
+});
+
+function decodeChunk(state, chunk, encoding) {
+  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
+    chunk = Buffer.from(chunk, encoding);
+  }
+
+  return chunk;
+}
+
+Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
+  // making it explicit this property is not enumerable
+  // because otherwise some prototype manipulation in
+  // userland will fail
+  enumerable: false,
+  get: function get() {
+    return this._writableState.highWaterMark;
+  }
+}); // if we're already writing something, then just put this
+// in the queue, and wait our turn.  Otherwise, call _write
+// If we return false, then we need a drain event, so set that flag.
+
+function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
+  if (!isBuf) {
+    var newChunk = decodeChunk(state, chunk, encoding);
+
+    if (chunk !== newChunk) {
+      isBuf = true;
+      encoding = 'buffer';
+      chunk = newChunk;
+    }
+  }
+
+  var len = state.objectMode ? 1 : chunk.length;
+  state.length += len;
+  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.
+
+  if (!ret) state.needDrain = true;
+
+  if (state.writing || state.corked) {
+    var last = state.lastBufferedRequest;
+    state.lastBufferedRequest = {
+      chunk: chunk,
+      encoding: encoding,
+      isBuf: isBuf,
+      callback: cb,
+      next: null
+    };
+
+    if (last) {
+      last.next = state.lastBufferedRequest;
+    } else {
+      state.bufferedRequest = state.lastBufferedRequest;
+    }
+
+    state.bufferedRequestCount += 1;
+  } else {
+    doWrite(stream, state, false, len, chunk, encoding, cb);
+  }
+
+  return ret;
+}
+
+function doWrite(stream, state, writev, len, chunk, encoding, cb) {
+  state.writelen = len;
+  state.writecb = cb;
+  state.writing = true;
+  state.sync = true;
+  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
+  state.sync = false;
+}
+
+function onwriteError(stream, state, sync, er, cb) {
+  --state.pendingcb;
+
+  if (sync) {
+    // defer the callback if we are being called synchronously
+    // to avoid piling up things on the stack
+    process.nextTick(cb, er); // this can emit finish, and it will always happen
+    // after error
+
+    process.nextTick(finishMaybe, stream, state);
+    stream._writableState.errorEmitted = true;
+    errorOrDestroy(stream, er);
+  } else {
+    // the caller expect this to happen before if
+    // it is async
+    cb(er);
+    stream._writableState.errorEmitted = true;
+    errorOrDestroy(stream, er); // this can emit finish, but finish must
+    // always follow error
+
+    finishMaybe(stream, state);
+  }
+}
+
+function onwriteStateUpdate(state) {
+  state.writing = false;
+  state.writecb = null;
+  state.length -= state.writelen;
+  state.writelen = 0;
+}
+
+function onwrite(stream, er) {
+  var state = stream._writableState;
+  var sync = state.sync;
+  var cb = state.writecb;
+  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();
+  onwriteStateUpdate(state);
+  if (er) onwriteError(stream, state, sync, er, cb);else {
+    // Check if we're actually ready to finish, but don't emit yet
+    var finished = needFinish(state) || stream.destroyed;
+
+    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
+      clearBuffer(stream, state);
+    }
+
+    if (sync) {
+      process.nextTick(afterWrite, stream, state, finished, cb);
+    } else {
+      afterWrite(stream, state, finished, cb);
+    }
+  }
+}
+
+function afterWrite(stream, state, finished, cb) {
+  if (!finished) onwriteDrain(stream, state);
+  state.pendingcb--;
+  cb();
+  finishMaybe(stream, state);
+} // Must force callback to be called on nextTick, so that we don't
+// emit 'drain' before the write() consumer gets the 'false' return
+// value, and has a chance to attach a 'drain' listener.
+
+
+function onwriteDrain(stream, state) {
+  if (state.length === 0 && state.needDrain) {
+    state.needDrain = false;
+    stream.emit('drain');
+  }
+} // if there's something in the buffer waiting, then process it
+
+
+function clearBuffer(stream, state) {
+  state.bufferProcessing = true;
+  var entry = state.bufferedRequest;
+
+  if (stream._writev && entry && entry.next) {
+    // Fast case, write everything using _writev()
+    var l = state.bufferedRequestCount;
+    var buffer = new Array(l);
+    var holder = state.corkedRequestsFree;
+    holder.entry = entry;
+    var count = 0;
+    var allBuffers = true;
+
+    while (entry) {
+      buffer[count] = entry;
+      if (!entry.isBuf) allBuffers = false;
+      entry = entry.next;
+      count += 1;
+    }
+
+    buffer.allBuffers = allBuffers;
+    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time
+    // as the hot path ends with doWrite
+
+    state.pendingcb++;
+    state.lastBufferedRequest = null;
+
+    if (holder.next) {
+      state.corkedRequestsFree = holder.next;
+      holder.next = null;
+    } else {
+      state.corkedRequestsFree = new CorkedRequest(state);
+    }
+
+    state.bufferedRequestCount = 0;
+  } else {
+    // Slow case, write chunks one-by-one
+    while (entry) {
+      var chunk = entry.chunk;
+      var encoding = entry.encoding;
+      var cb = entry.callback;
+      var len = state.objectMode ? 1 : chunk.length;
+      doWrite(stream, state, false, len, chunk, encoding, cb);
+      entry = entry.next;
+      state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then
+      // it means that we need to wait until it does.
+      // also, that means that the chunk and cb are currently
+      // being processed, so move the buffer counter past them.
+
+      if (state.writing) {
+        break;
+      }
+    }
+
+    if (entry === null) state.lastBufferedRequest = null;
+  }
+
+  state.bufferedRequest = entry;
+  state.bufferProcessing = false;
+}
+
+Writable.prototype._write = function (chunk, encoding, cb) {
+  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));
+};
+
+Writable.prototype._writev = null;
+
+Writable.prototype.end = function (chunk, encoding, cb) {
+  var state = this._writableState;
+
+  if (typeof chunk === 'function') {
+    cb = chunk;
+    chunk = null;
+    encoding = null;
+  } else if (typeof encoding === 'function') {
+    cb = encoding;
+    encoding = null;
+  }
+
+  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks
+
+  if (state.corked) {
+    state.corked = 1;
+    this.uncork();
+  } // ignore unnecessary end() calls.
+
+
+  if (!state.ending) endWritable(this, state, cb);
+  return this;
+};
+
+Object.defineProperty(Writable.prototype, 'writableLength', {
+  // making it explicit this property is not enumerable
+  // because otherwise some prototype manipulation in
+  // userland will fail
+  enumerable: false,
+  get: function get() {
+    return this._writableState.length;
+  }
+});
+
+function needFinish(state) {
+  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
+}
+
+function callFinal(stream, state) {
+  stream._final(function (err) {
+    state.pendingcb--;
+
+    if (err) {
+      errorOrDestroy(stream, err);
+    }
+
+    state.prefinished = true;
+    stream.emit('prefinish');
+    finishMaybe(stream, state);
+  });
+}
+
+function prefinish(stream, state) {
+  if (!state.prefinished && !state.finalCalled) {
+    if (typeof stream._final === 'function' && !state.destroyed) {
+      state.pendingcb++;
+      state.finalCalled = true;
+      process.nextTick(callFinal, stream, state);
+    } else {
+      state.prefinished = true;
+      stream.emit('prefinish');
+    }
+  }
+}
+
+function finishMaybe(stream, state) {
+  var need = needFinish(state);
+
+  if (need) {
+    prefinish(stream, state);
+
+    if (state.pendingcb === 0) {
+      state.finished = true;
+      stream.emit('finish');
+
+      if (state.autoDestroy) {
+        // In case of duplex streams we need a way to detect
+        // if the readable side is ready for autoDestroy as well
+        var rState = stream._readableState;
+
+        if (!rState || rState.autoDestroy && rState.endEmitted) {
+          stream.destroy();
+        }
+      }
+    }
+  }
+
+  return need;
+}
+
+function endWritable(stream, state, cb) {
+  state.ending = true;
+  finishMaybe(stream, state);
+
+  if (cb) {
+    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);
+  }
+
+  state.ended = true;
+  stream.writable = false;
+}
+
+function onCorkedFinish(corkReq, state, err) {
+  var entry = corkReq.entry;
+  corkReq.entry = null;
+
+  while (entry) {
+    var cb = entry.callback;
+    state.pendingcb--;
+    cb(err);
+    entry = entry.next;
+  } // reuse the free corkReq.
+
+
+  state.corkedRequestsFree.next = corkReq;
+}
+
+Object.defineProperty(Writable.prototype, 'destroyed', {
+  // making it explicit this property is not enumerable
+  // because otherwise some prototype manipulation in
+  // userland will fail
+  enumerable: false,
+  get: function get() {
+    if (this._writableState === undefined) {
+      return false;
+    }
+
+    return this._writableState.destroyed;
+  },
+  set: function set(value) {
+    // we ignore the value if the stream
+    // has not been initialized yet
+    if (!this._writableState) {
+      return;
+    } // backward compatibility, the user is explicitly
+    // managing destroyed
+
+
+    this._writableState.destroyed = value;
+  }
+});
+Writable.prototype.destroy = destroyImpl.destroy;
+Writable.prototype._undestroy = destroyImpl.undestroy;
+
+Writable.prototype._destroy = function (err, cb) {
+  cb(err);
+};
+
+/***/ }),
+
+/***/ 8187:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+/* provided dependency */ var process = __webpack_require__(2695);
+
+
+var _Object$setPrototypeO;
+
+function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+var finished = __webpack_require__(2426);
+
+var kLastResolve = Symbol('lastResolve');
+var kLastReject = Symbol('lastReject');
+var kError = Symbol('error');
+var kEnded = Symbol('ended');
+var kLastPromise = Symbol('lastPromise');
+var kHandlePromise = Symbol('handlePromise');
+var kStream = Symbol('stream');
+
+function createIterResult(value, done) {
+  return {
+    value: value,
+    done: done
+  };
+}
+
+function readAndResolve(iter) {
+  var resolve = iter[kLastResolve];
+
+  if (resolve !== null) {
+    var data = iter[kStream].read(); // we defer if data is null
+    // we can be expecting either 'end' or
+    // 'error'
+
+    if (data !== null) {
+      iter[kLastPromise] = null;
+      iter[kLastResolve] = null;
+      iter[kLastReject] = null;
+      resolve(createIterResult(data, false));
+    }
+  }
+}
+
+function onReadable(iter) {
+  // we wait for the next tick, because it might
+  // emit an error with process.nextTick
+  process.nextTick(readAndResolve, iter);
+}
+
+function wrapForNext(lastPromise, iter) {
+  return function (resolve, reject) {
+    lastPromise.then(function () {
+      if (iter[kEnded]) {
+        resolve(createIterResult(undefined, true));
+        return;
+      }
+
+      iter[kHandlePromise](resolve, reject);
+    }, reject);
+  };
+}
+
+var AsyncIteratorPrototype = Object.getPrototypeOf(function () {});
+var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
+  get stream() {
+    return this[kStream];
+  },
+
+  next: function next() {
+    var _this = this;
+
+    // if we have detected an error in the meanwhile
+    // reject straight away
+    var error = this[kError];
+
+    if (error !== null) {
+      return Promise.reject(error);
+    }
+
+    if (this[kEnded]) {
+      return Promise.resolve(createIterResult(undefined, true));
+    }
+
+    if (this[kStream].destroyed) {
+      // We need to defer via nextTick because if .destroy(err) is
+      // called, the error will be emitted via nextTick, and
+      // we cannot guarantee that there is no error lingering around
+      // waiting to be emitted.
+      return new Promise(function (resolve, reject) {
+        process.nextTick(function () {
+          if (_this[kError]) {
+            reject(_this[kError]);
+          } else {
+            resolve(createIterResult(undefined, true));
+          }
+        });
+      });
+    } // if we have multiple next() calls
+    // we will wait for the previous Promise to finish
+    // this logic is optimized to support for await loops,
+    // where next() is only called once at a time
+
+
+    var lastPromise = this[kLastPromise];
+    var promise;
+
+    if (lastPromise) {
+      promise = new Promise(wrapForNext(lastPromise, this));
+    } else {
+      // fast path needed to support multiple this.push()
+      // without triggering the next() queue
+      var data = this[kStream].read();
+
+      if (data !== null) {
+        return Promise.resolve(createIterResult(data, false));
+      }
+
+      promise = new Promise(this[kHandlePromise]);
+    }
+
+    this[kLastPromise] = promise;
+    return promise;
+  }
+}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {
+  return this;
+}), _defineProperty(_Object$setPrototypeO, "return", function _return() {
+  var _this2 = this;
+
+  // destroy(err, cb) is a private API
+  // we can guarantee we have that here, because we control the
+  // Readable class this is attached to
+  return new Promise(function (resolve, reject) {
+    _this2[kStream].destroy(null, function (err) {
+      if (err) {
+        reject(err);
+        return;
+      }
+
+      resolve(createIterResult(undefined, true));
+    });
+  });
+}), _Object$setPrototypeO), AsyncIteratorPrototype);
+
+var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
+  var _Object$create;
+
+  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
+    value: stream,
+    writable: true
+  }), _defineProperty(_Object$create, kLastResolve, {
+    value: null,
+    writable: true
+  }), _defineProperty(_Object$create, kLastReject, {
+    value: null,
+    writable: true
+  }), _defineProperty(_Object$create, kError, {
+    value: null,
+    writable: true
+  }), _defineProperty(_Object$create, kEnded, {
+    value: stream._readableState.endEmitted,
+    writable: true
+  }), _defineProperty(_Object$create, kHandlePromise, {
+    value: function value(resolve, reject) {
+      var data = iterator[kStream].read();
+
+      if (data) {
+        iterator[kLastPromise] = null;
+        iterator[kLastResolve] = null;
+        iterator[kLastReject] = null;
+        resolve(createIterResult(data, false));
+      } else {
+        iterator[kLastResolve] = resolve;
+        iterator[kLastReject] = reject;
+      }
+    },
+    writable: true
+  }), _Object$create));
+  iterator[kLastPromise] = null;
+  finished(stream, function (err) {
+    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
+      var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise
+      // returned by next() and store the error
+
+      if (reject !== null) {
+        iterator[kLastPromise] = null;
+        iterator[kLastResolve] = null;
+        iterator[kLastReject] = null;
+        reject(err);
+      }
+
+      iterator[kError] = err;
+      return;
+    }
+
+    var resolve = iterator[kLastResolve];
+
+    if (resolve !== null) {
+      iterator[kLastPromise] = null;
+      iterator[kLastResolve] = null;
+      iterator[kLastReject] = null;
+      resolve(createIterResult(undefined, true));
+    }
+
+    iterator[kEnded] = true;
+  });
+  stream.on('readable', onReadable.bind(null, iterator));
+  return iterator;
+};
+
+module.exports = createReadableStreamAsyncIterator;
+
+/***/ }),
+
+/***/ 4506:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+
+
+function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }
+
+function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
+
+function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
+
+function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
+
+function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }
+
+var _require = __webpack_require__(7866),
+    Buffer = _require.Buffer;
+
+var _require2 = __webpack_require__(462),
+    inspect = _require2.inspect;
+
+var custom = inspect && inspect.custom || 'inspect';
+
+function copyBuffer(src, target, offset) {
+  Buffer.prototype.copy.call(src, target, offset);
+}
+
+module.exports =
+/*#__PURE__*/
+function () {
+  function BufferList() {
+    _classCallCheck(this, BufferList);
+
+    this.head = null;
+    this.tail = null;
+    this.length = 0;
+  }
+
+  _createClass(BufferList, [{
+    key: "push",
+    value: function push(v) {
+      var entry = {
+        data: v,
+        next: null
+      };
+      if (this.length > 0) this.tail.next = entry;else this.head = entry;
+      this.tail = entry;
+      ++this.length;
+    }
+  }, {
+    key: "unshift",
+    value: function unshift(v) {
+      var entry = {
+        data: v,
+        next: this.head
+      };
+      if (this.length === 0) this.tail = entry;
+      this.head = entry;
+      ++this.length;
+    }
+  }, {
+    key: "shift",
+    value: function shift() {
+      if (this.length === 0) return;
+      var ret = this.head.data;
+      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
+      --this.length;
+      return ret;
+    }
+  }, {
+    key: "clear",
+    value: function clear() {
+      this.head = this.tail = null;
+      this.length = 0;
+    }
+  }, {
+    key: "join",
+    value: function join(s) {
+      if (this.length === 0) return '';
+      var p = this.head;
+      var ret = '' + p.data;
+
+      while (p = p.next) {
+        ret += s + p.data;
+      }
+
+      return ret;
+    }
+  }, {
+    key: "concat",
+    value: function concat(n) {
+      if (this.length === 0) return Buffer.alloc(0);
+      var ret = Buffer.allocUnsafe(n >>> 0);
+      var p = this.head;
+      var i = 0;
+
+      while (p) {
+        copyBuffer(p.data, ret, i);
+        i += p.data.length;
+        p = p.next;
+      }
+
+      return ret;
+    } // Consumes a specified amount of bytes or characters from the buffered data.
+
+  }, {
+    key: "consume",
+    value: function consume(n, hasStrings) {
+      var ret;
+
+      if (n < this.head.data.length) {
+        // `slice` is the same for buffers and strings.
+        ret = this.head.data.slice(0, n);
+        this.head.data = this.head.data.slice(n);
+      } else if (n === this.head.data.length) {
+        // First chunk is a perfect match.
+        ret = this.shift();
+      } else {
+        // Result spans more than one buffer.
+        ret = hasStrings ? this._getString(n) : this._getBuffer(n);
+      }
+
+      return ret;
+    }
+  }, {
+    key: "first",
+    value: function first() {
+      return this.head.data;
+    } // Consumes a specified amount of characters from the buffered data.
+
+  }, {
+    key: "_getString",
+    value: function _getString(n) {
+      var p = this.head;
+      var c = 1;
+      var ret = p.data;
+      n -= ret.length;
+
+      while (p = p.next) {
+        var str = p.data;
+        var nb = n > str.length ? str.length : n;
+        if (nb === str.length) ret += str;else ret += str.slice(0, n);
+        n -= nb;
+
+        if (n === 0) {
+          if (nb === str.length) {
+            ++c;
+            if (p.next) this.head = p.next;else this.head = this.tail = null;
+          } else {
+            this.head = p;
+            p.data = str.slice(nb);
+          }
+
+          break;
+        }
+
+        ++c;
+      }
+
+      this.length -= c;
+      return ret;
+    } // Consumes a specified amount of bytes from the buffered data.
+
+  }, {
+    key: "_getBuffer",
+    value: function _getBuffer(n) {
+      var ret = Buffer.allocUnsafe(n);
+      var p = this.head;
+      var c = 1;
+      p.data.copy(ret);
+      n -= p.data.length;
+
+      while (p = p.next) {
+        var buf = p.data;
+        var nb = n > buf.length ? buf.length : n;
+        buf.copy(ret, ret.length - n, 0, nb);
+        n -= nb;
+
+        if (n === 0) {
+          if (nb === buf.length) {
+            ++c;
+            if (p.next) this.head = p.next;else this.head = this.tail = null;
+          } else {
+            this.head = p;
+            p.data = buf.slice(nb);
+          }
+
+          break;
+        }
+
+        ++c;
+      }
+
+      this.length -= c;
+      return ret;
+    } // Make sure the linked list only shows the minimal necessary information.
+
+  }, {
+    key: custom,
+    value: function value(_, options) {
+      return inspect(this, _objectSpread({}, options, {
+        // Only inspect one level.
+        depth: 0,
+        // It should not recurse.
+        customInspect: false
+      }));
+    }
+  }]);
+
+  return BufferList;
+}();
+
+/***/ }),
+
+/***/ 3390:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+/* provided dependency */ var process = __webpack_require__(2695);
+ // undocumented cb() API, needed for core, not for public API
+
+function destroy(err, cb) {
+  var _this = this;
+
+  var readableDestroyed = this._readableState && this._readableState.destroyed;
+  var writableDestroyed = this._writableState && this._writableState.destroyed;
+
+  if (readableDestroyed || writableDestroyed) {
+    if (cb) {
+      cb(err);
+    } else if (err) {
+      if (!this._writableState) {
+        process.nextTick(emitErrorNT, this, err);
+      } else if (!this._writableState.errorEmitted) {
+        this._writableState.errorEmitted = true;
+        process.nextTick(emitErrorNT, this, err);
+      }
+    }
+
+    return this;
+  } // we set destroyed to true before firing error callbacks in order
+  // to make it re-entrance safe in case destroy() is called within callbacks
+
+
+  if (this._readableState) {
+    this._readableState.destroyed = true;
+  } // if this is a duplex stream mark the writable part as destroyed as well
+
+
+  if (this._writableState) {
+    this._writableState.destroyed = true;
+  }
+
+  this._destroy(err || null, function (err) {
+    if (!cb && err) {
+      if (!_this._writableState) {
+        process.nextTick(emitErrorAndCloseNT, _this, err);
+      } else if (!_this._writableState.errorEmitted) {
+        _this._writableState.errorEmitted = true;
+        process.nextTick(emitErrorAndCloseNT, _this, err);
+      } else {
+        process.nextTick(emitCloseNT, _this);
+      }
+    } else if (cb) {
+      process.nextTick(emitCloseNT, _this);
+      cb(err);
+    } else {
+      process.nextTick(emitCloseNT, _this);
+    }
+  });
+
+  return this;
+}
+
+function emitErrorAndCloseNT(self, err) {
+  emitErrorNT(self, err);
+  emitCloseNT(self);
+}
+
+function emitCloseNT(self) {
+  if (self._writableState && !self._writableState.emitClose) return;
+  if (self._readableState && !self._readableState.emitClose) return;
+  self.emit('close');
+}
+
+function undestroy() {
+  if (this._readableState) {
+    this._readableState.destroyed = false;
+    this._readableState.reading = false;
+    this._readableState.ended = false;
+    this._readableState.endEmitted = false;
+  }
+
+  if (this._writableState) {
+    this._writableState.destroyed = false;
+    this._writableState.ended = false;
+    this._writableState.ending = false;
+    this._writableState.finalCalled = false;
+    this._writableState.prefinished = false;
+    this._writableState.finished = false;
+    this._writableState.errorEmitted = false;
+  }
+}
+
+function emitErrorNT(self, err) {
+  self.emit('error', err);
+}
+
+function errorOrDestroy(stream, err) {
+  // We have tests that rely on errors being emitted
+  // in the same tick, so changing this is semver major.
+  // For now when you opt-in to autoDestroy we allow
+  // the error to be emitted nextTick. In a future
+  // semver major update we should change the default to this.
+  var rState = stream._readableState;
+  var wState = stream._writableState;
+  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);
+}
+
+module.exports = {
+  destroy: destroy,
+  undestroy: undestroy,
+  errorOrDestroy: errorOrDestroy
+};
+
+/***/ }),
+
+/***/ 2426:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+// Ported from https://github.com/mafintosh/end-of-stream with
+// permission from the author, Mathias Buus (@mafintosh).
+
+
+var ERR_STREAM_PREMATURE_CLOSE = __webpack_require__(553)/* .codes.ERR_STREAM_PREMATURE_CLOSE */ .q.ERR_STREAM_PREMATURE_CLOSE;
+
+function once(callback) {
+  var called = false;
+  return function () {
+    if (called) return;
+    called = true;
+
+    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
+      args[_key] = arguments[_key];
+    }
+
+    callback.apply(this, args);
+  };
+}
+
+function noop() {}
+
+function isRequest(stream) {
+  return stream.setHeader && typeof stream.abort === 'function';
+}
+
+function eos(stream, opts, callback) {
+  if (typeof opts === 'function') return eos(stream, null, opts);
+  if (!opts) opts = {};
+  callback = once(callback || noop);
+  var readable = opts.readable || opts.readable !== false && stream.readable;
+  var writable = opts.writable || opts.writable !== false && stream.writable;
+
+  var onlegacyfinish = function onlegacyfinish() {
+    if (!stream.writable) onfinish();
+  };
+
+  var writableEnded = stream._writableState && stream._writableState.finished;
+
+  var onfinish = function onfinish() {
+    writable = false;
+    writableEnded = true;
+    if (!readable) callback.call(stream);
+  };
+
+  var readableEnded = stream._readableState && stream._readableState.endEmitted;
+
+  var onend = function onend() {
+    readable = false;
+    readableEnded = true;
+    if (!writable) callback.call(stream);
+  };
+
+  var onerror = function onerror(err) {
+    callback.call(stream, err);
+  };
+
+  var onclose = function onclose() {
+    var err;
+
+    if (readable && !readableEnded) {
+      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
+      return callback.call(stream, err);
+    }
+
+    if (writable && !writableEnded) {
+      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
+      return callback.call(stream, err);
+    }
+  };
+
+  var onrequest = function onrequest() {
+    stream.req.on('finish', onfinish);
+  };
+
+  if (isRequest(stream)) {
+    stream.on('complete', onfinish);
+    stream.on('abort', onclose);
+    if (stream.req) onrequest();else stream.on('request', onrequest);
+  } else if (writable && !stream._writableState) {
+    // legacy streams
+    stream.on('end', onlegacyfinish);
+    stream.on('close', onlegacyfinish);
+  }
+
+  stream.on('end', onend);
+  stream.on('finish', onfinish);
+  if (opts.error !== false) stream.on('error', onerror);
+  stream.on('close', onclose);
+  return function () {
+    stream.removeListener('complete', onfinish);
+    stream.removeListener('abort', onclose);
+    stream.removeListener('request', onrequest);
+    if (stream.req) stream.req.removeListener('finish', onfinish);
+    stream.removeListener('end', onlegacyfinish);
+    stream.removeListener('close', onlegacyfinish);
+    stream.removeListener('finish', onfinish);
+    stream.removeListener('end', onend);
+    stream.removeListener('error', onerror);
+    stream.removeListener('close', onclose);
+  };
+}
+
+module.exports = eos;
+
+/***/ }),
+
+/***/ 3733:
+/***/ ((module) => {
+
+module.exports = function () {
+  throw new Error('Readable.from is not available in the browser')
+};
+
+
+/***/ }),
+
+/***/ 2970:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+// Ported from https://github.com/mafintosh/pump with
+// permission from the author, Mathias Buus (@mafintosh).
+
+
+var eos;
+
+function once(callback) {
+  var called = false;
+  return function () {
+    if (called) return;
+    called = true;
+    callback.apply(void 0, arguments);
+  };
+}
+
+var _require$codes = __webpack_require__(553)/* .codes */ .q,
+    ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,
+    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
+
+function noop(err) {
+  // Rethrow the error if it exists to avoid swallowing it
+  if (err) throw err;
+}
+
+function isRequest(stream) {
+  return stream.setHeader && typeof stream.abort === 'function';
+}
+
+function destroyer(stream, reading, writing, callback) {
+  callback = once(callback);
+  var closed = false;
+  stream.on('close', function () {
+    closed = true;
+  });
+  if (eos === undefined) eos = __webpack_require__(2426);
+  eos(stream, {
+    readable: reading,
+    writable: writing
+  }, function (err) {
+    if (err) return callback(err);
+    closed = true;
+    callback();
+  });
+  var destroyed = false;
+  return function (err) {
+    if (closed) return;
+    if (destroyed) return;
+    destroyed = true; // request.destroy just do .end - .abort is what we want
+
+    if (isRequest(stream)) return stream.abort();
+    if (typeof stream.destroy === 'function') return stream.destroy();
+    callback(err || new ERR_STREAM_DESTROYED('pipe'));
+  };
+}
+
+function call(fn) {
+  fn();
+}
+
+function pipe(from, to) {
+  return from.pipe(to);
+}
+
+function popCallback(streams) {
+  if (!streams.length) return noop;
+  if (typeof streams[streams.length - 1] !== 'function') return noop;
+  return streams.pop();
+}
+
+function pipeline() {
+  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
+    streams[_key] = arguments[_key];
+  }
+
+  var callback = popCallback(streams);
+  if (Array.isArray(streams[0])) streams = streams[0];
+
+  if (streams.length < 2) {
+    throw new ERR_MISSING_ARGS('streams');
+  }
+
+  var error;
+  var destroys = streams.map(function (stream, i) {
+    var reading = i < streams.length - 1;
+    var writing = i > 0;
+    return destroyer(stream, reading, writing, function (err) {
+      if (!error) error = err;
+      if (err) destroys.forEach(call);
+      if (reading) return;
+      destroys.forEach(call);
+      callback(error);
+    });
+  });
+  return streams.reduce(pipe);
+}
+
+module.exports = pipeline;
+
+/***/ }),
+
+/***/ 1111:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+
+
+var ERR_INVALID_OPT_VALUE = __webpack_require__(553)/* .codes.ERR_INVALID_OPT_VALUE */ .q.ERR_INVALID_OPT_VALUE;
+
+function highWaterMarkFrom(options, isDuplex, duplexKey) {
+  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
+}
+
+function getHighWaterMark(state, options, duplexKey, isDuplex) {
+  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
+
+  if (hwm != null) {
+    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
+      var name = isDuplex ? duplexKey : 'highWaterMark';
+      throw new ERR_INVALID_OPT_VALUE(name, hwm);
+    }
+
+    return Math.floor(hwm);
+  } // Default value
+
+
+  return state.objectMode ? 16 : 16 * 1024;
+}
+
+module.exports = {
+  getHighWaterMark: getHighWaterMark
+};
+
+/***/ }),
+
+/***/ 8208:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+module.exports = __webpack_require__(488).EventEmitter;
+
+
+/***/ }),
+
+/***/ 9210:
+/***/ ((module) => {
+
+/**
+ * Copyright (c) 2014-present, Facebook, Inc.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+var runtime = (function (exports) {
+  "use strict";
+
+  var Op = Object.prototype;
+  var hasOwn = Op.hasOwnProperty;
+  var undefined; // More compressible than void 0.
+  var $Symbol = typeof Symbol === "function" ? Symbol : {};
+  var iteratorSymbol = $Symbol.iterator || "@@iterator";
+  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
+  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
+
+  function define(obj, key, value) {
+    Object.defineProperty(obj, key, {
+      value: value,
+      enumerable: true,
+      configurable: true,
+      writable: true
+    });
+    return obj[key];
+  }
+  try {
+    // IE 8 has a broken Object.defineProperty that only works on DOM objects.
+    define({}, "");
+  } catch (err) {
+    define = function(obj, key, value) {
+      return obj[key] = value;
+    };
+  }
+
+  function wrap(innerFn, outerFn, self, tryLocsList) {
+    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
+    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
+    var generator = Object.create(protoGenerator.prototype);
+    var context = new Context(tryLocsList || []);
+
+    // The ._invoke method unifies the implementations of the .next,
+    // .throw, and .return methods.
+    generator._invoke = makeInvokeMethod(innerFn, self, context);
+
+    return generator;
+  }
+  exports.wrap = wrap;
+
+  // Try/catch helper to minimize deoptimizations. Returns a completion
+  // record like context.tryEntries[i].completion. This interface could
+  // have been (and was previously) designed to take a closure to be
+  // invoked without arguments, but in all the cases we care about we
+  // already have an existing method we want to call, so there's no need
+  // to create a new function object. We can even get away with assuming
+  // the method takes exactly one argument, since that happens to be true
+  // in every case, so we don't have to touch the arguments object. The
+  // only additional allocation required is the completion record, which
+  // has a stable shape and so hopefully should be cheap to allocate.
+  function tryCatch(fn, obj, arg) {
+    try {
+      return { type: "normal", arg: fn.call(obj, arg) };
+    } catch (err) {
+      return { type: "throw", arg: err };
+    }
+  }
+
+  var GenStateSuspendedStart = "suspendedStart";
+  var GenStateSuspendedYield = "suspendedYield";
+  var GenStateExecuting = "executing";
+  var GenStateCompleted = "completed";
+
+  // Returning this object from the innerFn has the same effect as
+  // breaking out of the dispatch switch statement.
+  var ContinueSentinel = {};
+
+  // Dummy constructor functions that we use as the .constructor and
+  // .constructor.prototype properties for functions that return Generator
+  // objects. For full spec compliance, you may wish to configure your
+  // minifier not to mangle the names of these two functions.
+  function Generator() {}
+  function GeneratorFunction() {}
+  function GeneratorFunctionPrototype() {}
+
+  // This is a polyfill for %IteratorPrototype% for environments that
+  // don't natively support it.
+  var IteratorPrototype = {};
+  define(IteratorPrototype, iteratorSymbol, function () {
+    return this;
+  });
+
+  var getProto = Object.getPrototypeOf;
+  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
+  if (NativeIteratorPrototype &&
+      NativeIteratorPrototype !== Op &&
+      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
+    // This environment has a native %IteratorPrototype%; use it instead
+    // of the polyfill.
+    IteratorPrototype = NativeIteratorPrototype;
+  }
+
+  var Gp = GeneratorFunctionPrototype.prototype =
+    Generator.prototype = Object.create(IteratorPrototype);
+  GeneratorFunction.prototype = GeneratorFunctionPrototype;
+  define(Gp, "constructor", GeneratorFunctionPrototype);
+  define(GeneratorFunctionPrototype, "constructor", GeneratorFunction);
+  GeneratorFunction.displayName = define(
+    GeneratorFunctionPrototype,
+    toStringTagSymbol,
+    "GeneratorFunction"
+  );
+
+  // Helper for defining the .next, .throw, and .return methods of the
+  // Iterator interface in terms of a single ._invoke method.
+  function defineIteratorMethods(prototype) {
+    ["next", "throw", "return"].forEach(function(method) {
+      define(prototype, method, function(arg) {
+        return this._invoke(method, arg);
+      });
+    });
+  }
+
+  exports.isGeneratorFunction = function(genFun) {
+    var ctor = typeof genFun === "function" && genFun.constructor;
+    return ctor
+      ? ctor === GeneratorFunction ||
+        // For the native GeneratorFunction constructor, the best we can
+        // do is to check its .name property.
+        (ctor.displayName || ctor.name) === "GeneratorFunction"
+      : false;
+  };
+
+  exports.mark = function(genFun) {
+    if (Object.setPrototypeOf) {
+      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
+    } else {
+      genFun.__proto__ = GeneratorFunctionPrototype;
+      define(genFun, toStringTagSymbol, "GeneratorFunction");
+    }
+    genFun.prototype = Object.create(Gp);
+    return genFun;
+  };
+
+  // Within the body of any async function, `await x` is transformed to
+  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
+  // `hasOwn.call(value, "__await")` to determine if the yielded value is
+  // meant to be awaited.
+  exports.awrap = function(arg) {
+    return { __await: arg };
+  };
+
+  function AsyncIterator(generator, PromiseImpl) {
+    function invoke(method, arg, resolve, reject) {
+      var record = tryCatch(generator[method], generator, arg);
+      if (record.type === "throw") {
+        reject(record.arg);
+      } else {
+        var result = record.arg;
+        var value = result.value;
+        if (value &&
+            typeof value === "object" &&
+            hasOwn.call(value, "__await")) {
+          return PromiseImpl.resolve(value.__await).then(function(value) {
+            invoke("next", value, resolve, reject);
+          }, function(err) {
+            invoke("throw", err, resolve, reject);
+          });
+        }
+
+        return PromiseImpl.resolve(value).then(function(unwrapped) {
+          // When a yielded Promise is resolved, its final value becomes
+          // the .value of the Promise<{value,done}> result for the
+          // current iteration.
+          result.value = unwrapped;
+          resolve(result);
+        }, function(error) {
+          // If a rejected Promise was yielded, throw the rejection back
+          // into the async generator function so it can be handled there.
+          return invoke("throw", error, resolve, reject);
+        });
+      }
+    }
+
+    var previousPromise;
+
+    function enqueue(method, arg) {
+      function callInvokeWithMethodAndArg() {
+        return new PromiseImpl(function(resolve, reject) {
+          invoke(method, arg, resolve, reject);
+        });
+      }
+
+      return previousPromise =
+        // If enqueue has been called before, then we want to wait until
+        // all previous Promises have been resolved before calling invoke,
+        // so that results are always delivered in the correct order. If
+        // enqueue has not been called before, then it is important to
+        // call invoke immediately, without waiting on a callback to fire,
+        // so that the async generator function has the opportunity to do
+        // any necessary setup in a predictable way. This predictability
+        // is why the Promise constructor synchronously invokes its
+        // executor callback, and why async functions synchronously
+        // execute code before the first await. Since we implement simple
+        // async functions in terms of async generators, it is especially
+        // important to get this right, even though it requires care.
+        previousPromise ? previousPromise.then(
+          callInvokeWithMethodAndArg,
+          // Avoid propagating failures to Promises returned by later
+          // invocations of the iterator.
+          callInvokeWithMethodAndArg
+        ) : callInvokeWithMethodAndArg();
+    }
+
+    // Define the unified helper method that is used to implement .next,
+    // .throw, and .return (see defineIteratorMethods).
+    this._invoke = enqueue;
+  }
+
+  defineIteratorMethods(AsyncIterator.prototype);
+  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
+    return this;
+  });
+  exports.AsyncIterator = AsyncIterator;
+
+  // Note that simple async functions are implemented on top of
+  // AsyncIterator objects; they just return a Promise for the value of
+  // the final result produced by the iterator.
+  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
+    if (PromiseImpl === void 0) PromiseImpl = Promise;
+
+    var iter = new AsyncIterator(
+      wrap(innerFn, outerFn, self, tryLocsList),
+      PromiseImpl
+    );
+
+    return exports.isGeneratorFunction(outerFn)
+      ? iter // If outerFn is a generator, return the full iterator.
+      : iter.next().then(function(result) {
+          return result.done ? result.value : iter.next();
+        });
+  };
+
+  function makeInvokeMethod(innerFn, self, context) {
+    var state = GenStateSuspendedStart;
+
+    return function invoke(method, arg) {
+      if (state === GenStateExecuting) {
+        throw new Error("Generator is already running");
+      }
+
+      if (state === GenStateCompleted) {
+        if (method === "throw") {
+          throw arg;
+        }
+
+        // Be forgiving, per 25.3.3.3.3 of the spec:
+        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
+        return doneResult();
+      }
+
+      context.method = method;
+      context.arg = arg;
+
+      while (true) {
+        var delegate = context.delegate;
+        if (delegate) {
+          var delegateResult = maybeInvokeDelegate(delegate, context);
+          if (delegateResult) {
+            if (delegateResult === ContinueSentinel) continue;
+            return delegateResult;
+          }
+        }
+
+        if (context.method === "next") {
+          // Setting context._sent for legacy support of Babel's
+          // function.sent implementation.
+          context.sent = context._sent = context.arg;
+
+        } else if (context.method === "throw") {
+          if (state === GenStateSuspendedStart) {
+            state = GenStateCompleted;
+            throw context.arg;
+          }
+
+          context.dispatchException(context.arg);
+
+        } else if (context.method === "return") {
+          context.abrupt("return", context.arg);
+        }
+
+        state = GenStateExecuting;
+
+        var record = tryCatch(innerFn, self, context);
+        if (record.type === "normal") {
+          // If an exception is thrown from innerFn, we leave state ===
+          // GenStateExecuting and loop back for another invocation.
+          state = context.done
+            ? GenStateCompleted
+            : GenStateSuspendedYield;
+
+          if (record.arg === ContinueSentinel) {
+            continue;
+          }
+
+          return {
+            value: record.arg,
+            done: context.done
+          };
+
+        } else if (record.type === "throw") {
+          state = GenStateCompleted;
+          // Dispatch the exception by looping back around to the
+          // context.dispatchException(context.arg) call above.
+          context.method = "throw";
+          context.arg = record.arg;
+        }
+      }
+    };
+  }
+
+  // Call delegate.iterator[context.method](context.arg) and handle the
+  // result, either by returning a { value, done } result from the
+  // delegate iterator, or by modifying context.method and context.arg,
+  // setting context.delegate to null, and returning the ContinueSentinel.
+  function maybeInvokeDelegate(delegate, context) {
+    var method = delegate.iterator[context.method];
+    if (method === undefined) {
+      // A .throw or .return when the delegate iterator has no .throw
+      // method always terminates the yield* loop.
+      context.delegate = null;
+
+      if (context.method === "throw") {
+        // Note: ["return"] must be used for ES3 parsing compatibility.
+        if (delegate.iterator["return"]) {
+          // If the delegate iterator has a return method, give it a
+          // chance to clean up.
+          context.method = "return";
+          context.arg = undefined;
+          maybeInvokeDelegate(delegate, context);
+
+          if (context.method === "throw") {
+            // If maybeInvokeDelegate(context) changed context.method from
+            // "return" to "throw", let that override the TypeError below.
+            return ContinueSentinel;
+          }
+        }
+
+        context.method = "throw";
+        context.arg = new TypeError(
+          "The iterator does not provide a 'throw' method");
+      }
+
+      return ContinueSentinel;
+    }
+
+    var record = tryCatch(method, delegate.iterator, context.arg);
+
+    if (record.type === "throw") {
+      context.method = "throw";
+      context.arg = record.arg;
+      context.delegate = null;
+      return ContinueSentinel;
+    }
+
+    var info = record.arg;
+
+    if (! info) {
+      context.method = "throw";
+      context.arg = new TypeError("iterator result is not an object");
+      context.delegate = null;
+      return ContinueSentinel;
+    }
+
+    if (info.done) {
+      // Assign the result of the finished delegate to the temporary
+      // variable specified by delegate.resultName (see delegateYield).
+      context[delegate.resultName] = info.value;
+
+      // Resume execution at the desired location (see delegateYield).
+      context.next = delegate.nextLoc;
+
+      // If context.method was "throw" but the delegate handled the
+      // exception, let the outer generator proceed normally. If
+      // context.method was "next", forget context.arg since it has been
+      // "consumed" by the delegate iterator. If context.method was
+      // "return", allow the original .return call to continue in the
+      // outer generator.
+      if (context.method !== "return") {
+        context.method = "next";
+        context.arg = undefined;
+      }
+
+    } else {
+      // Re-yield the result returned by the delegate method.
+      return info;
+    }
+
+    // The delegate iterator is finished, so forget it and continue with
+    // the outer generator.
+    context.delegate = null;
+    return ContinueSentinel;
+  }
+
+  // Define Generator.prototype.{next,throw,return} in terms of the
+  // unified ._invoke helper method.
+  defineIteratorMethods(Gp);
+
+  define(Gp, toStringTagSymbol, "Generator");
+
+  // A Generator should always return itself as the iterator object when the
+  // @@iterator function is called on it. Some browsers' implementations of the
+  // iterator prototype chain incorrectly implement this, causing the Generator
+  // object to not be returned from this call. This ensures that doesn't happen.
+  // See https://github.com/facebook/regenerator/issues/274 for more details.
+  define(Gp, iteratorSymbol, function() {
+    return this;
+  });
+
+  define(Gp, "toString", function() {
+    return "[object Generator]";
+  });
+
+  function pushTryEntry(locs) {
+    var entry = { tryLoc: locs[0] };
+
+    if (1 in locs) {
+      entry.catchLoc = locs[1];
+    }
+
+    if (2 in locs) {
+      entry.finallyLoc = locs[2];
+      entry.afterLoc = locs[3];
+    }
+
+    this.tryEntries.push(entry);
+  }
+
+  function resetTryEntry(entry) {
+    var record = entry.completion || {};
+    record.type = "normal";
+    delete record.arg;
+    entry.completion = record;
+  }
+
+  function Context(tryLocsList) {
+    // The root entry object (effectively a try statement without a catch
+    // or a finally block) gives us a place to store values thrown from
+    // locations where there is no enclosing try statement.
+    this.tryEntries = [{ tryLoc: "root" }];
+    tryLocsList.forEach(pushTryEntry, this);
+    this.reset(true);
+  }
+
+  exports.keys = function(object) {
+    var keys = [];
+    for (var key in object) {
+      keys.push(key);
+    }
+    keys.reverse();
+
+    // Rather than returning an object with a next method, we keep
+    // things simple and return the next function itself.
+    return function next() {
+      while (keys.length) {
+        var key = keys.pop();
+        if (key in object) {
+          next.value = key;
+          next.done = false;
+          return next;
+        }
+      }
+
+      // To avoid creating an additional object, we just hang the .value
+      // and .done properties off the next function object itself. This
+      // also ensures that the minifier will not anonymize the function.
+      next.done = true;
+      return next;
+    };
+  };
+
+  function values(iterable) {
+    if (iterable) {
+      var iteratorMethod = iterable[iteratorSymbol];
+      if (iteratorMethod) {
+        return iteratorMethod.call(iterable);
+      }
+
+      if (typeof iterable.next === "function") {
+        return iterable;
+      }
+
+      if (!isNaN(iterable.length)) {
+        var i = -1, next = function next() {
+          while (++i < iterable.length) {
+            if (hasOwn.call(iterable, i)) {
+              next.value = iterable[i];
+              next.done = false;
+              return next;
+            }
+          }
+
+          next.value = undefined;
+          next.done = true;
+
+          return next;
+        };
+
+        return next.next = next;
+      }
+    }
+
+    // Return an iterator with no values.
+    return { next: doneResult };
+  }
+  exports.values = values;
+
+  function doneResult() {
+    return { value: undefined, done: true };
+  }
+
+  Context.prototype = {
+    constructor: Context,
+
+    reset: function(skipTempReset) {
+      this.prev = 0;
+      this.next = 0;
+      // Resetting context._sent for legacy support of Babel's
+      // function.sent implementation.
+      this.sent = this._sent = undefined;
+      this.done = false;
+      this.delegate = null;
+
+      this.method = "next";
+      this.arg = undefined;
+
+      this.tryEntries.forEach(resetTryEntry);
+
+      if (!skipTempReset) {
+        for (var name in this) {
+          // Not sure about the optimal order of these conditions:
+          if (name.charAt(0) === "t" &&
+              hasOwn.call(this, name) &&
+              !isNaN(+name.slice(1))) {
+            this[name] = undefined;
+          }
+        }
+      }
+    },
+
+    stop: function() {
+      this.done = true;
+
+      var rootEntry = this.tryEntries[0];
+      var rootRecord = rootEntry.completion;
+      if (rootRecord.type === "throw") {
+        throw rootRecord.arg;
+      }
+
+      return this.rval;
+    },
+
+    dispatchException: function(exception) {
+      if (this.done) {
+        throw exception;
+      }
+
+      var context = this;
+      function handle(loc, caught) {
+        record.type = "throw";
+        record.arg = exception;
+        context.next = loc;
+
+        if (caught) {
+          // If the dispatched exception was caught by a catch block,
+          // then let that catch block handle the exception normally.
+          context.method = "next";
+          context.arg = undefined;
+        }
+
+        return !! caught;
+      }
+
+      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
+        var entry = this.tryEntries[i];
+        var record = entry.completion;
+
+        if (entry.tryLoc === "root") {
+          // Exception thrown outside of any try block that could handle
+          // it, so set the completion value of the entire function to
+          // throw the exception.
+          return handle("end");
+        }
+
+        if (entry.tryLoc <= this.prev) {
+          var hasCatch = hasOwn.call(entry, "catchLoc");
+          var hasFinally = hasOwn.call(entry, "finallyLoc");
+
+          if (hasCatch && hasFinally) {
+            if (this.prev < entry.catchLoc) {
+              return handle(entry.catchLoc, true);
+            } else if (this.prev < entry.finallyLoc) {
+              return handle(entry.finallyLoc);
+            }
+
+          } else if (hasCatch) {
+            if (this.prev < entry.catchLoc) {
+              return handle(entry.catchLoc, true);
+            }
+
+          } else if (hasFinally) {
+            if (this.prev < entry.finallyLoc) {
+              return handle(entry.finallyLoc);
+            }
+
+          } else {
+            throw new Error("try statement without catch or finally");
+          }
+        }
+      }
+    },
+
+    abrupt: function(type, arg) {
+      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
+        var entry = this.tryEntries[i];
+        if (entry.tryLoc <= this.prev &&
+            hasOwn.call(entry, "finallyLoc") &&
+            this.prev < entry.finallyLoc) {
+          var finallyEntry = entry;
+          break;
+        }
+      }
+
+      if (finallyEntry &&
+          (type === "break" ||
+           type === "continue") &&
+          finallyEntry.tryLoc <= arg &&
+          arg <= finallyEntry.finallyLoc) {
+        // Ignore the finally entry if control is not jumping to a
+        // location outside the try/catch block.
+        finallyEntry = null;
+      }
+
+      var record = finallyEntry ? finallyEntry.completion : {};
+      record.type = type;
+      record.arg = arg;
+
+      if (finallyEntry) {
+        this.method = "next";
+        this.next = finallyEntry.finallyLoc;
+        return ContinueSentinel;
+      }
+
+      return this.complete(record);
+    },
+
+    complete: function(record, afterLoc) {
+      if (record.type === "throw") {
+        throw record.arg;
+      }
+
+      if (record.type === "break" ||
+          record.type === "continue") {
+        this.next = record.arg;
+      } else if (record.type === "return") {
+        this.rval = this.arg = record.arg;
+        this.method = "return";
+        this.next = "end";
+      } else if (record.type === "normal" && afterLoc) {
+        this.next = afterLoc;
+      }
+
+      return ContinueSentinel;
+    },
+
+    finish: function(finallyLoc) {
+      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
+        var entry = this.tryEntries[i];
+        if (entry.finallyLoc === finallyLoc) {
+          this.complete(entry.completion, entry.afterLoc);
+          resetTryEntry(entry);
+          return ContinueSentinel;
+        }
+      }
+    },
+
+    "catch": function(tryLoc) {
+      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
+        var entry = this.tryEntries[i];
+        if (entry.tryLoc === tryLoc) {
+          var record = entry.completion;
+          if (record.type === "throw") {
+            var thrown = record.arg;
+            resetTryEntry(entry);
+          }
+          return thrown;
+        }
+      }
+
+      // The context.catch method must only be called with a location
+      // argument that corresponds to a known catch block.
+      throw new Error("illegal catch attempt");
+    },
+
+    delegateYield: function(iterable, resultName, nextLoc) {
+      this.delegate = {
+        iterator: values(iterable),
+        resultName: resultName,
+        nextLoc: nextLoc
+      };
+
+      if (this.method === "next") {
+        // Deliberately forget the last sent value so that we don't
+        // accidentally pass it on to the delegate.
+        this.arg = undefined;
+      }
+
+      return ContinueSentinel;
+    }
+  };
+
+  // Regardless of whether this script is executing as a CommonJS module
+  // or not, return the runtime object so that we can declare the variable
+  // regeneratorRuntime in the outer scope, which allows this module to be
+  // injected easily by `bin/regenerator --include-runtime script.js`.
+  return exports;
+
+}(
+  // If this script is executing as a CommonJS module, use module.exports
+  // as the regeneratorRuntime namespace. Otherwise create a new empty
+  // object. Either way, the resulting object will be used to initialize
+  // the regeneratorRuntime variable at the top of this file.
+   true ? module.exports : 0
+));
+
+try {
+  regeneratorRuntime = runtime;
+} catch (accidentalStrictMode) {
+  // This module should not be running in strict mode, so the above
+  // assignment should always work unless something is misconfigured. Just
+  // in case runtime.js accidentally runs in strict mode, in modern engines
+  // we can explicitly access globalThis. In older engines we can escape
+  // strict mode using a global Function call. This could conceivably fail
+  // if a Content Security Policy forbids using Function, but in that case
+  // the proper solution is to fix the accidental strict mode problem. If
+  // you've misconfigured your bundler to force strict mode and applied a
+  // CSP to forbid Function, and you're not willing to fix either of those
+  // problems, please detail your unique predicament in a GitHub issue.
+  if (typeof globalThis === "object") {
+    globalThis.regeneratorRuntime = runtime;
+  } else {
+    Function("r", "regeneratorRuntime = r")(runtime);
+  }
+}
+
+
+/***/ }),
+
+/***/ 9685:
+/***/ ((module, exports, __webpack_require__) => {
+
+/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
+/* eslint-disable node/no-deprecated-api */
+var buffer = __webpack_require__(7866)
+var Buffer = buffer.Buffer
+
+// alternative to using Object.keys for old browsers
+function copyProps (src, dst) {
+  for (var key in src) {
+    dst[key] = src[key]
+  }
+}
+if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
+  module.exports = buffer
+} else {
+  // Copy properties from require('buffer')
+  copyProps(buffer, exports)
+  exports.Buffer = SafeBuffer
+}
+
+function SafeBuffer (arg, encodingOrOffset, length) {
+  return Buffer(arg, encodingOrOffset, length)
+}
+
+SafeBuffer.prototype = Object.create(Buffer.prototype)
+
+// Copy static methods from Buffer
+copyProps(Buffer, SafeBuffer)
+
+SafeBuffer.from = function (arg, encodingOrOffset, length) {
+  if (typeof arg === 'number') {
+    throw new TypeError('Argument must not be a number')
+  }
+  return Buffer(arg, encodingOrOffset, length)
+}
+
+SafeBuffer.alloc = function (size, fill, encoding) {
+  if (typeof size !== 'number') {
+    throw new TypeError('Argument must be a number')
+  }
+  var buf = Buffer(size)
+  if (fill !== undefined) {
+    if (typeof encoding === 'string') {
+      buf.fill(fill, encoding)
+    } else {
+      buf.fill(fill)
+    }
+  } else {
+    buf.fill(0)
+  }
+  return buf
+}
+
+SafeBuffer.allocUnsafe = function (size) {
+  if (typeof size !== 'number') {
+    throw new TypeError('Argument must be a number')
+  }
+  return Buffer(size)
+}
+
+SafeBuffer.allocUnsafeSlow = function (size) {
+  if (typeof size !== 'number') {
+    throw new TypeError('Argument must be a number')
+  }
+  return buffer.SlowBuffer(size)
+}
+
+
+/***/ }),
+
+/***/ 8981:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+// Copyright Joyent, Inc. and other Node contributors.
+//
+// Permission is hereby granted, free of charge, to any person obtaining a
+// copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to permit
+// persons to whom the Software is furnished to do so, subject to the
+// following conditions:
+//
+// The above copyright notice and this permission notice shall be included
+// in all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
+// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
+// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
+// USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+module.exports = Stream;
+
+var EE = __webpack_require__(488).EventEmitter;
+var inherits = __webpack_require__(3730);
+
+inherits(Stream, EE);
+Stream.Readable = __webpack_require__(5006);
+Stream.Writable = __webpack_require__(8719);
+Stream.Duplex = __webpack_require__(673);
+Stream.Transform = __webpack_require__(8597);
+Stream.PassThrough = __webpack_require__(4343);
+Stream.finished = __webpack_require__(2426)
+Stream.pipeline = __webpack_require__(2970)
+
+// Backwards-compat with node 0.4.x
+Stream.Stream = Stream;
+
+
+
+// old-style streams.  Note that the pipe method (the only relevant
+// part of this class) is overridden in the Readable class.
+
+function Stream() {
+  EE.call(this);
+}
+
+Stream.prototype.pipe = function(dest, options) {
+  var source = this;
+
+  function ondata(chunk) {
+    if (dest.writable) {
+      if (false === dest.write(chunk) && source.pause) {
+        source.pause();
+      }
+    }
+  }
+
+  source.on('data', ondata);
+
+  function ondrain() {
+    if (source.readable && source.resume) {
+      source.resume();
+    }
+  }
+
+  dest.on('drain', ondrain);
+
+  // If the 'end' option is not supplied, dest.end() will be called when
+  // source gets the 'end' or 'close' events.  Only dest.end() once.
+  if (!dest._isStdio && (!options || options.end !== false)) {
+    source.on('end', onend);
+    source.on('close', onclose);
+  }
+
+  var didOnEnd = false;
+  function onend() {
+    if (didOnEnd) return;
+    didOnEnd = true;
+
+    dest.end();
+  }
+
+
+  function onclose() {
+    if (didOnEnd) return;
+    didOnEnd = true;
+
+    if (typeof dest.destroy === 'function') dest.destroy();
+  }
+
+  // don't leave dangling pipes when there are errors.
+  function onerror(er) {
+    cleanup();
+    if (EE.listenerCount(this, 'error') === 0) {
+      throw er; // Unhandled stream error in pipe.
+    }
+  }
+
+  source.on('error', onerror);
+  dest.on('error', onerror);
+
+  // remove all the event listeners that were added.
+  function cleanup() {
+    source.removeListener('data', ondata);
+    dest.removeListener('drain', ondrain);
+
+    source.removeListener('end', onend);
+    source.removeListener('close', onclose);
+
+    source.removeListener('error', onerror);
+    dest.removeListener('error', onerror);
+
+    source.removeListener('end', cleanup);
+    source.removeListener('close', cleanup);
+
+    dest.removeListener('close', cleanup);
+  }
+
+  source.on('end', cleanup);
+  source.on('close', cleanup);
+
+  dest.on('close', cleanup);
+
+  dest.emit('pipe', source);
+
+  // Allow for unix-like usage: A.pipe(B).pipe(C)
+  return dest;
+};
+
+
+/***/ }),
+
+/***/ 9481:
+/***/ ((__unused_webpack_module, exports, __webpack_require__) => {
+
+"use strict";
+// Copyright Joyent, Inc. and other Node contributors.
+//
+// Permission is hereby granted, free of charge, to any person obtaining a
+// copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to permit
+// persons to whom the Software is furnished to do so, subject to the
+// following conditions:
+//
+// The above copyright notice and this permission notice shall be included
+// in all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
+// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
+// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
+// USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+
+
+/*<replacement>*/
+
+var Buffer = __webpack_require__(9685).Buffer;
+/*</replacement>*/
+
+var isEncoding = Buffer.isEncoding || function (encoding) {
+  encoding = '' + encoding;
+  switch (encoding && encoding.toLowerCase()) {
+    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
+      return true;
+    default:
+      return false;
+  }
+};
+
+function _normalizeEncoding(enc) {
+  if (!enc) return 'utf8';
+  var retried;
+  while (true) {
+    switch (enc) {
+      case 'utf8':
+      case 'utf-8':
+        return 'utf8';
+      case 'ucs2':
+      case 'ucs-2':
+      case 'utf16le':
+      case 'utf-16le':
+        return 'utf16le';
+      case 'latin1':
+      case 'binary':
+        return 'latin1';
+      case 'base64':
+      case 'ascii':
+      case 'hex':
+        return enc;
+      default:
+        if (retried) return; // undefined
+        enc = ('' + enc).toLowerCase();
+        retried = true;
+    }
+  }
+};
+
+// Do not cache `Buffer.isEncoding` when checking encoding names as some
+// modules monkey-patch it to support additional encodings
+function normalizeEncoding(enc) {
+  var nenc = _normalizeEncoding(enc);
+  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
+  return nenc || enc;
+}
+
+// StringDecoder provides an interface for efficiently splitting a series of
+// buffers into a series of JS strings without breaking apart multi-byte
+// characters.
+exports.s = StringDecoder;
+function StringDecoder(encoding) {
+  this.encoding = normalizeEncoding(encoding);
+  var nb;
+  switch (this.encoding) {
+    case 'utf16le':
+      this.text = utf16Text;
+      this.end = utf16End;
+      nb = 4;
+      break;
+    case 'utf8':
+      this.fillLast = utf8FillLast;
+      nb = 4;
+      break;
+    case 'base64':
+      this.text = base64Text;
+      this.end = base64End;
+      nb = 3;
+      break;
+    default:
+      this.write = simpleWrite;
+      this.end = simpleEnd;
+      return;
+  }
+  this.lastNeed = 0;
+  this.lastTotal = 0;
+  this.lastChar = Buffer.allocUnsafe(nb);
+}
+
+StringDecoder.prototype.write = function (buf) {
+  if (buf.length === 0) return '';
+  var r;
+  var i;
+  if (this.lastNeed) {
+    r = this.fillLast(buf);
+    if (r === undefined) return '';
+    i = this.lastNeed;
+    this.lastNeed = 0;
+  } else {
+    i = 0;
+  }
+  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
+  return r || '';
+};
+
+StringDecoder.prototype.end = utf8End;
+
+// Returns only complete characters in a Buffer
+StringDecoder.prototype.text = utf8Text;
+
+// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
+StringDecoder.prototype.fillLast = function (buf) {
+  if (this.lastNeed <= buf.length) {
+    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
+    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
+  }
+  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
+  this.lastNeed -= buf.length;
+};
+
+// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
+// continuation byte. If an invalid byte is detected, -2 is returned.
+function utf8CheckByte(byte) {
+  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
+  return byte >> 6 === 0x02 ? -1 : -2;
+}
+
+// Checks at most 3 bytes at the end of a Buffer in order to detect an
+// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
+// needed to complete the UTF-8 character (if applicable) are returned.
+function utf8CheckIncomplete(self, buf, i) {
+  var j = buf.length - 1;
+  if (j < i) return 0;
+  var nb = utf8CheckByte(buf[j]);
+  if (nb >= 0) {
+    if (nb > 0) self.lastNeed = nb - 1;
+    return nb;
+  }
+  if (--j < i || nb === -2) return 0;
+  nb = utf8CheckByte(buf[j]);
+  if (nb >= 0) {
+    if (nb > 0) self.lastNeed = nb - 2;
+    return nb;
+  }
+  if (--j < i || nb === -2) return 0;
+  nb = utf8CheckByte(buf[j]);
+  if (nb >= 0) {
+    if (nb > 0) {
+      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
+    }
+    return nb;
+  }
+  return 0;
+}
+
+// Validates as many continuation bytes for a multi-byte UTF-8 character as
+// needed or are available. If we see a non-continuation byte where we expect
+// one, we "replace" the validated continuation bytes we've seen so far with
+// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
+// behavior. The continuation byte check is included three times in the case
+// where all of the continuation bytes for a character exist in the same buffer.
+// It is also done this way as a slight performance increase instead of using a
+// loop.
+function utf8CheckExtraBytes(self, buf, p) {
+  if ((buf[0] & 0xC0) !== 0x80) {
+    self.lastNeed = 0;
+    return '\ufffd';
+  }
+  if (self.lastNeed > 1 && buf.length > 1) {
+    if ((buf[1] & 0xC0) !== 0x80) {
+      self.lastNeed = 1;
+      return '\ufffd';
+    }
+    if (self.lastNeed > 2 && buf.length > 2) {
+      if ((buf[2] & 0xC0) !== 0x80) {
+        self.lastNeed = 2;
+        return '\ufffd';
+      }
+    }
+  }
+}
+
+// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
+function utf8FillLast(buf) {
+  var p = this.lastTotal - this.lastNeed;
+  var r = utf8CheckExtraBytes(this, buf, p);
+  if (r !== undefined) return r;
+  if (this.lastNeed <= buf.length) {
+    buf.copy(this.lastChar, p, 0, this.lastNeed);
+    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
+  }
+  buf.copy(this.lastChar, p, 0, buf.length);
+  this.lastNeed -= buf.length;
+}
+
+// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
+// partial character, the character's bytes are buffered until the required
+// number of bytes are available.
+function utf8Text(buf, i) {
+  var total = utf8CheckIncomplete(this, buf, i);
+  if (!this.lastNeed) return buf.toString('utf8', i);
+  this.lastTotal = total;
+  var end = buf.length - (total - this.lastNeed);
+  buf.copy(this.lastChar, 0, end);
+  return buf.toString('utf8', i, end);
+}
+
+// For UTF-8, a replacement character is added when ending on a partial
+// character.
+function utf8End(buf) {
+  var r = buf && buf.length ? this.write(buf) : '';
+  if (this.lastNeed) return r + '\ufffd';
+  return r;
+}
+
+// UTF-16LE typically needs two bytes per character, but even if we have an even
+// number of bytes available, we need to check if we end on a leading/high
+// surrogate. In that case, we need to wait for the next two bytes in order to
+// decode the last character properly.
+function utf16Text(buf, i) {
+  if ((buf.length - i) % 2 === 0) {
+    var r = buf.toString('utf16le', i);
+    if (r) {
+      var c = r.charCodeAt(r.length - 1);
+      if (c >= 0xD800 && c <= 0xDBFF) {
+        this.lastNeed = 2;
+        this.lastTotal = 4;
+        this.lastChar[0] = buf[buf.length - 2];
+        this.lastChar[1] = buf[buf.length - 1];
+        return r.slice(0, -1);
+      }
+    }
+    return r;
+  }
+  this.lastNeed = 1;
+  this.lastTotal = 2;
+  this.lastChar[0] = buf[buf.length - 1];
+  return buf.toString('utf16le', i, buf.length - 1);
+}
+
+// For UTF-16LE we do not explicitly append special replacement characters if we
+// end on a partial character, we simply let v8 handle that.
+function utf16End(buf) {
+  var r = buf && buf.length ? this.write(buf) : '';
+  if (this.lastNeed) {
+    var end = this.lastTotal - this.lastNeed;
+    return r + this.lastChar.toString('utf16le', 0, end);
+  }
+  return r;
+}
+
+function base64Text(buf, i) {
+  var n = (buf.length - i) % 3;
+  if (n === 0) return buf.toString('base64', i);
+  this.lastNeed = 3 - n;
+  this.lastTotal = 3;
+  if (n === 1) {
+    this.lastChar[0] = buf[buf.length - 1];
+  } else {
+    this.lastChar[0] = buf[buf.length - 2];
+    this.lastChar[1] = buf[buf.length - 1];
+  }
+  return buf.toString('base64', i, buf.length - n);
+}
+
+function base64End(buf) {
+  var r = buf && buf.length ? this.write(buf) : '';
+  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
+  return r;
+}
+
+// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
+function simpleWrite(buf) {
+  return buf.toString(this.encoding);
+}
+
+function simpleEnd(buf) {
+  return buf && buf.length ? this.write(buf) : '';
+}
+
+/***/ }),
+
+/***/ 2993:
+/***/ ((__unused_webpack_module, exports) => {
+
+"use strict";
+var __webpack_unused_export__;
+
+/*
+
+TypeScript Md5
+==============
+
+Based on work by
+* Joseph Myers: http://www.myersdaily.org/joseph/javascript/md5-text.html
+* Andr Cruz: https://github.com/satazor/SparkMD5
+* Raymond Hill: https://github.com/gorhill/yamd5.js
+
+Effectively a TypeScrypt re-write of Raymond Hill JS Library
+
+The MIT License (MIT)
+
+Copyright (C) 2014 Raymond Hill
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
+
+
+
+            DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE
+                    Version 2, December 2004
+
+ Copyright (C) 2015 Andr Cruz <amdfcruz@gmail.com>
+
+ Everyone is permitted to copy and distribute verbatim or modified
+ copies of this license document, and changing it is allowed as long
+ as the name is changed.
+
+            DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. You just DO WHAT THE FUCK YOU WANT TO.
+
+
+*/
+__webpack_unused_export__ = ({ value: true });
+var Md5 = /** @class */ (function () {
+    function Md5() {
+        this._state = new Int32Array(4);
+        this._buffer = new ArrayBuffer(68);
+        this._buffer8 = new Uint8Array(this._buffer, 0, 68);
+        this._buffer32 = new Uint32Array(this._buffer, 0, 17);
+        this.start();
+    }
+    Md5.hashStr = function (str, raw) {
+        if (raw === void 0) { raw = false; }
+        return this.onePassHasher
+            .start()
+            .appendStr(str)
+            .end(raw);
+    };
+    Md5.hashAsciiStr = function (str, raw) {
+        if (raw === void 0) { raw = false; }
+        return this.onePassHasher
+            .start()
+            .appendAsciiStr(str)
+            .end(raw);
+    };
+    Md5._hex = function (x) {
+        var hc = Md5.hexChars;
+        var ho = Md5.hexOut;
+        var n;
+        var offset;
+        var j;
+        var i;
+        for (i = 0; i < 4; i += 1) {
+            offset = i * 8;
+            n = x[i];
+            for (j = 0; j < 8; j += 2) {
+                ho[offset + 1 + j] = hc.charAt(n & 0x0F);
+                n >>>= 4;
+                ho[offset + 0 + j] = hc.charAt(n & 0x0F);
+                n >>>= 4;
+            }
+        }
+        return ho.join('');
+    };
+    Md5._md5cycle = function (x, k) {
+        var a = x[0];
+        var b = x[1];
+        var c = x[2];
+        var d = x[3];
+        // ff()
+        a += (b & c | ~b & d) + k[0] - 680876936 | 0;
+        a = (a << 7 | a >>> 25) + b | 0;
+        d += (a & b | ~a & c) + k[1] - 389564586 | 0;
+        d = (d << 12 | d >>> 20) + a | 0;
+        c += (d & a | ~d & b) + k[2] + 606105819 | 0;
+        c = (c << 17 | c >>> 15) + d | 0;
+        b += (c & d | ~c & a) + k[3] - 1044525330 | 0;
+        b = (b << 22 | b >>> 10) + c | 0;
+        a += (b & c | ~b & d) + k[4] - 176418897 | 0;
+        a = (a << 7 | a >>> 25) + b | 0;
+        d += (a & b | ~a & c) + k[5] + 1200080426 | 0;
+        d = (d << 12 | d >>> 20) + a | 0;
+        c += (d & a | ~d & b) + k[6] - 1473231341 | 0;
+        c = (c << 17 | c >>> 15) + d | 0;
+        b += (c & d | ~c & a) + k[7] - 45705983 | 0;
+        b = (b << 22 | b >>> 10) + c | 0;
+        a += (b & c | ~b & d) + k[8] + 1770035416 | 0;
+        a = (a << 7 | a >>> 25) + b | 0;
+        d += (a & b | ~a & c) + k[9] - 1958414417 | 0;
+        d = (d << 12 | d >>> 20) + a | 0;
+        c += (d & a | ~d & b) + k[10] - 42063 | 0;
+        c = (c << 17 | c >>> 15) + d | 0;
+        b += (c & d | ~c & a) + k[11] - 1990404162 | 0;
+        b = (b << 22 | b >>> 10) + c | 0;
+        a += (b & c | ~b & d) + k[12] + 1804603682 | 0;
+        a = (a << 7 | a >>> 25) + b | 0;
+        d += (a & b | ~a & c) + k[13] - 40341101 | 0;
+        d = (d << 12 | d >>> 20) + a | 0;
+        c += (d & a | ~d & b) + k[14] - 1502002290 | 0;
+        c = (c << 17 | c >>> 15) + d | 0;
+        b += (c & d | ~c & a) + k[15] + 1236535329 | 0;
+        b = (b << 22 | b >>> 10) + c | 0;
+        // gg()
+        a += (b & d | c & ~d) + k[1] - 165796510 | 0;
+        a = (a << 5 | a >>> 27) + b | 0;
+        d += (a & c | b & ~c) + k[6] - 1069501632 | 0;
+        d = (d << 9 | d >>> 23) + a | 0;
+        c += (d & b | a & ~b) + k[11] + 643717713 | 0;
+        c = (c << 14 | c >>> 18) + d | 0;
+        b += (c & a | d & ~a) + k[0] - 373897302 | 0;
+        b = (b << 20 | b >>> 12) + c | 0;
+        a += (b & d | c & ~d) + k[5] - 701558691 | 0;
+        a = (a << 5 | a >>> 27) + b | 0;
+        d += (a & c | b & ~c) + k[10] + 38016083 | 0;
+        d = (d << 9 | d >>> 23) + a | 0;
+        c += (d & b | a & ~b) + k[15] - 660478335 | 0;
+        c = (c << 14 | c >>> 18) + d | 0;
+        b += (c & a | d & ~a) + k[4] - 405537848 | 0;
+        b = (b << 20 | b >>> 12) + c | 0;
+        a += (b & d | c & ~d) + k[9] + 568446438 | 0;
+        a = (a << 5 | a >>> 27) + b | 0;
+        d += (a & c | b & ~c) + k[14] - 1019803690 | 0;
+        d = (d << 9 | d >>> 23) + a | 0;
+        c += (d & b | a & ~b) + k[3] - 187363961 | 0;
+        c = (c << 14 | c >>> 18) + d | 0;
+        b += (c & a | d & ~a) + k[8] + 1163531501 | 0;
+        b = (b << 20 | b >>> 12) + c | 0;
+        a += (b & d | c & ~d) + k[13] - 1444681467 | 0;
+        a = (a << 5 | a >>> 27) + b | 0;
+        d += (a & c | b & ~c) + k[2] - 51403784 | 0;
+        d = (d << 9 | d >>> 23) + a | 0;
+        c += (d & b | a & ~b) + k[7] + 1735328473 | 0;
+        c = (c << 14 | c >>> 18) + d | 0;
+        b += (c & a | d & ~a) + k[12] - 1926607734 | 0;
+        b = (b << 20 | b >>> 12) + c | 0;
+        // hh()
+        a += (b ^ c ^ d) + k[5] - 378558 | 0;
+        a = (a << 4 | a >>> 28) + b | 0;
+        d += (a ^ b ^ c) + k[8] - 2022574463 | 0;
+        d = (d << 11 | d >>> 21) + a | 0;
+        c += (d ^ a ^ b) + k[11] + 1839030562 | 0;
+        c = (c << 16 | c >>> 16) + d | 0;
+        b += (c ^ d ^ a) + k[14] - 35309556 | 0;
+        b = (b << 23 | b >>> 9) + c | 0;
+        a += (b ^ c ^ d) + k[1] - 1530992060 | 0;
+        a = (a << 4 | a >>> 28) + b | 0;
+        d += (a ^ b ^ c) + k[4] + 1272893353 | 0;
+        d = (d << 11 | d >>> 21) + a | 0;
+        c += (d ^ a ^ b) + k[7] - 155497632 | 0;
+        c = (c << 16 | c >>> 16) + d | 0;
+        b += (c ^ d ^ a) + k[10] - 1094730640 | 0;
+        b = (b << 23 | b >>> 9) + c | 0;
+        a += (b ^ c ^ d) + k[13] + 681279174 | 0;
+        a = (a << 4 | a >>> 28) + b | 0;
+        d += (a ^ b ^ c) + k[0] - 358537222 | 0;
+        d = (d << 11 | d >>> 21) + a | 0;
+        c += (d ^ a ^ b) + k[3] - 722521979 | 0;
+        c = (c << 16 | c >>> 16) + d | 0;
+        b += (c ^ d ^ a) + k[6] + 76029189 | 0;
+        b = (b << 23 | b >>> 9) + c | 0;
+        a += (b ^ c ^ d) + k[9] - 640364487 | 0;
+        a = (a << 4 | a >>> 28) + b | 0;
+        d += (a ^ b ^ c) + k[12] - 421815835 | 0;
+        d = (d << 11 | d >>> 21) + a | 0;
+        c += (d ^ a ^ b) + k[15] + 530742520 | 0;
+        c = (c << 16 | c >>> 16) + d | 0;
+        b += (c ^ d ^ a) + k[2] - 995338651 | 0;
+        b = (b << 23 | b >>> 9) + c | 0;
+        // ii()
+        a += (c ^ (b | ~d)) + k[0] - 198630844 | 0;
+        a = (a << 6 | a >>> 26) + b | 0;
+        d += (b ^ (a | ~c)) + k[7] + 1126891415 | 0;
+        d = (d << 10 | d >>> 22) + a | 0;
+        c += (a ^ (d | ~b)) + k[14] - 1416354905 | 0;
+        c = (c << 15 | c >>> 17) + d | 0;
+        b += (d ^ (c | ~a)) + k[5] - 57434055 | 0;
+        b = (b << 21 | b >>> 11) + c | 0;
+        a += (c ^ (b | ~d)) + k[12] + 1700485571 | 0;
+        a = (a << 6 | a >>> 26) + b | 0;
+        d += (b ^ (a | ~c)) + k[3] - 1894986606 | 0;
+        d = (d << 10 | d >>> 22) + a | 0;
+        c += (a ^ (d | ~b)) + k[10] - 1051523 | 0;
+        c = (c << 15 | c >>> 17) + d | 0;
+        b += (d ^ (c | ~a)) + k[1] - 2054922799 | 0;
+        b = (b << 21 | b >>> 11) + c | 0;
+        a += (c ^ (b | ~d)) + k[8] + 1873313359 | 0;
+        a = (a << 6 | a >>> 26) + b | 0;
+        d += (b ^ (a | ~c)) + k[15] - 30611744 | 0;
+        d = (d << 10 | d >>> 22) + a | 0;
+        c += (a ^ (d | ~b)) + k[6] - 1560198380 | 0;
+        c = (c << 15 | c >>> 17) + d | 0;
+        b += (d ^ (c | ~a)) + k[13] + 1309151649 | 0;
+        b = (b << 21 | b >>> 11) + c | 0;
+        a += (c ^ (b | ~d)) + k[4] - 145523070 | 0;
+        a = (a << 6 | a >>> 26) + b | 0;
+        d += (b ^ (a | ~c)) + k[11] - 1120210379 | 0;
+        d = (d << 10 | d >>> 22) + a | 0;
+        c += (a ^ (d | ~b)) + k[2] + 718787259 | 0;
+        c = (c << 15 | c >>> 17) + d | 0;
+        b += (d ^ (c | ~a)) + k[9] - 343485551 | 0;
+        b = (b << 21 | b >>> 11) + c | 0;
+        x[0] = a + x[0] | 0;
+        x[1] = b + x[1] | 0;
+        x[2] = c + x[2] | 0;
+        x[3] = d + x[3] | 0;
+    };
+    Md5.prototype.start = function () {
+        this._dataLength = 0;
+        this._bufferLength = 0;
+        this._state.set(Md5.stateIdentity);
+        return this;
+    };
+    // Char to code point to to array conversion:
+    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/charCodeAt
+    // #Example.3A_Fixing_charCodeAt_to_handle_non-Basic-Multilingual-Plane_characters_if_their_presence_earlier_in_the_string_is_unknown
+    Md5.prototype.appendStr = function (str) {
+        var buf8 = this._buffer8;
+        var buf32 = this._buffer32;
+        var bufLen = this._bufferLength;
+        var code;
+        var i;
+        for (i = 0; i < str.length; i += 1) {
+            code = str.charCodeAt(i);
+            if (code < 128) {
+                buf8[bufLen++] = code;
+            }
+            else if (code < 0x800) {
+                buf8[bufLen++] = (code >>> 6) + 0xC0;
+                buf8[bufLen++] = code & 0x3F | 0x80;
+            }
+            else if (code < 0xD800 || code > 0xDBFF) {
+                buf8[bufLen++] = (code >>> 12) + 0xE0;
+                buf8[bufLen++] = (code >>> 6 & 0x3F) | 0x80;
+                buf8[bufLen++] = (code & 0x3F) | 0x80;
+            }
+            else {
+                code = ((code - 0xD800) * 0x400) + (str.charCodeAt(++i) - 0xDC00) + 0x10000;
+                if (code > 0x10FFFF) {
+                    throw new Error('Unicode standard supports code points up to U+10FFFF');
+                }
+                buf8[bufLen++] = (code >>> 18) + 0xF0;
+                buf8[bufLen++] = (code >>> 12 & 0x3F) | 0x80;
+                buf8[bufLen++] = (code >>> 6 & 0x3F) | 0x80;
+                buf8[bufLen++] = (code & 0x3F) | 0x80;
+            }
+            if (bufLen >= 64) {
+                this._dataLength += 64;
+                Md5._md5cycle(this._state, buf32);
+                bufLen -= 64;
+                buf32[0] = buf32[16];
+            }
+        }
+        this._bufferLength = bufLen;
+        return this;
+    };
+    Md5.prototype.appendAsciiStr = function (str) {
+        var buf8 = this._buffer8;
+        var buf32 = this._buffer32;
+        var bufLen = this._bufferLength;
+        var i;
+        var j = 0;
+        for (;;) {
+            i = Math.min(str.length - j, 64 - bufLen);
+            while (i--) {
+                buf8[bufLen++] = str.charCodeAt(j++);
+            }
+            if (bufLen < 64) {
+                break;
+            }
+            this._dataLength += 64;
+            Md5._md5cycle(this._state, buf32);
+            bufLen = 0;
+        }
+        this._bufferLength = bufLen;
+        return this;
+    };
+    Md5.prototype.appendByteArray = function (input) {
+        var buf8 = this._buffer8;
+        var buf32 = this._buffer32;
+        var bufLen = this._bufferLength;
+        var i;
+        var j = 0;
+        for (;;) {
+            i = Math.min(input.length - j, 64 - bufLen);
+            while (i--) {
+                buf8[bufLen++] = input[j++];
+            }
+            if (bufLen < 64) {
+                break;
+            }
+            this._dataLength += 64;
+            Md5._md5cycle(this._state, buf32);
+            bufLen = 0;
+        }
+        this._bufferLength = bufLen;
+        return this;
+    };
+    Md5.prototype.getState = function () {
+        var self = this;
+        var s = self._state;
+        return {
+            buffer: String.fromCharCode.apply(null, self._buffer8),
+            buflen: self._bufferLength,
+            length: self._dataLength,
+            state: [s[0], s[1], s[2], s[3]]
+        };
+    };
+    Md5.prototype.setState = function (state) {
+        var buf = state.buffer;
+        var x = state.state;
+        var s = this._state;
+        var i;
+        this._dataLength = state.length;
+        this._bufferLength = state.buflen;
+        s[0] = x[0];
+        s[1] = x[1];
+        s[2] = x[2];
+        s[3] = x[3];
+        for (i = 0; i < buf.length; i += 1) {
+            this._buffer8[i] = buf.charCodeAt(i);
+        }
+    };
+    Md5.prototype.end = function (raw) {
+        if (raw === void 0) { raw = false; }
+        var bufLen = this._bufferLength;
+        var buf8 = this._buffer8;
+        var buf32 = this._buffer32;
+        var i = (bufLen >> 2) + 1;
+        var dataBitsLen;
+        this._dataLength += bufLen;
+        buf8[bufLen] = 0x80;
+        buf8[bufLen + 1] = buf8[bufLen + 2] = buf8[bufLen + 3] = 0;
+        buf32.set(Md5.buffer32Identity.subarray(i), i);
+        if (bufLen > 55) {
+            Md5._md5cycle(this._state, buf32);
+            buf32.set(Md5.buffer32Identity);
+        }
+        // Do the final computation based on the tail and length
+        // Beware that the final length may not fit in 32 bits so we take care of that
+        dataBitsLen = this._dataLength * 8;
+        if (dataBitsLen <= 0xFFFFFFFF) {
+            buf32[14] = dataBitsLen;
+        }
+        else {
+            var matches = dataBitsLen.toString(16).match(/(.*?)(.{0,8})$/);
+            if (matches === null) {
+                return;
+            }
+            var lo = parseInt(matches[2], 16);
+            var hi = parseInt(matches[1], 16) || 0;
+            buf32[14] = lo;
+            buf32[15] = hi;
+        }
+        Md5._md5cycle(this._state, buf32);
+        return raw ? this._state : Md5._hex(this._state);
+    };
+    // Private Static Variables
+    Md5.stateIdentity = new Int32Array([1732584193, -271733879, -1732584194, 271733878]);
+    Md5.buffer32Identity = new Int32Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
+    Md5.hexChars = '0123456789abcdef';
+    Md5.hexOut = [];
+    // Permanent instance is to use for one-call hashing
+    Md5.onePassHasher = new Md5();
+    return Md5;
+}());
+exports.V = Md5;
+if (Md5.hashStr('hello') !== '5d41402abc4b2a76b9719d911017c592') {
+    console.error('Md5 self test failed.');
+}
+//# sourceMappingURL=md5.js.map
+
+/***/ }),
+
+/***/ 72:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+
+/**
+ * Module exports.
+ */
+
+module.exports = deprecate;
+
+/**
+ * Mark that a method should not be used.
+ * Returns a modified function which warns once by default.
+ *
+ * If `localStorage.noDeprecation = true` is set, then it is a no-op.
+ *
+ * If `localStorage.throwDeprecation = true` is set, then deprecated functions
+ * will throw an Error when invoked.
+ *
+ * If `localStorage.traceDeprecation = true` is set, then deprecated functions
+ * will invoke `console.trace()` instead of `console.error()`.
+ *
+ * @param {Function} fn - the function to deprecate
+ * @param {String} msg - the string to print to the console when `fn` is invoked
+ * @returns {Function} a new "deprecated" version of `fn`
+ * @api public
+ */
+
+function deprecate (fn, msg) {
+  if (config('noDeprecation')) {
+    return fn;
+  }
+
+  var warned = false;
+  function deprecated() {
+    if (!warned) {
+      if (config('throwDeprecation')) {
+        throw new Error(msg);
+      } else if (config('traceDeprecation')) {
+        console.trace(msg);
+      } else {
+        console.warn(msg);
+      }
+      warned = true;
+    }
+    return fn.apply(this, arguments);
+  }
+
+  return deprecated;
+}
+
+/**
+ * Checks `localStorage` for boolean values for the given `name`.
+ *
+ * @param {String} name
+ * @returns {Boolean}
+ * @api private
+ */
+
+function config (name) {
+  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
+  try {
+    if (!__webpack_require__.g.localStorage) return false;
+  } catch (_) {
+    return false;
+  }
+  var val = __webpack_require__.g.localStorage[name];
+  if (null == val) return false;
+  return String(val).toLowerCase() === 'true';
+}
+
+
+/***/ }),
+
+/***/ 769:
+/***/ ((module) => {
+
+module.exports = function (it) {
+  if (typeof it != 'function') {
+    throw TypeError(String(it) + ' is not a function');
+  } return it;
+};
+
+
+/***/ }),
+
+/***/ 8143:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var isObject = __webpack_require__(6944);
+
+module.exports = function (it) {
+  if (!isObject(it) && it !== null) {
+    throw TypeError("Can't set " + String(it) + ' as a prototype');
+  } return it;
+};
+
+
+/***/ }),
+
+/***/ 9611:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var wellKnownSymbol = __webpack_require__(3706);
+var create = __webpack_require__(2361);
+var definePropertyModule = __webpack_require__(3376);
+
+var UNSCOPABLES = wellKnownSymbol('unscopables');
+var ArrayPrototype = Array.prototype;
+
+// Array.prototype[@@unscopables]
+// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
+if (ArrayPrototype[UNSCOPABLES] == undefined) {
+  definePropertyModule.f(ArrayPrototype, UNSCOPABLES, {
+    configurable: true,
+    value: create(null)
+  });
+}
+
+// add a key to Array.prototype[@@unscopables]
+module.exports = function (key) {
+  ArrayPrototype[UNSCOPABLES][key] = true;
+};
+
+
+/***/ }),
+
+/***/ 1866:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+
+var charAt = __webpack_require__(6174).charAt;
+
+// `AdvanceStringIndex` abstract operation
+// https://tc39.es/ecma262/#sec-advancestringindex
+module.exports = function (S, index, unicode) {
+  return index + (unicode ? charAt(S, index).length : 1);
+};
+
+
+/***/ }),
+
+/***/ 2482:
+/***/ ((module) => {
+
+module.exports = function (it, Constructor, name) {
+  if (!(it instanceof Constructor)) {
+    throw TypeError('Incorrect ' + (name ? name + ' ' : '') + 'invocation');
+  } return it;
+};
+
+
+/***/ }),
+
+/***/ 47:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var isObject = __webpack_require__(6944);
+
+module.exports = function (it) {
+  if (!isObject(it)) {
+    throw TypeError(String(it) + ' is not an object');
+  } return it;
+};
+
+
+/***/ }),
+
+/***/ 6321:
+/***/ ((module) => {
+
+// eslint-disable-next-line es/no-typed-arrays -- safe
+module.exports = typeof ArrayBuffer !== 'undefined' && typeof DataView !== 'undefined';
+
+
+/***/ }),
+
+/***/ 2211:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+
+var NATIVE_ARRAY_BUFFER = __webpack_require__(6321);
+var DESCRIPTORS = __webpack_require__(5542);
+var global = __webpack_require__(6874);
+var isObject = __webpack_require__(6944);
+var has = __webpack_require__(5884);
+var classof = __webpack_require__(8753);
+var createNonEnumerableProperty = __webpack_require__(4791);
+var redefine = __webpack_require__(1249);
+var defineProperty = __webpack_require__(3376).f;
+var getPrototypeOf = __webpack_require__(8186);
+var setPrototypeOf = __webpack_require__(2686);
+var wellKnownSymbol = __webpack_require__(3706);
+var uid = __webpack_require__(8435);
+
+var Int8Array = global.Int8Array;
+var Int8ArrayPrototype = Int8Array && Int8Array.prototype;
+var Uint8ClampedArray = global.Uint8ClampedArray;
+var Uint8ClampedArrayPrototype = Uint8ClampedArray && Uint8ClampedArray.prototype;
+var TypedArray = Int8Array && getPrototypeOf(Int8Array);
+var TypedArrayPrototype = Int8ArrayPrototype && getPrototypeOf(Int8ArrayPrototype);
+var ObjectPrototype = Object.prototype;
+var isPrototypeOf = ObjectPrototype.isPrototypeOf;
+
+var TO_STRING_TAG = wellKnownSymbol('toStringTag');
+var TYPED_ARRAY_TAG = uid('TYPED_ARRAY_TAG');
+var TYPED_ARRAY_CONSTRUCTOR = uid('TYPED_ARRAY_CONSTRUCTOR');
+// Fixing native typed arrays in Opera Presto crashes the browser, see #595
+var NATIVE_ARRAY_BUFFER_VIEWS = NATIVE_ARRAY_BUFFER && !!setPrototypeOf && classof(global.opera) !== 'Opera';
+var TYPED_ARRAY_TAG_REQIRED = false;
+var NAME, Constructor, Prototype;
+
+var TypedArrayConstructorsList = {
+  Int8Array: 1,
+  Uint8Array: 1,
+  Uint8ClampedArray: 1,
+  Int16Array: 2,
+  Uint16Array: 2,
+  Int32Array: 4,
+  Uint32Array: 4,
+  Float32Array: 4,
+  Float64Array: 8
+};
+
+var BigIntArrayConstructorsList = {
+  BigInt64Array: 8,
+  BigUint64Array: 8
+};
+
+var isView = function isView(it) {
+  if (!isObject(it)) return false;
+  var klass = classof(it);
+  return klass === 'DataView'
+    || has(TypedArrayConstructorsList, klass)
+    || has(BigIntArrayConstructorsList, klass);
+};
+
+var isTypedArray = function (it) {
+  if (!isObject(it)) return false;
+  var klass = classof(it);
+  return has(TypedArrayConstructorsList, klass)
+    || has(BigIntArrayConstructorsList, klass);
+};
+
+var aTypedArray = function (it) {
+  if (isTypedArray(it)) return it;
+  throw TypeError('Target is not a typed array');
+};
+
+var aTypedArrayConstructor = function (C) {
+  if (setPrototypeOf && !isPrototypeOf.call(TypedArray, C)) {
+    throw TypeError('Target is not a typed array constructor');
+  } return C;
+};
+
+var exportTypedArrayMethod = function (KEY, property, forced) {
+  if (!DESCRIPTORS) return;
+  if (forced) for (var ARRAY in TypedArrayConstructorsList) {
+    var TypedArrayConstructor = global[ARRAY];
+    if (TypedArrayConstructor && has(TypedArrayConstructor.prototype, KEY)) try {
+      delete TypedArrayConstructor.prototype[KEY];
+    } catch (error) { /* empty */ }
+  }
+  if (!TypedArrayPrototype[KEY] || forced) {
+    redefine(TypedArrayPrototype, KEY, forced ? property
+      : NATIVE_ARRAY_BUFFER_VIEWS && Int8ArrayPrototype[KEY] || property);
+  }
+};
+
+var exportTypedArrayStaticMethod = function (KEY, property, forced) {
+  var ARRAY, TypedArrayConstructor;
+  if (!DESCRIPTORS) return;
+  if (setPrototypeOf) {
+    if (forced) for (ARRAY in TypedArrayConstructorsList) {
+      TypedArrayConstructor = global[ARRAY];
+      if (TypedArrayConstructor && has(TypedArrayConstructor, KEY)) try {
+        delete TypedArrayConstructor[KEY];
+      } catch (error) { /* empty */ }
+    }
+    if (!TypedArray[KEY] || forced) {
+      // V8 ~ Chrome 49-50 `%TypedArray%` methods are non-writable non-configurable
+      try {
+        return redefine(TypedArray, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && TypedArray[KEY] || property);
+      } catch (error) { /* empty */ }
+    } else return;
+  }
+  for (ARRAY in TypedArrayConstructorsList) {
+    TypedArrayConstructor = global[ARRAY];
+    if (TypedArrayConstructor && (!TypedArrayConstructor[KEY] || forced)) {
+      redefine(TypedArrayConstructor, KEY, property);
+    }
+  }
+};
+
+for (NAME in TypedArrayConstructorsList) {
+  Constructor = global[NAME];
+  Prototype = Constructor && Constructor.prototype;
+  if (Prototype) createNonEnumerableProperty(Prototype, TYPED_ARRAY_CONSTRUCTOR, Constructor);
+  else NATIVE_ARRAY_BUFFER_VIEWS = false;
+}
+
+for (NAME in BigIntArrayConstructorsList) {
+  Constructor = global[NAME];
+  Prototype = Constructor && Constructor.prototype;
+  if (Prototype) createNonEnumerableProperty(Prototype, TYPED_ARRAY_CONSTRUCTOR, Constructor);
+}
+
+// WebKit bug - typed arrays constructors prototype is Object.prototype
+if (!NATIVE_ARRAY_BUFFER_VIEWS || typeof TypedArray != 'function' || TypedArray === Function.prototype) {
+  // eslint-disable-next-line no-shadow -- safe
+  TypedArray = function TypedArray() {
+    throw TypeError('Incorrect invocation');
+  };
+  if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME in TypedArrayConstructorsList) {
+    if (global[NAME]) setPrototypeOf(global[NAME], TypedArray);
+  }
+}
+
+if (!NATIVE_ARRAY_BUFFER_VIEWS || !TypedArrayPrototype || TypedArrayPrototype === ObjectPrototype) {
+  TypedArrayPrototype = TypedArray.prototype;
+  if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME in TypedArrayConstructorsList) {
+    if (global[NAME]) setPrototypeOf(global[NAME].prototype, TypedArrayPrototype);
+  }
+}
+
+// WebKit bug - one more object in Uint8ClampedArray prototype chain
+if (NATIVE_ARRAY_BUFFER_VIEWS && getPrototypeOf(Uint8ClampedArrayPrototype) !== TypedArrayPrototype) {
+  setPrototypeOf(Uint8ClampedArrayPrototype, TypedArrayPrototype);
+}
+
+if (DESCRIPTORS && !has(TypedArrayPrototype, TO_STRING_TAG)) {
+  TYPED_ARRAY_TAG_REQIRED = true;
+  defineProperty(TypedArrayPrototype, TO_STRING_TAG, { get: function () {
+    return isObject(this) ? this[TYPED_ARRAY_TAG] : undefined;
+  } });
+  for (NAME in TypedArrayConstructorsList) if (global[NAME]) {
+    createNonEnumerableProperty(global[NAME], TYPED_ARRAY_TAG, NAME);
+  }
+}
+
+module.exports = {
+  NATIVE_ARRAY_BUFFER_VIEWS: NATIVE_ARRAY_BUFFER_VIEWS,
+  TYPED_ARRAY_CONSTRUCTOR: TYPED_ARRAY_CONSTRUCTOR,
+  TYPED_ARRAY_TAG: TYPED_ARRAY_TAG_REQIRED && TYPED_ARRAY_TAG,
+  aTypedArray: aTypedArray,
+  aTypedArrayConstructor: aTypedArrayConstructor,
+  exportTypedArrayMethod: exportTypedArrayMethod,
+  exportTypedArrayStaticMethod: exportTypedArrayStaticMethod,
+  isView: isView,
+  isTypedArray: isTypedArray,
+  TypedArray: TypedArray,
+  TypedArrayPrototype: TypedArrayPrototype
+};
+
+
+/***/ }),
+
+/***/ 6594:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+
+var global = __webpack_require__(6874);
+var DESCRIPTORS = __webpack_require__(5542);
+var NATIVE_ARRAY_BUFFER = __webpack_require__(6321);
+var createNonEnumerableProperty = __webpack_require__(4791);
+var redefineAll = __webpack_require__(7490);
+var fails = __webpack_require__(7841);
+var anInstance = __webpack_require__(2482);
+var toInteger = __webpack_require__(7896);
+var toLength = __webpack_require__(4954);
+var toIndex = __webpack_require__(5513);
+var IEEE754 = __webpack_require__(6227);
+var getPrototypeOf = __webpack_require__(8186);
+var setPrototypeOf = __webpack_require__(2686);
+var getOwnPropertyNames = __webpack_require__(8401).f;
+var defineProperty = __webpack_require__(3376).f;
+var arrayFill = __webpack_require__(7515);
+var setToStringTag = __webpack_require__(9400);
+var InternalStateModule = __webpack_require__(6619);
+
+var getInternalState = InternalStateModule.get;
+var setInternalState = InternalStateModule.set;
+var ARRAY_BUFFER = 'ArrayBuffer';
+var DATA_VIEW = 'DataView';
+var PROTOTYPE = 'prototype';
+var WRONG_LENGTH = 'Wrong length';
+var WRONG_INDEX = 'Wrong index';
+var NativeArrayBuffer = global[ARRAY_BUFFER];
+var $ArrayBuffer = NativeArrayBuffer;
+var $DataView = global[DATA_VIEW];
+var $DataViewPrototype = $DataView && $DataView[PROTOTYPE];
+var ObjectPrototype = Object.prototype;
+var RangeError = global.RangeError;
+
+var packIEEE754 = IEEE754.pack;
+var unpackIEEE754 = IEEE754.unpack;
+
+var packInt8 = function (number) {
+  return [number & 0xFF];
+};
+
+var packInt16 = function (number) {
+  return [number & 0xFF, number >> 8 & 0xFF];
+};
+
+var packInt32 = function (number) {
+  return [number & 0xFF, number >> 8 & 0xFF, number >> 16 & 0xFF, number >> 24 & 0xFF];
+};
+
+var unpackInt32 = function (buffer) {
+  return buffer[3] << 24 | buffer[2] << 16 | buffer[1] << 8 | buffer[0];
+};
+
+var packFloat32 = function (number) {
+  return packIEEE754(number, 23, 4);
+};
+
+var packFloat64 = function (number) {
+  return packIEEE754(number, 52, 8);
+};
+
+var addGetter = function (Constructor, key) {
+  defineProperty(Constructor[PROTOTYPE], key, { get: function () { return getInternalState(this)[key]; } });
+};
+
+var get = function (view, count, index, isLittleEndian) {
+  var intIndex = toIndex(index);
+  var store = getInternalState(view);
+  if (intIndex + count > store.byteLength) throw RangeError(WRONG_INDEX);
+  var bytes = getInternalState(store.buffer).bytes;
+  var start = intIndex + store.byteOffset;
+  var pack = bytes.slice(start, start + count);
+  return isLittleEndian ? pack : pack.reverse();
+};
+
+var set = function (view, count, index, conversion, value, isLittleEndian) {
+  var intIndex = toIndex(index);
+  var store = getInternalState(view);
+  if (intIndex + count > store.byteLength) throw RangeError(WRONG_INDEX);
+  var bytes = getInternalState(store.buffer).bytes;
+  var start = intIndex + store.byteOffset;
+  var pack = conversion(+value);
+  for (var i = 0; i < count; i++) bytes[start + i] = pack[isLittleEndian ? i : count - i - 1];
+};
+
+if (!NATIVE_ARRAY_BUFFER) {
+  $ArrayBuffer = function ArrayBuffer(length) {
+    anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
+    var byteLength = toIndex(length);
+    setInternalState(this, {
+      bytes: arrayFill.call(new Array(byteLength), 0),
+      byteLength: byteLength
+    });
+    if (!DESCRIPTORS) this.byteLength = byteLength;
+  };
+
+  $DataView = function DataView(buffer, byteOffset, byteLength) {
+    anInstance(this, $DataView, DATA_VIEW);
+    anInstance(buffer, $ArrayBuffer, DATA_VIEW);
+    var bufferLength = getInternalState(buffer).byteLength;
+    var offset = toInteger(byteOffset);
+    if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset');
+    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
+    if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);
+    setInternalState(this, {
+      buffer: buffer,
+      byteLength: byteLength,
+      byteOffset: offset
+    });
+    if (!DESCRIPTORS) {
+      this.buffer = buffer;
+      this.byteLength = byteLength;
+      this.byteOffset = offset;
+    }
+  };
+
+  if (DESCRIPTORS) {
+    addGetter($ArrayBuffer, 'byteLength');
+    addGetter($DataView, 'buffer');
+    addGetter($DataView, 'byteLength');
+    addGetter($DataView, 'byteOffset');
+  }
+
+  redefineAll($DataView[PROTOTYPE], {
+    getInt8: function getInt8(byteOffset) {
+      return get(this, 1, byteOffset)[0] << 24 >> 24;
+    },
+    getUint8: function getUint8(byteOffset) {
+      return get(this, 1, byteOffset)[0];
+    },
+    getInt16: function getInt16(byteOffset /* , littleEndian */) {
+      var bytes = get(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : undefined);
+      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
+    },
+    getUint16: function getUint16(byteOffset /* , littleEndian */) {
+      var bytes = get(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : undefined);
+      return bytes[1] << 8 | bytes[0];
+    },
+    getInt32: function getInt32(byteOffset /* , littleEndian */) {
+      return unpackInt32(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined));
+    },
+    getUint32: function getUint32(byteOffset /* , littleEndian */) {
+      return unpackInt32(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined)) >>> 0;
+    },
+    getFloat32: function getFloat32(byteOffset /* , littleEndian */) {
+      return unpackIEEE754(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined), 23);
+    },
+    getFloat64: function getFloat64(byteOffset /* , littleEndian */) {
+      return unpackIEEE754(get(this, 8, byteOffset, arguments.length > 1 ? arguments[1] : undefined), 52);
+    },
+    setInt8: function setInt8(byteOffset, value) {
+      set(this, 1, byteOffset, packInt8, value);
+    },
+    setUint8: function setUint8(byteOffset, value) {
+      set(this, 1, byteOffset, packInt8, value);
+    },
+    setInt16: function setInt16(byteOffset, value /* , littleEndian */) {
+      set(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : undefined);
+    },
+    setUint16: function setUint16(byteOffset, value /* , littleEndian */) {
+      set(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : undefined);
+    },
+    setInt32: function setInt32(byteOffset, value /* , littleEndian */) {
+      set(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : undefined);
+    },
+    setUint32: function setUint32(byteOffset, value /* , littleEndian */) {
+      set(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : undefined);
+    },
+    setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) {
+      set(this, 4, byteOffset, packFloat32, value, arguments.length > 2 ? arguments[2] : undefined);
+    },
+    setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) {
+      set(this, 8, byteOffset, packFloat64, value, arguments.length > 2 ? arguments[2] : undefined);
+    }
+  });
+} else {
+  /* eslint-disable no-new -- required for testing */
+  if (!fails(function () {
+    NativeArrayBuffer(1);
+  }) || !fails(function () {
+    new NativeArrayBuffer(-1);
+  }) || fails(function () {
+    new NativeArrayBuffer();
+    new NativeArrayBuffer(1.5);
+    new NativeArrayBuffer(NaN);
+    return NativeArrayBuffer.name != ARRAY_BUFFER;
+  })) {
+  /* eslint-enable no-new -- required for testing */
+    $ArrayBuffer = function ArrayBuffer(length) {
+      anInstance(this, $ArrayBuffer);
+      return new NativeArrayBuffer(toIndex(length));
+    };
+    var ArrayBufferPrototype = $ArrayBuffer[PROTOTYPE] = NativeArrayBuffer[PROTOTYPE];
+    for (var keys = getOwnPropertyNames(NativeArrayBuffer), j = 0, key; keys.length > j;) {
+      if (!((key = keys[j++]) in $ArrayBuffer)) {
+        createNonEnumerableProperty($ArrayBuffer, key, NativeArrayBuffer[key]);
+      }
+    }
+    ArrayBufferPrototype.constructor = $ArrayBuffer;
+  }
+
+  // WebKit bug - the same parent prototype for typed arrays and data view
+  if (setPrototypeOf && getPrototypeOf($DataViewPrototype) !== ObjectPrototype) {
+    setPrototypeOf($DataViewPrototype, ObjectPrototype);
+  }
+
+  // iOS Safari 7.x bug
+  var testView = new $DataView(new $ArrayBuffer(2));
+  var $setInt8 = $DataViewPrototype.setInt8;
+  testView.setInt8(0, 2147483648);
+  testView.setInt8(1, 2147483649);
+  if (testView.getInt8(0) || !testView.getInt8(1)) redefineAll($DataViewPrototype, {
+    setInt8: function setInt8(byteOffset, value) {
+      $setInt8.call(this, byteOffset, value << 24 >> 24);
+    },
+    setUint8: function setUint8(byteOffset, value) {
+      $setInt8.call(this, byteOffset, value << 24 >> 24);
+    }
+  }, { unsafe: true });
+}
+
+setToStringTag($ArrayBuffer, ARRAY_BUFFER);
+setToStringTag($DataView, DATA_VIEW);
+
+module.exports = {
+  ArrayBuffer: $ArrayBuffer,
+  DataView: $DataView
+};
+
+
+/***/ }),
+
+/***/ 2116:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+
+var toObject = __webpack_require__(4680);
+var toAbsoluteIndex = __webpack_require__(2145);
+var toLength = __webpack_require__(4954);
+
+var min = Math.min;
+
+// `Array.prototype.copyWithin` method implementation
+// https://tc39.es/ecma262/#sec-array.prototype.copywithin
+// eslint-disable-next-line es/no-array-prototype-copywithin -- safe
+module.exports = [].copyWithin || function copyWithin(target /* = 0 */, start /* = 0, end = @length */) {
+  var O = toObject(this);
+  var len = toLength(O.length);
+  var to = toAbsoluteIndex(target, len);
+  var from = toAbsoluteIndex(start, len);
+  var end = arguments.length > 2 ? arguments[2] : undefined;
+  var count = min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
+  var inc = 1;
+  if (from < to && to < from + count) {
+    inc = -1;
+    from += count - 1;
+    to += count - 1;
+  }
+  while (count-- > 0) {
+    if (from in O) O[to] = O[from];
+    else delete O[to];
+    to += inc;
+    from += inc;
+  } return O;
+};
+
+
+/***/ }),
+
+/***/ 7515:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+
+var toObject = __webpack_require__(4680);
+var toAbsoluteIndex = __webpack_require__(2145);
+var toLength = __webpack_require__(4954);
+
+// `Array.prototype.fill` method implementation
+// https://tc39.es/ecma262/#sec-array.prototype.fill
+module.exports = function fill(value /* , start = 0, end = @length */) {
+  var O = toObject(this);
+  var length = toLength(O.length);
+  var argumentsLength = arguments.length;
+  var index = toAbsoluteIndex(argumentsLength > 1 ? arguments[1] : undefined, length);
+  var end = argumentsLength > 2 ? arguments[2] : undefined;
+  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);
+  while (endPos > index) O[index++] = value;
+  return O;
+};
+
+
+/***/ }),
+
+/***/ 1244:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+
+var $forEach = __webpack_require__(6374).forEach;
+var arrayMethodIsStrict = __webpack_require__(622);
+
+var STRICT_METHOD = arrayMethodIsStrict('forEach');
+
+// `Array.prototype.forEach` method implementation
+// https://tc39.es/ecma262/#sec-array.prototype.foreach
+module.exports = !STRICT_METHOD ? function forEach(callbackfn /* , thisArg */) {
+  return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
+// eslint-disable-next-line es/no-array-prototype-foreach -- safe
+} : [].forEach;
+
+
+/***/ }),
+
+/***/ 4413:
+/***/ ((module) => {
+
+module.exports = function (Constructor, list) {
+  var index = 0;
+  var length = list.length;
+  var result = new Constructor(length);
+  while (length > index) result[index] = list[index++];
+  return result;
+};
+
+
+/***/ }),
+
+/***/ 1774:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+
+var bind = __webpack_require__(4833);
+var toObject = __webpack_require__(4680);
+var callWithSafeIterationClosing = __webpack_require__(3960);
+var isArrayIteratorMethod = __webpack_require__(1008);
+var toLength = __webpack_require__(4954);
+var createProperty = __webpack_require__(2076);
+var getIteratorMethod = __webpack_require__(3126);
+
+// `Array.from` method implementation
+// https://tc39.es/ecma262/#sec-array.from
+module.exports = function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
+  var O = toObject(arrayLike);
+  var C = typeof this == 'function' ? this : Array;
+  var argumentsLength = arguments.length;
+  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
+  var mapping = mapfn !== undefined;
+  var iteratorMethod = getIteratorMethod(O);
+  var index = 0;
+  var length, result, step, iterator, next, value;
+  if (mapping) mapfn = bind(mapfn, argumentsLength > 2 ? arguments[2] : undefined, 2);
+  // if the target is not iterable or it's an array with the default iterator - use a simple case
+  if (iteratorMethod != undefined && !(C == Array && isArrayIteratorMethod(iteratorMethod))) {
+    iterator = iteratorMethod.call(O);
+    next = iterator.next;
+    result = new C();
+    for (;!(step = next.call(iterator)).done; index++) {
+      value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true) : step.value;
+      createProperty(result, index, value);
+    }
+  } else {
+    length = toLength(O.length);
+    result = new C(length);
+    for (;length > index; index++) {
+      value = mapping ? mapfn(O[index], index) : O[index];
+      createProperty(result, index, value);
+    }
+  }
+  result.length = index;
+  return result;
+};
+
+
+/***/ }),
+
+/***/ 1270:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var toIndexedObject = __webpack_require__(8852);
+var toLength = __webpack_require__(4954);
+var toAbsoluteIndex = __webpack_require__(2145);
+
+// `Array.prototype.{ indexOf, includes }` methods implementation
+var createMethod = function (IS_INCLUDES) {
+  return function ($this, el, fromIndex) {
+    var O = toIndexedObject($this);
+    var length = toLength(O.length);
+    var index = toAbsoluteIndex(fromIndex, length);
+    var value;
+    // Array#includes uses SameValueZero equality algorithm
+    // eslint-disable-next-line no-self-compare -- NaN check
+    if (IS_INCLUDES && el != el) while (length > index) {
+      value = O[index++];
+      // eslint-disable-next-line no-self-compare -- NaN check
+      if (value != value) return true;
+    // Array#indexOf ignores holes, Array#includes - not
+    } else for (;length > index; index++) {
+      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
+    } return !IS_INCLUDES && -1;
+  };
+};
+
+module.exports = {
+  // `Array.prototype.includes` method
+  // https://tc39.es/ecma262/#sec-array.prototype.includes
+  includes: createMethod(true),
+  // `Array.prototype.indexOf` method
+  // https://tc39.es/ecma262/#sec-array.prototype.indexof
+  indexOf: createMethod(false)
+};
+
+
+/***/ }),
+
+/***/ 6374:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var bind = __webpack_require__(4833);
+var IndexedObject = __webpack_require__(7361);
+var toObject = __webpack_require__(4680);
+var toLength = __webpack_require__(4954);
+var arraySpeciesCreate = __webpack_require__(68);
+
+var push = [].push;
+
+// `Array.prototype.{ forEach, map, filter, some, every, find, findIndex, filterReject }` methods implementation
+var createMethod = function (TYPE) {
+  var IS_MAP = TYPE == 1;
+  var IS_FILTER = TYPE == 2;
+  var IS_SOME = TYPE == 3;
+  var IS_EVERY = TYPE == 4;
+  var IS_FIND_INDEX = TYPE == 6;
+  var IS_FILTER_REJECT = TYPE == 7;
+  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
+  return function ($this, callbackfn, that, specificCreate) {
+    var O = toObject($this);
+    var self = IndexedObject(O);
+    var boundFunction = bind(callbackfn, that, 3);
+    var length = toLength(self.length);
+    var index = 0;
+    var create = specificCreate || arraySpeciesCreate;
+    var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_REJECT ? create($this, 0) : undefined;
+    var value, result;
+    for (;length > index; index++) if (NO_HOLES || index in self) {
+      value = self[index];
+      result = boundFunction(value, index, O);
+      if (TYPE) {
+        if (IS_MAP) target[index] = result; // map
+        else if (result) switch (TYPE) {
+          case 3: return true;              // some
+          case 5: return value;             // find
+          case 6: return index;             // findIndex
+          case 2: push.call(target, value); // filter
+        } else switch (TYPE) {
+          case 4: return false;             // every
+          case 7: push.call(target, value); // filterReject
+        }
+      }
+    }
+    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
+  };
+};
+
+module.exports = {
+  // `Array.prototype.forEach` method
+  // https://tc39.es/ecma262/#sec-array.prototype.foreach
+  forEach: createMethod(0),
+  // `Array.prototype.map` method
+  // https://tc39.es/ecma262/#sec-array.prototype.map
+  map: createMethod(1),
+  // `Array.prototype.filter` method
+  // https://tc39.es/ecma262/#sec-array.prototype.filter
+  filter: createMethod(2),
+  // `Array.prototype.some` method
+  // https://tc39.es/ecma262/#sec-array.prototype.some
+  some: createMethod(3),
+  // `Array.prototype.every` method
+  // https://tc39.es/ecma262/#sec-array.prototype.every
+  every: createMethod(4),
+  // `Array.prototype.find` method
+  // https://tc39.es/ecma262/#sec-array.prototype.find
+  find: createMethod(5),
+  // `Array.prototype.findIndex` method
+  // https://tc39.es/ecma262/#sec-array.prototype.findIndex
+  findIndex: createMethod(6),
+  // `Array.prototype.filterReject` method
+  // https://github.com/tc39/proposal-array-filtering
+  filterReject: createMethod(7)
+};
+
+
+/***/ }),
+
+/***/ 16:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+
+/* eslint-disable es/no-array-prototype-lastindexof -- safe */
+var toIndexedObject = __webpack_require__(8852);
+var toInteger = __webpack_require__(7896);
+var toLength = __webpack_require__(4954);
+var arrayMethodIsStrict = __webpack_require__(622);
+
+var min = Math.min;
+var $lastIndexOf = [].lastIndexOf;
+var NEGATIVE_ZERO = !!$lastIndexOf && 1 / [1].lastIndexOf(1, -0) < 0;
+var STRICT_METHOD = arrayMethodIsStrict('lastIndexOf');
+var FORCED = NEGATIVE_ZERO || !STRICT_METHOD;
+
+// `Array.prototype.lastIndexOf` method implementation
+// https://tc39.es/ecma262/#sec-array.prototype.lastindexof
+module.exports = FORCED ? function lastIndexOf(searchElement /* , fromIndex = @[*-1] */) {
+  // convert -0 to +0
+  if (NEGATIVE_ZERO) return $lastIndexOf.apply(this, arguments) || 0;
+  var O = toIndexedObject(this);
+  var length = toLength(O.length);
+  var index = length - 1;
+  if (arguments.length > 1) index = min(index, toInteger(arguments[1]));
+  if (index < 0) index = length + index;
+  for (;index >= 0; index--) if (index in O && O[index] === searchElement) return index || 0;
+  return -1;
+} : $lastIndexOf;
+
+
+/***/ }),
+
+/***/ 6937:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var fails = __webpack_require__(7841);
+var wellKnownSymbol = __webpack_require__(3706);
+var V8_VERSION = __webpack_require__(579);
+
+var SPECIES = wellKnownSymbol('species');
+
+module.exports = function (METHOD_NAME) {
+  // We can't use this feature detection in V8 since it causes
+  // deoptimization and serious performance degradation
+  // https://github.com/zloirock/core-js/issues/677
+  return V8_VERSION >= 51 || !fails(function () {
+    var array = [];
+    var constructor = array.constructor = {};
+    constructor[SPECIES] = function () {
+      return { foo: 1 };
+    };
+    return array[METHOD_NAME](Boolean).foo !== 1;
+  });
+};
+
+
+/***/ }),
+
+/***/ 622:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+
+var fails = __webpack_require__(7841);
+
+module.exports = function (METHOD_NAME, argument) {
+  var method = [][METHOD_NAME];
+  return !!method && fails(function () {
+    // eslint-disable-next-line no-useless-call,no-throw-literal -- required for testing
+    method.call(null, argument || function () { throw 1; }, 1);
+  });
+};
+
+
+/***/ }),
+
+/***/ 9553:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var aFunction = __webpack_require__(769);
+var toObject = __webpack_require__(4680);
+var IndexedObject = __webpack_require__(7361);
+var toLength = __webpack_require__(4954);
+
+// `Array.prototype.{ reduce, reduceRight }` methods implementation
+var createMethod = function (IS_RIGHT) {
+  return function (that, callbackfn, argumentsLength, memo) {
+    aFunction(callbackfn);
+    var O = toObject(that);
+    var self = IndexedObject(O);
+    var length = toLength(O.length);
+    var index = IS_RIGHT ? length - 1 : 0;
+    var i = IS_RIGHT ? -1 : 1;
+    if (argumentsLength < 2) while (true) {
+      if (index in self) {
+        memo = self[index];
+        index += i;
+        break;
+      }
+      index += i;
+      if (IS_RIGHT ? index < 0 : length <= index) {
+        throw TypeError('Reduce of empty array with no initial value');
+      }
+    }
+    for (;IS_RIGHT ? index >= 0 : length > index; index += i) if (index in self) {
+      memo = callbackfn(memo, self[index], index, O);
+    }
+    return memo;
+  };
+};
+
+module.exports = {
+  // `Array.prototype.reduce` method
+  // https://tc39.es/ecma262/#sec-array.prototype.reduce
+  left: createMethod(false),
+  // `Array.prototype.reduceRight` method
+  // https://tc39.es/ecma262/#sec-array.prototype.reduceright
+  right: createMethod(true)
+};
+
+
+/***/ }),
+
+/***/ 7921:
+/***/ ((module) => {
+
+// TODO: use something more complex like timsort?
+var floor = Math.floor;
+
+var mergeSort = function (array, comparefn) {
+  var length = array.length;
+  var middle = floor(length / 2);
+  return length < 8 ? insertionSort(array, comparefn) : merge(
+    mergeSort(array.slice(0, middle), comparefn),
+    mergeSort(array.slice(middle), comparefn),
+    comparefn
+  );
+};
+
+var insertionSort = function (array, comparefn) {
+  var length = array.length;
+  var i = 1;
+  var element, j;
+
+  while (i < length) {
+    j = i;
+    element = array[i];
+    while (j && comparefn(array[j - 1], element) > 0) {
+      array[j] = array[--j];
+    }
+    if (j !== i++) array[j] = element;
+  } return array;
+};
+
+var merge = function (left, right, comparefn) {
+  var llength = left.length;
+  var rlength = right.length;
+  var lindex = 0;
+  var rindex = 0;
+  var result = [];
+
+  while (lindex < llength || rindex < rlength) {
+    if (lindex < llength && rindex < rlength) {
+      result.push(comparefn(left[lindex], right[rindex]) <= 0 ? left[lindex++] : right[rindex++]);
+    } else {
+      result.push(lindex < llength ? left[lindex++] : right[rindex++]);
+    }
+  } return result;
+};
+
+module.exports = mergeSort;
+
+
+/***/ }),
+
+/***/ 7082:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var isObject = __webpack_require__(6944);
+var isArray = __webpack_require__(7828);
+var wellKnownSymbol = __webpack_require__(3706);
+
+var SPECIES = wellKnownSymbol('species');
+
+// a part of `ArraySpeciesCreate` abstract operation
+// https://tc39.es/ecma262/#sec-arrayspeciescreate
+module.exports = function (originalArray) {
+  var C;
+  if (isArray(originalArray)) {
+    C = originalArray.constructor;
+    // cross-realm fallback
+    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
+    else if (isObject(C)) {
+      C = C[SPECIES];
+      if (C === null) C = undefined;
+    }
+  } return C === undefined ? Array : C;
+};
+
+
+/***/ }),
+
+/***/ 68:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var arraySpeciesConstructor = __webpack_require__(7082);
+
+// `ArraySpeciesCreate` abstract operation
+// https://tc39.es/ecma262/#sec-arrayspeciescreate
+module.exports = function (originalArray, length) {
+  return new (arraySpeciesConstructor(originalArray))(length === 0 ? 0 : length);
+};
+
+
+/***/ }),
+
+/***/ 3960:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var anObject = __webpack_require__(47);
+var iteratorClose = __webpack_require__(2608);
+
+// call something on iterator step with safe closing on error
+module.exports = function (iterator, fn, value, ENTRIES) {
+  try {
+    return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);
+  } catch (error) {
+    iteratorClose(iterator);
+    throw error;
+  }
+};
+
+
+/***/ }),
+
+/***/ 4585:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var wellKnownSymbol = __webpack_require__(3706);
+
+var ITERATOR = wellKnownSymbol('iterator');
+var SAFE_CLOSING = false;
+
+try {
+  var called = 0;
+  var iteratorWithReturn = {
+    next: function () {
+      return { done: !!called++ };
+    },
+    'return': function () {
+      SAFE_CLOSING = true;
+    }
+  };
+  iteratorWithReturn[ITERATOR] = function () {
+    return this;
+  };
+  // eslint-disable-next-line es/no-array-from, no-throw-literal -- required for testing
+  Array.from(iteratorWithReturn, function () { throw 2; });
+} catch (error) { /* empty */ }
+
+module.exports = function (exec, SKIP_CLOSING) {
+  if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
+  var ITERATION_SUPPORT = false;
+  try {
+    var object = {};
+    object[ITERATOR] = function () {
+      return {
+        next: function () {
+          return { done: ITERATION_SUPPORT = true };
+        }
+      };
+    };
+    exec(object);
+  } catch (error) { /* empty */ }
+  return ITERATION_SUPPORT;
+};
+
+
+/***/ }),
+
+/***/ 3565:
+/***/ ((module) => {
+
+var toString = {}.toString;
+
+module.exports = function (it) {
+  return toString.call(it).slice(8, -1);
+};
+
+
+/***/ }),
+
+/***/ 8753:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var TO_STRING_TAG_SUPPORT = __webpack_require__(939);
+var classofRaw = __webpack_require__(3565);
+var wellKnownSymbol = __webpack_require__(3706);
+
+var TO_STRING_TAG = wellKnownSymbol('toStringTag');
+// ES3 wrong here
+var CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';
+
+// fallback for IE11 Script Access Denied error
+var tryGet = function (it, key) {
+  try {
+    return it[key];
+  } catch (error) { /* empty */ }
+};
+
+// getting tag from ES6+ `Object.prototype.toString`
+module.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {
+  var O, tag, result;
+  return it === undefined ? 'Undefined' : it === null ? 'Null'
+    // @@toStringTag case
+    : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG)) == 'string' ? tag
+    // builtinTag case
+    : CORRECT_ARGUMENTS ? classofRaw(O)
+    // ES3 arguments fallback
+    : (result = classofRaw(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : result;
+};
+
+
+/***/ }),
+
+/***/ 6955:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+
+var defineProperty = __webpack_require__(3376).f;
+var create = __webpack_require__(2361);
+var redefineAll = __webpack_require__(7490);
+var bind = __webpack_require__(4833);
+var anInstance = __webpack_require__(2482);
+var iterate = __webpack_require__(7093);
+var defineIterator = __webpack_require__(3131);
+var setSpecies = __webpack_require__(8802);
+var DESCRIPTORS = __webpack_require__(5542);
+var fastKey = __webpack_require__(28).fastKey;
+var InternalStateModule = __webpack_require__(6619);
+
+var setInternalState = InternalStateModule.set;
+var internalStateGetterFor = InternalStateModule.getterFor;
+
+module.exports = {
+  getConstructor: function (wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
+    var C = wrapper(function (that, iterable) {
+      anInstance(that, C, CONSTRUCTOR_NAME);
+      setInternalState(that, {
+        type: CONSTRUCTOR_NAME,
+        index: create(null),
+        first: undefined,
+        last: undefined,
+        size: 0
+      });
+      if (!DESCRIPTORS) that.size = 0;
+      if (iterable != undefined) iterate(iterable, that[ADDER], { that: that, AS_ENTRIES: IS_MAP });
+    });
+
+    var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);
+
+    var define = function (that, key, value) {
+      var state = getInternalState(that);
+      var entry = getEntry(that, key);
+      var previous, index;
+      // change existing entry
+      if (entry) {
+        entry.value = value;
+      // create new entry
+      } else {
+        state.last = entry = {
+          index: index = fastKey(key, true),
+          key: key,
+          value: value,
+          previous: previous = state.last,
+          next: undefined,
+          removed: false
+        };
+        if (!state.first) state.first = entry;
+        if (previous) previous.next = entry;
+        if (DESCRIPTORS) state.size++;
+        else that.size++;
+        // add to index
+        if (index !== 'F') state.index[index] = entry;
+      } return that;
+    };
+
+    var getEntry = function (that, key) {
+      var state = getInternalState(that);
+      // fast case
+      var index = fastKey(key);
+      var entry;
+      if (index !== 'F') return state.index[index];
+      // frozen object case
+      for (entry = state.first; entry; entry = entry.next) {
+        if (entry.key == key) return entry;
+      }
+    };
+
+    redefineAll(C.prototype, {
+      // `{ Map, Set }.prototype.clear()` methods
+      // https://tc39.es/ecma262/#sec-map.prototype.clear
+      // https://tc39.es/ecma262/#sec-set.prototype.clear
+      clear: function clear() {
+        var that = this;
+        var state = getInternalState(that);
+        var data = state.index;
+        var entry = state.first;
+        while (entry) {
+          entry.removed = true;
+          if (entry.previous) entry.previous = entry.previous.next = undefined;
+          delete data[entry.index];
+          entry = entry.next;
+        }
+        state.first = state.last = undefined;
+        if (DESCRIPTORS) state.size = 0;
+        else that.size = 0;
+      },
+      // `{ Map, Set }.prototype.delete(key)` methods
+      // https://tc39.es/ecma262/#sec-map.prototype.delete
+      // https://tc39.es/ecma262/#sec-set.prototype.delete
+      'delete': function (key) {
+        var that = this;
+        var state = getInternalState(that);
+        var entry = getEntry(that, key);
+        if (entry) {
+          var next = entry.next;
+          var prev = entry.previous;
+          delete state.index[entry.index];
+          entry.removed = true;
+          if (prev) prev.next = next;
+          if (next) next.previous = prev;
+          if (state.first == entry) state.first = next;
+          if (state.last == entry) state.last = prev;
+          if (DESCRIPTORS) state.size--;
+          else that.size--;
+        } return !!entry;
+      },
+      // `{ Map, Set }.prototype.forEach(callbackfn, thisArg = undefined)` methods
+      // https://tc39.es/ecma262/#sec-map.prototype.foreach
+      // https://tc39.es/ecma262/#sec-set.prototype.foreach
+      forEach: function forEach(callbackfn /* , that = undefined */) {
+        var state = getInternalState(this);
+        var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
+        var entry;
+        while (entry = entry ? entry.next : state.first) {
+          boundFunction(entry.value, entry.key, this);
+          // revert to the last existing entry
+          while (entry && entry.removed) entry = entry.previous;
+        }
+      },
+      // `{ Map, Set}.prototype.has(key)` methods
+      // https://tc39.es/ecma262/#sec-map.prototype.has
+      // https://tc39.es/ecma262/#sec-set.prototype.has
+      has: function has(key) {
+        return !!getEntry(this, key);
+      }
+    });
+
+    redefineAll(C.prototype, IS_MAP ? {
+      // `Map.prototype.get(key)` method
+      // https://tc39.es/ecma262/#sec-map.prototype.get
+      get: function get(key) {
+        var entry = getEntry(this, key);
+        return entry && entry.value;
+      },
+      // `Map.prototype.set(key, value)` method
+      // https://tc39.es/ecma262/#sec-map.prototype.set
+      set: function set(key, value) {
+        return define(this, key === 0 ? 0 : key, value);
+      }
+    } : {
+      // `Set.prototype.add(value)` method
+      // https://tc39.es/ecma262/#sec-set.prototype.add
+      add: function add(value) {
+        return define(this, value = value === 0 ? 0 : value, value);
+      }
+    });
+    if (DESCRIPTORS) defineProperty(C.prototype, 'size', {
+      get: function () {
+        return getInternalState(this).size;
+      }
+    });
+    return C;
+  },
+  setStrong: function (C, CONSTRUCTOR_NAME, IS_MAP) {
+    var ITERATOR_NAME = CONSTRUCTOR_NAME + ' Iterator';
+    var getInternalCollectionState = internalStateGetterFor(CONSTRUCTOR_NAME);
+    var getInternalIteratorState = internalStateGetterFor(ITERATOR_NAME);
+    // `{ Map, Set }.prototype.{ keys, values, entries, @@iterator }()` methods
+    // https://tc39.es/ecma262/#sec-map.prototype.entries
+    // https://tc39.es/ecma262/#sec-map.prototype.keys
+    // https://tc39.es/ecma262/#sec-map.prototype.values
+    // https://tc39.es/ecma262/#sec-map.prototype-@@iterator
+    // https://tc39.es/ecma262/#sec-set.prototype.entries
+    // https://tc39.es/ecma262/#sec-set.prototype.keys
+    // https://tc39.es/ecma262/#sec-set.prototype.values
+    // https://tc39.es/ecma262/#sec-set.prototype-@@iterator
+    defineIterator(C, CONSTRUCTOR_NAME, function (iterated, kind) {
+      setInternalState(this, {
+        type: ITERATOR_NAME,
+        target: iterated,
+        state: getInternalCollectionState(iterated),
+        kind: kind,
+        last: undefined
+      });
+    }, function () {
+      var state = getInternalIteratorState(this);
+      var kind = state.kind;
+      var entry = state.last;
+      // revert to the last existing entry
+      while (entry && entry.removed) entry = entry.previous;
+      // get next entry
+      if (!state.target || !(state.last = entry = entry ? entry.next : state.state.first)) {
+        // or finish the iteration
+        state.target = undefined;
+        return { value: undefined, done: true };
+      }
+      // return step by kind
+      if (kind == 'keys') return { value: entry.key, done: false };
+      if (kind == 'values') return { value: entry.value, done: false };
+      return { value: [entry.key, entry.value], done: false };
+    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);
+
+    // `{ Map, Set }.prototype[@@species]` accessors
+    // https://tc39.es/ecma262/#sec-get-map-@@species
+    // https://tc39.es/ecma262/#sec-get-set-@@species
+    setSpecies(CONSTRUCTOR_NAME);
+  }
+};
+
+
+/***/ }),
+
+/***/ 6935:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+
+var $ = __webpack_require__(1082);
+var global = __webpack_require__(6874);
+var isForced = __webpack_require__(2350);
+var redefine = __webpack_require__(1249);
+var InternalMetadataModule = __webpack_require__(28);
+var iterate = __webpack_require__(7093);
+var anInstance = __webpack_require__(2482);
+var isObject = __webpack_require__(6944);
+var fails = __webpack_require__(7841);
+var checkCorrectnessOfIteration = __webpack_require__(4585);
+var setToStringTag = __webpack_require__(9400);
+var inheritIfRequired = __webpack_require__(4029);
+
+module.exports = function (CONSTRUCTOR_NAME, wrapper, common) {
+  var IS_MAP = CONSTRUCTOR_NAME.indexOf('Map') !== -1;
+  var IS_WEAK = CONSTRUCTOR_NAME.indexOf('Weak') !== -1;
+  var ADDER = IS_MAP ? 'set' : 'add';
+  var NativeConstructor = global[CONSTRUCTOR_NAME];
+  var NativePrototype = NativeConstructor && NativeConstructor.prototype;
+  var Constructor = NativeConstructor;
+  var exported = {};
+
+  var fixMethod = function (KEY) {
+    var nativeMethod = NativePrototype[KEY];
+    redefine(NativePrototype, KEY,
+      KEY == 'add' ? function add(value) {
+        nativeMethod.call(this, value === 0 ? 0 : value);
+        return this;
+      } : KEY == 'delete' ? function (key) {
+        return IS_WEAK && !isObject(key) ? false : nativeMethod.call(this, key === 0 ? 0 : key);
+      } : KEY == 'get' ? function get(key) {
+        return IS_WEAK && !isObject(key) ? undefined : nativeMethod.call(this, key === 0 ? 0 : key);
+      } : KEY == 'has' ? function has(key) {
+        return IS_WEAK && !isObject(key) ? false : nativeMethod.call(this, key === 0 ? 0 : key);
+      } : function set(key, value) {
+        nativeMethod.call(this, key === 0 ? 0 : key, value);
+        return this;
+      }
+    );
+  };
+
+  var REPLACE = isForced(
+    CONSTRUCTOR_NAME,
+    typeof NativeConstructor != 'function' || !(IS_WEAK || NativePrototype.forEach && !fails(function () {
+      new NativeConstructor().entries().next();
+    }))
+  );
+
+  if (REPLACE) {
+    // create collection constructor
+    Constructor = common.getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER);
+    InternalMetadataModule.enable();
+  } else if (isForced(CONSTRUCTOR_NAME, true)) {
+    var instance = new Constructor();
+    // early implementations not supports chaining
+    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
+    // V8 ~ Chromium 40- weak-collections throws on primitives, but should return false
+    var THROWS_ON_PRIMITIVES = fails(function () { instance.has(1); });
+    // most early implementations doesn't supports iterables, most modern - not close it correctly
+    // eslint-disable-next-line no-new -- required for testing
+    var ACCEPT_ITERABLES = checkCorrectnessOfIteration(function (iterable) { new NativeConstructor(iterable); });
+    // for early implementations -0 and +0 not the same
+    var BUGGY_ZERO = !IS_WEAK && fails(function () {
+      // V8 ~ Chromium 42- fails only with 5+ elements
+      var $instance = new NativeConstructor();
+      var index = 5;
+      while (index--) $instance[ADDER](index, index);
+      return !$instance.has(-0);
+    });
+
+    if (!ACCEPT_ITERABLES) {
+      Constructor = wrapper(function (dummy, iterable) {
+        anInstance(dummy, Constructor, CONSTRUCTOR_NAME);
+        var that = inheritIfRequired(new NativeConstructor(), dummy, Constructor);
+        if (iterable != undefined) iterate(iterable, that[ADDER], { that: that, AS_ENTRIES: IS_MAP });
+        return that;
+      });
+      Constructor.prototype = NativePrototype;
+      NativePrototype.constructor = Constructor;
+    }
+
+    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
+      fixMethod('delete');
+      fixMethod('has');
+      IS_MAP && fixMethod('get');
+    }
+
+    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);
+
+    // weak collections should not contains .clear method
+    if (IS_WEAK && NativePrototype.clear) delete NativePrototype.clear;
+  }
+
+  exported[CONSTRUCTOR_NAME] = Constructor;
+  $({ global: true, forced: Constructor != NativeConstructor }, exported);
+
+  setToStringTag(Constructor, CONSTRUCTOR_NAME);
+
+  if (!IS_WEAK) common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);
+
+  return Constructor;
+};
+
+
+/***/ }),
+
+/***/ 7918:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var has = __webpack_require__(5884);
+var ownKeys = __webpack_require__(8204);
+var getOwnPropertyDescriptorModule = __webpack_require__(7825);
+var definePropertyModule = __webpack_require__(3376);
+
+module.exports = function (target, source) {
+  var keys = ownKeys(source);
+  var defineProperty = definePropertyModule.f;
+  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
+  for (var i = 0; i < keys.length; i++) {
+    var key = keys[i];
+    if (!has(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));
+  }
+};
+
+
+/***/ }),
+
+/***/ 6870:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var wellKnownSymbol = __webpack_require__(3706);
+
+var MATCH = wellKnownSymbol('match');
+
+module.exports = function (METHOD_NAME) {
+  var regexp = /./;
+  try {
+    '/./'[METHOD_NAME](regexp);
+  } catch (error1) {
+    try {
+      regexp[MATCH] = false;
+      return '/./'[METHOD_NAME](regexp);
+    } catch (error2) { /* empty */ }
+  } return false;
+};
+
+
+/***/ }),
+
+/***/ 9241:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var fails = __webpack_require__(7841);
+
+module.exports = !fails(function () {
+  function F() { /* empty */ }
+  F.prototype.constructor = null;
+  // eslint-disable-next-line es/no-object-getprototypeof -- required for testing
+  return Object.getPrototypeOf(new F()) !== F.prototype;
+});
+
+
+/***/ }),
+
+/***/ 9670:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+
+var IteratorPrototype = __webpack_require__(888).IteratorPrototype;
+var create = __webpack_require__(2361);
+var createPropertyDescriptor = __webpack_require__(976);
+var setToStringTag = __webpack_require__(9400);
+var Iterators = __webpack_require__(873);
+
+var returnThis = function () { return this; };
+
+module.exports = function (IteratorConstructor, NAME, next) {
+  var TO_STRING_TAG = NAME + ' Iterator';
+  IteratorConstructor.prototype = create(IteratorPrototype, { next: createPropertyDescriptor(1, next) });
+  setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
+  Iterators[TO_STRING_TAG] = returnThis;
+  return IteratorConstructor;
+};
+
+
+/***/ }),
+
+/***/ 4791:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var DESCRIPTORS = __webpack_require__(5542);
+var definePropertyModule = __webpack_require__(3376);
+var createPropertyDescriptor = __webpack_require__(976);
+
+module.exports = DESCRIPTORS ? function (object, key, value) {
+  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
+} : function (object, key, value) {
+  object[key] = value;
+  return object;
+};
+
+
+/***/ }),
+
+/***/ 976:
+/***/ ((module) => {
+
+module.exports = function (bitmap, value) {
+  return {
+    enumerable: !(bitmap & 1),
+    configurable: !(bitmap & 2),
+    writable: !(bitmap & 4),
+    value: value
+  };
+};
+
+
+/***/ }),
+
+/***/ 2076:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+
+var toPropertyKey = __webpack_require__(2694);
+var definePropertyModule = __webpack_require__(3376);
+var createPropertyDescriptor = __webpack_require__(976);
+
+module.exports = function (object, key, value) {
+  var propertyKey = toPropertyKey(key);
+  if (propertyKey in object) definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));
+  else object[propertyKey] = value;
+};
+
+
+/***/ }),
+
+/***/ 3131:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+
+var $ = __webpack_require__(1082);
+var createIteratorConstructor = __webpack_require__(9670);
+var getPrototypeOf = __webpack_require__(8186);
+var setPrototypeOf = __webpack_require__(2686);
+var setToStringTag = __webpack_require__(9400);
+var createNonEnumerableProperty = __webpack_require__(4791);
+var redefine = __webpack_require__(1249);
+var wellKnownSymbol = __webpack_require__(3706);
+var IS_PURE = __webpack_require__(6852);
+var Iterators = __webpack_require__(873);
+var IteratorsCore = __webpack_require__(888);
+
+var IteratorPrototype = IteratorsCore.IteratorPrototype;
+var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
+var ITERATOR = wellKnownSymbol('iterator');
+var KEYS = 'keys';
+var VALUES = 'values';
+var ENTRIES = 'entries';
+
+var returnThis = function () { return this; };
+
+module.exports = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
+  createIteratorConstructor(IteratorConstructor, NAME, next);
+
+  var getIterationMethod = function (KIND) {
+    if (KIND === DEFAULT && defaultIterator) return defaultIterator;
+    if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];
+    switch (KIND) {
+      case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };
+      case VALUES: return function values() { return new IteratorConstructor(this, KIND); };
+      case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };
+    } return function () { return new IteratorConstructor(this); };
+  };
+
+  var TO_STRING_TAG = NAME + ' Iterator';
+  var INCORRECT_VALUES_NAME = false;
+  var IterablePrototype = Iterable.prototype;
+  var nativeIterator = IterablePrototype[ITERATOR]
+    || IterablePrototype['@@iterator']
+    || DEFAULT && IterablePrototype[DEFAULT];
+  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
+  var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
+  var CurrentIteratorPrototype, methods, KEY;
+
+  // fix native
+  if (anyNativeIterator) {
+    CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
+    if (IteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
+      if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
+        if (setPrototypeOf) {
+          setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
+        } else if (typeof CurrentIteratorPrototype[ITERATOR] != 'function') {
+          createNonEnumerableProperty(CurrentIteratorPrototype, ITERATOR, returnThis);
+        }
+      }
+      // Set @@toStringTag to native iterators
+      setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
+      if (IS_PURE) Iterators[TO_STRING_TAG] = returnThis;
+    }
+  }
+
+  // fix Array.prototype.{ values, @@iterator }.name in V8 / FF
+  if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
+    INCORRECT_VALUES_NAME = true;
+    defaultIterator = function values() { return nativeIterator.call(this); };
+  }
+
+  // define iterator
+  if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
+    createNonEnumerableProperty(IterablePrototype, ITERATOR, defaultIterator);
+  }
+  Iterators[NAME] = defaultIterator;
+
+  // export additional methods
+  if (DEFAULT) {
+    methods = {
+      values: getIterationMethod(VALUES),
+      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
+      entries: getIterationMethod(ENTRIES)
+    };
+    if (FORCED) for (KEY in methods) {
+      if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
+        redefine(IterablePrototype, KEY, methods[KEY]);
+      }
+    } else $({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
+  }
+
+  return methods;
+};
+
+
+/***/ }),
+
+/***/ 1578:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var path = __webpack_require__(2067);
+var has = __webpack_require__(5884);
+var wrappedWellKnownSymbolModule = __webpack_require__(8403);
+var defineProperty = __webpack_require__(3376).f;
+
+module.exports = function (NAME) {
+  var Symbol = path.Symbol || (path.Symbol = {});
+  if (!has(Symbol, NAME)) defineProperty(Symbol, NAME, {
+    value: wrappedWellKnownSymbolModule.f(NAME)
+  });
+};
+
+
+/***/ }),
+
+/***/ 5542:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var fails = __webpack_require__(7841);
+
+// Detect IE8's incomplete defineProperty implementation
+module.exports = !fails(function () {
+  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
+  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;
+});
+
+
+/***/ }),
+
+/***/ 3879:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var global = __webpack_require__(6874);
+var isObject = __webpack_require__(6944);
+
+var document = global.document;
+// typeof document.createElement is 'object' in old IE
+var EXISTS = isObject(document) && isObject(document.createElement);
+
+module.exports = function (it) {
+  return EXISTS ? document.createElement(it) : {};
+};
+
+
+/***/ }),
+
+/***/ 8956:
+/***/ ((module) => {
+
+// iterable DOM collections
+// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods
+module.exports = {
+  CSSRuleList: 0,
+  CSSStyleDeclaration: 0,
+  CSSValueList: 0,
+  ClientRectList: 0,
+  DOMRectList: 0,
+  DOMStringList: 0,
+  DOMTokenList: 1,
+  DataTransferItemList: 0,
+  FileList: 0,
+  HTMLAllCollection: 0,
+  HTMLCollection: 0,
+  HTMLFormElement: 0,
+  HTMLSelectElement: 0,
+  MediaList: 0,
+  MimeTypeArray: 0,
+  NamedNodeMap: 0,
+  NodeList: 1,
+  PaintRequestList: 0,
+  Plugin: 0,
+  PluginArray: 0,
+  SVGLengthList: 0,
+  SVGNumberList: 0,
+  SVGPathSegList: 0,
+  SVGPointList: 0,
+  SVGStringList: 0,
+  SVGTransformList: 0,
+  SourceBufferList: 0,
+  StyleSheetList: 0,
+  TextTrackCueList: 0,
+  TextTrackList: 0,
+  TouchList: 0
+};
+
+
+/***/ }),
+
+/***/ 6817:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var userAgent = __webpack_require__(4229);
+
+var firefox = userAgent.match(/firefox\/(\d+)/i);
+
+module.exports = !!firefox && +firefox[1];
+
+
+/***/ }),
+
+/***/ 206:
+/***/ ((module) => {
+
+module.exports = typeof window == 'object';
+
+
+/***/ }),
+
+/***/ 6264:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var UA = __webpack_require__(4229);
+
+module.exports = /MSIE|Trident/.test(UA);
+
+
+/***/ }),
+
+/***/ 2389:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var userAgent = __webpack_require__(4229);
+var global = __webpack_require__(6874);
+
+module.exports = /ipad|iphone|ipod/i.test(userAgent) && global.Pebble !== undefined;
+
+
+/***/ }),
+
+/***/ 3359:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var userAgent = __webpack_require__(4229);
+
+module.exports = /(?:ipad|iphone|ipod).*applewebkit/i.test(userAgent);
+
+
+/***/ }),
+
+/***/ 8723:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var classof = __webpack_require__(3565);
+var global = __webpack_require__(6874);
+
+module.exports = classof(global.process) == 'process';
+
+
+/***/ }),
+
+/***/ 4306:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var userAgent = __webpack_require__(4229);
+
+module.exports = /web0s(?!.*chrome)/i.test(userAgent);
+
+
+/***/ }),
+
+/***/ 4229:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var getBuiltIn = __webpack_require__(4578);
+
+module.exports = getBuiltIn('navigator', 'userAgent') || '';
+
+
+/***/ }),
+
+/***/ 579:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var global = __webpack_require__(6874);
+var userAgent = __webpack_require__(4229);
+
+var process = global.process;
+var Deno = global.Deno;
+var versions = process && process.versions || Deno && Deno.version;
+var v8 = versions && versions.v8;
+var match, version;
+
+if (v8) {
+  match = v8.split('.');
+  version = match[0] < 4 ? 1 : match[0] + match[1];
+} else if (userAgent) {
+  match = userAgent.match(/Edge\/(\d+)/);
+  if (!match || match[1] >= 74) {
+    match = userAgent.match(/Chrome\/(\d+)/);
+    if (match) version = match[1];
+  }
+}
+
+module.exports = version && +version;
+
+
+/***/ }),
+
+/***/ 9736:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var userAgent = __webpack_require__(4229);
+
+var webkit = userAgent.match(/AppleWebKit\/(\d+)\./);
+
+module.exports = !!webkit && +webkit[1];
+
+
+/***/ }),
+
+/***/ 9752:
+/***/ ((module) => {
+
+// IE8- don't enum bug keys
+module.exports = [
+  'constructor',
+  'hasOwnProperty',
+  'isPrototypeOf',
+  'propertyIsEnumerable',
+  'toLocaleString',
+  'toString',
+  'valueOf'
+];
+
+
+/***/ }),
+
+/***/ 1082:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var global = __webpack_require__(6874);
+var getOwnPropertyDescriptor = __webpack_require__(7825).f;
+var createNonEnumerableProperty = __webpack_require__(4791);
+var redefine = __webpack_require__(1249);
+var setGlobal = __webpack_require__(1278);
+var copyConstructorProperties = __webpack_require__(7918);
+var isForced = __webpack_require__(2350);
+
+/*
+  options.target      - name of the target object
+  options.global      - target is the global object
+  options.stat        - export as static methods of target
+  options.proto       - export as prototype methods of target
+  options.real        - real prototype method for the `pure` version
+  options.forced      - export even if the native feature is available
+  options.bind        - bind methods to the target, required for the `pure` version
+  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
+  options.unsafe      - use the simple assignment of property instead of delete + defineProperty
+  options.sham        - add a flag to not completely full polyfills
+  options.enumerable  - export as enumerable property
+  options.noTargetGet - prevent calling a getter on target
+*/
+module.exports = function (options, source) {
+  var TARGET = options.target;
+  var GLOBAL = options.global;
+  var STATIC = options.stat;
+  var FORCED, target, key, targetProperty, sourceProperty, descriptor;
+  if (GLOBAL) {
+    target = global;
+  } else if (STATIC) {
+    target = global[TARGET] || setGlobal(TARGET, {});
+  } else {
+    target = (global[TARGET] || {}).prototype;
+  }
+  if (target) for (key in source) {
+    sourceProperty = source[key];
+    if (options.noTargetGet) {
+      descriptor = getOwnPropertyDescriptor(target, key);
+      targetProperty = descriptor && descriptor.value;
+    } else targetProperty = target[key];
+    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
+    // contained in target
+    if (!FORCED && targetProperty !== undefined) {
+      if (typeof sourceProperty === typeof targetProperty) continue;
+      copyConstructorProperties(sourceProperty, targetProperty);
+    }
+    // add a flag to not completely full polyfills
+    if (options.sham || (targetProperty && targetProperty.sham)) {
+      createNonEnumerableProperty(sourceProperty, 'sham', true);
+    }
+    // extend global
+    redefine(target, key, sourceProperty, options);
+  }
+};
+
+
+/***/ }),
+
+/***/ 7841:
+/***/ ((module) => {
+
+module.exports = function (exec) {
+  try {
+    return !!exec();
+  } catch (error) {
+    return true;
+  }
+};
+
+
+/***/ }),
+
+/***/ 6918:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+
+// TODO: Remove from `core-js@4` since it's moved to entry points
+__webpack_require__(1818);
+var redefine = __webpack_require__(1249);
+var regexpExec = __webpack_require__(1144);
+var fails = __webpack_require__(7841);
+var wellKnownSymbol = __webpack_require__(3706);
+var createNonEnumerableProperty = __webpack_require__(4791);
+
+var SPECIES = wellKnownSymbol('species');
+var RegExpPrototype = RegExp.prototype;
+
+module.exports = function (KEY, exec, FORCED, SHAM) {
+  var SYMBOL = wellKnownSymbol(KEY);
+
+  var DELEGATES_TO_SYMBOL = !fails(function () {
+    // String methods call symbol-named RegEp methods
+    var O = {};
+    O[SYMBOL] = function () { return 7; };
+    return ''[KEY](O) != 7;
+  });
+
+  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails(function () {
+    // Symbol-named RegExp methods call .exec
+    var execCalled = false;
+    var re = /a/;
+
+    if (KEY === 'split') {
+      // We can't use real regex here since it causes deoptimization
+      // and serious performance degradation in V8
+      // https://github.com/zloirock/core-js/issues/306
+      re = {};
+      // RegExp[@@split] doesn't call the regex's exec method, but first creates
+      // a new one. We need to return the patched regex when creating the new one.
+      re.constructor = {};
+      re.constructor[SPECIES] = function () { return re; };
+      re.flags = '';
+      re[SYMBOL] = /./[SYMBOL];
+    }
+
+    re.exec = function () { execCalled = true; return null; };
+
+    re[SYMBOL]('');
+    return !execCalled;
+  });
+
+  if (
+    !DELEGATES_TO_SYMBOL ||
+    !DELEGATES_TO_EXEC ||
+    FORCED
+  ) {
+    var nativeRegExpMethod = /./[SYMBOL];
+    var methods = exec(SYMBOL, ''[KEY], function (nativeMethod, regexp, str, arg2, forceStringMethod) {
+      var $exec = regexp.exec;
+      if ($exec === regexpExec || $exec === RegExpPrototype.exec) {
+        if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
+          // The native String method already delegates to @@method (this
+          // polyfilled function), leasing to infinite recursion.
+          // We avoid it by directly calling the native @@method method.
+          return { done: true, value: nativeRegExpMethod.call(regexp, str, arg2) };
+        }
+        return { done: true, value: nativeMethod.call(str, regexp, arg2) };
+      }
+      return { done: false };
+    });
+
+    redefine(String.prototype, KEY, methods[0]);
+    redefine(RegExpPrototype, SYMBOL, methods[1]);
+  }
+
+  if (SHAM) createNonEnumerableProperty(RegExpPrototype[SYMBOL], 'sham', true);
+};
+
+
+/***/ }),
+
+/***/ 2009:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var fails = __webpack_require__(7841);
+
+module.exports = !fails(function () {
+  // eslint-disable-next-line es/no-object-isextensible, es/no-object-preventextensions -- required for testing
+  return Object.isExtensible(Object.preventExtensions({}));
+});
+
+
+/***/ }),
+
+/***/ 4833:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var aFunction = __webpack_require__(769);
+
+// optional / simple context binding
+module.exports = function (fn, that, length) {
+  aFunction(fn);
+  if (that === undefined) return fn;
+  switch (length) {
+    case 0: return function () {
+      return fn.call(that);
+    };
+    case 1: return function (a) {
+      return fn.call(that, a);
+    };
+    case 2: return function (a, b) {
+      return fn.call(that, a, b);
+    };
+    case 3: return function (a, b, c) {
+      return fn.call(that, a, b, c);
+    };
+  }
+  return function (/* ...args */) {
+    return fn.apply(that, arguments);
+  };
+};
+
+
+/***/ }),
+
+/***/ 5462:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+
+var aFunction = __webpack_require__(769);
+var isObject = __webpack_require__(6944);
+
+var slice = [].slice;
+var factories = {};
+
+var construct = function (C, argsLength, args) {
+  if (!(argsLength in factories)) {
+    for (var list = [], i = 0; i < argsLength; i++) list[i] = 'a[' + i + ']';
+    // eslint-disable-next-line no-new-func -- we have no proper alternatives, IE8- only
+    factories[argsLength] = Function('C,a', 'return new C(' + list.join(',') + ')');
+  } return factories[argsLength](C, args);
+};
+
+// `Function.prototype.bind` method implementation
+// https://tc39.es/ecma262/#sec-function.prototype.bind
+module.exports = Function.bind || function bind(that /* , ...args */) {
+  var fn = aFunction(this);
+  var partArgs = slice.call(arguments, 1);
+  var boundFunction = function bound(/* args... */) {
+    var args = partArgs.concat(slice.call(arguments));
+    return this instanceof boundFunction ? construct(fn, args.length, args) : fn.apply(that, args);
+  };
+  if (isObject(fn.prototype)) boundFunction.prototype = fn.prototype;
+  return boundFunction;
+};
+
+
+/***/ }),
+
+/***/ 4578:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var global = __webpack_require__(6874);
+
+var aFunction = function (variable) {
+  return typeof variable == 'function' ? variable : undefined;
+};
+
+module.exports = function (namespace, method) {
+  return arguments.length < 2 ? aFunction(global[namespace]) : global[namespace] && global[namespace][method];
+};
+
+
+/***/ }),
+
+/***/ 3126:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var classof = __webpack_require__(8753);
+var Iterators = __webpack_require__(873);
+var wellKnownSymbol = __webpack_require__(3706);
+
+var ITERATOR = wellKnownSymbol('iterator');
+
+module.exports = function (it) {
+  if (it != undefined) return it[ITERATOR]
+    || it['@@iterator']
+    || Iterators[classof(it)];
+};
+
+
+/***/ }),
+
+/***/ 7053:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var anObject = __webpack_require__(47);
+var getIteratorMethod = __webpack_require__(3126);
+
+module.exports = function (it) {
+  var iteratorMethod = getIteratorMethod(it);
+  if (typeof iteratorMethod != 'function') {
+    throw TypeError(String(it) + ' is not iterable');
+  } return anObject(iteratorMethod.call(it));
+};
+
+
+/***/ }),
+
+/***/ 9:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var toObject = __webpack_require__(4680);
+
+var floor = Math.floor;
+var replace = ''.replace;
+var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d{1,2}|<[^>]*>)/g;
+var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d{1,2})/g;
+
+// `GetSubstitution` abstract operation
+// https://tc39.es/ecma262/#sec-getsubstitution
+module.exports = function (matched, str, position, captures, namedCaptures, replacement) {
+  var tailPos = position + matched.length;
+  var m = captures.length;
+  var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
+  if (namedCaptures !== undefined) {
+    namedCaptures = toObject(namedCaptures);
+    symbols = SUBSTITUTION_SYMBOLS;
+  }
+  return replace.call(replacement, symbols, function (match, ch) {
+    var capture;
+    switch (ch.charAt(0)) {
+      case '$': return '$';
+      case '&': return matched;
+      case '`': return str.slice(0, position);
+      case "'": return str.slice(tailPos);
+      case '<':
+        capture = namedCaptures[ch.slice(1, -1)];
+        break;
+      default: // \d\d?
+        var n = +ch;
+        if (n === 0) return match;
+        if (n > m) {
+          var f = floor(n / 10);
+          if (f === 0) return match;
+          if (f <= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);
+          return match;
+        }
+        capture = captures[n - 1];
+    }
+    return capture === undefined ? '' : capture;
+  });
+};
+
+
+/***/ }),
+
+/***/ 6874:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var check = function (it) {
+  return it && it.Math == Math && it;
+};
+
+// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
+module.exports =
+  // eslint-disable-next-line es/no-global-this -- safe
+  check(typeof globalThis == 'object' && globalThis) ||
+  check(typeof window == 'object' && window) ||
+  // eslint-disable-next-line no-restricted-globals -- safe
+  check(typeof self == 'object' && self) ||
+  check(typeof __webpack_require__.g == 'object' && __webpack_require__.g) ||
+  // eslint-disable-next-line no-new-func -- fallback
+  (function () { return this; })() || Function('return this')();
+
+
+/***/ }),
+
+/***/ 5884:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var toObject = __webpack_require__(4680);
+
+var hasOwnProperty = {}.hasOwnProperty;
+
+module.exports = Object.hasOwn || function hasOwn(it, key) {
+  return hasOwnProperty.call(toObject(it), key);
+};
+
+
+/***/ }),
+
+/***/ 5644:
+/***/ ((module) => {
+
+module.exports = {};
+
+
+/***/ }),
+
+/***/ 1250:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var global = __webpack_require__(6874);
+
+module.exports = function (a, b) {
+  var console = global.console;
+  if (console && console.error) {
+    arguments.length === 1 ? console.error(a) : console.error(a, b);
+  }
+};
+
+
+/***/ }),
+
+/***/ 7666:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var getBuiltIn = __webpack_require__(4578);
+
+module.exports = getBuiltIn('document', 'documentElement');
+
+
+/***/ }),
+
+/***/ 6056:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var DESCRIPTORS = __webpack_require__(5542);
+var fails = __webpack_require__(7841);
+var createElement = __webpack_require__(3879);
+
+// Thank's IE8 for his funny defineProperty
+module.exports = !DESCRIPTORS && !fails(function () {
+  // eslint-disable-next-line es/no-object-defineproperty -- requied for testing
+  return Object.defineProperty(createElement('div'), 'a', {
+    get: function () { return 7; }
+  }).a != 7;
+});
+
+
+/***/ }),
+
+/***/ 6227:
+/***/ ((module) => {
+
+// IEEE754 conversions based on https://github.com/feross/ieee754
+var abs = Math.abs;
+var pow = Math.pow;
+var floor = Math.floor;
+var log = Math.log;
+var LN2 = Math.LN2;
+
+var pack = function (number, mantissaLength, bytes) {
+  var buffer = new Array(bytes);
+  var exponentLength = bytes * 8 - mantissaLength - 1;
+  var eMax = (1 << exponentLength) - 1;
+  var eBias = eMax >> 1;
+  var rt = mantissaLength === 23 ? pow(2, -24) - pow(2, -77) : 0;
+  var sign = number < 0 || number === 0 && 1 / number < 0 ? 1 : 0;
+  var index = 0;
+  var exponent, mantissa, c;
+  number = abs(number);
+  // eslint-disable-next-line no-self-compare -- NaN check
+  if (number != number || number === Infinity) {
+    // eslint-disable-next-line no-self-compare -- NaN check
+    mantissa = number != number ? 1 : 0;
+    exponent = eMax;
+  } else {
+    exponent = floor(log(number) / LN2);
+    if (number * (c = pow(2, -exponent)) < 1) {
+      exponent--;
+      c *= 2;
+    }
+    if (exponent + eBias >= 1) {
+      number += rt / c;
+    } else {
+      number += rt * pow(2, 1 - eBias);
+    }
+    if (number * c >= 2) {
+      exponent++;
+      c /= 2;
+    }
+    if (exponent + eBias >= eMax) {
+      mantissa = 0;
+      exponent = eMax;
+    } else if (exponent + eBias >= 1) {
+      mantissa = (number * c - 1) * pow(2, mantissaLength);
+      exponent = exponent + eBias;
+    } else {
+      mantissa = number * pow(2, eBias - 1) * pow(2, mantissaLength);
+      exponent = 0;
+    }
+  }
+  for (; mantissaLength >= 8; buffer[index++] = mantissa & 255, mantissa /= 256, mantissaLength -= 8);
+  exponent = exponent << mantissaLength | mantissa;
+  exponentLength += mantissaLength;
+  for (; exponentLength > 0; buffer[index++] = exponent & 255, exponent /= 256, exponentLength -= 8);
+  buffer[--index] |= sign * 128;
+  return buffer;
+};
+
+var unpack = function (buffer, mantissaLength) {
+  var bytes = buffer.length;
+  var exponentLength = bytes * 8 - mantissaLength - 1;
+  var eMax = (1 << exponentLength) - 1;
+  var eBias = eMax >> 1;
+  var nBits = exponentLength - 7;
+  var index = bytes - 1;
+  var sign = buffer[index--];
+  var exponent = sign & 127;
+  var mantissa;
+  sign >>= 7;
+  for (; nBits > 0; exponent = exponent * 256 + buffer[index], index--, nBits -= 8);
+  mantissa = exponent & (1 << -nBits) - 1;
+  exponent >>= -nBits;
+  nBits += mantissaLength;
+  for (; nBits > 0; mantissa = mantissa * 256 + buffer[index], index--, nBits -= 8);
+  if (exponent === 0) {
+    exponent = 1 - eBias;
+  } else if (exponent === eMax) {
+    return mantissa ? NaN : sign ? -Infinity : Infinity;
+  } else {
+    mantissa = mantissa + pow(2, mantissaLength);
+    exponent = exponent - eBias;
+  } return (sign ? -1 : 1) * mantissa * pow(2, exponent - mantissaLength);
+};
+
+module.exports = {
+  pack: pack,
+  unpack: unpack
+};
+
+
+/***/ }),
+
+/***/ 7361:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var fails = __webpack_require__(7841);
+var classof = __webpack_require__(3565);
+
+var split = ''.split;
+
+// fallback for non-array-like ES3 and non-enumerable old V8 strings
+module.exports = fails(function () {
+  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
+  // eslint-disable-next-line no-prototype-builtins -- safe
+  return !Object('z').propertyIsEnumerable(0);
+}) ? function (it) {
+  return classof(it) == 'String' ? split.call(it, '') : Object(it);
+} : Object;
+
+
+/***/ }),
+
+/***/ 4029:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var isObject = __webpack_require__(6944);
+var setPrototypeOf = __webpack_require__(2686);
+
+// makes subclassing work correct for wrapped built-ins
+module.exports = function ($this, dummy, Wrapper) {
+  var NewTarget, NewTargetPrototype;
+  if (
+    // it can work only with native `setPrototypeOf`
+    setPrototypeOf &&
+    // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
+    typeof (NewTarget = dummy.constructor) == 'function' &&
+    NewTarget !== Wrapper &&
+    isObject(NewTargetPrototype = NewTarget.prototype) &&
+    NewTargetPrototype !== Wrapper.prototype
+  ) setPrototypeOf($this, NewTargetPrototype);
+  return $this;
+};
+
+
+/***/ }),
+
+/***/ 6090:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var store = __webpack_require__(4925);
+
+var functionToString = Function.toString;
+
+// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper
+if (typeof store.inspectSource != 'function') {
+  store.inspectSource = function (it) {
+    return functionToString.call(it);
+  };
+}
+
+module.exports = store.inspectSource;
+
+
+/***/ }),
+
+/***/ 28:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var $ = __webpack_require__(1082);
+var hiddenKeys = __webpack_require__(5644);
+var isObject = __webpack_require__(6944);
+var has = __webpack_require__(5884);
+var defineProperty = __webpack_require__(3376).f;
+var getOwnPropertyNamesModule = __webpack_require__(8401);
+var getOwnPropertyNamesExternalModule = __webpack_require__(3866);
+var uid = __webpack_require__(8435);
+var FREEZING = __webpack_require__(2009);
+
+var REQUIRED = false;
+var METADATA = uid('meta');
+var id = 0;
+
+// eslint-disable-next-line es/no-object-isextensible -- safe
+var isExtensible = Object.isExtensible || function () {
+  return true;
+};
+
+var setMetadata = function (it) {
+  defineProperty(it, METADATA, { value: {
+    objectID: 'O' + id++, // object ID
+    weakData: {}          // weak collections IDs
+  } });
+};
+
+var fastKey = function (it, create) {
+  // return a primitive with prefix
+  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
+  if (!has(it, METADATA)) {
+    // can't set metadata to uncaught frozen object
+    if (!isExtensible(it)) return 'F';
+    // not necessary to add metadata
+    if (!create) return 'E';
+    // add missing metadata
+    setMetadata(it);
+  // return object ID
+  } return it[METADATA].objectID;
+};
+
+var getWeakData = function (it, create) {
+  if (!has(it, METADATA)) {
+    // can't set metadata to uncaught frozen object
+    if (!isExtensible(it)) return true;
+    // not necessary to add metadata
+    if (!create) return false;
+    // add missing metadata
+    setMetadata(it);
+  // return the store of weak collections IDs
+  } return it[METADATA].weakData;
+};
+
+// add metadata on freeze-family methods calling
+var onFreeze = function (it) {
+  if (FREEZING && REQUIRED && isExtensible(it) && !has(it, METADATA)) setMetadata(it);
+  return it;
+};
+
+var enable = function () {
+  meta.enable = function () { /* empty */ };
+  REQUIRED = true;
+  var getOwnPropertyNames = getOwnPropertyNamesModule.f;
+  var splice = [].splice;
+  var test = {};
+  test[METADATA] = 1;
+
+  // prevent exposing of metadata key
+  if (getOwnPropertyNames(test).length) {
+    getOwnPropertyNamesModule.f = function (it) {
+      var result = getOwnPropertyNames(it);
+      for (var i = 0, length = result.length; i < length; i++) {
+        if (result[i] === METADATA) {
+          splice.call(result, i, 1);
+          break;
+        }
+      } return result;
+    };
+
+    $({ target: 'Object', stat: true, forced: true }, {
+      getOwnPropertyNames: getOwnPropertyNamesExternalModule.f
+    });
+  }
+};
+
+var meta = module.exports = {
+  enable: enable,
+  fastKey: fastKey,
+  getWeakData: getWeakData,
+  onFreeze: onFreeze
+};
+
+hiddenKeys[METADATA] = true;
+
+
+/***/ }),
+
+/***/ 6619:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var NATIVE_WEAK_MAP = __webpack_require__(9957);
+var global = __webpack_require__(6874);
+var isObject = __webpack_require__(6944);
+var createNonEnumerableProperty = __webpack_require__(4791);
+var objectHas = __webpack_require__(5884);
+var shared = __webpack_require__(4925);
+var sharedKey = __webpack_require__(8698);
+var hiddenKeys = __webpack_require__(5644);
+
+var OBJECT_ALREADY_INITIALIZED = 'Object already initialized';
+var WeakMap = global.WeakMap;
+var set, get, has;
+
+var enforce = function (it) {
+  return has(it) ? get(it) : set(it, {});
+};
+
+var getterFor = function (TYPE) {
+  return function (it) {
+    var state;
+    if (!isObject(it) || (state = get(it)).type !== TYPE) {
+      throw TypeError('Incompatible receiver, ' + TYPE + ' required');
+    } return state;
+  };
+};
+
+if (NATIVE_WEAK_MAP || shared.state) {
+  var store = shared.state || (shared.state = new WeakMap());
+  var wmget = store.get;
+  var wmhas = store.has;
+  var wmset = store.set;
+  set = function (it, metadata) {
+    if (wmhas.call(store, it)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
+    metadata.facade = it;
+    wmset.call(store, it, metadata);
+    return metadata;
+  };
+  get = function (it) {
+    return wmget.call(store, it) || {};
+  };
+  has = function (it) {
+    return wmhas.call(store, it);
+  };
+} else {
+  var STATE = sharedKey('state');
+  hiddenKeys[STATE] = true;
+  set = function (it, metadata) {
+    if (objectHas(it, STATE)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
+    metadata.facade = it;
+    createNonEnumerableProperty(it, STATE, metadata);
+    return metadata;
+  };
+  get = function (it) {
+    return objectHas(it, STATE) ? it[STATE] : {};
+  };
+  has = function (it) {
+    return objectHas(it, STATE);
+  };
+}
+
+module.exports = {
+  set: set,
+  get: get,
+  has: has,
+  enforce: enforce,
+  getterFor: getterFor
+};
+
+
+/***/ }),
+
+/***/ 1008:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var wellKnownSymbol = __webpack_require__(3706);
+var Iterators = __webpack_require__(873);
+
+var ITERATOR = wellKnownSymbol('iterator');
+var ArrayPrototype = Array.prototype;
+
+// check on default Array iterator
+module.exports = function (it) {
+  return it !== undefined && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
+};
+
+
+/***/ }),
+
+/***/ 7828:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var classof = __webpack_require__(3565);
+
+// `IsArray` abstract operation
+// https://tc39.es/ecma262/#sec-isarray
+// eslint-disable-next-line es/no-array-isarray -- safe
+module.exports = Array.isArray || function isArray(arg) {
+  return classof(arg) == 'Array';
+};
+
+
+/***/ }),
+
+/***/ 2350:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var fails = __webpack_require__(7841);
+
+var replacement = /#|\.prototype\./;
+
+var isForced = function (feature, detection) {
+  var value = data[normalize(feature)];
+  return value == POLYFILL ? true
+    : value == NATIVE ? false
+    : typeof detection == 'function' ? fails(detection)
+    : !!detection;
+};
+
+var normalize = isForced.normalize = function (string) {
+  return String(string).replace(replacement, '.').toLowerCase();
+};
+
+var data = isForced.data = {};
+var NATIVE = isForced.NATIVE = 'N';
+var POLYFILL = isForced.POLYFILL = 'P';
+
+module.exports = isForced;
+
+
+/***/ }),
+
+/***/ 3614:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var isObject = __webpack_require__(6944);
+
+var floor = Math.floor;
+
+// `Number.isInteger` method implementation
+// https://tc39.es/ecma262/#sec-number.isinteger
+module.exports = function isInteger(it) {
+  return !isObject(it) && isFinite(it) && floor(it) === it;
+};
+
+
+/***/ }),
+
+/***/ 6944:
+/***/ ((module) => {
+
+module.exports = function (it) {
+  return typeof it === 'object' ? it !== null : typeof it === 'function';
+};
+
+
+/***/ }),
+
+/***/ 6852:
+/***/ ((module) => {
+
+module.exports = false;
+
+
+/***/ }),
+
+/***/ 2399:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var isObject = __webpack_require__(6944);
+var classof = __webpack_require__(3565);
+var wellKnownSymbol = __webpack_require__(3706);
+
+var MATCH = wellKnownSymbol('match');
+
+// `IsRegExp` abstract operation
+// https://tc39.es/ecma262/#sec-isregexp
+module.exports = function (it) {
+  var isRegExp;
+  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : classof(it) == 'RegExp');
+};
+
+
+/***/ }),
+
+/***/ 8377:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var getBuiltIn = __webpack_require__(4578);
+var USE_SYMBOL_AS_UID = __webpack_require__(4587);
+
+module.exports = USE_SYMBOL_AS_UID ? function (it) {
+  return typeof it == 'symbol';
+} : function (it) {
+  var $Symbol = getBuiltIn('Symbol');
+  return typeof $Symbol == 'function' && Object(it) instanceof $Symbol;
+};
+
+
+/***/ }),
+
+/***/ 7093:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var anObject = __webpack_require__(47);
+var isArrayIteratorMethod = __webpack_require__(1008);
+var toLength = __webpack_require__(4954);
+var bind = __webpack_require__(4833);
+var getIteratorMethod = __webpack_require__(3126);
+var iteratorClose = __webpack_require__(2608);
+
+var Result = function (stopped, result) {
+  this.stopped = stopped;
+  this.result = result;
+};
+
+module.exports = function (iterable, unboundFunction, options) {
+  var that = options && options.that;
+  var AS_ENTRIES = !!(options && options.AS_ENTRIES);
+  var IS_ITERATOR = !!(options && options.IS_ITERATOR);
+  var INTERRUPTED = !!(options && options.INTERRUPTED);
+  var fn = bind(unboundFunction, that, 1 + AS_ENTRIES + INTERRUPTED);
+  var iterator, iterFn, index, length, result, next, step;
+
+  var stop = function (condition) {
+    if (iterator) iteratorClose(iterator);
+    return new Result(true, condition);
+  };
+
+  var callFn = function (value) {
+    if (AS_ENTRIES) {
+      anObject(value);
+      return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
+    } return INTERRUPTED ? fn(value, stop) : fn(value);
+  };
+
+  if (IS_ITERATOR) {
+    iterator = iterable;
+  } else {
+    iterFn = getIteratorMethod(iterable);
+    if (typeof iterFn != 'function') throw TypeError('Target is not iterable');
+    // optimisation for array iterators
+    if (isArrayIteratorMethod(iterFn)) {
+      for (index = 0, length = toLength(iterable.length); length > index; index++) {
+        result = callFn(iterable[index]);
+        if (result && result instanceof Result) return result;
+      } return new Result(false);
+    }
+    iterator = iterFn.call(iterable);
+  }
+
+  next = iterator.next;
+  while (!(step = next.call(iterator)).done) {
+    try {
+      result = callFn(step.value);
+    } catch (error) {
+      iteratorClose(iterator);
+      throw error;
+    }
+    if (typeof result == 'object' && result && result instanceof Result) return result;
+  } return new Result(false);
+};
+
+
+/***/ }),
+
+/***/ 2608:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var anObject = __webpack_require__(47);
+
+module.exports = function (iterator) {
+  var returnMethod = iterator['return'];
+  if (returnMethod !== undefined) {
+    return anObject(returnMethod.call(iterator)).value;
+  }
+};
+
+
+/***/ }),
+
+/***/ 888:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+
+var fails = __webpack_require__(7841);
+var getPrototypeOf = __webpack_require__(8186);
+var createNonEnumerableProperty = __webpack_require__(4791);
+var has = __webpack_require__(5884);
+var wellKnownSymbol = __webpack_require__(3706);
+var IS_PURE = __webpack_require__(6852);
+
+var ITERATOR = wellKnownSymbol('iterator');
+var BUGGY_SAFARI_ITERATORS = false;
+
+var returnThis = function () { return this; };
+
+// `%IteratorPrototype%` object
+// https://tc39.es/ecma262/#sec-%iteratorprototype%-object
+var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;
+
+/* eslint-disable es/no-array-prototype-keys -- safe */
+if ([].keys) {
+  arrayIterator = [].keys();
+  // Safari 8 has buggy iterators w/o `next`
+  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;
+  else {
+    PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
+    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
+  }
+}
+
+var NEW_ITERATOR_PROTOTYPE = IteratorPrototype == undefined || fails(function () {
+  var test = {};
+  // FF44- legacy iterators case
+  return IteratorPrototype[ITERATOR].call(test) !== test;
+});
+
+if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype = {};
+
+// `%IteratorPrototype%[@@iterator]()` method
+// https://tc39.es/ecma262/#sec-%iteratorprototype%-@@iterator
+if ((!IS_PURE || NEW_ITERATOR_PROTOTYPE) && !has(IteratorPrototype, ITERATOR)) {
+  createNonEnumerableProperty(IteratorPrototype, ITERATOR, returnThis);
+}
+
+module.exports = {
+  IteratorPrototype: IteratorPrototype,
+  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS
+};
+
+
+/***/ }),
+
+/***/ 873:
+/***/ ((module) => {
+
+module.exports = {};
+
+
+/***/ }),
+
+/***/ 6309:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var global = __webpack_require__(6874);
+var getOwnPropertyDescriptor = __webpack_require__(7825).f;
+var macrotask = __webpack_require__(998).set;
+var IS_IOS = __webpack_require__(3359);
+var IS_IOS_PEBBLE = __webpack_require__(2389);
+var IS_WEBOS_WEBKIT = __webpack_require__(4306);
+var IS_NODE = __webpack_require__(8723);
+
+var MutationObserver = global.MutationObserver || global.WebKitMutationObserver;
+var document = global.document;
+var process = global.process;
+var Promise = global.Promise;
+// Node.js 11 shows ExperimentalWarning on getting `queueMicrotask`
+var queueMicrotaskDescriptor = getOwnPropertyDescriptor(global, 'queueMicrotask');
+var queueMicrotask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;
+
+var flush, head, last, notify, toggle, node, promise, then;
+
+// modern engines have queueMicrotask method
+if (!queueMicrotask) {
+  flush = function () {
+    var parent, fn;
+    if (IS_NODE && (parent = process.domain)) parent.exit();
+    while (head) {
+      fn = head.fn;
+      head = head.next;
+      try {
+        fn();
+      } catch (error) {
+        if (head) notify();
+        else last = undefined;
+        throw error;
+      }
+    } last = undefined;
+    if (parent) parent.enter();
+  };
+
+  // browsers with MutationObserver, except iOS - https://github.com/zloirock/core-js/issues/339
+  // also except WebOS Webkit https://github.com/zloirock/core-js/issues/898
+  if (!IS_IOS && !IS_NODE && !IS_WEBOS_WEBKIT && MutationObserver && document) {
+    toggle = true;
+    node = document.createTextNode('');
+    new MutationObserver(flush).observe(node, { characterData: true });
+    notify = function () {
+      node.data = toggle = !toggle;
+    };
+  // environments with maybe non-completely correct, but existent Promise
+  } else if (!IS_IOS_PEBBLE && Promise && Promise.resolve) {
+    // Promise.resolve without an argument throws an error in LG WebOS 2
+    promise = Promise.resolve(undefined);
+    // workaround of WebKit ~ iOS Safari 10.1 bug
+    promise.constructor = Promise;
+    then = promise.then;
+    notify = function () {
+      then.call(promise, flush);
+    };
+  // Node.js without promises
+  } else if (IS_NODE) {
+    notify = function () {
+      process.nextTick(flush);
+    };
+  // for other environments - macrotask based on:
+  // - setImmediate
+  // - MessageChannel
+  // - window.postMessag
+  // - onreadystatechange
+  // - setTimeout
+  } else {
+    notify = function () {
+      // strange IE + webpack dev server bug - use .call(global)
+      macrotask.call(global, flush);
+    };
+  }
+}
+
+module.exports = queueMicrotask || function (fn) {
+  var task = { fn: fn, next: undefined };
+  if (last) last.next = task;
+  if (!head) {
+    head = task;
+    notify();
+  } last = task;
+};
+
+
+/***/ }),
+
+/***/ 6838:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var global = __webpack_require__(6874);
+
+module.exports = global.Promise;
+
+
+/***/ }),
+
+/***/ 1453:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+/* eslint-disable es/no-symbol -- required for testing */
+var V8_VERSION = __webpack_require__(579);
+var fails = __webpack_require__(7841);
+
+// eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing
+module.exports = !!Object.getOwnPropertySymbols && !fails(function () {
+  var symbol = Symbol();
+  // Chrome 38 Symbol has incorrect toString conversion
+  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances
+  return !String(symbol) || !(Object(symbol) instanceof Symbol) ||
+    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
+    !Symbol.sham && V8_VERSION && V8_VERSION < 41;
+});
+
+
+/***/ }),
+
+/***/ 1781:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var fails = __webpack_require__(7841);
+var wellKnownSymbol = __webpack_require__(3706);
+var IS_PURE = __webpack_require__(6852);
+
+var ITERATOR = wellKnownSymbol('iterator');
+
+module.exports = !fails(function () {
+  var url = new URL('b?a=1&b=2&c=3', 'http://a');
+  var searchParams = url.searchParams;
+  var result = '';
+  url.pathname = 'c%20d';
+  searchParams.forEach(function (value, key) {
+    searchParams['delete']('b');
+    result += key + value;
+  });
+  return (IS_PURE && !url.toJSON)
+    || !searchParams.sort
+    || url.href !== 'http://a/c%20d?a=1&c=3'
+    || searchParams.get('c') !== '3'
+    || String(new URLSearchParams('?a=1')) !== 'a=1'
+    || !searchParams[ITERATOR]
+    // throws in Edge
+    || new URL('https://a@b').username !== 'a'
+    || new URLSearchParams(new URLSearchParams('a=b')).get('a') !== 'b'
+    // not punycoded in Edge
+    || new URL('http://').host !== 'xn--e1aybc'
+    // not escaped in Chrome 62-
+    || new URL('http://a#').hash !== '#%D0%B1'
+    // fails in Chrome 66-
+    || result !== 'a1c3'
+    // throws in Safari
+    || new URL('http://x', undefined).host !== 'x';
+});
+
+
+/***/ }),
+
+/***/ 9957:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var global = __webpack_require__(6874);
+var inspectSource = __webpack_require__(6090);
+
+var WeakMap = global.WeakMap;
+
+module.exports = typeof WeakMap === 'function' && /native code/.test(inspectSource(WeakMap));
+
+
+/***/ }),
+
+/***/ 7529:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+
+var aFunction = __webpack_require__(769);
+
+var PromiseCapability = function (C) {
+  var resolve, reject;
+  this.promise = new C(function ($$resolve, $$reject) {
+    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
+    resolve = $$resolve;
+    reject = $$reject;
+  });
+  this.resolve = aFunction(resolve);
+  this.reject = aFunction(reject);
+};
+
+// `NewPromiseCapability` abstract operation
+// https://tc39.es/ecma262/#sec-newpromisecapability
+module.exports.f = function (C) {
+  return new PromiseCapability(C);
+};
+
+
+/***/ }),
+
+/***/ 4315:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var isRegExp = __webpack_require__(2399);
+
+module.exports = function (it) {
+  if (isRegExp(it)) {
+    throw TypeError("The method doesn't accept regular expressions");
+  } return it;
+};
+
+
+/***/ }),
+
+/***/ 5277:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+
+var DESCRIPTORS = __webpack_require__(5542);
+var fails = __webpack_require__(7841);
+var objectKeys = __webpack_require__(965);
+var getOwnPropertySymbolsModule = __webpack_require__(1913);
+var propertyIsEnumerableModule = __webpack_require__(3626);
+var toObject = __webpack_require__(4680);
+var IndexedObject = __webpack_require__(7361);
+
+// eslint-disable-next-line es/no-object-assign -- safe
+var $assign = Object.assign;
+// eslint-disable-next-line es/no-object-defineproperty -- required for testing
+var defineProperty = Object.defineProperty;
+
+// `Object.assign` method
+// https://tc39.es/ecma262/#sec-object.assign
+module.exports = !$assign || fails(function () {
+  // should have correct order of operations (Edge bug)
+  if (DESCRIPTORS && $assign({ b: 1 }, $assign(defineProperty({}, 'a', {
+    enumerable: true,
+    get: function () {
+      defineProperty(this, 'b', {
+        value: 3,
+        enumerable: false
+      });
+    }
+  }), { b: 2 })).b !== 1) return true;
+  // should work with symbols and should have deterministic property order (V8 bug)
+  var A = {};
+  var B = {};
+  // eslint-disable-next-line es/no-symbol -- safe
+  var symbol = Symbol();
+  var alphabet = 'abcdefghijklmnopqrst';
+  A[symbol] = 7;
+  alphabet.split('').forEach(function (chr) { B[chr] = chr; });
+  return $assign({}, A)[symbol] != 7 || objectKeys($assign({}, B)).join('') != alphabet;
+}) ? function assign(target, source) { // eslint-disable-line no-unused-vars -- required for `.length`
+  var T = toObject(target);
+  var argumentsLength = arguments.length;
+  var index = 1;
+  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
+  var propertyIsEnumerable = propertyIsEnumerableModule.f;
+  while (argumentsLength > index) {
+    var S = IndexedObject(arguments[index++]);
+    var keys = getOwnPropertySymbols ? objectKeys(S).concat(getOwnPropertySymbols(S)) : objectKeys(S);
+    var length = keys.length;
+    var j = 0;
+    var key;
+    while (length > j) {
+      key = keys[j++];
+      if (!DESCRIPTORS || propertyIsEnumerable.call(S, key)) T[key] = S[key];
+    }
+  } return T;
+} : $assign;
+
+
+/***/ }),
+
+/***/ 2361:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+/* global ActiveXObject -- old IE, WSH */
+var anObject = __webpack_require__(47);
+var defineProperties = __webpack_require__(7852);
+var enumBugKeys = __webpack_require__(9752);
+var hiddenKeys = __webpack_require__(5644);
+var html = __webpack_require__(7666);
+var documentCreateElement = __webpack_require__(3879);
+var sharedKey = __webpack_require__(8698);
+
+var GT = '>';
+var LT = '<';
+var PROTOTYPE = 'prototype';
+var SCRIPT = 'script';
+var IE_PROTO = sharedKey('IE_PROTO');
+
+var EmptyConstructor = function () { /* empty */ };
+
+var scriptTag = function (content) {
+  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
+};
+
+// Create object with fake `null` prototype: use ActiveX Object with cleared prototype
+var NullProtoObjectViaActiveX = function (activeXDocument) {
+  activeXDocument.write(scriptTag(''));
+  activeXDocument.close();
+  var temp = activeXDocument.parentWindow.Object;
+  activeXDocument = null; // avoid memory leak
+  return temp;
+};
+
+// Create object with fake `null` prototype: use iframe Object with cleared prototype
+var NullProtoObjectViaIFrame = function () {
+  // Thrash, waste and sodomy: IE GC bug
+  var iframe = documentCreateElement('iframe');
+  var JS = 'java' + SCRIPT + ':';
+  var iframeDocument;
+  iframe.style.display = 'none';
+  html.appendChild(iframe);
+  // https://github.com/zloirock/core-js/issues/475
+  iframe.src = String(JS);
+  iframeDocument = iframe.contentWindow.document;
+  iframeDocument.open();
+  iframeDocument.write(scriptTag('document.F=Object'));
+  iframeDocument.close();
+  return iframeDocument.F;
+};
+
+// Check for document.domain and active x support
+// No need to use active x approach when document.domain is not set
+// see https://github.com/es-shims/es5-shim/issues/150
+// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
+// avoid IE GC bug
+var activeXDocument;
+var NullProtoObject = function () {
+  try {
+    activeXDocument = new ActiveXObject('htmlfile');
+  } catch (error) { /* ignore */ }
+  NullProtoObject = typeof document != 'undefined'
+    ? document.domain && activeXDocument
+      ? NullProtoObjectViaActiveX(activeXDocument) // old IE
+      : NullProtoObjectViaIFrame()
+    : NullProtoObjectViaActiveX(activeXDocument); // WSH
+  var length = enumBugKeys.length;
+  while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
+  return NullProtoObject();
+};
+
+hiddenKeys[IE_PROTO] = true;
+
+// `Object.create` method
+// https://tc39.es/ecma262/#sec-object.create
+module.exports = Object.create || function create(O, Properties) {
+  var result;
+  if (O !== null) {
+    EmptyConstructor[PROTOTYPE] = anObject(O);
+    result = new EmptyConstructor();
+    EmptyConstructor[PROTOTYPE] = null;
+    // add "__proto__" for Object.getPrototypeOf polyfill
+    result[IE_PROTO] = O;
+  } else result = NullProtoObject();
+  return Properties === undefined ? result : defineProperties(result, Properties);
+};
+
+
+/***/ }),
+
+/***/ 7852:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var DESCRIPTORS = __webpack_require__(5542);
+var definePropertyModule = __webpack_require__(3376);
+var anObject = __webpack_require__(47);
+var objectKeys = __webpack_require__(965);
+
+// `Object.defineProperties` method
+// https://tc39.es/ecma262/#sec-object.defineproperties
+// eslint-disable-next-line es/no-object-defineproperties -- safe
+module.exports = DESCRIPTORS ? Object.defineProperties : function defineProperties(O, Properties) {
+  anObject(O);
+  var keys = objectKeys(Properties);
+  var length = keys.length;
+  var index = 0;
+  var key;
+  while (length > index) definePropertyModule.f(O, key = keys[index++], Properties[key]);
+  return O;
+};
+
+
+/***/ }),
+
+/***/ 3376:
+/***/ ((__unused_webpack_module, exports, __webpack_require__) => {
+
+var DESCRIPTORS = __webpack_require__(5542);
+var IE8_DOM_DEFINE = __webpack_require__(6056);
+var anObject = __webpack_require__(47);
+var toPropertyKey = __webpack_require__(2694);
+
+// eslint-disable-next-line es/no-object-defineproperty -- safe
+var $defineProperty = Object.defineProperty;
+
+// `Object.defineProperty` method
+// https://tc39.es/ecma262/#sec-object.defineproperty
+exports.f = DESCRIPTORS ? $defineProperty : function defineProperty(O, P, Attributes) {
+  anObject(O);
+  P = toPropertyKey(P);
+  anObject(Attributes);
+  if (IE8_DOM_DEFINE) try {
+    return $defineProperty(O, P, Attributes);
+  } catch (error) { /* empty */ }
+  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');
+  if ('value' in Attributes) O[P] = Attributes.value;
+  return O;
+};
+
+
+/***/ }),
+
+/***/ 7825:
+/***/ ((__unused_webpack_module, exports, __webpack_require__) => {
+
+var DESCRIPTORS = __webpack_require__(5542);
+var propertyIsEnumerableModule = __webpack_require__(3626);
+var createPropertyDescriptor = __webpack_require__(976);
+var toIndexedObject = __webpack_require__(8852);
+var toPropertyKey = __webpack_require__(2694);
+var has = __webpack_require__(5884);
+var IE8_DOM_DEFINE = __webpack_require__(6056);
+
+// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
+var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
+
+// `Object.getOwnPropertyDescriptor` method
+// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
+exports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
+  O = toIndexedObject(O);
+  P = toPropertyKey(P);
+  if (IE8_DOM_DEFINE) try {
+    return $getOwnPropertyDescriptor(O, P);
+  } catch (error) { /* empty */ }
+  if (has(O, P)) return createPropertyDescriptor(!propertyIsEnumerableModule.f.call(O, P), O[P]);
+};
+
+
+/***/ }),
+
+/***/ 3866:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+/* eslint-disable es/no-object-getownpropertynames -- safe */
+var toIndexedObject = __webpack_require__(8852);
+var $getOwnPropertyNames = __webpack_require__(8401).f;
+
+var toString = {}.toString;
+
+var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
+  ? Object.getOwnPropertyNames(window) : [];
+
+var getWindowNames = function (it) {
+  try {
+    return $getOwnPropertyNames(it);
+  } catch (error) {
+    return windowNames.slice();
+  }
+};
+
+// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
+module.exports.f = function getOwnPropertyNames(it) {
+  return windowNames && toString.call(it) == '[object Window]'
+    ? getWindowNames(it)
+    : $getOwnPropertyNames(toIndexedObject(it));
+};
+
+
+/***/ }),
+
+/***/ 8401:
+/***/ ((__unused_webpack_module, exports, __webpack_require__) => {
+
+var internalObjectKeys = __webpack_require__(8104);
+var enumBugKeys = __webpack_require__(9752);
+
+var hiddenKeys = enumBugKeys.concat('length', 'prototype');
+
+// `Object.getOwnPropertyNames` method
+// https://tc39.es/ecma262/#sec-object.getownpropertynames
+// eslint-disable-next-line es/no-object-getownpropertynames -- safe
+exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
+  return internalObjectKeys(O, hiddenKeys);
+};
+
+
+/***/ }),
+
+/***/ 1913:
+/***/ ((__unused_webpack_module, exports) => {
+
+// eslint-disable-next-line es/no-object-getownpropertysymbols -- safe
+exports.f = Object.getOwnPropertySymbols;
+
+
+/***/ }),
+
+/***/ 8186:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var has = __webpack_require__(5884);
+var toObject = __webpack_require__(4680);
+var sharedKey = __webpack_require__(8698);
+var CORRECT_PROTOTYPE_GETTER = __webpack_require__(9241);
+
+var IE_PROTO = sharedKey('IE_PROTO');
+var ObjectPrototype = Object.prototype;
+
+// `Object.getPrototypeOf` method
+// https://tc39.es/ecma262/#sec-object.getprototypeof
+// eslint-disable-next-line es/no-object-getprototypeof -- safe
+module.exports = CORRECT_PROTOTYPE_GETTER ? Object.getPrototypeOf : function (O) {
+  O = toObject(O);
+  if (has(O, IE_PROTO)) return O[IE_PROTO];
+  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
+    return O.constructor.prototype;
+  } return O instanceof Object ? ObjectPrototype : null;
+};
+
+
+/***/ }),
+
+/***/ 8104:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var has = __webpack_require__(5884);
+var toIndexedObject = __webpack_require__(8852);
+var indexOf = __webpack_require__(1270).indexOf;
+var hiddenKeys = __webpack_require__(5644);
+
+module.exports = function (object, names) {
+  var O = toIndexedObject(object);
+  var i = 0;
+  var result = [];
+  var key;
+  for (key in O) !has(hiddenKeys, key) && has(O, key) && result.push(key);
+  // Don't enum bug & hidden keys
+  while (names.length > i) if (has(O, key = names[i++])) {
+    ~indexOf(result, key) || result.push(key);
+  }
+  return result;
+};
+
+
+/***/ }),
+
+/***/ 965:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var internalObjectKeys = __webpack_require__(8104);
+var enumBugKeys = __webpack_require__(9752);
+
+// `Object.keys` method
+// https://tc39.es/ecma262/#sec-object.keys
+// eslint-disable-next-line es/no-object-keys -- safe
+module.exports = Object.keys || function keys(O) {
+  return internalObjectKeys(O, enumBugKeys);
+};
+
+
+/***/ }),
+
+/***/ 3626:
+/***/ ((__unused_webpack_module, exports) => {
+
+"use strict";
+
+var $propertyIsEnumerable = {}.propertyIsEnumerable;
+// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
+var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
+
+// Nashorn ~ JDK8 bug
+var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);
+
+// `Object.prototype.propertyIsEnumerable` method implementation
+// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable
+exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
+  var descriptor = getOwnPropertyDescriptor(this, V);
+  return !!descriptor && descriptor.enumerable;
+} : $propertyIsEnumerable;
+
+
+/***/ }),
+
+/***/ 2686:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+/* eslint-disable no-proto -- safe */
+var anObject = __webpack_require__(47);
+var aPossiblePrototype = __webpack_require__(8143);
+
+// `Object.setPrototypeOf` method
+// https://tc39.es/ecma262/#sec-object.setprototypeof
+// Works with __proto__ only. Old v8 can't work with null proto objects.
+// eslint-disable-next-line es/no-object-setprototypeof -- safe
+module.exports = Object.setPrototypeOf || ('__proto__' in {} ? function () {
+  var CORRECT_SETTER = false;
+  var test = {};
+  var setter;
+  try {
+    // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
+    setter = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set;
+    setter.call(test, []);
+    CORRECT_SETTER = test instanceof Array;
+  } catch (error) { /* empty */ }
+  return function setPrototypeOf(O, proto) {
+    anObject(O);
+    aPossiblePrototype(proto);
+    if (CORRECT_SETTER) setter.call(O, proto);
+    else O.__proto__ = proto;
+    return O;
+  };
+}() : undefined);
+
+
+/***/ }),
+
+/***/ 8686:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var DESCRIPTORS = __webpack_require__(5542);
+var objectKeys = __webpack_require__(965);
+var toIndexedObject = __webpack_require__(8852);
+var propertyIsEnumerable = __webpack_require__(3626).f;
+
+// `Object.{ entries, values }` methods implementation
+var createMethod = function (TO_ENTRIES) {
+  return function (it) {
+    var O = toIndexedObject(it);
+    var keys = objectKeys(O);
+    var length = keys.length;
+    var i = 0;
+    var result = [];
+    var key;
+    while (length > i) {
+      key = keys[i++];
+      if (!DESCRIPTORS || propertyIsEnumerable.call(O, key)) {
+        result.push(TO_ENTRIES ? [key, O[key]] : O[key]);
+      }
+    }
+    return result;
+  };
+};
+
+module.exports = {
+  // `Object.entries` method
+  // https://tc39.es/ecma262/#sec-object.entries
+  entries: createMethod(true),
+  // `Object.values` method
+  // https://tc39.es/ecma262/#sec-object.values
+  values: createMethod(false)
+};
+
+
+/***/ }),
+
+/***/ 1851:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+
+var TO_STRING_TAG_SUPPORT = __webpack_require__(939);
+var classof = __webpack_require__(8753);
+
+// `Object.prototype.toString` method implementation
+// https://tc39.es/ecma262/#sec-object.prototype.tostring
+module.exports = TO_STRING_TAG_SUPPORT ? {}.toString : function toString() {
+  return '[object ' + classof(this) + ']';
+};
+
+
+/***/ }),
+
+/***/ 2392:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var isObject = __webpack_require__(6944);
+
+// `OrdinaryToPrimitive` abstract operation
+// https://tc39.es/ecma262/#sec-ordinarytoprimitive
+module.exports = function (input, pref) {
+  var fn, val;
+  if (pref === 'string' && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
+  if (typeof (fn = input.valueOf) == 'function' && !isObject(val = fn.call(input))) return val;
+  if (pref !== 'string' && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
+  throw TypeError("Can't convert object to primitive value");
+};
+
+
+/***/ }),
+
+/***/ 8204:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var getBuiltIn = __webpack_require__(4578);
+var getOwnPropertyNamesModule = __webpack_require__(8401);
+var getOwnPropertySymbolsModule = __webpack_require__(1913);
+var anObject = __webpack_require__(47);
+
+// all object keys, includes non-enumerable and symbols
+module.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
+  var keys = getOwnPropertyNamesModule.f(anObject(it));
+  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
+  return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;
+};
+
+
+/***/ }),
+
+/***/ 2067:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var global = __webpack_require__(6874);
+
+module.exports = global;
+
+
+/***/ }),
+
+/***/ 7105:
+/***/ ((module) => {
+
+module.exports = function (exec) {
+  try {
+    return { error: false, value: exec() };
+  } catch (error) {
+    return { error: true, value: error };
+  }
+};
+
+
+/***/ }),
+
+/***/ 4022:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var anObject = __webpack_require__(47);
+var isObject = __webpack_require__(6944);
+var newPromiseCapability = __webpack_require__(7529);
+
+module.exports = function (C, x) {
+  anObject(C);
+  if (isObject(x) && x.constructor === C) return x;
+  var promiseCapability = newPromiseCapability.f(C);
+  var resolve = promiseCapability.resolve;
+  resolve(x);
+  return promiseCapability.promise;
+};
+
+
+/***/ }),
+
+/***/ 7490:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var redefine = __webpack_require__(1249);
+
+module.exports = function (target, src, options) {
+  for (var key in src) redefine(target, key, src[key], options);
+  return target;
+};
+
+
+/***/ }),
+
+/***/ 1249:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var global = __webpack_require__(6874);
+var createNonEnumerableProperty = __webpack_require__(4791);
+var has = __webpack_require__(5884);
+var setGlobal = __webpack_require__(1278);
+var inspectSource = __webpack_require__(6090);
+var InternalStateModule = __webpack_require__(6619);
+
+var getInternalState = InternalStateModule.get;
+var enforceInternalState = InternalStateModule.enforce;
+var TEMPLATE = String(String).split('String');
+
+(module.exports = function (O, key, value, options) {
+  var unsafe = options ? !!options.unsafe : false;
+  var simple = options ? !!options.enumerable : false;
+  var noTargetGet = options ? !!options.noTargetGet : false;
+  var state;
+  if (typeof value == 'function') {
+    if (typeof key == 'string' && !has(value, 'name')) {
+      createNonEnumerableProperty(value, 'name', key);
+    }
+    state = enforceInternalState(value);
+    if (!state.source) {
+      state.source = TEMPLATE.join(typeof key == 'string' ? key : '');
+    }
+  }
+  if (O === global) {
+    if (simple) O[key] = value;
+    else setGlobal(key, value);
+    return;
+  } else if (!unsafe) {
+    delete O[key];
+  } else if (!noTargetGet && O[key]) {
+    simple = true;
+  }
+  if (simple) O[key] = value;
+  else createNonEnumerableProperty(O, key, value);
+// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
+})(Function.prototype, 'toString', function toString() {
+  return typeof this == 'function' && getInternalState(this).source || inspectSource(this);
+});
+
+
+/***/ }),
+
+/***/ 3915:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var classof = __webpack_require__(3565);
+var regexpExec = __webpack_require__(1144);
+
+// `RegExpExec` abstract operation
+// https://tc39.es/ecma262/#sec-regexpexec
+module.exports = function (R, S) {
+  var exec = R.exec;
+  if (typeof exec === 'function') {
+    var result = exec.call(R, S);
+    if (typeof result !== 'object') {
+      throw TypeError('RegExp exec method returned something other than an Object or null');
+    }
+    return result;
+  }
+
+  if (classof(R) !== 'RegExp') {
+    throw TypeError('RegExp#exec called on incompatible receiver');
+  }
+
+  return regexpExec.call(R, S);
+};
+
+
+
+/***/ }),
+
+/***/ 1144:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+
+/* eslint-disable regexp/no-empty-capturing-group, regexp/no-empty-group, regexp/no-lazy-ends -- testing */
+/* eslint-disable regexp/no-useless-quantifier -- testing */
+var toString = __webpack_require__(401);
+var regexpFlags = __webpack_require__(9262);
+var stickyHelpers = __webpack_require__(768);
+var shared = __webpack_require__(3215);
+var create = __webpack_require__(2361);
+var getInternalState = __webpack_require__(6619).get;
+var UNSUPPORTED_DOT_ALL = __webpack_require__(1972);
+var UNSUPPORTED_NCG = __webpack_require__(5876);
+
+var nativeExec = RegExp.prototype.exec;
+var nativeReplace = shared('native-string-replace', String.prototype.replace);
+
+var patchedExec = nativeExec;
+
+var UPDATES_LAST_INDEX_WRONG = (function () {
+  var re1 = /a/;
+  var re2 = /b*/g;
+  nativeExec.call(re1, 'a');
+  nativeExec.call(re2, 'a');
+  return re1.lastIndex !== 0 || re2.lastIndex !== 0;
+})();
+
+var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y || stickyHelpers.BROKEN_CARET;
+
+// nonparticipating capturing group, copied from es5-shim's String#split patch.
+var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;
+
+var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y || UNSUPPORTED_DOT_ALL || UNSUPPORTED_NCG;
+
+if (PATCH) {
+  // eslint-disable-next-line max-statements -- TODO
+  patchedExec = function exec(string) {
+    var re = this;
+    var state = getInternalState(re);
+    var str = toString(string);
+    var raw = state.raw;
+    var result, reCopy, lastIndex, match, i, object, group;
+
+    if (raw) {
+      raw.lastIndex = re.lastIndex;
+      result = patchedExec.call(raw, str);
+      re.lastIndex = raw.lastIndex;
+      return result;
+    }
+
+    var groups = state.groups;
+    var sticky = UNSUPPORTED_Y && re.sticky;
+    var flags = regexpFlags.call(re);
+    var source = re.source;
+    var charsAdded = 0;
+    var strCopy = str;
+
+    if (sticky) {
+      flags = flags.replace('y', '');
+      if (flags.indexOf('g') === -1) {
+        flags += 'g';
+      }
+
+      strCopy = str.slice(re.lastIndex);
+      // Support anchored sticky behavior.
+      if (re.lastIndex > 0 && (!re.multiline || re.multiline && str.charAt(re.lastIndex - 1) !== '\n')) {
+        source = '(?: ' + source + ')';
+        strCopy = ' ' + strCopy;
+        charsAdded++;
+      }
+      // ^(? + rx + ) is needed, in combination with some str slicing, to
+      // simulate the 'y' flag.
+      reCopy = new RegExp('^(?:' + source + ')', flags);
+    }
+
+    if (NPCG_INCLUDED) {
+      reCopy = new RegExp('^' + source + '$(?!\\s)', flags);
+    }
+    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex;
+
+    match = nativeExec.call(sticky ? reCopy : re, strCopy);
+
+    if (sticky) {
+      if (match) {
+        match.input = match.input.slice(charsAdded);
+        match[0] = match[0].slice(charsAdded);
+        match.index = re.lastIndex;
+        re.lastIndex += match[0].length;
+      } else re.lastIndex = 0;
+    } else if (UPDATES_LAST_INDEX_WRONG && match) {
+      re.lastIndex = re.global ? match.index + match[0].length : lastIndex;
+    }
+    if (NPCG_INCLUDED && match && match.length > 1) {
+      // Fix browsers whose `exec` methods don't consistently return `undefined`
+      // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
+      nativeReplace.call(match[0], reCopy, function () {
+        for (i = 1; i < arguments.length - 2; i++) {
+          if (arguments[i] === undefined) match[i] = undefined;
+        }
+      });
+    }
+
+    if (match && groups) {
+      match.groups = object = create(null);
+      for (i = 0; i < groups.length; i++) {
+        group = groups[i];
+        object[group[0]] = match[group[1]];
+      }
+    }
+
+    return match;
+  };
+}
+
+module.exports = patchedExec;
+
+
+/***/ }),
+
+/***/ 9262:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+
+var anObject = __webpack_require__(47);
+
+// `RegExp.prototype.flags` getter implementation
+// https://tc39.es/ecma262/#sec-get-regexp.prototype.flags
+module.exports = function () {
+  var that = anObject(this);
+  var result = '';
+  if (that.global) result += 'g';
+  if (that.ignoreCase) result += 'i';
+  if (that.multiline) result += 'm';
+  if (that.dotAll) result += 's';
+  if (that.unicode) result += 'u';
+  if (that.sticky) result += 'y';
+  return result;
+};
+
+
+/***/ }),
+
+/***/ 768:
+/***/ ((__unused_webpack_module, exports, __webpack_require__) => {
+
+var fails = __webpack_require__(7841);
+var global = __webpack_require__(6874);
+
+// babel-minify and Closure Compiler transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError
+var $RegExp = global.RegExp;
+
+exports.UNSUPPORTED_Y = fails(function () {
+  var re = $RegExp('a', 'y');
+  re.lastIndex = 2;
+  return re.exec('abcd') != null;
+});
+
+exports.BROKEN_CARET = fails(function () {
+  // https://bugzilla.mozilla.org/show_bug.cgi?id=773687
+  var re = $RegExp('^r', 'gy');
+  re.lastIndex = 2;
+  return re.exec('str') != null;
+});
+
+
+/***/ }),
+
+/***/ 1972:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var fails = __webpack_require__(7841);
+var global = __webpack_require__(6874);
+
+// babel-minify and Closure Compiler transpiles RegExp('.', 's') -> /./s and it causes SyntaxError
+var $RegExp = global.RegExp;
+
+module.exports = fails(function () {
+  var re = $RegExp('.', 's');
+  return !(re.dotAll && re.exec('\n') && re.flags === 's');
+});
+
+
+/***/ }),
+
+/***/ 5876:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var fails = __webpack_require__(7841);
+var global = __webpack_require__(6874);
+
+// babel-minify and Closure Compiler transpiles RegExp('(?<a>b)', 'g') -> /(?<a>b)/g and it causes SyntaxError
+var $RegExp = global.RegExp;
+
+module.exports = fails(function () {
+  var re = $RegExp('(?<a>b)', 'g');
+  return re.exec('b').groups.a !== 'b' ||
+    'b'.replace(re, '$<a>c') !== 'bc';
+});
+
+
+/***/ }),
+
+/***/ 164:
+/***/ ((module) => {
+
+// `RequireObjectCoercible` abstract operation
+// https://tc39.es/ecma262/#sec-requireobjectcoercible
+module.exports = function (it) {
+  if (it == undefined) throw TypeError("Can't call method on " + it);
+  return it;
+};
+
+
+/***/ }),
+
+/***/ 1278:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var global = __webpack_require__(6874);
+
+module.exports = function (key, value) {
+  try {
+    // eslint-disable-next-line es/no-object-defineproperty -- safe
+    Object.defineProperty(global, key, { value: value, configurable: true, writable: true });
+  } catch (error) {
+    global[key] = value;
+  } return value;
+};
+
+
+/***/ }),
+
+/***/ 8802:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+
+var getBuiltIn = __webpack_require__(4578);
+var definePropertyModule = __webpack_require__(3376);
+var wellKnownSymbol = __webpack_require__(3706);
+var DESCRIPTORS = __webpack_require__(5542);
+
+var SPECIES = wellKnownSymbol('species');
+
+module.exports = function (CONSTRUCTOR_NAME) {
+  var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
+  var defineProperty = definePropertyModule.f;
+
+  if (DESCRIPTORS && Constructor && !Constructor[SPECIES]) {
+    defineProperty(Constructor, SPECIES, {
+      configurable: true,
+      get: function () { return this; }
+    });
+  }
+};
+
+
+/***/ }),
+
+/***/ 9400:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var defineProperty = __webpack_require__(3376).f;
+var has = __webpack_require__(5884);
+var wellKnownSymbol = __webpack_require__(3706);
+
+var TO_STRING_TAG = wellKnownSymbol('toStringTag');
+
+module.exports = function (it, TAG, STATIC) {
+  if (it && !has(it = STATIC ? it : it.prototype, TO_STRING_TAG)) {
+    defineProperty(it, TO_STRING_TAG, { configurable: true, value: TAG });
+  }
+};
+
+
+/***/ }),
+
+/***/ 8698:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var shared = __webpack_require__(3215);
+var uid = __webpack_require__(8435);
+
+var keys = shared('keys');
+
+module.exports = function (key) {
+  return keys[key] || (keys[key] = uid(key));
+};
+
+
+/***/ }),
+
+/***/ 4925:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var global = __webpack_require__(6874);
+var setGlobal = __webpack_require__(1278);
+
+var SHARED = '__core-js_shared__';
+var store = global[SHARED] || setGlobal(SHARED, {});
+
+module.exports = store;
+
+
+/***/ }),
+
+/***/ 3215:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var IS_PURE = __webpack_require__(6852);
+var store = __webpack_require__(4925);
+
+(module.exports = function (key, value) {
+  return store[key] || (store[key] = value !== undefined ? value : {});
+})('versions', []).push({
+  version: '3.16.2',
+  mode: IS_PURE ? 'pure' : 'global',
+  copyright: ' 2021 Denis Pushkarev (zloirock.ru)'
+});
+
+
+/***/ }),
+
+/***/ 2004:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var anObject = __webpack_require__(47);
+var aFunction = __webpack_require__(769);
+var wellKnownSymbol = __webpack_require__(3706);
+
+var SPECIES = wellKnownSymbol('species');
+
+// `SpeciesConstructor` abstract operation
+// https://tc39.es/ecma262/#sec-speciesconstructor
+module.exports = function (O, defaultConstructor) {
+  var C = anObject(O).constructor;
+  var S;
+  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? defaultConstructor : aFunction(S);
+};
+
+
+/***/ }),
+
+/***/ 6174:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var toInteger = __webpack_require__(7896);
+var toString = __webpack_require__(401);
+var requireObjectCoercible = __webpack_require__(164);
+
+// `String.prototype.codePointAt` methods implementation
+var createMethod = function (CONVERT_TO_STRING) {
+  return function ($this, pos) {
+    var S = toString(requireObjectCoercible($this));
+    var position = toInteger(pos);
+    var size = S.length;
+    var first, second;
+    if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
+    first = S.charCodeAt(position);
+    return first < 0xD800 || first > 0xDBFF || position + 1 === size
+      || (second = S.charCodeAt(position + 1)) < 0xDC00 || second > 0xDFFF
+        ? CONVERT_TO_STRING ? S.charAt(position) : first
+        : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
+  };
+};
+
+module.exports = {
+  // `String.prototype.codePointAt` method
+  // https://tc39.es/ecma262/#sec-string.prototype.codepointat
+  codeAt: createMethod(false),
+  // `String.prototype.at` method
+  // https://github.com/mathiasbynens/String.prototype.at
+  charAt: createMethod(true)
+};
+
+
+/***/ }),
+
+/***/ 4931:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+// https://github.com/zloirock/core-js/issues/280
+var userAgent = __webpack_require__(4229);
+
+// eslint-disable-next-line unicorn/no-unsafe-regex -- safe
+module.exports = /Version\/10(?:\.\d+){1,2}(?: [\w./]+)?(?: Mobile\/\w+)? Safari\//.test(userAgent);
+
+
+/***/ }),
+
+/***/ 9534:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+// https://github.com/tc39/proposal-string-pad-start-end
+var toLength = __webpack_require__(4954);
+var toString = __webpack_require__(401);
+var repeat = __webpack_require__(6640);
+var requireObjectCoercible = __webpack_require__(164);
+
+var ceil = Math.ceil;
+
+// `String.prototype.{ padStart, padEnd }` methods implementation
+var createMethod = function (IS_END) {
+  return function ($this, maxLength, fillString) {
+    var S = toString(requireObjectCoercible($this));
+    var stringLength = S.length;
+    var fillStr = fillString === undefined ? ' ' : toString(fillString);
+    var intMaxLength = toLength(maxLength);
+    var fillLen, stringFiller;
+    if (intMaxLength <= stringLength || fillStr == '') return S;
+    fillLen = intMaxLength - stringLength;
+    stringFiller = repeat.call(fillStr, ceil(fillLen / fillStr.length));
+    if (stringFiller.length > fillLen) stringFiller = stringFiller.slice(0, fillLen);
+    return IS_END ? S + stringFiller : stringFiller + S;
+  };
+};
+
+module.exports = {
+  // `String.prototype.padStart` method
+  // https://tc39.es/ecma262/#sec-string.prototype.padstart
+  start: createMethod(false),
+  // `String.prototype.padEnd` method
+  // https://tc39.es/ecma262/#sec-string.prototype.padend
+  end: createMethod(true)
+};
+
+
+/***/ }),
+
+/***/ 8:
+/***/ ((module) => {
+
+"use strict";
+
+// based on https://github.com/bestiejs/punycode.js/blob/master/punycode.js
+var maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1
+var base = 36;
+var tMin = 1;
+var tMax = 26;
+var skew = 38;
+var damp = 700;
+var initialBias = 72;
+var initialN = 128; // 0x80
+var delimiter = '-'; // '\x2D'
+var regexNonASCII = /[^\0-\u007E]/; // non-ASCII chars
+var regexSeparators = /[.\u3002\uFF0E\uFF61]/g; // RFC 3490 separators
+var OVERFLOW_ERROR = 'Overflow: input needs wider integers to process';
+var baseMinusTMin = base - tMin;
+var floor = Math.floor;
+var stringFromCharCode = String.fromCharCode;
+
+/**
+ * Creates an array containing the numeric code points of each Unicode
+ * character in the string. While JavaScript uses UCS-2 internally,
+ * this function will convert a pair of surrogate halves (each of which
+ * UCS-2 exposes as separate characters) into a single code point,
+ * matching UTF-16.
+ */
+var ucs2decode = function (string) {
+  var output = [];
+  var counter = 0;
+  var length = string.length;
+  while (counter < length) {
+    var value = string.charCodeAt(counter++);
+    if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
+      // It's a high surrogate, and there is a next character.
+      var extra = string.charCodeAt(counter++);
+      if ((extra & 0xFC00) == 0xDC00) { // Low surrogate.
+        output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
+      } else {
+        // It's an unmatched surrogate; only append this code unit, in case the
+        // next code unit is the high surrogate of a surrogate pair.
+        output.push(value);
+        counter--;
+      }
+    } else {
+      output.push(value);
+    }
+  }
+  return output;
+};
+
+/**
+ * Converts a digit/integer into a basic code point.
+ */
+var digitToBasic = function (digit) {
+  //  0..25 map to ASCII a..z or A..Z
+  // 26..35 map to ASCII 0..9
+  return digit + 22 + 75 * (digit < 26);
+};
+
+/**
+ * Bias adaptation function as per section 3.4 of RFC 3492.
+ * https://tools.ietf.org/html/rfc3492#section-3.4
+ */
+var adapt = function (delta, numPoints, firstTime) {
+  var k = 0;
+  delta = firstTime ? floor(delta / damp) : delta >> 1;
+  delta += floor(delta / numPoints);
+  for (; delta > baseMinusTMin * tMax >> 1; k += base) {
+    delta = floor(delta / baseMinusTMin);
+  }
+  return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
+};
+
+/**
+ * Converts a string of Unicode symbols (e.g. a domain name label) to a
+ * Punycode string of ASCII-only symbols.
+ */
+// eslint-disable-next-line max-statements -- TODO
+var encode = function (input) {
+  var output = [];
+
+  // Convert the input in UCS-2 to an array of Unicode code points.
+  input = ucs2decode(input);
+
+  // Cache the length.
+  var inputLength = input.length;
+
+  // Initialize the state.
+  var n = initialN;
+  var delta = 0;
+  var bias = initialBias;
+  var i, currentValue;
+
+  // Handle the basic code points.
+  for (i = 0; i < input.length; i++) {
+    currentValue = input[i];
+    if (currentValue < 0x80) {
+      output.push(stringFromCharCode(currentValue));
+    }
+  }
+
+  var basicLength = output.length; // number of basic code points.
+  var handledCPCount = basicLength; // number of code points that have been handled;
+
+  // Finish the basic string with a delimiter unless it's empty.
+  if (basicLength) {
+    output.push(delimiter);
+  }
+
+  // Main encoding loop:
+  while (handledCPCount < inputLength) {
+    // All non-basic code points < n have been handled already. Find the next larger one:
+    var m = maxInt;
+    for (i = 0; i < input.length; i++) {
+      currentValue = input[i];
+      if (currentValue >= n && currentValue < m) {
+        m = currentValue;
+      }
+    }
+
+    // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>, but guard against overflow.
+    var handledCPCountPlusOne = handledCPCount + 1;
+    if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
+      throw RangeError(OVERFLOW_ERROR);
+    }
+
+    delta += (m - n) * handledCPCountPlusOne;
+    n = m;
+
+    for (i = 0; i < input.length; i++) {
+      currentValue = input[i];
+      if (currentValue < n && ++delta > maxInt) {
+        throw RangeError(OVERFLOW_ERROR);
+      }
+      if (currentValue == n) {
+        // Represent delta as a generalized variable-length integer.
+        var q = delta;
+        for (var k = base; /* no condition */; k += base) {
+          var t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
+          if (q < t) break;
+          var qMinusT = q - t;
+          var baseMinusT = base - t;
+          output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT)));
+          q = floor(qMinusT / baseMinusT);
+        }
+
+        output.push(stringFromCharCode(digitToBasic(q)));
+        bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
+        delta = 0;
+        ++handledCPCount;
+      }
+    }
+
+    ++delta;
+    ++n;
+  }
+  return output.join('');
+};
+
+module.exports = function (input) {
+  var encoded = [];
+  var labels = input.toLowerCase().replace(regexSeparators, '\u002E').split('.');
+  var i, label;
+  for (i = 0; i < labels.length; i++) {
+    label = labels[i];
+    encoded.push(regexNonASCII.test(label) ? 'xn--' + encode(label) : label);
+  }
+  return encoded.join('.');
+};
+
+
+/***/ }),
+
+/***/ 6640:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+
+var toInteger = __webpack_require__(7896);
+var toString = __webpack_require__(401);
+var requireObjectCoercible = __webpack_require__(164);
+
+// `String.prototype.repeat` method implementation
+// https://tc39.es/ecma262/#sec-string.prototype.repeat
+module.exports = function repeat(count) {
+  var str = toString(requireObjectCoercible(this));
+  var result = '';
+  var n = toInteger(count);
+  if (n < 0 || n == Infinity) throw RangeError('Wrong number of repetitions');
+  for (;n > 0; (n >>>= 1) && (str += str)) if (n & 1) result += str;
+  return result;
+};
+
+
+/***/ }),
+
+/***/ 5206:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var fails = __webpack_require__(7841);
+var whitespaces = __webpack_require__(9458);
+
+var non = '\u200B\u0085\u180E';
+
+// check that a method works with the correct list
+// of whitespaces and has a correct name
+module.exports = function (METHOD_NAME) {
+  return fails(function () {
+    return !!whitespaces[METHOD_NAME]() || non[METHOD_NAME]() != non || whitespaces[METHOD_NAME].name !== METHOD_NAME;
+  });
+};
+
+
+/***/ }),
+
+/***/ 7753:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var requireObjectCoercible = __webpack_require__(164);
+var toString = __webpack_require__(401);
+var whitespaces = __webpack_require__(9458);
+
+var whitespace = '[' + whitespaces + ']';
+var ltrim = RegExp('^' + whitespace + whitespace + '*');
+var rtrim = RegExp(whitespace + whitespace + '*$');
+
+// `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation
+var createMethod = function (TYPE) {
+  return function ($this) {
+    var string = toString(requireObjectCoercible($this));
+    if (TYPE & 1) string = string.replace(ltrim, '');
+    if (TYPE & 2) string = string.replace(rtrim, '');
+    return string;
+  };
+};
+
+module.exports = {
+  // `String.prototype.{ trimLeft, trimStart }` methods
+  // https://tc39.es/ecma262/#sec-string.prototype.trimstart
+  start: createMethod(1),
+  // `String.prototype.{ trimRight, trimEnd }` methods
+  // https://tc39.es/ecma262/#sec-string.prototype.trimend
+  end: createMethod(2),
+  // `String.prototype.trim` method
+  // https://tc39.es/ecma262/#sec-string.prototype.trim
+  trim: createMethod(3)
+};
+
+
+/***/ }),
+
+/***/ 998:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var global = __webpack_require__(6874);
+var fails = __webpack_require__(7841);
+var bind = __webpack_require__(4833);
+var html = __webpack_require__(7666);
+var createElement = __webpack_require__(3879);
+var IS_IOS = __webpack_require__(3359);
+var IS_NODE = __webpack_require__(8723);
+
+var set = global.setImmediate;
+var clear = global.clearImmediate;
+var process = global.process;
+var MessageChannel = global.MessageChannel;
+var Dispatch = global.Dispatch;
+var counter = 0;
+var queue = {};
+var ONREADYSTATECHANGE = 'onreadystatechange';
+var location, defer, channel, port;
+
+try {
+  // Deno throws a ReferenceError on `location` access without `--location` flag
+  location = global.location;
+} catch (error) { /* empty */ }
+
+var run = function (id) {
+  // eslint-disable-next-line no-prototype-builtins -- safe
+  if (queue.hasOwnProperty(id)) {
+    var fn = queue[id];
+    delete queue[id];
+    fn();
+  }
+};
+
+var runner = function (id) {
+  return function () {
+    run(id);
+  };
+};
+
+var listener = function (event) {
+  run(event.data);
+};
+
+var post = function (id) {
+  // old engines have not location.origin
+  global.postMessage(String(id), location.protocol + '//' + location.host);
+};
+
+// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
+if (!set || !clear) {
+  set = function setImmediate(fn) {
+    var args = [];
+    var argumentsLength = arguments.length;
+    var i = 1;
+    while (argumentsLength > i) args.push(arguments[i++]);
+    queue[++counter] = function () {
+      // eslint-disable-next-line no-new-func -- spec requirement
+      (typeof fn == 'function' ? fn : Function(fn)).apply(undefined, args);
+    };
+    defer(counter);
+    return counter;
+  };
+  clear = function clearImmediate(id) {
+    delete queue[id];
+  };
+  // Node.js 0.8-
+  if (IS_NODE) {
+    defer = function (id) {
+      process.nextTick(runner(id));
+    };
+  // Sphere (JS game engine) Dispatch API
+  } else if (Dispatch && Dispatch.now) {
+    defer = function (id) {
+      Dispatch.now(runner(id));
+    };
+  // Browsers with MessageChannel, includes WebWorkers
+  // except iOS - https://github.com/zloirock/core-js/issues/624
+  } else if (MessageChannel && !IS_IOS) {
+    channel = new MessageChannel();
+    port = channel.port2;
+    channel.port1.onmessage = listener;
+    defer = bind(port.postMessage, port, 1);
+  // Browsers with postMessage, skip WebWorkers
+  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
+  } else if (
+    global.addEventListener &&
+    typeof postMessage == 'function' &&
+    !global.importScripts &&
+    location && location.protocol !== 'file:' &&
+    !fails(post)
+  ) {
+    defer = post;
+    global.addEventListener('message', listener, false);
+  // IE8-
+  } else if (ONREADYSTATECHANGE in createElement('script')) {
+    defer = function (id) {
+      html.appendChild(createElement('script'))[ONREADYSTATECHANGE] = function () {
+        html.removeChild(this);
+        run(id);
+      };
+    };
+  // Rest old browsers
+  } else {
+    defer = function (id) {
+      setTimeout(runner(id), 0);
+    };
+  }
+}
+
+module.exports = {
+  set: set,
+  clear: clear
+};
+
+
+/***/ }),
+
+/***/ 7347:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var classof = __webpack_require__(3565);
+
+// `thisNumberValue` abstract operation
+// https://tc39.es/ecma262/#sec-thisnumbervalue
+module.exports = function (value) {
+  if (typeof value != 'number' && classof(value) != 'Number') {
+    throw TypeError('Incorrect invocation');
+  }
+  return +value;
+};
+
+
+/***/ }),
+
+/***/ 2145:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var toInteger = __webpack_require__(7896);
+
+var max = Math.max;
+var min = Math.min;
+
+// Helper for a popular repeating case of the spec:
+// Let integer be ? ToInteger(index).
+// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
+module.exports = function (index, length) {
+  var integer = toInteger(index);
+  return integer < 0 ? max(integer + length, 0) : min(integer, length);
+};
+
+
+/***/ }),
+
+/***/ 5513:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var toInteger = __webpack_require__(7896);
+var toLength = __webpack_require__(4954);
+
+// `ToIndex` abstract operation
+// https://tc39.es/ecma262/#sec-toindex
+module.exports = function (it) {
+  if (it === undefined) return 0;
+  var number = toInteger(it);
+  var length = toLength(number);
+  if (number !== length) throw RangeError('Wrong length or index');
+  return length;
+};
+
+
+/***/ }),
+
+/***/ 8852:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+// toObject with fallback for non-array-like ES3 strings
+var IndexedObject = __webpack_require__(7361);
+var requireObjectCoercible = __webpack_require__(164);
+
+module.exports = function (it) {
+  return IndexedObject(requireObjectCoercible(it));
+};
+
+
+/***/ }),
+
+/***/ 7896:
+/***/ ((module) => {
+
+var ceil = Math.ceil;
+var floor = Math.floor;
+
+// `ToInteger` abstract operation
+// https://tc39.es/ecma262/#sec-tointeger
+module.exports = function (argument) {
+  return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);
+};
+
+
+/***/ }),
+
+/***/ 4954:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var toInteger = __webpack_require__(7896);
+
+var min = Math.min;
+
+// `ToLength` abstract operation
+// https://tc39.es/ecma262/#sec-tolength
+module.exports = function (argument) {
+  return argument > 0 ? min(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
+};
+
+
+/***/ }),
+
+/***/ 4680:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var requireObjectCoercible = __webpack_require__(164);
+
+// `ToObject` abstract operation
+// https://tc39.es/ecma262/#sec-toobject
+module.exports = function (argument) {
+  return Object(requireObjectCoercible(argument));
+};
+
+
+/***/ }),
+
+/***/ 6189:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var toPositiveInteger = __webpack_require__(3096);
+
+module.exports = function (it, BYTES) {
+  var offset = toPositiveInteger(it);
+  if (offset % BYTES) throw RangeError('Wrong offset');
+  return offset;
+};
+
+
+/***/ }),
+
+/***/ 3096:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var toInteger = __webpack_require__(7896);
+
+module.exports = function (it) {
+  var result = toInteger(it);
+  if (result < 0) throw RangeError("The argument can't be less than 0");
+  return result;
+};
+
+
+/***/ }),
+
+/***/ 2034:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var isObject = __webpack_require__(6944);
+var isSymbol = __webpack_require__(8377);
+var ordinaryToPrimitive = __webpack_require__(2392);
+var wellKnownSymbol = __webpack_require__(3706);
+
+var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');
+
+// `ToPrimitive` abstract operation
+// https://tc39.es/ecma262/#sec-toprimitive
+module.exports = function (input, pref) {
+  if (!isObject(input) || isSymbol(input)) return input;
+  var exoticToPrim = input[TO_PRIMITIVE];
+  var result;
+  if (exoticToPrim !== undefined) {
+    if (pref === undefined) pref = 'default';
+    result = exoticToPrim.call(input, pref);
+    if (!isObject(result) || isSymbol(result)) return result;
+    throw TypeError("Can't convert object to primitive value");
+  }
+  if (pref === undefined) pref = 'number';
+  return ordinaryToPrimitive(input, pref);
+};
+
+
+/***/ }),
+
+/***/ 2694:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var toPrimitive = __webpack_require__(2034);
+var isSymbol = __webpack_require__(8377);
+
+// `ToPropertyKey` abstract operation
+// https://tc39.es/ecma262/#sec-topropertykey
+module.exports = function (argument) {
+  var key = toPrimitive(argument, 'string');
+  return isSymbol(key) ? key : String(key);
+};
+
+
+/***/ }),
+
+/***/ 939:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var wellKnownSymbol = __webpack_require__(3706);
+
+var TO_STRING_TAG = wellKnownSymbol('toStringTag');
+var test = {};
+
+test[TO_STRING_TAG] = 'z';
+
+module.exports = String(test) === '[object z]';
+
+
+/***/ }),
+
+/***/ 401:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var isSymbol = __webpack_require__(8377);
+
+module.exports = function (argument) {
+  if (isSymbol(argument)) throw TypeError('Cannot convert a Symbol value to a string');
+  return String(argument);
+};
+
+
+/***/ }),
+
+/***/ 3151:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+
+var $ = __webpack_require__(1082);
+var global = __webpack_require__(6874);
+var DESCRIPTORS = __webpack_require__(5542);
+var TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS = __webpack_require__(6178);
+var ArrayBufferViewCore = __webpack_require__(2211);
+var ArrayBufferModule = __webpack_require__(6594);
+var anInstance = __webpack_require__(2482);
+var createPropertyDescriptor = __webpack_require__(976);
+var createNonEnumerableProperty = __webpack_require__(4791);
+var isInteger = __webpack_require__(3614);
+var toLength = __webpack_require__(4954);
+var toIndex = __webpack_require__(5513);
+var toOffset = __webpack_require__(6189);
+var toPropertyKey = __webpack_require__(2694);
+var has = __webpack_require__(5884);
+var classof = __webpack_require__(8753);
+var isObject = __webpack_require__(6944);
+var isSymbol = __webpack_require__(8377);
+var create = __webpack_require__(2361);
+var setPrototypeOf = __webpack_require__(2686);
+var getOwnPropertyNames = __webpack_require__(8401).f;
+var typedArrayFrom = __webpack_require__(9782);
+var forEach = __webpack_require__(6374).forEach;
+var setSpecies = __webpack_require__(8802);
+var definePropertyModule = __webpack_require__(3376);
+var getOwnPropertyDescriptorModule = __webpack_require__(7825);
+var InternalStateModule = __webpack_require__(6619);
+var inheritIfRequired = __webpack_require__(4029);
+
+var getInternalState = InternalStateModule.get;
+var setInternalState = InternalStateModule.set;
+var nativeDefineProperty = definePropertyModule.f;
+var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
+var round = Math.round;
+var RangeError = global.RangeError;
+var ArrayBuffer = ArrayBufferModule.ArrayBuffer;
+var DataView = ArrayBufferModule.DataView;
+var NATIVE_ARRAY_BUFFER_VIEWS = ArrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;
+var TYPED_ARRAY_CONSTRUCTOR = ArrayBufferViewCore.TYPED_ARRAY_CONSTRUCTOR;
+var TYPED_ARRAY_TAG = ArrayBufferViewCore.TYPED_ARRAY_TAG;
+var TypedArray = ArrayBufferViewCore.TypedArray;
+var TypedArrayPrototype = ArrayBufferViewCore.TypedArrayPrototype;
+var aTypedArrayConstructor = ArrayBufferViewCore.aTypedArrayConstructor;
+var isTypedArray = ArrayBufferViewCore.isTypedArray;
+var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
+var WRONG_LENGTH = 'Wrong length';
+
+var fromList = function (C, list) {
+  var index = 0;
+  var length = list.length;
+  var result = new (aTypedArrayConstructor(C))(length);
+  while (length > index) result[index] = list[index++];
+  return result;
+};
+
+var addGetter = function (it, key) {
+  nativeDefineProperty(it, key, { get: function () {
+    return getInternalState(this)[key];
+  } });
+};
+
+var isArrayBuffer = function (it) {
+  var klass;
+  return it instanceof ArrayBuffer || (klass = classof(it)) == 'ArrayBuffer' || klass == 'SharedArrayBuffer';
+};
+
+var isTypedArrayIndex = function (target, key) {
+  return isTypedArray(target)
+    && !isSymbol(key)
+    && key in target
+    && isInteger(+key)
+    && key >= 0;
+};
+
+var wrappedGetOwnPropertyDescriptor = function getOwnPropertyDescriptor(target, key) {
+  key = toPropertyKey(key);
+  return isTypedArrayIndex(target, key)
+    ? createPropertyDescriptor(2, target[key])
+    : nativeGetOwnPropertyDescriptor(target, key);
+};
+
+var wrappedDefineProperty = function defineProperty(target, key, descriptor) {
+  key = toPropertyKey(key);
+  if (isTypedArrayIndex(target, key)
+    && isObject(descriptor)
+    && has(descriptor, 'value')
+    && !has(descriptor, 'get')
+    && !has(descriptor, 'set')
+    // TODO: add validation descriptor w/o calling accessors
+    && !descriptor.configurable
+    && (!has(descriptor, 'writable') || descriptor.writable)
+    && (!has(descriptor, 'enumerable') || descriptor.enumerable)
+  ) {
+    target[key] = descriptor.value;
+    return target;
+  } return nativeDefineProperty(target, key, descriptor);
+};
+
+if (DESCRIPTORS) {
+  if (!NATIVE_ARRAY_BUFFER_VIEWS) {
+    getOwnPropertyDescriptorModule.f = wrappedGetOwnPropertyDescriptor;
+    definePropertyModule.f = wrappedDefineProperty;
+    addGetter(TypedArrayPrototype, 'buffer');
+    addGetter(TypedArrayPrototype, 'byteOffset');
+    addGetter(TypedArrayPrototype, 'byteLength');
+    addGetter(TypedArrayPrototype, 'length');
+  }
+
+  $({ target: 'Object', stat: true, forced: !NATIVE_ARRAY_BUFFER_VIEWS }, {
+    getOwnPropertyDescriptor: wrappedGetOwnPropertyDescriptor,
+    defineProperty: wrappedDefineProperty
+  });
+
+  module.exports = function (TYPE, wrapper, CLAMPED) {
+    var BYTES = TYPE.match(/\d+$/)[0] / 8;
+    var CONSTRUCTOR_NAME = TYPE + (CLAMPED ? 'Clamped' : '') + 'Array';
+    var GETTER = 'get' + TYPE;
+    var SETTER = 'set' + TYPE;
+    var NativeTypedArrayConstructor = global[CONSTRUCTOR_NAME];
+    var TypedArrayConstructor = NativeTypedArrayConstructor;
+    var TypedArrayConstructorPrototype = TypedArrayConstructor && TypedArrayConstructor.prototype;
+    var exported = {};
+
+    var getter = function (that, index) {
+      var data = getInternalState(that);
+      return data.view[GETTER](index * BYTES + data.byteOffset, true);
+    };
+
+    var setter = function (that, index, value) {
+      var data = getInternalState(that);
+      if (CLAMPED) value = (value = round(value)) < 0 ? 0 : value > 0xFF ? 0xFF : value & 0xFF;
+      data.view[SETTER](index * BYTES + data.byteOffset, value, true);
+    };
+
+    var addElement = function (that, index) {
+      nativeDefineProperty(that, index, {
+        get: function () {
+          return getter(this, index);
+        },
+        set: function (value) {
+          return setter(this, index, value);
+        },
+        enumerable: true
+      });
+    };
+
+    if (!NATIVE_ARRAY_BUFFER_VIEWS) {
+      TypedArrayConstructor = wrapper(function (that, data, offset, $length) {
+        anInstance(that, TypedArrayConstructor, CONSTRUCTOR_NAME);
+        var index = 0;
+        var byteOffset = 0;
+        var buffer, byteLength, length;
+        if (!isObject(data)) {
+          length = toIndex(data);
+          byteLength = length * BYTES;
+          buffer = new ArrayBuffer(byteLength);
+        } else if (isArrayBuffer(data)) {
+          buffer = data;
+          byteOffset = toOffset(offset, BYTES);
+          var $len = data.byteLength;
+          if ($length === undefined) {
+            if ($len % BYTES) throw RangeError(WRONG_LENGTH);
+            byteLength = $len - byteOffset;
+            if (byteLength < 0) throw RangeError(WRONG_LENGTH);
+          } else {
+            byteLength = toLength($length) * BYTES;
+            if (byteLength + byteOffset > $len) throw RangeError(WRONG_LENGTH);
+          }
+          length = byteLength / BYTES;
+        } else if (isTypedArray(data)) {
+          return fromList(TypedArrayConstructor, data);
+        } else {
+          return typedArrayFrom.call(TypedArrayConstructor, data);
+        }
+        setInternalState(that, {
+          buffer: buffer,
+          byteOffset: byteOffset,
+          byteLength: byteLength,
+          length: length,
+          view: new DataView(buffer)
+        });
+        while (index < length) addElement(that, index++);
+      });
+
+      if (setPrototypeOf) setPrototypeOf(TypedArrayConstructor, TypedArray);
+      TypedArrayConstructorPrototype = TypedArrayConstructor.prototype = create(TypedArrayPrototype);
+    } else if (TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS) {
+      TypedArrayConstructor = wrapper(function (dummy, data, typedArrayOffset, $length) {
+        anInstance(dummy, TypedArrayConstructor, CONSTRUCTOR_NAME);
+        return inheritIfRequired(function () {
+          if (!isObject(data)) return new NativeTypedArrayConstructor(toIndex(data));
+          if (isArrayBuffer(data)) return $length !== undefined
+            ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES), $length)
+            : typedArrayOffset !== undefined
+              ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES))
+              : new NativeTypedArrayConstructor(data);
+          if (isTypedArray(data)) return fromList(TypedArrayConstructor, data);
+          return typedArrayFrom.call(TypedArrayConstructor, data);
+        }(), dummy, TypedArrayConstructor);
+      });
+
+      if (setPrototypeOf) setPrototypeOf(TypedArrayConstructor, TypedArray);
+      forEach(getOwnPropertyNames(NativeTypedArrayConstructor), function (key) {
+        if (!(key in TypedArrayConstructor)) {
+          createNonEnumerableProperty(TypedArrayConstructor, key, NativeTypedArrayConstructor[key]);
+        }
+      });
+      TypedArrayConstructor.prototype = TypedArrayConstructorPrototype;
+    }
+
+    if (TypedArrayConstructorPrototype.constructor !== TypedArrayConstructor) {
+      createNonEnumerableProperty(TypedArrayConstructorPrototype, 'constructor', TypedArrayConstructor);
+    }
+
+    createNonEnumerableProperty(TypedArrayConstructorPrototype, TYPED_ARRAY_CONSTRUCTOR, TypedArrayConstructor);
+
+    if (TYPED_ARRAY_TAG) {
+      createNonEnumerableProperty(TypedArrayConstructorPrototype, TYPED_ARRAY_TAG, CONSTRUCTOR_NAME);
+    }
+
+    exported[CONSTRUCTOR_NAME] = TypedArrayConstructor;
+
+    $({
+      global: true, forced: TypedArrayConstructor != NativeTypedArrayConstructor, sham: !NATIVE_ARRAY_BUFFER_VIEWS
+    }, exported);
+
+    if (!(BYTES_PER_ELEMENT in TypedArrayConstructor)) {
+      createNonEnumerableProperty(TypedArrayConstructor, BYTES_PER_ELEMENT, BYTES);
+    }
+
+    if (!(BYTES_PER_ELEMENT in TypedArrayConstructorPrototype)) {
+      createNonEnumerableProperty(TypedArrayConstructorPrototype, BYTES_PER_ELEMENT, BYTES);
+    }
+
+    setSpecies(CONSTRUCTOR_NAME);
+  };
+} else module.exports = function () { /* empty */ };
+
+
+/***/ }),
+
+/***/ 6178:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+/* eslint-disable no-new -- required for testing */
+var global = __webpack_require__(6874);
+var fails = __webpack_require__(7841);
+var checkCorrectnessOfIteration = __webpack_require__(4585);
+var NATIVE_ARRAY_BUFFER_VIEWS = __webpack_require__(2211).NATIVE_ARRAY_BUFFER_VIEWS;
+
+var ArrayBuffer = global.ArrayBuffer;
+var Int8Array = global.Int8Array;
+
+module.exports = !NATIVE_ARRAY_BUFFER_VIEWS || !fails(function () {
+  Int8Array(1);
+}) || !fails(function () {
+  new Int8Array(-1);
+}) || !checkCorrectnessOfIteration(function (iterable) {
+  new Int8Array();
+  new Int8Array(null);
+  new Int8Array(1.5);
+  new Int8Array(iterable);
+}, true) || fails(function () {
+  // Safari (11+) bug - a reason why even Safari 13 should load a typed array polyfill
+  return new Int8Array(new ArrayBuffer(2), 1, undefined).length !== 1;
+});
+
+
+/***/ }),
+
+/***/ 6696:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var arrayFromConstructorAndList = __webpack_require__(4413);
+var typedArraySpeciesConstructor = __webpack_require__(5751);
+
+module.exports = function (instance, list) {
+  return arrayFromConstructorAndList(typedArraySpeciesConstructor(instance), list);
+};
+
+
+/***/ }),
+
+/***/ 9782:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var toObject = __webpack_require__(4680);
+var toLength = __webpack_require__(4954);
+var getIteratorMethod = __webpack_require__(3126);
+var isArrayIteratorMethod = __webpack_require__(1008);
+var bind = __webpack_require__(4833);
+var aTypedArrayConstructor = __webpack_require__(2211).aTypedArrayConstructor;
+
+module.exports = function from(source /* , mapfn, thisArg */) {
+  var O = toObject(source);
+  var argumentsLength = arguments.length;
+  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
+  var mapping = mapfn !== undefined;
+  var iteratorMethod = getIteratorMethod(O);
+  var i, length, result, step, iterator, next;
+  if (iteratorMethod != undefined && !isArrayIteratorMethod(iteratorMethod)) {
+    iterator = iteratorMethod.call(O);
+    next = iterator.next;
+    O = [];
+    while (!(step = next.call(iterator)).done) {
+      O.push(step.value);
+    }
+  }
+  if (mapping && argumentsLength > 2) {
+    mapfn = bind(mapfn, arguments[2], 2);
+  }
+  length = toLength(O.length);
+  result = new (aTypedArrayConstructor(this))(length);
+  for (i = 0; length > i; i++) {
+    result[i] = mapping ? mapfn(O[i], i) : O[i];
+  }
+  return result;
+};
+
+
+/***/ }),
+
+/***/ 5751:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var ArrayBufferViewCore = __webpack_require__(2211);
+var speciesConstructor = __webpack_require__(2004);
+
+var TYPED_ARRAY_CONSTRUCTOR = ArrayBufferViewCore.TYPED_ARRAY_CONSTRUCTOR;
+var aTypedArrayConstructor = ArrayBufferViewCore.aTypedArrayConstructor;
+
+// a part of `TypedArraySpeciesCreate` abstract operation
+// https://tc39.es/ecma262/#typedarray-species-create
+module.exports = function (originalArray) {
+  return aTypedArrayConstructor(speciesConstructor(originalArray, originalArray[TYPED_ARRAY_CONSTRUCTOR]));
+};
+
+
+/***/ }),
+
+/***/ 8435:
+/***/ ((module) => {
+
+var id = 0;
+var postfix = Math.random();
+
+module.exports = function (key) {
+  return 'Symbol(' + String(key === undefined ? '' : key) + ')_' + (++id + postfix).toString(36);
+};
+
+
+/***/ }),
+
+/***/ 4587:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+/* eslint-disable es/no-symbol -- required for testing */
+var NATIVE_SYMBOL = __webpack_require__(1453);
+
+module.exports = NATIVE_SYMBOL
+  && !Symbol.sham
+  && typeof Symbol.iterator == 'symbol';
+
+
+/***/ }),
+
+/***/ 8403:
+/***/ ((__unused_webpack_module, exports, __webpack_require__) => {
+
+var wellKnownSymbol = __webpack_require__(3706);
+
+exports.f = wellKnownSymbol;
+
+
+/***/ }),
+
+/***/ 3706:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var global = __webpack_require__(6874);
+var shared = __webpack_require__(3215);
+var has = __webpack_require__(5884);
+var uid = __webpack_require__(8435);
+var NATIVE_SYMBOL = __webpack_require__(1453);
+var USE_SYMBOL_AS_UID = __webpack_require__(4587);
+
+var WellKnownSymbolsStore = shared('wks');
+var Symbol = global.Symbol;
+var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol : Symbol && Symbol.withoutSetter || uid;
+
+module.exports = function (name) {
+  if (!has(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == 'string')) {
+    if (NATIVE_SYMBOL && has(Symbol, name)) {
+      WellKnownSymbolsStore[name] = Symbol[name];
+    } else {
+      WellKnownSymbolsStore[name] = createWellKnownSymbol('Symbol.' + name);
+    }
+  } return WellKnownSymbolsStore[name];
+};
+
+
+/***/ }),
+
+/***/ 9458:
+/***/ ((module) => {
+
+// a string of all valid unicode whitespaces
+module.exports = '\u0009\u000A\u000B\u000C\u000D\u0020\u00A0\u1680\u2000\u2001\u2002' +
+  '\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';
+
+
+/***/ }),
+
+/***/ 9722:
+/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+
+var $ = __webpack_require__(1082);
+var fails = __webpack_require__(7841);
+var ArrayBufferModule = __webpack_require__(6594);
+var anObject = __webpack_require__(47);
+var toAbsoluteIndex = __webpack_require__(2145);
+var toLength = __webpack_require__(4954);
+var speciesConstructor = __webpack_require__(2004);
+
+var ArrayBuffer = ArrayBufferModule.ArrayBuffer;
+var DataView = ArrayBufferModule.DataView;
+var nativeArrayBufferSlice = ArrayBuffer.prototype.slice;
+
+var INCORRECT_SLICE = fails(function () {
+  return !new ArrayBuffer(2).slice(1, undefined).byteLength;
+});
+
+// `ArrayBuffer.prototype.slice` method
+// https://tc39.es/ecma262/#sec-arraybuffer.prototype.slice
+$({ target: 'ArrayBuffer', proto: true, unsafe: true, forced: INCORRECT_SLICE }, {
+  slice: function slice(start, end) {
+    if (nativeArrayBufferSlice !== undefined && end === undefined) {
+      return nativeArrayBufferSlice.call(anObject(this), start); // FF fix
+    }
+    var length = anObject(this).byteLength;
+    var first = toAbsoluteIndex(start, length);
+    var fin = toAbsoluteIndex(end === undefined ? length : end, length);
+    var result = new (speciesConstructor(this, ArrayBuffer))(toLength(fin - first));
+    var viewSource = new DataView(this);
+    var viewTarget = new DataView(result);
+    var index = 0;
+    while (first < fin) {
+      viewTarget.setUint8(index++, viewSource.getUint8(first++));
+    } return result;
+  }
+});
+
+
+/***/ }),
+
+/***/ 6218:
+/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+
+var $ = __webpack_require__(1082);
+var fails = __webpack_require__(7841);
+var isArray = __webpack_require__(7828);
+var isObject = __webpack_require__(6944);
+var toObject = __webpack_require__(4680);
+var toLength = __webpack_require__(4954);
+var createProperty = __webpack_require__(2076);
+var arraySpeciesCreate = __webpack_require__(68);
+var arrayMethodHasSpeciesSupport = __webpack_require__(6937);
+var wellKnownSymbol = __webpack_require__(3706);
+var V8_VERSION = __webpack_require__(579);
+
+var IS_CONCAT_SPREADABLE = wellKnownSymbol('isConcatSpreadable');
+var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF;
+var MAXIMUM_ALLOWED_INDEX_EXCEEDED = 'Maximum allowed index exceeded';
+
+// We can't use this feature detection in V8 since it causes
+// deoptimization and serious performance degradation
+// https://github.com/zloirock/core-js/issues/679
+var IS_CONCAT_SPREADABLE_SUPPORT = V8_VERSION >= 51 || !fails(function () {
+  var array = [];
+  array[IS_CONCAT_SPREADABLE] = false;
+  return array.concat()[0] !== array;
+});
+
+var SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('concat');
+
+var isConcatSpreadable = function (O) {
+  if (!isObject(O)) return false;
+  var spreadable = O[IS_CONCAT_SPREADABLE];
+  return spreadable !== undefined ? !!spreadable : isArray(O);
+};
+
+var FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !SPECIES_SUPPORT;
+
+// `Array.prototype.concat` method
+// https://tc39.es/ecma262/#sec-array.prototype.concat
+// with adding support of @@isConcatSpreadable and @@species
+$({ target: 'Array', proto: true, forced: FORCED }, {
+  // eslint-disable-next-line no-unused-vars -- required for `.length`
+  concat: function concat(arg) {
+    var O = toObject(this);
+    var A = arraySpeciesCreate(O, 0);
+    var n = 0;
+    var i, k, length, len, E;
+    for (i = -1, length = arguments.length; i < length; i++) {
+      E = i === -1 ? O : arguments[i];
+      if (isConcatSpreadable(E)) {
+        len = toLength(E.length);
+        if (n + len > MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
+        for (k = 0; k < len; k++, n++) if (k in E) createProperty(A, n, E[k]);
+      } else {
+        if (n >= MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
+        createProperty(A, n++, E);
+      }
+    }
+    A.length = n;
+    return A;
+  }
+});
+
+
+/***/ }),
+
+/***/ 8544:
+/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {
+
+var $ = __webpack_require__(1082);
+var fill = __webpack_require__(7515);
+var addToUnscopables = __webpack_require__(9611);
+
+// `Array.prototype.fill` method
+// https://tc39.es/ecma262/#sec-array.prototype.fill
+$({ target: 'Array', proto: true }, {
+  fill: fill
+});
+
+// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
+addToUnscopables('fill');
+
+
+/***/ }),
+
+/***/ 3324:
+/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+
+var $ = __webpack_require__(1082);
+var $filter = __webpack_require__(6374).filter;
+var arrayMethodHasSpeciesSupport = __webpack_require__(6937);
+
+var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('filter');
+
+// `Array.prototype.filter` method
+// https://tc39.es/ecma262/#sec-array.prototype.filter
+// with adding support of @@species
+$({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT }, {
+  filter: function filter(callbackfn /* , thisArg */) {
+    return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
+  }
+});
+
+
+/***/ }),
+
+/***/ 6582:
+/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+
+var $ = __webpack_require__(1082);
+var $find = __webpack_require__(6374).find;
+var addToUnscopables = __webpack_require__(9611);
+
+var FIND = 'find';
+var SKIPS_HOLES = true;
+
+// Shouldn't skip holes
+if (FIND in []) Array(1)[FIND](function () { SKIPS_HOLES = false; });
+
+// `Array.prototype.find` method
+// https://tc39.es/ecma262/#sec-array.prototype.find
+$({ target: 'Array', proto: true, forced: SKIPS_HOLES }, {
+  find: function find(callbackfn /* , that = undefined */) {
+    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
+  }
+});
+
+// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
+addToUnscopables(FIND);
+
+
+/***/ }),
+
+/***/ 1917:
+/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {
+
+var $ = __webpack_require__(1082);
+var from = __webpack_require__(1774);
+var checkCorrectnessOfIteration = __webpack_require__(4585);
+
+var INCORRECT_ITERATION = !checkCorrectnessOfIteration(function (iterable) {
+  // eslint-disable-next-line es/no-array-from -- required for testing
+  Array.from(iterable);
+});
+
+// `Array.from` method
+// https://tc39.es/ecma262/#sec-array.from
+$({ target: 'Array', stat: true, forced: INCORRECT_ITERATION }, {
+  from: from
+});
+
+
+/***/ }),
+
+/***/ 4270:
+/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+
+var $ = __webpack_require__(1082);
+var $includes = __webpack_require__(1270).includes;
+var addToUnscopables = __webpack_require__(9611);
+
+// `Array.prototype.includes` method
+// https://tc39.es/ecma262/#sec-array.prototype.includes
+$({ target: 'Array', proto: true }, {
+  includes: function includes(el /* , fromIndex = 0 */) {
+    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
+  }
+});
+
+// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
+addToUnscopables('includes');
+
+
+/***/ }),
+
+/***/ 2837:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+
+var toIndexedObject = __webpack_require__(8852);
+var addToUnscopables = __webpack_require__(9611);
+var Iterators = __webpack_require__(873);
+var InternalStateModule = __webpack_require__(6619);
+var defineIterator = __webpack_require__(3131);
+
+var ARRAY_ITERATOR = 'Array Iterator';
+var setInternalState = InternalStateModule.set;
+var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);
+
+// `Array.prototype.entries` method
+// https://tc39.es/ecma262/#sec-array.prototype.entries
+// `Array.prototype.keys` method
+// https://tc39.es/ecma262/#sec-array.prototype.keys
+// `Array.prototype.values` method
+// https://tc39.es/ecma262/#sec-array.prototype.values
+// `Array.prototype[@@iterator]` method
+// https://tc39.es/ecma262/#sec-array.prototype-@@iterator
+// `CreateArrayIterator` internal method
+// https://tc39.es/ecma262/#sec-createarrayiterator
+module.exports = defineIterator(Array, 'Array', function (iterated, kind) {
+  setInternalState(this, {
+    type: ARRAY_ITERATOR,
+    target: toIndexedObject(iterated), // target
+    index: 0,                          // next index
+    kind: kind                         // kind
+  });
+// `%ArrayIteratorPrototype%.next` method
+// https://tc39.es/ecma262/#sec-%arrayiteratorprototype%.next
+}, function () {
+  var state = getInternalState(this);
+  var target = state.target;
+  var kind = state.kind;
+  var index = state.index++;
+  if (!target || index >= target.length) {
+    state.target = undefined;
+    return { value: undefined, done: true };
+  }
+  if (kind == 'keys') return { value: index, done: false };
+  if (kind == 'values') return { value: target[index], done: false };
+  return { value: [index, target[index]], done: false };
+}, 'values');
+
+// argumentsList[@@iterator] is %ArrayProto_values%
+// https://tc39.es/ecma262/#sec-createunmappedargumentsobject
+// https://tc39.es/ecma262/#sec-createmappedargumentsobject
+Iterators.Arguments = Iterators.Array;
+
+// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
+addToUnscopables('keys');
+addToUnscopables('values');
+addToUnscopables('entries');
+
+
+/***/ }),
+
+/***/ 5691:
+/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+
+var $ = __webpack_require__(1082);
+var IndexedObject = __webpack_require__(7361);
+var toIndexedObject = __webpack_require__(8852);
+var arrayMethodIsStrict = __webpack_require__(622);
+
+var nativeJoin = [].join;
+
+var ES3_STRINGS = IndexedObject != Object;
+var STRICT_METHOD = arrayMethodIsStrict('join', ',');
+
+// `Array.prototype.join` method
+// https://tc39.es/ecma262/#sec-array.prototype.join
+$({ target: 'Array', proto: true, forced: ES3_STRINGS || !STRICT_METHOD }, {
+  join: function join(separator) {
+    return nativeJoin.call(toIndexedObject(this), separator === undefined ? ',' : separator);
+  }
+});
+
+
+/***/ }),
+
+/***/ 7316:
+/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+
+var $ = __webpack_require__(1082);
+var $map = __webpack_require__(6374).map;
+var arrayMethodHasSpeciesSupport = __webpack_require__(6937);
+
+var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('map');
+
+// `Array.prototype.map` method
+// https://tc39.es/ecma262/#sec-array.prototype.map
+// with adding support of @@species
+$({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT }, {
+  map: function map(callbackfn /* , thisArg */) {
+    return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
+  }
+});
+
+
+/***/ }),
+
+/***/ 1122:
+/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+
+var $ = __webpack_require__(1082);
+var isObject = __webpack_require__(6944);
+var isArray = __webpack_require__(7828);
+var toAbsoluteIndex = __webpack_require__(2145);
+var toLength = __webpack_require__(4954);
+var toIndexedObject = __webpack_require__(8852);
+var createProperty = __webpack_require__(2076);
+var wellKnownSymbol = __webpack_require__(3706);
+var arrayMethodHasSpeciesSupport = __webpack_require__(6937);
+
+var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('slice');
+
+var SPECIES = wellKnownSymbol('species');
+var nativeSlice = [].slice;
+var max = Math.max;
+
+// `Array.prototype.slice` method
+// https://tc39.es/ecma262/#sec-array.prototype.slice
+// fallback for not array-like ES3 strings and DOM objects
+$({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT }, {
+  slice: function slice(start, end) {
+    var O = toIndexedObject(this);
+    var length = toLength(O.length);
+    var k = toAbsoluteIndex(start, length);
+    var fin = toAbsoluteIndex(end === undefined ? length : end, length);
+    // inline `ArraySpeciesCreate` for usage native `Array#slice` where it's possible
+    var Constructor, result, n;
+    if (isArray(O)) {
+      Constructor = O.constructor;
+      // cross-realm fallback
+      if (typeof Constructor == 'function' && (Constructor === Array || isArray(Constructor.prototype))) {
+        Constructor = undefined;
+      } else if (isObject(Constructor)) {
+        Constructor = Constructor[SPECIES];
+        if (Constructor === null) Constructor = undefined;
+      }
+      if (Constructor === Array || Constructor === undefined) {
+        return nativeSlice.call(O, k, fin);
+      }
+    }
+    result = new (Constructor === undefined ? Array : Constructor)(max(fin - k, 0));
+    for (n = 0; k < fin; k++, n++) if (k in O) createProperty(result, n, O[k]);
+    result.length = n;
+    return result;
+  }
+});
+
+
+/***/ }),
+
+/***/ 2656:
+/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {
+
+var DESCRIPTORS = __webpack_require__(5542);
+var defineProperty = __webpack_require__(3376).f;
+
+var FunctionPrototype = Function.prototype;
+var FunctionPrototypeToString = FunctionPrototype.toString;
+var nameRE = /^\s*function ([^ (]*)/;
+var NAME = 'name';
+
+// Function instances `.name` property
+// https://tc39.es/ecma262/#sec-function-instances-name
+if (DESCRIPTORS && !(NAME in FunctionPrototype)) {
+  defineProperty(FunctionPrototype, NAME, {
+    configurable: true,
+    get: function () {
+      try {
+        return FunctionPrototypeToString.call(this).match(nameRE)[1];
+      } catch (error) {
+        return '';
+      }
+    }
+  });
+}
+
+
+/***/ }),
+
+/***/ 7775:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+
+var collection = __webpack_require__(6935);
+var collectionStrong = __webpack_require__(6955);
+
+// `Map` constructor
+// https://tc39.es/ecma262/#sec-map-objects
+module.exports = collection('Map', function (init) {
+  return function Map() { return init(this, arguments.length ? arguments[0] : undefined); };
+}, collectionStrong);
+
+
+/***/ }),
+
+/***/ 3729:
+/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+
+var DESCRIPTORS = __webpack_require__(5542);
+var global = __webpack_require__(6874);
+var isForced = __webpack_require__(2350);
+var redefine = __webpack_require__(1249);
+var has = __webpack_require__(5884);
+var classof = __webpack_require__(3565);
+var inheritIfRequired = __webpack_require__(4029);
+var isSymbol = __webpack_require__(8377);
+var toPrimitive = __webpack_require__(2034);
+var fails = __webpack_require__(7841);
+var create = __webpack_require__(2361);
+var getOwnPropertyNames = __webpack_require__(8401).f;
+var getOwnPropertyDescriptor = __webpack_require__(7825).f;
+var defineProperty = __webpack_require__(3376).f;
+var trim = __webpack_require__(7753).trim;
+
+var NUMBER = 'Number';
+var NativeNumber = global[NUMBER];
+var NumberPrototype = NativeNumber.prototype;
+
+// Opera ~12 has broken Object#toString
+var BROKEN_CLASSOF = classof(create(NumberPrototype)) == NUMBER;
+
+// `ToNumber` abstract operation
+// https://tc39.es/ecma262/#sec-tonumber
+var toNumber = function (argument) {
+  if (isSymbol(argument)) throw TypeError('Cannot convert a Symbol value to a number');
+  var it = toPrimitive(argument, 'number');
+  var first, third, radix, maxCode, digits, length, index, code;
+  if (typeof it == 'string' && it.length > 2) {
+    it = trim(it);
+    first = it.charCodeAt(0);
+    if (first === 43 || first === 45) {
+      third = it.charCodeAt(2);
+      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
+    } else if (first === 48) {
+      switch (it.charCodeAt(1)) {
+        case 66: case 98: radix = 2; maxCode = 49; break; // fast equal of /^0b[01]+$/i
+        case 79: case 111: radix = 8; maxCode = 55; break; // fast equal of /^0o[0-7]+$/i
+        default: return +it;
+      }
+      digits = it.slice(2);
+      length = digits.length;
+      for (index = 0; index < length; index++) {
+        code = digits.charCodeAt(index);
+        // parseInt parses a string to a first unavailable symbol
+        // but ToNumber should return NaN if a string contains unavailable symbols
+        if (code < 48 || code > maxCode) return NaN;
+      } return parseInt(digits, radix);
+    }
+  } return +it;
+};
+
+// `Number` constructor
+// https://tc39.es/ecma262/#sec-number-constructor
+if (isForced(NUMBER, !NativeNumber(' 0o1') || !NativeNumber('0b1') || NativeNumber('+0x1'))) {
+  var NumberWrapper = function Number(value) {
+    var it = arguments.length < 1 ? 0 : value;
+    var dummy = this;
+    return dummy instanceof NumberWrapper
+      // check on 1..constructor(foo) case
+      && (BROKEN_CLASSOF ? fails(function () { NumberPrototype.valueOf.call(dummy); }) : classof(dummy) != NUMBER)
+        ? inheritIfRequired(new NativeNumber(toNumber(it)), dummy, NumberWrapper) : toNumber(it);
+  };
+  for (var keys = DESCRIPTORS ? getOwnPropertyNames(NativeNumber) : (
+    // ES3:
+    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
+    // ES2015 (in case, if modules with ES2015 Number statics required before):
+    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +
+    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger,' +
+    // ESNext
+    'fromString,range'
+  ).split(','), j = 0, key; keys.length > j; j++) {
+    if (has(NativeNumber, key = keys[j]) && !has(NumberWrapper, key)) {
+      defineProperty(NumberWrapper, key, getOwnPropertyDescriptor(NativeNumber, key));
+    }
+  }
+  NumberWrapper.prototype = NumberPrototype;
+  NumberPrototype.constructor = NumberWrapper;
+  redefine(global, NUMBER, NumberWrapper);
+}
+
+
+/***/ }),
+
+/***/ 5957:
+/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+
+var $ = __webpack_require__(1082);
+var toInteger = __webpack_require__(7896);
+var thisNumberValue = __webpack_require__(7347);
+var repeat = __webpack_require__(6640);
+var fails = __webpack_require__(7841);
+
+var nativeToFixed = 1.0.toFixed;
+var floor = Math.floor;
+
+var pow = function (x, n, acc) {
+  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
+};
+
+var log = function (x) {
+  var n = 0;
+  var x2 = x;
+  while (x2 >= 4096) {
+    n += 12;
+    x2 /= 4096;
+  }
+  while (x2 >= 2) {
+    n += 1;
+    x2 /= 2;
+  } return n;
+};
+
+var multiply = function (data, n, c) {
+  var index = -1;
+  var c2 = c;
+  while (++index < 6) {
+    c2 += n * data[index];
+    data[index] = c2 % 1e7;
+    c2 = floor(c2 / 1e7);
+  }
+};
+
+var divide = function (data, n) {
+  var index = 6;
+  var c = 0;
+  while (--index >= 0) {
+    c += data[index];
+    data[index] = floor(c / n);
+    c = (c % n) * 1e7;
+  }
+};
+
+var dataToString = function (data) {
+  var index = 6;
+  var s = '';
+  while (--index >= 0) {
+    if (s !== '' || index === 0 || data[index] !== 0) {
+      var t = String(data[index]);
+      s = s === '' ? t : s + repeat.call('0', 7 - t.length) + t;
+    }
+  } return s;
+};
+
+var FORCED = nativeToFixed && (
+  0.00008.toFixed(3) !== '0.000' ||
+  0.9.toFixed(0) !== '1' ||
+  1.255.toFixed(2) !== '1.25' ||
+  1000000000000000128.0.toFixed(0) !== '1000000000000000128'
+) || !fails(function () {
+  // V8 ~ Android 4.3-
+  nativeToFixed.call({});
+});
+
+// `Number.prototype.toFixed` method
+// https://tc39.es/ecma262/#sec-number.prototype.tofixed
+$({ target: 'Number', proto: true, forced: FORCED }, {
+  toFixed: function toFixed(fractionDigits) {
+    var number = thisNumberValue(this);
+    var fractDigits = toInteger(fractionDigits);
+    var data = [0, 0, 0, 0, 0, 0];
+    var sign = '';
+    var result = '0';
+    var e, z, j, k;
+
+    if (fractDigits < 0 || fractDigits > 20) throw RangeError('Incorrect fraction digits');
+    // eslint-disable-next-line no-self-compare -- NaN check
+    if (number != number) return 'NaN';
+    if (number <= -1e21 || number >= 1e21) return String(number);
+    if (number < 0) {
+      sign = '-';
+      number = -number;
+    }
+    if (number > 1e-21) {
+      e = log(number * pow(2, 69, 1)) - 69;
+      z = e < 0 ? number * pow(2, -e, 1) : number / pow(2, e, 1);
+      z *= 0x10000000000000;
+      e = 52 - e;
+      if (e > 0) {
+        multiply(data, 0, z);
+        j = fractDigits;
+        while (j >= 7) {
+          multiply(data, 1e7, 0);
+          j -= 7;
+        }
+        multiply(data, pow(10, j, 1), 0);
+        j = e - 1;
+        while (j >= 23) {
+          divide(data, 1 << 23);
+          j -= 23;
+        }
+        divide(data, 1 << j);
+        multiply(data, 1, 1);
+        divide(data, 2);
+        result = dataToString(data);
+      } else {
+        multiply(data, 0, z);
+        multiply(data, 1 << -e, 0);
+        result = dataToString(data) + repeat.call('0', fractDigits);
+      }
+    }
+    if (fractDigits > 0) {
+      k = result.length;
+      result = sign + (k <= fractDigits
+        ? '0.' + repeat.call('0', fractDigits - k) + result
+        : result.slice(0, k - fractDigits) + '.' + result.slice(k - fractDigits));
+    } else {
+      result = sign + result;
+    } return result;
+  }
+});
+
+
+/***/ }),
+
+/***/ 5940:
+/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {
+
+var $ = __webpack_require__(1082);
+var assign = __webpack_require__(5277);
+
+// `Object.assign` method
+// https://tc39.es/ecma262/#sec-object.assign
+// eslint-disable-next-line es/no-object-assign -- required for testing
+$({ target: 'Object', stat: true, forced: Object.assign !== assign }, {
+  assign: assign
+});
+
+
+/***/ }),
+
+/***/ 5916:
+/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {
+
+var $ = __webpack_require__(1082);
+var $entries = __webpack_require__(8686).entries;
+
+// `Object.entries` method
+// https://tc39.es/ecma262/#sec-object.entries
+$({ target: 'Object', stat: true }, {
+  entries: function entries(O) {
+    return $entries(O);
+  }
+});
+
+
+/***/ }),
+
+/***/ 2512:
+/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {
+
+var $ = __webpack_require__(1082);
+var fails = __webpack_require__(7841);
+var toIndexedObject = __webpack_require__(8852);
+var nativeGetOwnPropertyDescriptor = __webpack_require__(7825).f;
+var DESCRIPTORS = __webpack_require__(5542);
+
+var FAILS_ON_PRIMITIVES = fails(function () { nativeGetOwnPropertyDescriptor(1); });
+var FORCED = !DESCRIPTORS || FAILS_ON_PRIMITIVES;
+
+// `Object.getOwnPropertyDescriptor` method
+// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
+$({ target: 'Object', stat: true, forced: FORCED, sham: !DESCRIPTORS }, {
+  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(it, key) {
+    return nativeGetOwnPropertyDescriptor(toIndexedObject(it), key);
+  }
+});
+
+
+/***/ }),
+
+/***/ 8574:
+/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {
+
+var $ = __webpack_require__(1082);
+var DESCRIPTORS = __webpack_require__(5542);
+var ownKeys = __webpack_require__(8204);
+var toIndexedObject = __webpack_require__(8852);
+var getOwnPropertyDescriptorModule = __webpack_require__(7825);
+var createProperty = __webpack_require__(2076);
+
+// `Object.getOwnPropertyDescriptors` method
+// https://tc39.es/ecma262/#sec-object.getownpropertydescriptors
+$({ target: 'Object', stat: true, sham: !DESCRIPTORS }, {
+  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
+    var O = toIndexedObject(object);
+    var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
+    var keys = ownKeys(O);
+    var result = {};
+    var index = 0;
+    var key, descriptor;
+    while (keys.length > index) {
+      descriptor = getOwnPropertyDescriptor(O, key = keys[index++]);
+      if (descriptor !== undefined) createProperty(result, key, descriptor);
+    }
+    return result;
+  }
+});
+
+
+/***/ }),
+
+/***/ 8400:
+/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {
+
+var $ = __webpack_require__(1082);
+var fails = __webpack_require__(7841);
+var toObject = __webpack_require__(4680);
+var nativeGetPrototypeOf = __webpack_require__(8186);
+var CORRECT_PROTOTYPE_GETTER = __webpack_require__(9241);
+
+var FAILS_ON_PRIMITIVES = fails(function () { nativeGetPrototypeOf(1); });
+
+// `Object.getPrototypeOf` method
+// https://tc39.es/ecma262/#sec-object.getprototypeof
+$({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES, sham: !CORRECT_PROTOTYPE_GETTER }, {
+  getPrototypeOf: function getPrototypeOf(it) {
+    return nativeGetPrototypeOf(toObject(it));
+  }
+});
+
+
+
+/***/ }),
+
+/***/ 9835:
+/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {
+
+var $ = __webpack_require__(1082);
+var toObject = __webpack_require__(4680);
+var nativeKeys = __webpack_require__(965);
+var fails = __webpack_require__(7841);
+
+var FAILS_ON_PRIMITIVES = fails(function () { nativeKeys(1); });
+
+// `Object.keys` method
+// https://tc39.es/ecma262/#sec-object.keys
+$({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES }, {
+  keys: function keys(it) {
+    return nativeKeys(toObject(it));
+  }
+});
+
+
+/***/ }),
+
+/***/ 1511:
+/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {
+
+var $ = __webpack_require__(1082);
+var setPrototypeOf = __webpack_require__(2686);
+
+// `Object.setPrototypeOf` method
+// https://tc39.es/ecma262/#sec-object.setprototypeof
+$({ target: 'Object', stat: true }, {
+  setPrototypeOf: setPrototypeOf
+});
+
+
+/***/ }),
+
+/***/ 74:
+/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {
+
+var TO_STRING_TAG_SUPPORT = __webpack_require__(939);
+var redefine = __webpack_require__(1249);
+var toString = __webpack_require__(1851);
+
+// `Object.prototype.toString` method
+// https://tc39.es/ecma262/#sec-object.prototype.tostring
+if (!TO_STRING_TAG_SUPPORT) {
+  redefine(Object.prototype, 'toString', toString, { unsafe: true });
+}
+
+
+/***/ }),
+
+/***/ 1337:
+/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+
+var $ = __webpack_require__(1082);
+var IS_PURE = __webpack_require__(6852);
+var global = __webpack_require__(6874);
+var getBuiltIn = __webpack_require__(4578);
+var NativePromise = __webpack_require__(6838);
+var redefine = __webpack_require__(1249);
+var redefineAll = __webpack_require__(7490);
+var setPrototypeOf = __webpack_require__(2686);
+var setToStringTag = __webpack_require__(9400);
+var setSpecies = __webpack_require__(8802);
+var isObject = __webpack_require__(6944);
+var aFunction = __webpack_require__(769);
+var anInstance = __webpack_require__(2482);
+var inspectSource = __webpack_require__(6090);
+var iterate = __webpack_require__(7093);
+var checkCorrectnessOfIteration = __webpack_require__(4585);
+var speciesConstructor = __webpack_require__(2004);
+var task = __webpack_require__(998).set;
+var microtask = __webpack_require__(6309);
+var promiseResolve = __webpack_require__(4022);
+var hostReportErrors = __webpack_require__(1250);
+var newPromiseCapabilityModule = __webpack_require__(7529);
+var perform = __webpack_require__(7105);
+var InternalStateModule = __webpack_require__(6619);
+var isForced = __webpack_require__(2350);
+var wellKnownSymbol = __webpack_require__(3706);
+var IS_BROWSER = __webpack_require__(206);
+var IS_NODE = __webpack_require__(8723);
+var V8_VERSION = __webpack_require__(579);
+
+var SPECIES = wellKnownSymbol('species');
+var PROMISE = 'Promise';
+var getInternalState = InternalStateModule.get;
+var setInternalState = InternalStateModule.set;
+var getInternalPromiseState = InternalStateModule.getterFor(PROMISE);
+var NativePromisePrototype = NativePromise && NativePromise.prototype;
+var PromiseConstructor = NativePromise;
+var PromiseConstructorPrototype = NativePromisePrototype;
+var TypeError = global.TypeError;
+var document = global.document;
+var process = global.process;
+var newPromiseCapability = newPromiseCapabilityModule.f;
+var newGenericPromiseCapability = newPromiseCapability;
+var DISPATCH_EVENT = !!(document && document.createEvent && global.dispatchEvent);
+var NATIVE_REJECTION_EVENT = typeof PromiseRejectionEvent == 'function';
+var UNHANDLED_REJECTION = 'unhandledrejection';
+var REJECTION_HANDLED = 'rejectionhandled';
+var PENDING = 0;
+var FULFILLED = 1;
+var REJECTED = 2;
+var HANDLED = 1;
+var UNHANDLED = 2;
+var SUBCLASSING = false;
+var Internal, OwnPromiseCapability, PromiseWrapper, nativeThen;
+
+var FORCED = isForced(PROMISE, function () {
+  var PROMISE_CONSTRUCTOR_SOURCE = inspectSource(PromiseConstructor);
+  var GLOBAL_CORE_JS_PROMISE = PROMISE_CONSTRUCTOR_SOURCE !== String(PromiseConstructor);
+  // V8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
+  // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
+  // We can't detect it synchronously, so just check versions
+  if (!GLOBAL_CORE_JS_PROMISE && V8_VERSION === 66) return true;
+  // We need Promise#finally in the pure version for preventing prototype pollution
+  if (IS_PURE && !PromiseConstructorPrototype['finally']) return true;
+  // We can't use @@species feature detection in V8 since it causes
+  // deoptimization and performance degradation
+  // https://github.com/zloirock/core-js/issues/679
+  if (V8_VERSION >= 51 && /native code/.test(PROMISE_CONSTRUCTOR_SOURCE)) return false;
+  // Detect correctness of subclassing with @@species support
+  var promise = new PromiseConstructor(function (resolve) { resolve(1); });
+  var FakePromise = function (exec) {
+    exec(function () { /* empty */ }, function () { /* empty */ });
+  };
+  var constructor = promise.constructor = {};
+  constructor[SPECIES] = FakePromise;
+  SUBCLASSING = promise.then(function () { /* empty */ }) instanceof FakePromise;
+  if (!SUBCLASSING) return true;
+  // Unhandled rejections tracking support, NodeJS Promise without it fails @@species test
+  return !GLOBAL_CORE_JS_PROMISE && IS_BROWSER && !NATIVE_REJECTION_EVENT;
+});
+
+var INCORRECT_ITERATION = FORCED || !checkCorrectnessOfIteration(function (iterable) {
+  PromiseConstructor.all(iterable)['catch'](function () { /* empty */ });
+});
+
+// helpers
+var isThenable = function (it) {
+  var then;
+  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
+};
+
+var notify = function (state, isReject) {
+  if (state.notified) return;
+  state.notified = true;
+  var chain = state.reactions;
+  microtask(function () {
+    var value = state.value;
+    var ok = state.state == FULFILLED;
+    var index = 0;
+    // variable length - can't use forEach
+    while (chain.length > index) {
+      var reaction = chain[index++];
+      var handler = ok ? reaction.ok : reaction.fail;
+      var resolve = reaction.resolve;
+      var reject = reaction.reject;
+      var domain = reaction.domain;
+      var result, then, exited;
+      try {
+        if (handler) {
+          if (!ok) {
+            if (state.rejection === UNHANDLED) onHandleUnhandled(state);
+            state.rejection = HANDLED;
+          }
+          if (handler === true) result = value;
+          else {
+            if (domain) domain.enter();
+            result = handler(value); // can throw
+            if (domain) {
+              domain.exit();
+              exited = true;
+            }
+          }
+          if (result === reaction.promise) {
+            reject(TypeError('Promise-chain cycle'));
+          } else if (then = isThenable(result)) {
+            then.call(result, resolve, reject);
+          } else resolve(result);
+        } else reject(value);
+      } catch (error) {
+        if (domain && !exited) domain.exit();
+        reject(error);
+      }
+    }
+    state.reactions = [];
+    state.notified = false;
+    if (isReject && !state.rejection) onUnhandled(state);
+  });
+};
+
+var dispatchEvent = function (name, promise, reason) {
+  var event, handler;
+  if (DISPATCH_EVENT) {
+    event = document.createEvent('Event');
+    event.promise = promise;
+    event.reason = reason;
+    event.initEvent(name, false, true);
+    global.dispatchEvent(event);
+  } else event = { promise: promise, reason: reason };
+  if (!NATIVE_REJECTION_EVENT && (handler = global['on' + name])) handler(event);
+  else if (name === UNHANDLED_REJECTION) hostReportErrors('Unhandled promise rejection', reason);
+};
+
+var onUnhandled = function (state) {
+  task.call(global, function () {
+    var promise = state.facade;
+    var value = state.value;
+    var IS_UNHANDLED = isUnhandled(state);
+    var result;
+    if (IS_UNHANDLED) {
+      result = perform(function () {
+        if (IS_NODE) {
+          process.emit('unhandledRejection', value, promise);
+        } else dispatchEvent(UNHANDLED_REJECTION, promise, value);
+      });
+      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
+      state.rejection = IS_NODE || isUnhandled(state) ? UNHANDLED : HANDLED;
+      if (result.error) throw result.value;
+    }
+  });
+};
+
+var isUnhandled = function (state) {
+  return state.rejection !== HANDLED && !state.parent;
+};
+
+var onHandleUnhandled = function (state) {
+  task.call(global, function () {
+    var promise = state.facade;
+    if (IS_NODE) {
+      process.emit('rejectionHandled', promise);
+    } else dispatchEvent(REJECTION_HANDLED, promise, state.value);
+  });
+};
+
+var bind = function (fn, state, unwrap) {
+  return function (value) {
+    fn(state, value, unwrap);
+  };
+};
+
+var internalReject = function (state, value, unwrap) {
+  if (state.done) return;
+  state.done = true;
+  if (unwrap) state = unwrap;
+  state.value = value;
+  state.state = REJECTED;
+  notify(state, true);
+};
+
+var internalResolve = function (state, value, unwrap) {
+  if (state.done) return;
+  state.done = true;
+  if (unwrap) state = unwrap;
+  try {
+    if (state.facade === value) throw TypeError("Promise can't be resolved itself");
+    var then = isThenable(value);
+    if (then) {
+      microtask(function () {
+        var wrapper = { done: false };
+        try {
+          then.call(value,
+            bind(internalResolve, wrapper, state),
+            bind(internalReject, wrapper, state)
+          );
+        } catch (error) {
+          internalReject(wrapper, error, state);
+        }
+      });
+    } else {
+      state.value = value;
+      state.state = FULFILLED;
+      notify(state, false);
+    }
+  } catch (error) {
+    internalReject({ done: false }, error, state);
+  }
+};
+
+// constructor polyfill
+if (FORCED) {
+  // 25.4.3.1 Promise(executor)
+  PromiseConstructor = function Promise(executor) {
+    anInstance(this, PromiseConstructor, PROMISE);
+    aFunction(executor);
+    Internal.call(this);
+    var state = getInternalState(this);
+    try {
+      executor(bind(internalResolve, state), bind(internalReject, state));
+    } catch (error) {
+      internalReject(state, error);
+    }
+  };
+  PromiseConstructorPrototype = PromiseConstructor.prototype;
+  // eslint-disable-next-line no-unused-vars -- required for `.length`
+  Internal = function Promise(executor) {
+    setInternalState(this, {
+      type: PROMISE,
+      done: false,
+      notified: false,
+      parent: false,
+      reactions: [],
+      rejection: false,
+      state: PENDING,
+      value: undefined
+    });
+  };
+  Internal.prototype = redefineAll(PromiseConstructorPrototype, {
+    // `Promise.prototype.then` method
+    // https://tc39.es/ecma262/#sec-promise.prototype.then
+    then: function then(onFulfilled, onRejected) {
+      var state = getInternalPromiseState(this);
+      var reaction = newPromiseCapability(speciesConstructor(this, PromiseConstructor));
+      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
+      reaction.fail = typeof onRejected == 'function' && onRejected;
+      reaction.domain = IS_NODE ? process.domain : undefined;
+      state.parent = true;
+      state.reactions.push(reaction);
+      if (state.state != PENDING) notify(state, false);
+      return reaction.promise;
+    },
+    // `Promise.prototype.catch` method
+    // https://tc39.es/ecma262/#sec-promise.prototype.catch
+    'catch': function (onRejected) {
+      return this.then(undefined, onRejected);
+    }
+  });
+  OwnPromiseCapability = function () {
+    var promise = new Internal();
+    var state = getInternalState(promise);
+    this.promise = promise;
+    this.resolve = bind(internalResolve, state);
+    this.reject = bind(internalReject, state);
+  };
+  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
+    return C === PromiseConstructor || C === PromiseWrapper
+      ? new OwnPromiseCapability(C)
+      : newGenericPromiseCapability(C);
+  };
+
+  if (!IS_PURE && typeof NativePromise == 'function' && NativePromisePrototype !== Object.prototype) {
+    nativeThen = NativePromisePrototype.then;
+
+    if (!SUBCLASSING) {
+      // make `Promise#then` return a polyfilled `Promise` for native promise-based APIs
+      redefine(NativePromisePrototype, 'then', function then(onFulfilled, onRejected) {
+        var that = this;
+        return new PromiseConstructor(function (resolve, reject) {
+          nativeThen.call(that, resolve, reject);
+        }).then(onFulfilled, onRejected);
+      // https://github.com/zloirock/core-js/issues/640
+      }, { unsafe: true });
+
+      // makes sure that native promise-based APIs `Promise#catch` properly works with patched `Promise#then`
+      redefine(NativePromisePrototype, 'catch', PromiseConstructorPrototype['catch'], { unsafe: true });
+    }
+
+    // make `.constructor === Promise` work for native promise-based APIs
+    try {
+      delete NativePromisePrototype.constructor;
+    } catch (error) { /* empty */ }
+
+    // make `instanceof Promise` work for native promise-based APIs
+    if (setPrototypeOf) {
+      setPrototypeOf(NativePromisePrototype, PromiseConstructorPrototype);
+    }
+  }
+}
+
+$({ global: true, wrap: true, forced: FORCED }, {
+  Promise: PromiseConstructor
+});
+
+setToStringTag(PromiseConstructor, PROMISE, false, true);
+setSpecies(PROMISE);
+
+PromiseWrapper = getBuiltIn(PROMISE);
+
+// statics
+$({ target: PROMISE, stat: true, forced: FORCED }, {
+  // `Promise.reject` method
+  // https://tc39.es/ecma262/#sec-promise.reject
+  reject: function reject(r) {
+    var capability = newPromiseCapability(this);
+    capability.reject.call(undefined, r);
+    return capability.promise;
+  }
+});
+
+$({ target: PROMISE, stat: true, forced: IS_PURE || FORCED }, {
+  // `Promise.resolve` method
+  // https://tc39.es/ecma262/#sec-promise.resolve
+  resolve: function resolve(x) {
+    return promiseResolve(IS_PURE && this === PromiseWrapper ? PromiseConstructor : this, x);
+  }
+});
+
+$({ target: PROMISE, stat: true, forced: INCORRECT_ITERATION }, {
+  // `Promise.all` method
+  // https://tc39.es/ecma262/#sec-promise.all
+  all: function all(iterable) {
+    var C = this;
+    var capability = newPromiseCapability(C);
+    var resolve = capability.resolve;
+    var reject = capability.reject;
+    var result = perform(function () {
+      var $promiseResolve = aFunction(C.resolve);
+      var values = [];
+      var counter = 0;
+      var remaining = 1;
+      iterate(iterable, function (promise) {
+        var index = counter++;
+        var alreadyCalled = false;
+        values.push(undefined);
+        remaining++;
+        $promiseResolve.call(C, promise).then(function (value) {
+          if (alreadyCalled) return;
+          alreadyCalled = true;
+          values[index] = value;
+          --remaining || resolve(values);
+        }, reject);
+      });
+      --remaining || resolve(values);
+    });
+    if (result.error) reject(result.value);
+    return capability.promise;
+  },
+  // `Promise.race` method
+  // https://tc39.es/ecma262/#sec-promise.race
+  race: function race(iterable) {
+    var C = this;
+    var capability = newPromiseCapability(C);
+    var reject = capability.reject;
+    var result = perform(function () {
+      var $promiseResolve = aFunction(C.resolve);
+      iterate(iterable, function (promise) {
+        $promiseResolve.call(C, promise).then(capability.resolve, reject);
+      });
+    });
+    if (result.error) reject(result.value);
+    return capability.promise;
+  }
+});
+
+
+/***/ }),
+
+/***/ 6259:
+/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {
+
+var $ = __webpack_require__(1082);
+var getBuiltIn = __webpack_require__(4578);
+var aFunction = __webpack_require__(769);
+var anObject = __webpack_require__(47);
+var isObject = __webpack_require__(6944);
+var create = __webpack_require__(2361);
+var bind = __webpack_require__(5462);
+var fails = __webpack_require__(7841);
+
+var nativeConstruct = getBuiltIn('Reflect', 'construct');
+
+// `Reflect.construct` method
+// https://tc39.es/ecma262/#sec-reflect.construct
+// MS Edge supports only 2 arguments and argumentsList argument is optional
+// FF Nightly sets third argument as `new.target`, but does not create `this` from it
+var NEW_TARGET_BUG = fails(function () {
+  function F() { /* empty */ }
+  return !(nativeConstruct(function () { /* empty */ }, [], F) instanceof F);
+});
+var ARGS_BUG = !fails(function () {
+  nativeConstruct(function () { /* empty */ });
+});
+var FORCED = NEW_TARGET_BUG || ARGS_BUG;
+
+$({ target: 'Reflect', stat: true, forced: FORCED, sham: FORCED }, {
+  construct: function construct(Target, args /* , newTarget */) {
+    aFunction(Target);
+    anObject(args);
+    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
+    if (ARGS_BUG && !NEW_TARGET_BUG) return nativeConstruct(Target, args, newTarget);
+    if (Target == newTarget) {
+      // w/o altered newTarget, optimization for 0-4 arguments
+      switch (args.length) {
+        case 0: return new Target();
+        case 1: return new Target(args[0]);
+        case 2: return new Target(args[0], args[1]);
+        case 3: return new Target(args[0], args[1], args[2]);
+        case 4: return new Target(args[0], args[1], args[2], args[3]);
+      }
+      // w/o altered newTarget, lot of arguments case
+      var $args = [null];
+      $args.push.apply($args, args);
+      return new (bind.apply(Target, $args))();
+    }
+    // with altered newTarget, not support built-in constructors
+    var proto = newTarget.prototype;
+    var instance = create(isObject(proto) ? proto : Object.prototype);
+    var result = Function.apply.call(Target, instance, args);
+    return isObject(result) ? result : instance;
+  }
+});
+
+
+/***/ }),
+
+/***/ 1818:
+/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+
+var $ = __webpack_require__(1082);
+var exec = __webpack_require__(1144);
+
+// `RegExp.prototype.exec` method
+// https://tc39.es/ecma262/#sec-regexp.prototype.exec
+$({ target: 'RegExp', proto: true, forced: /./.exec !== exec }, {
+  exec: exec
+});
+
+
+/***/ }),
+
+/***/ 5699:
+/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+
+var redefine = __webpack_require__(1249);
+var anObject = __webpack_require__(47);
+var $toString = __webpack_require__(401);
+var fails = __webpack_require__(7841);
+var flags = __webpack_require__(9262);
+
+var TO_STRING = 'toString';
+var RegExpPrototype = RegExp.prototype;
+var nativeToString = RegExpPrototype[TO_STRING];
+
+var NOT_GENERIC = fails(function () { return nativeToString.call({ source: 'a', flags: 'b' }) != '/a/b'; });
+// FF44- RegExp#toString has a wrong name
+var INCORRECT_NAME = nativeToString.name != TO_STRING;
+
+// `RegExp.prototype.toString` method
+// https://tc39.es/ecma262/#sec-regexp.prototype.tostring
+if (NOT_GENERIC || INCORRECT_NAME) {
+  redefine(RegExp.prototype, TO_STRING, function toString() {
+    var R = anObject(this);
+    var p = $toString(R.source);
+    var rf = R.flags;
+    var f = $toString(rf === undefined && R instanceof RegExp && !('flags' in RegExpPrototype) ? flags.call(R) : rf);
+    return '/' + p + '/' + f;
+  }, { unsafe: true });
+}
+
+
+/***/ }),
+
+/***/ 461:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+
+var collection = __webpack_require__(6935);
+var collectionStrong = __webpack_require__(6955);
+
+// `Set` constructor
+// https://tc39.es/ecma262/#sec-set-objects
+module.exports = collection('Set', function (init) {
+  return function Set() { return init(this, arguments.length ? arguments[0] : undefined); };
+}, collectionStrong);
+
+
+/***/ }),
+
+/***/ 6837:
+/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+
+var $ = __webpack_require__(1082);
+var notARegExp = __webpack_require__(4315);
+var requireObjectCoercible = __webpack_require__(164);
+var toString = __webpack_require__(401);
+var correctIsRegExpLogic = __webpack_require__(6870);
+
+// `String.prototype.includes` method
+// https://tc39.es/ecma262/#sec-string.prototype.includes
+$({ target: 'String', proto: true, forced: !correctIsRegExpLogic('includes') }, {
+  includes: function includes(searchString /* , position = 0 */) {
+    return !!~toString(requireObjectCoercible(this))
+      .indexOf(toString(notARegExp(searchString)), arguments.length > 1 ? arguments[1] : undefined);
+  }
+});
+
+
+/***/ }),
+
+/***/ 6949:
+/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+
+var charAt = __webpack_require__(6174).charAt;
+var toString = __webpack_require__(401);
+var InternalStateModule = __webpack_require__(6619);
+var defineIterator = __webpack_require__(3131);
+
+var STRING_ITERATOR = 'String Iterator';
+var setInternalState = InternalStateModule.set;
+var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);
+
+// `String.prototype[@@iterator]` method
+// https://tc39.es/ecma262/#sec-string.prototype-@@iterator
+defineIterator(String, 'String', function (iterated) {
+  setInternalState(this, {
+    type: STRING_ITERATOR,
+    string: toString(iterated),
+    index: 0
+  });
+// `%StringIteratorPrototype%.next` method
+// https://tc39.es/ecma262/#sec-%stringiteratorprototype%.next
+}, function next() {
+  var state = getInternalState(this);
+  var string = state.string;
+  var index = state.index;
+  var point;
+  if (index >= string.length) return { value: undefined, done: true };
+  point = charAt(string, index);
+  state.index += point.length;
+  return { value: point, done: false };
+});
+
+
+/***/ }),
+
+/***/ 7505:
+/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+
+var fixRegExpWellKnownSymbolLogic = __webpack_require__(6918);
+var anObject = __webpack_require__(47);
+var toLength = __webpack_require__(4954);
+var toString = __webpack_require__(401);
+var requireObjectCoercible = __webpack_require__(164);
+var advanceStringIndex = __webpack_require__(1866);
+var regExpExec = __webpack_require__(3915);
+
+// @@match logic
+fixRegExpWellKnownSymbolLogic('match', function (MATCH, nativeMatch, maybeCallNative) {
+  return [
+    // `String.prototype.match` method
+    // https://tc39.es/ecma262/#sec-string.prototype.match
+    function match(regexp) {
+      var O = requireObjectCoercible(this);
+      var matcher = regexp == undefined ? undefined : regexp[MATCH];
+      return matcher !== undefined ? matcher.call(regexp, O) : new RegExp(regexp)[MATCH](toString(O));
+    },
+    // `RegExp.prototype[@@match]` method
+    // https://tc39.es/ecma262/#sec-regexp.prototype-@@match
+    function (string) {
+      var rx = anObject(this);
+      var S = toString(string);
+      var res = maybeCallNative(nativeMatch, rx, S);
+
+      if (res.done) return res.value;
+
+      if (!rx.global) return regExpExec(rx, S);
+
+      var fullUnicode = rx.unicode;
+      rx.lastIndex = 0;
+      var A = [];
+      var n = 0;
+      var result;
+      while ((result = regExpExec(rx, S)) !== null) {
+        var matchStr = toString(result[0]);
+        A[n] = matchStr;
+        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
+        n++;
+      }
+      return n === 0 ? null : A;
+    }
+  ];
+});
+
+
+/***/ }),
+
+/***/ 3292:
+/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+
+var $ = __webpack_require__(1082);
+var $padStart = __webpack_require__(9534).start;
+var WEBKIT_BUG = __webpack_require__(4931);
+
+// `String.prototype.padStart` method
+// https://tc39.es/ecma262/#sec-string.prototype.padstart
+$({ target: 'String', proto: true, forced: WEBKIT_BUG }, {
+  padStart: function padStart(maxLength /* , fillString = ' ' */) {
+    return $padStart(this, maxLength, arguments.length > 1 ? arguments[1] : undefined);
+  }
+});
+
+
+/***/ }),
+
+/***/ 4750:
+/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {
+
+var $ = __webpack_require__(1082);
+var repeat = __webpack_require__(6640);
+
+// `String.prototype.repeat` method
+// https://tc39.es/ecma262/#sec-string.prototype.repeat
+$({ target: 'String', proto: true }, {
+  repeat: repeat
+});
+
+
+/***/ }),
+
+/***/ 4449:
+/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+
+var fixRegExpWellKnownSymbolLogic = __webpack_require__(6918);
+var fails = __webpack_require__(7841);
+var anObject = __webpack_require__(47);
+var toInteger = __webpack_require__(7896);
+var toLength = __webpack_require__(4954);
+var toString = __webpack_require__(401);
+var requireObjectCoercible = __webpack_require__(164);
+var advanceStringIndex = __webpack_require__(1866);
+var getSubstitution = __webpack_require__(9);
+var regExpExec = __webpack_require__(3915);
+var wellKnownSymbol = __webpack_require__(3706);
+
+var REPLACE = wellKnownSymbol('replace');
+var max = Math.max;
+var min = Math.min;
+
+var maybeToString = function (it) {
+  return it === undefined ? it : String(it);
+};
+
+// IE <= 11 replaces $0 with the whole match, as if it was $&
+// https://stackoverflow.com/questions/6024666/getting-ie-to-replace-a-regex-with-the-literal-string-0
+var REPLACE_KEEPS_$0 = (function () {
+  // eslint-disable-next-line regexp/prefer-escape-replacement-dollar-char -- required for testing
+  return 'a'.replace(/./, '$0') === '$0';
+})();
+
+// Safari <= 13.0.3(?) substitutes nth capture where n>m with an empty string
+var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = (function () {
+  if (/./[REPLACE]) {
+    return /./[REPLACE]('a', '$0') === '';
+  }
+  return false;
+})();
+
+var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
+  var re = /./;
+  re.exec = function () {
+    var result = [];
+    result.groups = { a: '7' };
+    return result;
+  };
+  // eslint-disable-next-line regexp/no-useless-dollar-replacements -- false positive
+  return ''.replace(re, '$<a>') !== '7';
+});
+
+// @@replace logic
+fixRegExpWellKnownSymbolLogic('replace', function (_, nativeReplace, maybeCallNative) {
+  var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? '$' : '$0';
+
+  return [
+    // `String.prototype.replace` method
+    // https://tc39.es/ecma262/#sec-string.prototype.replace
+    function replace(searchValue, replaceValue) {
+      var O = requireObjectCoercible(this);
+      var replacer = searchValue == undefined ? undefined : searchValue[REPLACE];
+      return replacer !== undefined
+        ? replacer.call(searchValue, O, replaceValue)
+        : nativeReplace.call(toString(O), searchValue, replaceValue);
+    },
+    // `RegExp.prototype[@@replace]` method
+    // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
+    function (string, replaceValue) {
+      var rx = anObject(this);
+      var S = toString(string);
+
+      if (
+        typeof replaceValue === 'string' &&
+        replaceValue.indexOf(UNSAFE_SUBSTITUTE) === -1 &&
+        replaceValue.indexOf('$<') === -1
+      ) {
+        var res = maybeCallNative(nativeReplace, rx, S, replaceValue);
+        if (res.done) return res.value;
+      }
+
+      var functionalReplace = typeof replaceValue === 'function';
+      if (!functionalReplace) replaceValue = toString(replaceValue);
+
+      var global = rx.global;
+      if (global) {
+        var fullUnicode = rx.unicode;
+        rx.lastIndex = 0;
+      }
+      var results = [];
+      while (true) {
+        var result = regExpExec(rx, S);
+        if (result === null) break;
+
+        results.push(result);
+        if (!global) break;
+
+        var matchStr = toString(result[0]);
+        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
+      }
+
+      var accumulatedResult = '';
+      var nextSourcePosition = 0;
+      for (var i = 0; i < results.length; i++) {
+        result = results[i];
+
+        var matched = toString(result[0]);
+        var position = max(min(toInteger(result.index), S.length), 0);
+        var captures = [];
+        // NOTE: This is equivalent to
+        //   captures = result.slice(1).map(maybeToString)
+        // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
+        // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
+        // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.
+        for (var j = 1; j < result.length; j++) captures.push(maybeToString(result[j]));
+        var namedCaptures = result.groups;
+        if (functionalReplace) {
+          var replacerArgs = [matched].concat(captures, position, S);
+          if (namedCaptures !== undefined) replacerArgs.push(namedCaptures);
+          var replacement = toString(replaceValue.apply(undefined, replacerArgs));
+        } else {
+          replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
+        }
+        if (position >= nextSourcePosition) {
+          accumulatedResult += S.slice(nextSourcePosition, position) + replacement;
+          nextSourcePosition = position + matched.length;
+        }
+      }
+      return accumulatedResult + S.slice(nextSourcePosition);
+    }
+  ];
+}, !REPLACE_SUPPORTS_NAMED_GROUPS || !REPLACE_KEEPS_$0 || REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE);
+
+
+/***/ }),
+
+/***/ 1661:
+/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+
+var fixRegExpWellKnownSymbolLogic = __webpack_require__(6918);
+var isRegExp = __webpack_require__(2399);
+var anObject = __webpack_require__(47);
+var requireObjectCoercible = __webpack_require__(164);
+var speciesConstructor = __webpack_require__(2004);
+var advanceStringIndex = __webpack_require__(1866);
+var toLength = __webpack_require__(4954);
+var toString = __webpack_require__(401);
+var callRegExpExec = __webpack_require__(3915);
+var regexpExec = __webpack_require__(1144);
+var stickyHelpers = __webpack_require__(768);
+var fails = __webpack_require__(7841);
+
+var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y;
+var arrayPush = [].push;
+var min = Math.min;
+var MAX_UINT32 = 0xFFFFFFFF;
+
+// Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
+// Weex JS has frozen built-in prototypes, so use try / catch wrapper
+var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function () {
+  // eslint-disable-next-line regexp/no-empty-group -- required for testing
+  var re = /(?:)/;
+  var originalExec = re.exec;
+  re.exec = function () { return originalExec.apply(this, arguments); };
+  var result = 'ab'.split(re);
+  return result.length !== 2 || result[0] !== 'a' || result[1] !== 'b';
+});
+
+// @@split logic
+fixRegExpWellKnownSymbolLogic('split', function (SPLIT, nativeSplit, maybeCallNative) {
+  var internalSplit;
+  if (
+    'abbc'.split(/(b)*/)[1] == 'c' ||
+    // eslint-disable-next-line regexp/no-empty-group -- required for testing
+    'test'.split(/(?:)/, -1).length != 4 ||
+    'ab'.split(/(?:ab)*/).length != 2 ||
+    '.'.split(/(.?)(.?)/).length != 4 ||
+    // eslint-disable-next-line regexp/no-empty-capturing-group, regexp/no-empty-group -- required for testing
+    '.'.split(/()()/).length > 1 ||
+    ''.split(/.?/).length
+  ) {
+    // based on es5-shim implementation, need to rework it
+    internalSplit = function (separator, limit) {
+      var string = toString(requireObjectCoercible(this));
+      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
+      if (lim === 0) return [];
+      if (separator === undefined) return [string];
+      // If `separator` is not a regex, use native split
+      if (!isRegExp(separator)) {
+        return nativeSplit.call(string, separator, lim);
+      }
+      var output = [];
+      var flags = (separator.ignoreCase ? 'i' : '') +
+                  (separator.multiline ? 'm' : '') +
+                  (separator.unicode ? 'u' : '') +
+                  (separator.sticky ? 'y' : '');
+      var lastLastIndex = 0;
+      // Make `global` and avoid `lastIndex` issues by working with a copy
+      var separatorCopy = new RegExp(separator.source, flags + 'g');
+      var match, lastIndex, lastLength;
+      while (match = regexpExec.call(separatorCopy, string)) {
+        lastIndex = separatorCopy.lastIndex;
+        if (lastIndex > lastLastIndex) {
+          output.push(string.slice(lastLastIndex, match.index));
+          if (match.length > 1 && match.index < string.length) arrayPush.apply(output, match.slice(1));
+          lastLength = match[0].length;
+          lastLastIndex = lastIndex;
+          if (output.length >= lim) break;
+        }
+        if (separatorCopy.lastIndex === match.index) separatorCopy.lastIndex++; // Avoid an infinite loop
+      }
+      if (lastLastIndex === string.length) {
+        if (lastLength || !separatorCopy.test('')) output.push('');
+      } else output.push(string.slice(lastLastIndex));
+      return output.length > lim ? output.slice(0, lim) : output;
+    };
+  // Chakra, V8
+  } else if ('0'.split(undefined, 0).length) {
+    internalSplit = function (separator, limit) {
+      return separator === undefined && limit === 0 ? [] : nativeSplit.call(this, separator, limit);
+    };
+  } else internalSplit = nativeSplit;
+
+  return [
+    // `String.prototype.split` method
+    // https://tc39.es/ecma262/#sec-string.prototype.split
+    function split(separator, limit) {
+      var O = requireObjectCoercible(this);
+      var splitter = separator == undefined ? undefined : separator[SPLIT];
+      return splitter !== undefined
+        ? splitter.call(separator, O, limit)
+        : internalSplit.call(toString(O), separator, limit);
+    },
+    // `RegExp.prototype[@@split]` method
+    // https://tc39.es/ecma262/#sec-regexp.prototype-@@split
+    //
+    // NOTE: This cannot be properly polyfilled in engines that don't support
+    // the 'y' flag.
+    function (string, limit) {
+      var rx = anObject(this);
+      var S = toString(string);
+      var res = maybeCallNative(internalSplit, rx, S, limit, internalSplit !== nativeSplit);
+
+      if (res.done) return res.value;
+
+      var C = speciesConstructor(rx, RegExp);
+
+      var unicodeMatching = rx.unicode;
+      var flags = (rx.ignoreCase ? 'i' : '') +
+                  (rx.multiline ? 'm' : '') +
+                  (rx.unicode ? 'u' : '') +
+                  (UNSUPPORTED_Y ? 'g' : 'y');
+
+      // ^(? + rx + ) is needed, in combination with some S slicing, to
+      // simulate the 'y' flag.
+      var splitter = new C(UNSUPPORTED_Y ? '^(?:' + rx.source + ')' : rx, flags);
+      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
+      if (lim === 0) return [];
+      if (S.length === 0) return callRegExpExec(splitter, S) === null ? [S] : [];
+      var p = 0;
+      var q = 0;
+      var A = [];
+      while (q < S.length) {
+        splitter.lastIndex = UNSUPPORTED_Y ? 0 : q;
+        var z = callRegExpExec(splitter, UNSUPPORTED_Y ? S.slice(q) : S);
+        var e;
+        if (
+          z === null ||
+          (e = min(toLength(splitter.lastIndex + (UNSUPPORTED_Y ? q : 0)), S.length)) === p
+        ) {
+          q = advanceStringIndex(S, q, unicodeMatching);
+        } else {
+          A.push(S.slice(p, q));
+          if (A.length === lim) return A;
+          for (var i = 1; i <= z.length - 1; i++) {
+            A.push(z[i]);
+            if (A.length === lim) return A;
+          }
+          q = p = e;
+        }
+      }
+      A.push(S.slice(p));
+      return A;
+    }
+  ];
+}, !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC, UNSUPPORTED_Y);
+
+
+/***/ }),
+
+/***/ 9340:
+/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+
+var $ = __webpack_require__(1082);
+var $trim = __webpack_require__(7753).trim;
+var forcedStringTrimMethod = __webpack_require__(5206);
+
+// `String.prototype.trim` method
+// https://tc39.es/ecma262/#sec-string.prototype.trim
+$({ target: 'String', proto: true, forced: forcedStringTrimMethod('trim') }, {
+  trim: function trim() {
+    return $trim(this);
+  }
+});
+
+
+/***/ }),
+
+/***/ 8787:
+/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+// `Symbol.prototype.description` getter
+// https://tc39.es/ecma262/#sec-symbol.prototype.description
+
+var $ = __webpack_require__(1082);
+var DESCRIPTORS = __webpack_require__(5542);
+var global = __webpack_require__(6874);
+var has = __webpack_require__(5884);
+var isObject = __webpack_require__(6944);
+var defineProperty = __webpack_require__(3376).f;
+var copyConstructorProperties = __webpack_require__(7918);
+
+var NativeSymbol = global.Symbol;
+
+if (DESCRIPTORS && typeof NativeSymbol == 'function' && (!('description' in NativeSymbol.prototype) ||
+  // Safari 12 bug
+  NativeSymbol().description !== undefined
+)) {
+  var EmptyStringDescriptionStore = {};
+  // wrap Symbol constructor for correct work with undefined description
+  var SymbolWrapper = function Symbol() {
+    var description = arguments.length < 1 || arguments[0] === undefined ? undefined : String(arguments[0]);
+    var result = this instanceof SymbolWrapper
+      ? new NativeSymbol(description)
+      // in Edge 13, String(Symbol(undefined)) === 'Symbol(undefined)'
+      : description === undefined ? NativeSymbol() : NativeSymbol(description);
+    if (description === '') EmptyStringDescriptionStore[result] = true;
+    return result;
+  };
+  copyConstructorProperties(SymbolWrapper, NativeSymbol);
+  var symbolPrototype = SymbolWrapper.prototype = NativeSymbol.prototype;
+  symbolPrototype.constructor = SymbolWrapper;
+
+  var symbolToString = symbolPrototype.toString;
+  var native = String(NativeSymbol('test')) == 'Symbol(test)';
+  var regexp = /^Symbol\((.*)\)[^)]+$/;
+  defineProperty(symbolPrototype, 'description', {
+    configurable: true,
+    get: function description() {
+      var symbol = isObject(this) ? this.valueOf() : this;
+      var string = symbolToString.call(symbol);
+      if (has(EmptyStringDescriptionStore, symbol)) return '';
+      var desc = native ? string.slice(7, -1) : string.replace(regexp, '$1');
+      return desc === '' ? undefined : desc;
+    }
+  });
+
+  $({ global: true, forced: true }, {
+    Symbol: SymbolWrapper
+  });
+}
+
+
+/***/ }),
+
+/***/ 5753:
+/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {
+
+var defineWellKnownSymbol = __webpack_require__(1578);
+
+// `Symbol.iterator` well-known symbol
+// https://tc39.es/ecma262/#sec-symbol.iterator
+defineWellKnownSymbol('iterator');
+
+
+/***/ }),
+
+/***/ 7404:
+/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+
+var $ = __webpack_require__(1082);
+var global = __webpack_require__(6874);
+var getBuiltIn = __webpack_require__(4578);
+var IS_PURE = __webpack_require__(6852);
+var DESCRIPTORS = __webpack_require__(5542);
+var NATIVE_SYMBOL = __webpack_require__(1453);
+var fails = __webpack_require__(7841);
+var has = __webpack_require__(5884);
+var isArray = __webpack_require__(7828);
+var isObject = __webpack_require__(6944);
+var isSymbol = __webpack_require__(8377);
+var anObject = __webpack_require__(47);
+var toObject = __webpack_require__(4680);
+var toIndexedObject = __webpack_require__(8852);
+var toPropertyKey = __webpack_require__(2694);
+var $toString = __webpack_require__(401);
+var createPropertyDescriptor = __webpack_require__(976);
+var nativeObjectCreate = __webpack_require__(2361);
+var objectKeys = __webpack_require__(965);
+var getOwnPropertyNamesModule = __webpack_require__(8401);
+var getOwnPropertyNamesExternal = __webpack_require__(3866);
+var getOwnPropertySymbolsModule = __webpack_require__(1913);
+var getOwnPropertyDescriptorModule = __webpack_require__(7825);
+var definePropertyModule = __webpack_require__(3376);
+var propertyIsEnumerableModule = __webpack_require__(3626);
+var createNonEnumerableProperty = __webpack_require__(4791);
+var redefine = __webpack_require__(1249);
+var shared = __webpack_require__(3215);
+var sharedKey = __webpack_require__(8698);
+var hiddenKeys = __webpack_require__(5644);
+var uid = __webpack_require__(8435);
+var wellKnownSymbol = __webpack_require__(3706);
+var wrappedWellKnownSymbolModule = __webpack_require__(8403);
+var defineWellKnownSymbol = __webpack_require__(1578);
+var setToStringTag = __webpack_require__(9400);
+var InternalStateModule = __webpack_require__(6619);
+var $forEach = __webpack_require__(6374).forEach;
+
+var HIDDEN = sharedKey('hidden');
+var SYMBOL = 'Symbol';
+var PROTOTYPE = 'prototype';
+var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');
+var setInternalState = InternalStateModule.set;
+var getInternalState = InternalStateModule.getterFor(SYMBOL);
+var ObjectPrototype = Object[PROTOTYPE];
+var $Symbol = global.Symbol;
+var $stringify = getBuiltIn('JSON', 'stringify');
+var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
+var nativeDefineProperty = definePropertyModule.f;
+var nativeGetOwnPropertyNames = getOwnPropertyNamesExternal.f;
+var nativePropertyIsEnumerable = propertyIsEnumerableModule.f;
+var AllSymbols = shared('symbols');
+var ObjectPrototypeSymbols = shared('op-symbols');
+var StringToSymbolRegistry = shared('string-to-symbol-registry');
+var SymbolToStringRegistry = shared('symbol-to-string-registry');
+var WellKnownSymbolsStore = shared('wks');
+var QObject = global.QObject;
+// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
+var USE_SETTER = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;
+
+// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
+var setSymbolDescriptor = DESCRIPTORS && fails(function () {
+  return nativeObjectCreate(nativeDefineProperty({}, 'a', {
+    get: function () { return nativeDefineProperty(this, 'a', { value: 7 }).a; }
+  })).a != 7;
+}) ? function (O, P, Attributes) {
+  var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor(ObjectPrototype, P);
+  if (ObjectPrototypeDescriptor) delete ObjectPrototype[P];
+  nativeDefineProperty(O, P, Attributes);
+  if (ObjectPrototypeDescriptor && O !== ObjectPrototype) {
+    nativeDefineProperty(ObjectPrototype, P, ObjectPrototypeDescriptor);
+  }
+} : nativeDefineProperty;
+
+var wrap = function (tag, description) {
+  var symbol = AllSymbols[tag] = nativeObjectCreate($Symbol[PROTOTYPE]);
+  setInternalState(symbol, {
+    type: SYMBOL,
+    tag: tag,
+    description: description
+  });
+  if (!DESCRIPTORS) symbol.description = description;
+  return symbol;
+};
+
+var $defineProperty = function defineProperty(O, P, Attributes) {
+  if (O === ObjectPrototype) $defineProperty(ObjectPrototypeSymbols, P, Attributes);
+  anObject(O);
+  var key = toPropertyKey(P);
+  anObject(Attributes);
+  if (has(AllSymbols, key)) {
+    if (!Attributes.enumerable) {
+      if (!has(O, HIDDEN)) nativeDefineProperty(O, HIDDEN, createPropertyDescriptor(1, {}));
+      O[HIDDEN][key] = true;
+    } else {
+      if (has(O, HIDDEN) && O[HIDDEN][key]) O[HIDDEN][key] = false;
+      Attributes = nativeObjectCreate(Attributes, { enumerable: createPropertyDescriptor(0, false) });
+    } return setSymbolDescriptor(O, key, Attributes);
+  } return nativeDefineProperty(O, key, Attributes);
+};
+
+var $defineProperties = function defineProperties(O, Properties) {
+  anObject(O);
+  var properties = toIndexedObject(Properties);
+  var keys = objectKeys(properties).concat($getOwnPropertySymbols(properties));
+  $forEach(keys, function (key) {
+    if (!DESCRIPTORS || $propertyIsEnumerable.call(properties, key)) $defineProperty(O, key, properties[key]);
+  });
+  return O;
+};
+
+var $create = function create(O, Properties) {
+  return Properties === undefined ? nativeObjectCreate(O) : $defineProperties(nativeObjectCreate(O), Properties);
+};
+
+var $propertyIsEnumerable = function propertyIsEnumerable(V) {
+  var P = toPropertyKey(V);
+  var enumerable = nativePropertyIsEnumerable.call(this, P);
+  if (this === ObjectPrototype && has(AllSymbols, P) && !has(ObjectPrototypeSymbols, P)) return false;
+  return enumerable || !has(this, P) || !has(AllSymbols, P) || has(this, HIDDEN) && this[HIDDEN][P] ? enumerable : true;
+};
+
+var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O, P) {
+  var it = toIndexedObject(O);
+  var key = toPropertyKey(P);
+  if (it === ObjectPrototype && has(AllSymbols, key) && !has(ObjectPrototypeSymbols, key)) return;
+  var descriptor = nativeGetOwnPropertyDescriptor(it, key);
+  if (descriptor && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) {
+    descriptor.enumerable = true;
+  }
+  return descriptor;
+};
+
+var $getOwnPropertyNames = function getOwnPropertyNames(O) {
+  var names = nativeGetOwnPropertyNames(toIndexedObject(O));
+  var result = [];
+  $forEach(names, function (key) {
+    if (!has(AllSymbols, key) && !has(hiddenKeys, key)) result.push(key);
+  });
+  return result;
+};
+
+var $getOwnPropertySymbols = function getOwnPropertySymbols(O) {
+  var IS_OBJECT_PROTOTYPE = O === ObjectPrototype;
+  var names = nativeGetOwnPropertyNames(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject(O));
+  var result = [];
+  $forEach(names, function (key) {
+    if (has(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || has(ObjectPrototype, key))) {
+      result.push(AllSymbols[key]);
+    }
+  });
+  return result;
+};
+
+// `Symbol` constructor
+// https://tc39.es/ecma262/#sec-symbol-constructor
+if (!NATIVE_SYMBOL) {
+  $Symbol = function Symbol() {
+    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor');
+    var description = !arguments.length || arguments[0] === undefined ? undefined : $toString(arguments[0]);
+    var tag = uid(description);
+    var setter = function (value) {
+      if (this === ObjectPrototype) setter.call(ObjectPrototypeSymbols, value);
+      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
+      setSymbolDescriptor(this, tag, createPropertyDescriptor(1, value));
+    };
+    if (DESCRIPTORS && USE_SETTER) setSymbolDescriptor(ObjectPrototype, tag, { configurable: true, set: setter });
+    return wrap(tag, description);
+  };
+
+  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
+    return getInternalState(this).tag;
+  });
+
+  redefine($Symbol, 'withoutSetter', function (description) {
+    return wrap(uid(description), description);
+  });
+
+  propertyIsEnumerableModule.f = $propertyIsEnumerable;
+  definePropertyModule.f = $defineProperty;
+  getOwnPropertyDescriptorModule.f = $getOwnPropertyDescriptor;
+  getOwnPropertyNamesModule.f = getOwnPropertyNamesExternal.f = $getOwnPropertyNames;
+  getOwnPropertySymbolsModule.f = $getOwnPropertySymbols;
+
+  wrappedWellKnownSymbolModule.f = function (name) {
+    return wrap(wellKnownSymbol(name), name);
+  };
+
+  if (DESCRIPTORS) {
+    // https://github.com/tc39/proposal-Symbol-description
+    nativeDefineProperty($Symbol[PROTOTYPE], 'description', {
+      configurable: true,
+      get: function description() {
+        return getInternalState(this).description;
+      }
+    });
+    if (!IS_PURE) {
+      redefine(ObjectPrototype, 'propertyIsEnumerable', $propertyIsEnumerable, { unsafe: true });
+    }
+  }
+}
+
+$({ global: true, wrap: true, forced: !NATIVE_SYMBOL, sham: !NATIVE_SYMBOL }, {
+  Symbol: $Symbol
+});
+
+$forEach(objectKeys(WellKnownSymbolsStore), function (name) {
+  defineWellKnownSymbol(name);
+});
+
+$({ target: SYMBOL, stat: true, forced: !NATIVE_SYMBOL }, {
+  // `Symbol.for` method
+  // https://tc39.es/ecma262/#sec-symbol.for
+  'for': function (key) {
+    var string = $toString(key);
+    if (has(StringToSymbolRegistry, string)) return StringToSymbolRegistry[string];
+    var symbol = $Symbol(string);
+    StringToSymbolRegistry[string] = symbol;
+    SymbolToStringRegistry[symbol] = string;
+    return symbol;
+  },
+  // `Symbol.keyFor` method
+  // https://tc39.es/ecma262/#sec-symbol.keyfor
+  keyFor: function keyFor(sym) {
+    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol');
+    if (has(SymbolToStringRegistry, sym)) return SymbolToStringRegistry[sym];
+  },
+  useSetter: function () { USE_SETTER = true; },
+  useSimple: function () { USE_SETTER = false; }
+});
+
+$({ target: 'Object', stat: true, forced: !NATIVE_SYMBOL, sham: !DESCRIPTORS }, {
+  // `Object.create` method
+  // https://tc39.es/ecma262/#sec-object.create
+  create: $create,
+  // `Object.defineProperty` method
+  // https://tc39.es/ecma262/#sec-object.defineproperty
+  defineProperty: $defineProperty,
+  // `Object.defineProperties` method
+  // https://tc39.es/ecma262/#sec-object.defineproperties
+  defineProperties: $defineProperties,
+  // `Object.getOwnPropertyDescriptor` method
+  // https://tc39.es/ecma262/#sec-object.getownpropertydescriptors
+  getOwnPropertyDescriptor: $getOwnPropertyDescriptor
+});
+
+$({ target: 'Object', stat: true, forced: !NATIVE_SYMBOL }, {
+  // `Object.getOwnPropertyNames` method
+  // https://tc39.es/ecma262/#sec-object.getownpropertynames
+  getOwnPropertyNames: $getOwnPropertyNames,
+  // `Object.getOwnPropertySymbols` method
+  // https://tc39.es/ecma262/#sec-object.getownpropertysymbols
+  getOwnPropertySymbols: $getOwnPropertySymbols
+});
+
+// Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
+// https://bugs.chromium.org/p/v8/issues/detail?id=3443
+$({ target: 'Object', stat: true, forced: fails(function () { getOwnPropertySymbolsModule.f(1); }) }, {
+  getOwnPropertySymbols: function getOwnPropertySymbols(it) {
+    return getOwnPropertySymbolsModule.f(toObject(it));
+  }
+});
+
+// `JSON.stringify` method behavior with symbols
+// https://tc39.es/ecma262/#sec-json.stringify
+if ($stringify) {
+  var FORCED_JSON_STRINGIFY = !NATIVE_SYMBOL || fails(function () {
+    var symbol = $Symbol();
+    // MS Edge converts symbol values to JSON as {}
+    return $stringify([symbol]) != '[null]'
+      // WebKit converts symbol values to JSON as null
+      || $stringify({ a: symbol }) != '{}'
+      // V8 throws on boxed symbols
+      || $stringify(Object(symbol)) != '{}';
+  });
+
+  $({ target: 'JSON', stat: true, forced: FORCED_JSON_STRINGIFY }, {
+    // eslint-disable-next-line no-unused-vars -- required for `.length`
+    stringify: function stringify(it, replacer, space) {
+      var args = [it];
+      var index = 1;
+      var $replacer;
+      while (arguments.length > index) args.push(arguments[index++]);
+      $replacer = replacer;
+      if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
+      if (!isArray(replacer)) replacer = function (key, value) {
+        if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
+        if (!isSymbol(value)) return value;
+      };
+      args[1] = replacer;
+      return $stringify.apply(null, args);
+    }
+  });
+}
+
+// `Symbol.prototype[@@toPrimitive]` method
+// https://tc39.es/ecma262/#sec-symbol.prototype-@@toprimitive
+if (!$Symbol[PROTOTYPE][TO_PRIMITIVE]) {
+  createNonEnumerableProperty($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
+}
+// `Symbol.prototype[@@toStringTag]` property
+// https://tc39.es/ecma262/#sec-symbol.prototype-@@tostringtag
+setToStringTag($Symbol, SYMBOL);
+
+hiddenKeys[HIDDEN] = true;
+
+
+/***/ }),
+
+/***/ 77:
+/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+
+var ArrayBufferViewCore = __webpack_require__(2211);
+var $copyWithin = __webpack_require__(2116);
+
+var aTypedArray = ArrayBufferViewCore.aTypedArray;
+var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
+
+// `%TypedArray%.prototype.copyWithin` method
+// https://tc39.es/ecma262/#sec-%typedarray%.prototype.copywithin
+exportTypedArrayMethod('copyWithin', function copyWithin(target, start /* , end */) {
+  return $copyWithin.call(aTypedArray(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
+});
+
+
+/***/ }),
+
+/***/ 9038:
+/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+
+var ArrayBufferViewCore = __webpack_require__(2211);
+var $every = __webpack_require__(6374).every;
+
+var aTypedArray = ArrayBufferViewCore.aTypedArray;
+var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
+
+// `%TypedArray%.prototype.every` method
+// https://tc39.es/ecma262/#sec-%typedarray%.prototype.every
+exportTypedArrayMethod('every', function every(callbackfn /* , thisArg */) {
+  return $every(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
+});
+
+
+/***/ }),
+
+/***/ 7522:
+/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+
+var ArrayBufferViewCore = __webpack_require__(2211);
+var $fill = __webpack_require__(7515);
+
+var aTypedArray = ArrayBufferViewCore.aTypedArray;
+var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
+
+// `%TypedArray%.prototype.fill` method
+// https://tc39.es/ecma262/#sec-%typedarray%.prototype.fill
+// eslint-disable-next-line no-unused-vars -- required for `.length`
+exportTypedArrayMethod('fill', function fill(value /* , start, end */) {
+  return $fill.apply(aTypedArray(this), arguments);
+});
+
+
+/***/ }),
+
+/***/ 6534:
+/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+
+var ArrayBufferViewCore = __webpack_require__(2211);
+var $filter = __webpack_require__(6374).filter;
+var fromSpeciesAndList = __webpack_require__(6696);
+
+var aTypedArray = ArrayBufferViewCore.aTypedArray;
+var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
+
+// `%TypedArray%.prototype.filter` method
+// https://tc39.es/ecma262/#sec-%typedarray%.prototype.filter
+exportTypedArrayMethod('filter', function filter(callbackfn /* , thisArg */) {
+  var list = $filter(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
+  return fromSpeciesAndList(this, list);
+});
+
+
+/***/ }),
+
+/***/ 1888:
+/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+
+var ArrayBufferViewCore = __webpack_require__(2211);
+var $findIndex = __webpack_require__(6374).findIndex;
+
+var aTypedArray = ArrayBufferViewCore.aTypedArray;
+var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
+
+// `%TypedArray%.prototype.findIndex` method
+// https://tc39.es/ecma262/#sec-%typedarray%.prototype.findindex
+exportTypedArrayMethod('findIndex', function findIndex(predicate /* , thisArg */) {
+  return $findIndex(aTypedArray(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
+});
+
+
+/***/ }),
+
+/***/ 538:
+/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+
+var ArrayBufferViewCore = __webpack_require__(2211);
+var $find = __webpack_require__(6374).find;
+
+var aTypedArray = ArrayBufferViewCore.aTypedArray;
+var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
+
+// `%TypedArray%.prototype.find` method
+// https://tc39.es/ecma262/#sec-%typedarray%.prototype.find
+exportTypedArrayMethod('find', function find(predicate /* , thisArg */) {
+  return $find(aTypedArray(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
+});
+
+
+/***/ }),
+
+/***/ 1613:
+/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+
+var ArrayBufferViewCore = __webpack_require__(2211);
+var $forEach = __webpack_require__(6374).forEach;
+
+var aTypedArray = ArrayBufferViewCore.aTypedArray;
+var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
+
+// `%TypedArray%.prototype.forEach` method
+// https://tc39.es/ecma262/#sec-%typedarray%.prototype.foreach
+exportTypedArrayMethod('forEach', function forEach(callbackfn /* , thisArg */) {
+  $forEach(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
+});
+
+
+/***/ }),
+
+/***/ 2744:
+/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+
+var ArrayBufferViewCore = __webpack_require__(2211);
+var $includes = __webpack_require__(1270).includes;
+
+var aTypedArray = ArrayBufferViewCore.aTypedArray;
+var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
+
+// `%TypedArray%.prototype.includes` method
+// https://tc39.es/ecma262/#sec-%typedarray%.prototype.includes
+exportTypedArrayMethod('includes', function includes(searchElement /* , fromIndex */) {
+  return $includes(aTypedArray(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
+});
+
+
+/***/ }),
+
+/***/ 5066:
+/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+
+var ArrayBufferViewCore = __webpack_require__(2211);
+var $indexOf = __webpack_require__(1270).indexOf;
+
+var aTypedArray = ArrayBufferViewCore.aTypedArray;
+var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
+
+// `%TypedArray%.prototype.indexOf` method
+// https://tc39.es/ecma262/#sec-%typedarray%.prototype.indexof
+exportTypedArrayMethod('indexOf', function indexOf(searchElement /* , fromIndex */) {
+  return $indexOf(aTypedArray(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
+});
+
+
+/***/ }),
+
+/***/ 2315:
+/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+
+var global = __webpack_require__(6874);
+var ArrayBufferViewCore = __webpack_require__(2211);
+var ArrayIterators = __webpack_require__(2837);
+var wellKnownSymbol = __webpack_require__(3706);
+
+var ITERATOR = wellKnownSymbol('iterator');
+var Uint8Array = global.Uint8Array;
+var arrayValues = ArrayIterators.values;
+var arrayKeys = ArrayIterators.keys;
+var arrayEntries = ArrayIterators.entries;
+var aTypedArray = ArrayBufferViewCore.aTypedArray;
+var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
+var nativeTypedArrayIterator = Uint8Array && Uint8Array.prototype[ITERATOR];
+
+var CORRECT_ITER_NAME = !!nativeTypedArrayIterator
+  && (nativeTypedArrayIterator.name == 'values' || nativeTypedArrayIterator.name == undefined);
+
+var typedArrayValues = function values() {
+  return arrayValues.call(aTypedArray(this));
+};
+
+// `%TypedArray%.prototype.entries` method
+// https://tc39.es/ecma262/#sec-%typedarray%.prototype.entries
+exportTypedArrayMethod('entries', function entries() {
+  return arrayEntries.call(aTypedArray(this));
+});
+// `%TypedArray%.prototype.keys` method
+// https://tc39.es/ecma262/#sec-%typedarray%.prototype.keys
+exportTypedArrayMethod('keys', function keys() {
+  return arrayKeys.call(aTypedArray(this));
+});
+// `%TypedArray%.prototype.values` method
+// https://tc39.es/ecma262/#sec-%typedarray%.prototype.values
+exportTypedArrayMethod('values', typedArrayValues, !CORRECT_ITER_NAME);
+// `%TypedArray%.prototype[@@iterator]` method
+// https://tc39.es/ecma262/#sec-%typedarray%.prototype-@@iterator
+exportTypedArrayMethod(ITERATOR, typedArrayValues, !CORRECT_ITER_NAME);
+
+
+/***/ }),
+
+/***/ 5288:
+/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+
+var ArrayBufferViewCore = __webpack_require__(2211);
+
+var aTypedArray = ArrayBufferViewCore.aTypedArray;
+var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
+var $join = [].join;
+
+// `%TypedArray%.prototype.join` method
+// https://tc39.es/ecma262/#sec-%typedarray%.prototype.join
+// eslint-disable-next-line no-unused-vars -- required for `.length`
+exportTypedArrayMethod('join', function join(separator) {
+  return $join.apply(aTypedArray(this), arguments);
+});
+
+
+/***/ }),
+
+/***/ 5503:
+/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+
+var ArrayBufferViewCore = __webpack_require__(2211);
+var $lastIndexOf = __webpack_require__(16);
+
+var aTypedArray = ArrayBufferViewCore.aTypedArray;
+var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
+
+// `%TypedArray%.prototype.lastIndexOf` method
+// https://tc39.es/ecma262/#sec-%typedarray%.prototype.lastindexof
+// eslint-disable-next-line no-unused-vars -- required for `.length`
+exportTypedArrayMethod('lastIndexOf', function lastIndexOf(searchElement /* , fromIndex */) {
+  return $lastIndexOf.apply(aTypedArray(this), arguments);
+});
+
+
+/***/ }),
+
+/***/ 9969:
+/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+
+var ArrayBufferViewCore = __webpack_require__(2211);
+var $map = __webpack_require__(6374).map;
+var typedArraySpeciesConstructor = __webpack_require__(5751);
+
+var aTypedArray = ArrayBufferViewCore.aTypedArray;
+var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
+
+// `%TypedArray%.prototype.map` method
+// https://tc39.es/ecma262/#sec-%typedarray%.prototype.map
+exportTypedArrayMethod('map', function map(mapfn /* , thisArg */) {
+  return $map(aTypedArray(this), mapfn, arguments.length > 1 ? arguments[1] : undefined, function (O, length) {
+    return new (typedArraySpeciesConstructor(O))(length);
+  });
+});
+
+
+/***/ }),
+
+/***/ 1587:
+/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+
+var ArrayBufferViewCore = __webpack_require__(2211);
+var $reduceRight = __webpack_require__(9553).right;
+
+var aTypedArray = ArrayBufferViewCore.aTypedArray;
+var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
+
+// `%TypedArray%.prototype.reduceRicht` method
+// https://tc39.es/ecma262/#sec-%typedarray%.prototype.reduceright
+exportTypedArrayMethod('reduceRight', function reduceRight(callbackfn /* , initialValue */) {
+  return $reduceRight(aTypedArray(this), callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
+});
+
+
+/***/ }),
+
+/***/ 2103:
+/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+
+var ArrayBufferViewCore = __webpack_require__(2211);
+var $reduce = __webpack_require__(9553).left;
+
+var aTypedArray = ArrayBufferViewCore.aTypedArray;
+var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
+
+// `%TypedArray%.prototype.reduce` method
+// https://tc39.es/ecma262/#sec-%typedarray%.prototype.reduce
+exportTypedArrayMethod('reduce', function reduce(callbackfn /* , initialValue */) {
+  return $reduce(aTypedArray(this), callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
+});
+
+
+/***/ }),
+
+/***/ 5109:
+/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+
+var ArrayBufferViewCore = __webpack_require__(2211);
+
+var aTypedArray = ArrayBufferViewCore.aTypedArray;
+var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
+var floor = Math.floor;
+
+// `%TypedArray%.prototype.reverse` method
+// https://tc39.es/ecma262/#sec-%typedarray%.prototype.reverse
+exportTypedArrayMethod('reverse', function reverse() {
+  var that = this;
+  var length = aTypedArray(that).length;
+  var middle = floor(length / 2);
+  var index = 0;
+  var value;
+  while (index < middle) {
+    value = that[index];
+    that[index++] = that[--length];
+    that[length] = value;
+  } return that;
+});
+
+
+/***/ }),
+
+/***/ 1418:
+/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+
+var ArrayBufferViewCore = __webpack_require__(2211);
+var toLength = __webpack_require__(4954);
+var toOffset = __webpack_require__(6189);
+var toObject = __webpack_require__(4680);
+var fails = __webpack_require__(7841);
+
+var aTypedArray = ArrayBufferViewCore.aTypedArray;
+var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
+
+var FORCED = fails(function () {
+  // eslint-disable-next-line es/no-typed-arrays -- required for testing
+  new Int8Array(1).set({});
+});
+
+// `%TypedArray%.prototype.set` method
+// https://tc39.es/ecma262/#sec-%typedarray%.prototype.set
+exportTypedArrayMethod('set', function set(arrayLike /* , offset */) {
+  aTypedArray(this);
+  var offset = toOffset(arguments.length > 1 ? arguments[1] : undefined, 1);
+  var length = this.length;
+  var src = toObject(arrayLike);
+  var len = toLength(src.length);
+  var index = 0;
+  if (len + offset > length) throw RangeError('Wrong length');
+  while (index < len) this[offset + index] = src[index++];
+}, FORCED);
+
+
+/***/ }),
+
+/***/ 9760:
+/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+
+var ArrayBufferViewCore = __webpack_require__(2211);
+var typedArraySpeciesConstructor = __webpack_require__(5751);
+var fails = __webpack_require__(7841);
+
+var aTypedArray = ArrayBufferViewCore.aTypedArray;
+var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
+var $slice = [].slice;
+
+var FORCED = fails(function () {
+  // eslint-disable-next-line es/no-typed-arrays -- required for testing
+  new Int8Array(1).slice();
+});
+
+// `%TypedArray%.prototype.slice` method
+// https://tc39.es/ecma262/#sec-%typedarray%.prototype.slice
+exportTypedArrayMethod('slice', function slice(start, end) {
+  var list = $slice.call(aTypedArray(this), start, end);
+  var C = typedArraySpeciesConstructor(this);
+  var index = 0;
+  var length = list.length;
+  var result = new C(length);
+  while (length > index) result[index] = list[index++];
+  return result;
+}, FORCED);
+
+
+/***/ }),
+
+/***/ 4948:
+/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+
+var ArrayBufferViewCore = __webpack_require__(2211);
+var $some = __webpack_require__(6374).some;
+
+var aTypedArray = ArrayBufferViewCore.aTypedArray;
+var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
+
+// `%TypedArray%.prototype.some` method
+// https://tc39.es/ecma262/#sec-%typedarray%.prototype.some
+exportTypedArrayMethod('some', function some(callbackfn /* , thisArg */) {
+  return $some(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
+});
+
+
+/***/ }),
+
+/***/ 727:
+/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+
+var ArrayBufferViewCore = __webpack_require__(2211);
+var global = __webpack_require__(6874);
+var fails = __webpack_require__(7841);
+var aFunction = __webpack_require__(769);
+var toLength = __webpack_require__(4954);
+var internalSort = __webpack_require__(7921);
+var FF = __webpack_require__(6817);
+var IE_OR_EDGE = __webpack_require__(6264);
+var V8 = __webpack_require__(579);
+var WEBKIT = __webpack_require__(9736);
+
+var aTypedArray = ArrayBufferViewCore.aTypedArray;
+var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
+var Uint16Array = global.Uint16Array;
+var nativeSort = Uint16Array && Uint16Array.prototype.sort;
+
+// WebKit
+var ACCEPT_INCORRECT_ARGUMENTS = !!nativeSort && !fails(function () {
+  var array = new Uint16Array(2);
+  array.sort(null);
+  array.sort({});
+});
+
+var STABLE_SORT = !!nativeSort && !fails(function () {
+  // feature detection can be too slow, so check engines versions
+  if (V8) return V8 < 74;
+  if (FF) return FF < 67;
+  if (IE_OR_EDGE) return true;
+  if (WEBKIT) return WEBKIT < 602;
+
+  var array = new Uint16Array(516);
+  var expected = Array(516);
+  var index, mod;
+
+  for (index = 0; index < 516; index++) {
+    mod = index % 4;
+    array[index] = 515 - index;
+    expected[index] = index - 2 * mod + 3;
+  }
+
+  array.sort(function (a, b) {
+    return (a / 4 | 0) - (b / 4 | 0);
+  });
+
+  for (index = 0; index < 516; index++) {
+    if (array[index] !== expected[index]) return true;
+  }
+});
+
+var getSortCompare = function (comparefn) {
+  return function (x, y) {
+    if (comparefn !== undefined) return +comparefn(x, y) || 0;
+    // eslint-disable-next-line no-self-compare -- NaN check
+    if (y !== y) return -1;
+    // eslint-disable-next-line no-self-compare -- NaN check
+    if (x !== x) return 1;
+    if (x === 0 && y === 0) return 1 / x > 0 && 1 / y < 0 ? 1 : -1;
+    return x > y;
+  };
+};
+
+// `%TypedArray%.prototype.sort` method
+// https://tc39.es/ecma262/#sec-%typedarray%.prototype.sort
+exportTypedArrayMethod('sort', function sort(comparefn) {
+  var array = this;
+  if (comparefn !== undefined) aFunction(comparefn);
+  if (STABLE_SORT) return nativeSort.call(array, comparefn);
+
+  aTypedArray(array);
+  var arrayLength = toLength(array.length);
+  var items = Array(arrayLength);
+  var index;
+
+  for (index = 0; index < arrayLength; index++) {
+    items[index] = array[index];
+  }
+
+  items = internalSort(array, getSortCompare(comparefn));
+
+  for (index = 0; index < arrayLength; index++) {
+    array[index] = items[index];
+  }
+
+  return array;
+}, !STABLE_SORT || ACCEPT_INCORRECT_ARGUMENTS);
+
+
+/***/ }),
+
+/***/ 5448:
+/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+
+var ArrayBufferViewCore = __webpack_require__(2211);
+var toLength = __webpack_require__(4954);
+var toAbsoluteIndex = __webpack_require__(2145);
+var typedArraySpeciesConstructor = __webpack_require__(5751);
+
+var aTypedArray = ArrayBufferViewCore.aTypedArray;
+var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
+
+// `%TypedArray%.prototype.subarray` method
+// https://tc39.es/ecma262/#sec-%typedarray%.prototype.subarray
+exportTypedArrayMethod('subarray', function subarray(begin, end) {
+  var O = aTypedArray(this);
+  var length = O.length;
+  var beginIndex = toAbsoluteIndex(begin, length);
+  var C = typedArraySpeciesConstructor(O);
+  return new C(
+    O.buffer,
+    O.byteOffset + beginIndex * O.BYTES_PER_ELEMENT,
+    toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - beginIndex)
+  );
+});
+
+
+/***/ }),
+
+/***/ 6179:
+/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+
+var global = __webpack_require__(6874);
+var ArrayBufferViewCore = __webpack_require__(2211);
+var fails = __webpack_require__(7841);
+
+var Int8Array = global.Int8Array;
+var aTypedArray = ArrayBufferViewCore.aTypedArray;
+var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
+var $toLocaleString = [].toLocaleString;
+var $slice = [].slice;
+
+// iOS Safari 6.x fails here
+var TO_LOCALE_STRING_BUG = !!Int8Array && fails(function () {
+  $toLocaleString.call(new Int8Array(1));
+});
+
+var FORCED = fails(function () {
+  return [1, 2].toLocaleString() != new Int8Array([1, 2]).toLocaleString();
+}) || !fails(function () {
+  Int8Array.prototype.toLocaleString.call([1, 2]);
+});
+
+// `%TypedArray%.prototype.toLocaleString` method
+// https://tc39.es/ecma262/#sec-%typedarray%.prototype.tolocalestring
+exportTypedArrayMethod('toLocaleString', function toLocaleString() {
+  return $toLocaleString.apply(TO_LOCALE_STRING_BUG ? $slice.call(aTypedArray(this)) : aTypedArray(this), arguments);
+}, FORCED);
+
+
+/***/ }),
+
+/***/ 5694:
+/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+
+var exportTypedArrayMethod = __webpack_require__(2211).exportTypedArrayMethod;
+var fails = __webpack_require__(7841);
+var global = __webpack_require__(6874);
+
+var Uint8Array = global.Uint8Array;
+var Uint8ArrayPrototype = Uint8Array && Uint8Array.prototype || {};
+var arrayToString = [].toString;
+var arrayJoin = [].join;
+
+if (fails(function () { arrayToString.call({}); })) {
+  arrayToString = function toString() {
+    return arrayJoin.call(this);
+  };
+}
+
+var IS_NOT_ARRAY_METHOD = Uint8ArrayPrototype.toString != arrayToString;
+
+// `%TypedArray%.prototype.toString` method
+// https://tc39.es/ecma262/#sec-%typedarray%.prototype.tostring
+exportTypedArrayMethod('toString', arrayToString, IS_NOT_ARRAY_METHOD);
+
+
+/***/ }),
+
+/***/ 6747:
+/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {
+
+var createTypedArrayConstructor = __webpack_require__(3151);
+
+// `Uint8Array` constructor
+// https://tc39.es/ecma262/#sec-typedarray-objects
+createTypedArrayConstructor('Uint8', function (init) {
+  return function Uint8Array(data, byteOffset, length) {
+    return init(this, data, byteOffset, length);
+  };
+});
+
+
+/***/ }),
+
+/***/ 31:
+/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {
+
+var global = __webpack_require__(6874);
+var DOMIterables = __webpack_require__(8956);
+var forEach = __webpack_require__(1244);
+var createNonEnumerableProperty = __webpack_require__(4791);
+
+for (var COLLECTION_NAME in DOMIterables) {
+  var Collection = global[COLLECTION_NAME];
+  var CollectionPrototype = Collection && Collection.prototype;
+  // some Chrome versions have non-configurable methods on DOMTokenList
+  if (CollectionPrototype && CollectionPrototype.forEach !== forEach) try {
+    createNonEnumerableProperty(CollectionPrototype, 'forEach', forEach);
+  } catch (error) {
+    CollectionPrototype.forEach = forEach;
+  }
+}
+
+
+/***/ }),
+
+/***/ 9773:
+/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {
+
+var global = __webpack_require__(6874);
+var DOMIterables = __webpack_require__(8956);
+var ArrayIteratorMethods = __webpack_require__(2837);
+var createNonEnumerableProperty = __webpack_require__(4791);
+var wellKnownSymbol = __webpack_require__(3706);
+
+var ITERATOR = wellKnownSymbol('iterator');
+var TO_STRING_TAG = wellKnownSymbol('toStringTag');
+var ArrayValues = ArrayIteratorMethods.values;
+
+for (var COLLECTION_NAME in DOMIterables) {
+  var Collection = global[COLLECTION_NAME];
+  var CollectionPrototype = Collection && Collection.prototype;
+  if (CollectionPrototype) {
+    // some Chrome versions have non-configurable methods on DOMTokenList
+    if (CollectionPrototype[ITERATOR] !== ArrayValues) try {
+      createNonEnumerableProperty(CollectionPrototype, ITERATOR, ArrayValues);
+    } catch (error) {
+      CollectionPrototype[ITERATOR] = ArrayValues;
+    }
+    if (!CollectionPrototype[TO_STRING_TAG]) {
+      createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME);
+    }
+    if (DOMIterables[COLLECTION_NAME]) for (var METHOD_NAME in ArrayIteratorMethods) {
+      // some Chrome versions have non-configurable methods on DOMTokenList
+      if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME]) try {
+        createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);
+      } catch (error) {
+        CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];
+      }
+    }
+  }
+}
+
+
+/***/ }),
+
+/***/ 2303:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+
+// TODO: in core-js@4, move /modules/ dependencies to public entries for better optimization by tools like `preset-env`
+__webpack_require__(2837);
+var $ = __webpack_require__(1082);
+var getBuiltIn = __webpack_require__(4578);
+var USE_NATIVE_URL = __webpack_require__(1781);
+var redefine = __webpack_require__(1249);
+var redefineAll = __webpack_require__(7490);
+var setToStringTag = __webpack_require__(9400);
+var createIteratorConstructor = __webpack_require__(9670);
+var InternalStateModule = __webpack_require__(6619);
+var anInstance = __webpack_require__(2482);
+var hasOwn = __webpack_require__(5884);
+var bind = __webpack_require__(4833);
+var classof = __webpack_require__(8753);
+var anObject = __webpack_require__(47);
+var isObject = __webpack_require__(6944);
+var $toString = __webpack_require__(401);
+var create = __webpack_require__(2361);
+var createPropertyDescriptor = __webpack_require__(976);
+var getIterator = __webpack_require__(7053);
+var getIteratorMethod = __webpack_require__(3126);
+var wellKnownSymbol = __webpack_require__(3706);
+
+var nativeFetch = getBuiltIn('fetch');
+var NativeRequest = getBuiltIn('Request');
+var RequestPrototype = NativeRequest && NativeRequest.prototype;
+var Headers = getBuiltIn('Headers');
+var ITERATOR = wellKnownSymbol('iterator');
+var URL_SEARCH_PARAMS = 'URLSearchParams';
+var URL_SEARCH_PARAMS_ITERATOR = URL_SEARCH_PARAMS + 'Iterator';
+var setInternalState = InternalStateModule.set;
+var getInternalParamsState = InternalStateModule.getterFor(URL_SEARCH_PARAMS);
+var getInternalIteratorState = InternalStateModule.getterFor(URL_SEARCH_PARAMS_ITERATOR);
+
+var plus = /\+/g;
+var sequences = Array(4);
+
+var percentSequence = function (bytes) {
+  return sequences[bytes - 1] || (sequences[bytes - 1] = RegExp('((?:%[\\da-f]{2}){' + bytes + '})', 'gi'));
+};
+
+var percentDecode = function (sequence) {
+  try {
+    return decodeURIComponent(sequence);
+  } catch (error) {
+    return sequence;
+  }
+};
+
+var deserialize = function (it) {
+  var result = it.replace(plus, ' ');
+  var bytes = 4;
+  try {
+    return decodeURIComponent(result);
+  } catch (error) {
+    while (bytes) {
+      result = result.replace(percentSequence(bytes--), percentDecode);
+    }
+    return result;
+  }
+};
+
+var find = /[!'()~]|%20/g;
+
+var replace = {
+  '!': '%21',
+  "'": '%27',
+  '(': '%28',
+  ')': '%29',
+  '~': '%7E',
+  '%20': '+'
+};
+
+var replacer = function (match) {
+  return replace[match];
+};
+
+var serialize = function (it) {
+  return encodeURIComponent(it).replace(find, replacer);
+};
+
+var parseSearchParams = function (result, query) {
+  if (query) {
+    var attributes = query.split('&');
+    var index = 0;
+    var attribute, entry;
+    while (index < attributes.length) {
+      attribute = attributes[index++];
+      if (attribute.length) {
+        entry = attribute.split('=');
+        result.push({
+          key: deserialize(entry.shift()),
+          value: deserialize(entry.join('='))
+        });
+      }
+    }
+  }
+};
+
+var updateSearchParams = function (query) {
+  this.entries.length = 0;
+  parseSearchParams(this.entries, query);
+};
+
+var validateArgumentsLength = function (passed, required) {
+  if (passed < required) throw TypeError('Not enough arguments');
+};
+
+var URLSearchParamsIterator = createIteratorConstructor(function Iterator(params, kind) {
+  setInternalState(this, {
+    type: URL_SEARCH_PARAMS_ITERATOR,
+    iterator: getIterator(getInternalParamsState(params).entries),
+    kind: kind
+  });
+}, 'Iterator', function next() {
+  var state = getInternalIteratorState(this);
+  var kind = state.kind;
+  var step = state.iterator.next();
+  var entry = step.value;
+  if (!step.done) {
+    step.value = kind === 'keys' ? entry.key : kind === 'values' ? entry.value : [entry.key, entry.value];
+  } return step;
+});
+
+// `URLSearchParams` constructor
+// https://url.spec.whatwg.org/#interface-urlsearchparams
+var URLSearchParamsConstructor = function URLSearchParams(/* init */) {
+  anInstance(this, URLSearchParamsConstructor, URL_SEARCH_PARAMS);
+  var init = arguments.length > 0 ? arguments[0] : undefined;
+  var that = this;
+  var entries = [];
+  var iteratorMethod, iterator, next, step, entryIterator, entryNext, first, second, key;
+
+  setInternalState(that, {
+    type: URL_SEARCH_PARAMS,
+    entries: entries,
+    updateURL: function () { /* empty */ },
+    updateSearchParams: updateSearchParams
+  });
+
+  if (init !== undefined) {
+    if (isObject(init)) {
+      iteratorMethod = getIteratorMethod(init);
+      if (typeof iteratorMethod === 'function') {
+        iterator = iteratorMethod.call(init);
+        next = iterator.next;
+        while (!(step = next.call(iterator)).done) {
+          entryIterator = getIterator(anObject(step.value));
+          entryNext = entryIterator.next;
+          if (
+            (first = entryNext.call(entryIterator)).done ||
+            (second = entryNext.call(entryIterator)).done ||
+            !entryNext.call(entryIterator).done
+          ) throw TypeError('Expected sequence with length 2');
+          entries.push({ key: $toString(first.value), value: $toString(second.value) });
+        }
+      } else for (key in init) if (hasOwn(init, key)) entries.push({ key: key, value: $toString(init[key]) });
+    } else {
+      parseSearchParams(
+        entries,
+        typeof init === 'string' ? init.charAt(0) === '?' ? init.slice(1) : init : $toString(init)
+      );
+    }
+  }
+};
+
+var URLSearchParamsPrototype = URLSearchParamsConstructor.prototype;
+
+redefineAll(URLSearchParamsPrototype, {
+  // `URLSearchParams.prototype.append` method
+  // https://url.spec.whatwg.org/#dom-urlsearchparams-append
+  append: function append(name, value) {
+    validateArgumentsLength(arguments.length, 2);
+    var state = getInternalParamsState(this);
+    state.entries.push({ key: $toString(name), value: $toString(value) });
+    state.updateURL();
+  },
+  // `URLSearchParams.prototype.delete` method
+  // https://url.spec.whatwg.org/#dom-urlsearchparams-delete
+  'delete': function (name) {
+    validateArgumentsLength(arguments.length, 1);
+    var state = getInternalParamsState(this);
+    var entries = state.entries;
+    var key = $toString(name);
+    var index = 0;
+    while (index < entries.length) {
+      if (entries[index].key === key) entries.splice(index, 1);
+      else index++;
+    }
+    state.updateURL();
+  },
+  // `URLSearchParams.prototype.get` method
+  // https://url.spec.whatwg.org/#dom-urlsearchparams-get
+  get: function get(name) {
+    validateArgumentsLength(arguments.length, 1);
+    var entries = getInternalParamsState(this).entries;
+    var key = $toString(name);
+    var index = 0;
+    for (; index < entries.length; index++) {
+      if (entries[index].key === key) return entries[index].value;
+    }
+    return null;
+  },
+  // `URLSearchParams.prototype.getAll` method
+  // https://url.spec.whatwg.org/#dom-urlsearchparams-getall
+  getAll: function getAll(name) {
+    validateArgumentsLength(arguments.length, 1);
+    var entries = getInternalParamsState(this).entries;
+    var key = $toString(name);
+    var result = [];
+    var index = 0;
+    for (; index < entries.length; index++) {
+      if (entries[index].key === key) result.push(entries[index].value);
+    }
+    return result;
+  },
+  // `URLSearchParams.prototype.has` method
+  // https://url.spec.whatwg.org/#dom-urlsearchparams-has
+  has: function has(name) {
+    validateArgumentsLength(arguments.length, 1);
+    var entries = getInternalParamsState(this).entries;
+    var key = $toString(name);
+    var index = 0;
+    while (index < entries.length) {
+      if (entries[index++].key === key) return true;
+    }
+    return false;
+  },
+  // `URLSearchParams.prototype.set` method
+  // https://url.spec.whatwg.org/#dom-urlsearchparams-set
+  set: function set(name, value) {
+    validateArgumentsLength(arguments.length, 1);
+    var state = getInternalParamsState(this);
+    var entries = state.entries;
+    var found = false;
+    var key = $toString(name);
+    var val = $toString(value);
+    var index = 0;
+    var entry;
+    for (; index < entries.length; index++) {
+      entry = entries[index];
+      if (entry.key === key) {
+        if (found) entries.splice(index--, 1);
+        else {
+          found = true;
+          entry.value = val;
+        }
+      }
+    }
+    if (!found) entries.push({ key: key, value: val });
+    state.updateURL();
+  },
+  // `URLSearchParams.prototype.sort` method
+  // https://url.spec.whatwg.org/#dom-urlsearchparams-sort
+  sort: function sort() {
+    var state = getInternalParamsState(this);
+    var entries = state.entries;
+    // Array#sort is not stable in some engines
+    var slice = entries.slice();
+    var entry, entriesIndex, sliceIndex;
+    entries.length = 0;
+    for (sliceIndex = 0; sliceIndex < slice.length; sliceIndex++) {
+      entry = slice[sliceIndex];
+      for (entriesIndex = 0; entriesIndex < sliceIndex; entriesIndex++) {
+        if (entries[entriesIndex].key > entry.key) {
+          entries.splice(entriesIndex, 0, entry);
+          break;
+        }
+      }
+      if (entriesIndex === sliceIndex) entries.push(entry);
+    }
+    state.updateURL();
+  },
+  // `URLSearchParams.prototype.forEach` method
+  forEach: function forEach(callback /* , thisArg */) {
+    var entries = getInternalParamsState(this).entries;
+    var boundFunction = bind(callback, arguments.length > 1 ? arguments[1] : undefined, 3);
+    var index = 0;
+    var entry;
+    while (index < entries.length) {
+      entry = entries[index++];
+      boundFunction(entry.value, entry.key, this);
+    }
+  },
+  // `URLSearchParams.prototype.keys` method
+  keys: function keys() {
+    return new URLSearchParamsIterator(this, 'keys');
+  },
+  // `URLSearchParams.prototype.values` method
+  values: function values() {
+    return new URLSearchParamsIterator(this, 'values');
+  },
+  // `URLSearchParams.prototype.entries` method
+  entries: function entries() {
+    return new URLSearchParamsIterator(this, 'entries');
+  }
+}, { enumerable: true });
+
+// `URLSearchParams.prototype[@@iterator]` method
+redefine(URLSearchParamsPrototype, ITERATOR, URLSearchParamsPrototype.entries);
+
+// `URLSearchParams.prototype.toString` method
+// https://url.spec.whatwg.org/#urlsearchparams-stringification-behavior
+redefine(URLSearchParamsPrototype, 'toString', function toString() {
+  var entries = getInternalParamsState(this).entries;
+  var result = [];
+  var index = 0;
+  var entry;
+  while (index < entries.length) {
+    entry = entries[index++];
+    result.push(serialize(entry.key) + '=' + serialize(entry.value));
+  } return result.join('&');
+}, { enumerable: true });
+
+setToStringTag(URLSearchParamsConstructor, URL_SEARCH_PARAMS);
+
+$({ global: true, forced: !USE_NATIVE_URL }, {
+  URLSearchParams: URLSearchParamsConstructor
+});
+
+// Wrap `fetch` and `Request` for correct work with polyfilled `URLSearchParams`
+if (!USE_NATIVE_URL && typeof Headers == 'function') {
+  var wrapRequestOptions = function (init) {
+    if (isObject(init)) {
+      var body = init.body;
+      var headers;
+      if (classof(body) === URL_SEARCH_PARAMS) {
+        headers = init.headers ? new Headers(init.headers) : new Headers();
+        if (!headers.has('content-type')) {
+          headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
+        }
+        return create(init, {
+          body: createPropertyDescriptor(0, String(body)),
+          headers: createPropertyDescriptor(0, headers)
+        });
+      }
+    } return init;
+  };
+
+  if (typeof nativeFetch == 'function') {
+    $({ global: true, enumerable: true, forced: true }, {
+      fetch: function fetch(input /* , init */) {
+        return nativeFetch(input, arguments.length > 1 ? wrapRequestOptions(arguments[1]) : {});
+      }
+    });
+  }
+
+  if (typeof NativeRequest == 'function') {
+    var RequestConstructor = function Request(input /* , init */) {
+      anInstance(this, RequestConstructor, 'Request');
+      return new NativeRequest(input, arguments.length > 1 ? wrapRequestOptions(arguments[1]) : {});
+    };
+
+    RequestPrototype.constructor = RequestConstructor;
+    RequestConstructor.prototype = RequestPrototype;
+
+    $({ global: true, forced: true }, {
+      Request: RequestConstructor
+    });
+  }
+}
+
+module.exports = {
+  URLSearchParams: URLSearchParamsConstructor,
+  getState: getInternalParamsState
+};
+
+
+/***/ }),
+
+/***/ 2743:
+/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+
+// TODO: in core-js@4, move /modules/ dependencies to public entries for better optimization by tools like `preset-env`
+__webpack_require__(6949);
+var $ = __webpack_require__(1082);
+var DESCRIPTORS = __webpack_require__(5542);
+var USE_NATIVE_URL = __webpack_require__(1781);
+var global = __webpack_require__(6874);
+var defineProperties = __webpack_require__(7852);
+var redefine = __webpack_require__(1249);
+var anInstance = __webpack_require__(2482);
+var has = __webpack_require__(5884);
+var assign = __webpack_require__(5277);
+var arrayFrom = __webpack_require__(1774);
+var codeAt = __webpack_require__(6174).codeAt;
+var toASCII = __webpack_require__(8);
+var $toString = __webpack_require__(401);
+var setToStringTag = __webpack_require__(9400);
+var URLSearchParamsModule = __webpack_require__(2303);
+var InternalStateModule = __webpack_require__(6619);
+
+var NativeURL = global.URL;
+var URLSearchParams = URLSearchParamsModule.URLSearchParams;
+var getInternalSearchParamsState = URLSearchParamsModule.getState;
+var setInternalState = InternalStateModule.set;
+var getInternalURLState = InternalStateModule.getterFor('URL');
+var floor = Math.floor;
+var pow = Math.pow;
+
+var INVALID_AUTHORITY = 'Invalid authority';
+var INVALID_SCHEME = 'Invalid scheme';
+var INVALID_HOST = 'Invalid host';
+var INVALID_PORT = 'Invalid port';
+
+var ALPHA = /[A-Za-z]/;
+// eslint-disable-next-line regexp/no-obscure-range -- safe
+var ALPHANUMERIC = /[\d+-.A-Za-z]/;
+var DIGIT = /\d/;
+var HEX_START = /^0x/i;
+var OCT = /^[0-7]+$/;
+var DEC = /^\d+$/;
+var HEX = /^[\dA-Fa-f]+$/;
+/* eslint-disable no-control-regex -- safe */
+var FORBIDDEN_HOST_CODE_POINT = /[\0\t\n\r #%/:<>?@[\\\]^|]/;
+var FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT = /[\0\t\n\r #/:<>?@[\\\]^|]/;
+var LEADING_AND_TRAILING_C0_CONTROL_OR_SPACE = /^[\u0000-\u0020]+|[\u0000-\u0020]+$/g;
+var TAB_AND_NEW_LINE = /[\t\n\r]/g;
+/* eslint-enable no-control-regex -- safe */
+var EOF;
+
+var parseHost = function (url, input) {
+  var result, codePoints, index;
+  if (input.charAt(0) == '[') {
+    if (input.charAt(input.length - 1) != ']') return INVALID_HOST;
+    result = parseIPv6(input.slice(1, -1));
+    if (!result) return INVALID_HOST;
+    url.host = result;
+  // opaque host
+  } else if (!isSpecial(url)) {
+    if (FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT.test(input)) return INVALID_HOST;
+    result = '';
+    codePoints = arrayFrom(input);
+    for (index = 0; index < codePoints.length; index++) {
+      result += percentEncode(codePoints[index], C0ControlPercentEncodeSet);
+    }
+    url.host = result;
+  } else {
+    input = toASCII(input);
+    if (FORBIDDEN_HOST_CODE_POINT.test(input)) return INVALID_HOST;
+    result = parseIPv4(input);
+    if (result === null) return INVALID_HOST;
+    url.host = result;
+  }
+};
+
+var parseIPv4 = function (input) {
+  var parts = input.split('.');
+  var partsLength, numbers, index, part, radix, number, ipv4;
+  if (parts.length && parts[parts.length - 1] == '') {
+    parts.pop();
+  }
+  partsLength = parts.length;
+  if (partsLength > 4) return input;
+  numbers = [];
+  for (index = 0; index < partsLength; index++) {
+    part = parts[index];
+    if (part == '') return input;
+    radix = 10;
+    if (part.length > 1 && part.charAt(0) == '0') {
+      radix = HEX_START.test(part) ? 16 : 8;
+      part = part.slice(radix == 8 ? 1 : 2);
+    }
+    if (part === '') {
+      number = 0;
+    } else {
+      if (!(radix == 10 ? DEC : radix == 8 ? OCT : HEX).test(part)) return input;
+      number = parseInt(part, radix);
+    }
+    numbers.push(number);
+  }
+  for (index = 0; index < partsLength; index++) {
+    number = numbers[index];
+    if (index == partsLength - 1) {
+      if (number >= pow(256, 5 - partsLength)) return null;
+    } else if (number > 255) return null;
+  }
+  ipv4 = numbers.pop();
+  for (index = 0; index < numbers.length; index++) {
+    ipv4 += numbers[index] * pow(256, 3 - index);
+  }
+  return ipv4;
+};
+
+// eslint-disable-next-line max-statements -- TODO
+var parseIPv6 = function (input) {
+  var address = [0, 0, 0, 0, 0, 0, 0, 0];
+  var pieceIndex = 0;
+  var compress = null;
+  var pointer = 0;
+  var value, length, numbersSeen, ipv4Piece, number, swaps, swap;
+
+  var char = function () {
+    return input.charAt(pointer);
+  };
+
+  if (char() == ':') {
+    if (input.charAt(1) != ':') return;
+    pointer += 2;
+    pieceIndex++;
+    compress = pieceIndex;
+  }
+  while (char()) {
+    if (pieceIndex == 8) return;
+    if (char() == ':') {
+      if (compress !== null) return;
+      pointer++;
+      pieceIndex++;
+      compress = pieceIndex;
+      continue;
+    }
+    value = length = 0;
+    while (length < 4 && HEX.test(char())) {
+      value = value * 16 + parseInt(char(), 16);
+      pointer++;
+      length++;
+    }
+    if (char() == '.') {
+      if (length == 0) return;
+      pointer -= length;
+      if (pieceIndex > 6) return;
+      numbersSeen = 0;
+      while (char()) {
+        ipv4Piece = null;
+        if (numbersSeen > 0) {
+          if (char() == '.' && numbersSeen < 4) pointer++;
+          else return;
+        }
+        if (!DIGIT.test(char())) return;
+        while (DIGIT.test(char())) {
+          number = parseInt(char(), 10);
+          if (ipv4Piece === null) ipv4Piece = number;
+          else if (ipv4Piece == 0) return;
+          else ipv4Piece = ipv4Piece * 10 + number;
+          if (ipv4Piece > 255) return;
+          pointer++;
+        }
+        address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
+        numbersSeen++;
+        if (numbersSeen == 2 || numbersSeen == 4) pieceIndex++;
+      }
+      if (numbersSeen != 4) return;
+      break;
+    } else if (char() == ':') {
+      pointer++;
+      if (!char()) return;
+    } else if (char()) return;
+    address[pieceIndex++] = value;
+  }
+  if (compress !== null) {
+    swaps = pieceIndex - compress;
+    pieceIndex = 7;
+    while (pieceIndex != 0 && swaps > 0) {
+      swap = address[pieceIndex];
+      address[pieceIndex--] = address[compress + swaps - 1];
+      address[compress + --swaps] = swap;
+    }
+  } else if (pieceIndex != 8) return;
+  return address;
+};
+
+var findLongestZeroSequence = function (ipv6) {
+  var maxIndex = null;
+  var maxLength = 1;
+  var currStart = null;
+  var currLength = 0;
+  var index = 0;
+  for (; index < 8; index++) {
+    if (ipv6[index] !== 0) {
+      if (currLength > maxLength) {
+        maxIndex = currStart;
+        maxLength = currLength;
+      }
+      currStart = null;
+      currLength = 0;
+    } else {
+      if (currStart === null) currStart = index;
+      ++currLength;
+    }
+  }
+  if (currLength > maxLength) {
+    maxIndex = currStart;
+    maxLength = currLength;
+  }
+  return maxIndex;
+};
+
+var serializeHost = function (host) {
+  var result, index, compress, ignore0;
+  // ipv4
+  if (typeof host == 'number') {
+    result = [];
+    for (index = 0; index < 4; index++) {
+      result.unshift(host % 256);
+      host = floor(host / 256);
+    } return result.join('.');
+  // ipv6
+  } else if (typeof host == 'object') {
+    result = '';
+    compress = findLongestZeroSequence(host);
+    for (index = 0; index < 8; index++) {
+      if (ignore0 && host[index] === 0) continue;
+      if (ignore0) ignore0 = false;
+      if (compress === index) {
+        result += index ? ':' : '::';
+        ignore0 = true;
+      } else {
+        result += host[index].toString(16);
+        if (index < 7) result += ':';
+      }
+    }
+    return '[' + result + ']';
+  } return host;
+};
+
+var C0ControlPercentEncodeSet = {};
+var fragmentPercentEncodeSet = assign({}, C0ControlPercentEncodeSet, {
+  ' ': 1, '"': 1, '<': 1, '>': 1, '`': 1
+});
+var pathPercentEncodeSet = assign({}, fragmentPercentEncodeSet, {
+  '#': 1, '?': 1, '{': 1, '}': 1
+});
+var userinfoPercentEncodeSet = assign({}, pathPercentEncodeSet, {
+  '/': 1, ':': 1, ';': 1, '=': 1, '@': 1, '[': 1, '\\': 1, ']': 1, '^': 1, '|': 1
+});
+
+var percentEncode = function (char, set) {
+  var code = codeAt(char, 0);
+  return code > 0x20 && code < 0x7F && !has(set, char) ? char : encodeURIComponent(char);
+};
+
+var specialSchemes = {
+  ftp: 21,
+  file: null,
+  http: 80,
+  https: 443,
+  ws: 80,
+  wss: 443
+};
+
+var isSpecial = function (url) {
+  return has(specialSchemes, url.scheme);
+};
+
+var includesCredentials = function (url) {
+  return url.username != '' || url.password != '';
+};
+
+var cannotHaveUsernamePasswordPort = function (url) {
+  return !url.host || url.cannotBeABaseURL || url.scheme == 'file';
+};
+
+var isWindowsDriveLetter = function (string, normalized) {
+  var second;
+  return string.length == 2 && ALPHA.test(string.charAt(0))
+    && ((second = string.charAt(1)) == ':' || (!normalized && second == '|'));
+};
+
+var startsWithWindowsDriveLetter = function (string) {
+  var third;
+  return string.length > 1 && isWindowsDriveLetter(string.slice(0, 2)) && (
+    string.length == 2 ||
+    ((third = string.charAt(2)) === '/' || third === '\\' || third === '?' || third === '#')
+  );
+};
+
+var shortenURLsPath = function (url) {
+  var path = url.path;
+  var pathSize = path.length;
+  if (pathSize && (url.scheme != 'file' || pathSize != 1 || !isWindowsDriveLetter(path[0], true))) {
+    path.pop();
+  }
+};
+
+var isSingleDot = function (segment) {
+  return segment === '.' || segment.toLowerCase() === '%2e';
+};
+
+var isDoubleDot = function (segment) {
+  segment = segment.toLowerCase();
+  return segment === '..' || segment === '%2e.' || segment === '.%2e' || segment === '%2e%2e';
+};
+
+// States:
+var SCHEME_START = {};
+var SCHEME = {};
+var NO_SCHEME = {};
+var SPECIAL_RELATIVE_OR_AUTHORITY = {};
+var PATH_OR_AUTHORITY = {};
+var RELATIVE = {};
+var RELATIVE_SLASH = {};
+var SPECIAL_AUTHORITY_SLASHES = {};
+var SPECIAL_AUTHORITY_IGNORE_SLASHES = {};
+var AUTHORITY = {};
+var HOST = {};
+var HOSTNAME = {};
+var PORT = {};
+var FILE = {};
+var FILE_SLASH = {};
+var FILE_HOST = {};
+var PATH_START = {};
+var PATH = {};
+var CANNOT_BE_A_BASE_URL_PATH = {};
+var QUERY = {};
+var FRAGMENT = {};
+
+// eslint-disable-next-line max-statements -- TODO
+var parseURL = function (url, input, stateOverride, base) {
+  var state = stateOverride || SCHEME_START;
+  var pointer = 0;
+  var buffer = '';
+  var seenAt = false;
+  var seenBracket = false;
+  var seenPasswordToken = false;
+  var codePoints, char, bufferCodePoints, failure;
+
+  if (!stateOverride) {
+    url.scheme = '';
+    url.username = '';
+    url.password = '';
+    url.host = null;
+    url.port = null;
+    url.path = [];
+    url.query = null;
+    url.fragment = null;
+    url.cannotBeABaseURL = false;
+    input = input.replace(LEADING_AND_TRAILING_C0_CONTROL_OR_SPACE, '');
+  }
+
+  input = input.replace(TAB_AND_NEW_LINE, '');
+
+  codePoints = arrayFrom(input);
+
+  while (pointer <= codePoints.length) {
+    char = codePoints[pointer];
+    switch (state) {
+      case SCHEME_START:
+        if (char && ALPHA.test(char)) {
+          buffer += char.toLowerCase();
+          state = SCHEME;
+        } else if (!stateOverride) {
+          state = NO_SCHEME;
+          continue;
+        } else return INVALID_SCHEME;
+        break;
+
+      case SCHEME:
+        if (char && (ALPHANUMERIC.test(char) || char == '+' || char == '-' || char == '.')) {
+          buffer += char.toLowerCase();
+        } else if (char == ':') {
+          if (stateOverride && (
+            (isSpecial(url) != has(specialSchemes, buffer)) ||
+            (buffer == 'file' && (includesCredentials(url) || url.port !== null)) ||
+            (url.scheme == 'file' && !url.host)
+          )) return;
+          url.scheme = buffer;
+          if (stateOverride) {
+            if (isSpecial(url) && specialSchemes[url.scheme] == url.port) url.port = null;
+            return;
+          }
+          buffer = '';
+          if (url.scheme == 'file') {
+            state = FILE;
+          } else if (isSpecial(url) && base && base.scheme == url.scheme) {
+            state = SPECIAL_RELATIVE_OR_AUTHORITY;
+          } else if (isSpecial(url)) {
+            state = SPECIAL_AUTHORITY_SLASHES;
+          } else if (codePoints[pointer + 1] == '/') {
+            state = PATH_OR_AUTHORITY;
+            pointer++;
+          } else {
+            url.cannotBeABaseURL = true;
+            url.path.push('');
+            state = CANNOT_BE_A_BASE_URL_PATH;
+          }
+        } else if (!stateOverride) {
+          buffer = '';
+          state = NO_SCHEME;
+          pointer = 0;
+          continue;
+        } else return INVALID_SCHEME;
+        break;
+
+      case NO_SCHEME:
+        if (!base || (base.cannotBeABaseURL && char != '#')) return INVALID_SCHEME;
+        if (base.cannotBeABaseURL && char == '#') {
+          url.scheme = base.scheme;
+          url.path = base.path.slice();
+          url.query = base.query;
+          url.fragment = '';
+          url.cannotBeABaseURL = true;
+          state = FRAGMENT;
+          break;
+        }
+        state = base.scheme == 'file' ? FILE : RELATIVE;
+        continue;
+
+      case SPECIAL_RELATIVE_OR_AUTHORITY:
+        if (char == '/' && codePoints[pointer + 1] == '/') {
+          state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
+          pointer++;
+        } else {
+          state = RELATIVE;
+          continue;
+        } break;
+
+      case PATH_OR_AUTHORITY:
+        if (char == '/') {
+          state = AUTHORITY;
+          break;
+        } else {
+          state = PATH;
+          continue;
+        }
+
+      case RELATIVE:
+        url.scheme = base.scheme;
+        if (char == EOF) {
+          url.username = base.username;
+          url.password = base.password;
+          url.host = base.host;
+          url.port = base.port;
+          url.path = base.path.slice();
+          url.query = base.query;
+        } else if (char == '/' || (char == '\\' && isSpecial(url))) {
+          state = RELATIVE_SLASH;
+        } else if (char == '?') {
+          url.username = base.username;
+          url.password = base.password;
+          url.host = base.host;
+          url.port = base.port;
+          url.path = base.path.slice();
+          url.query = '';
+          state = QUERY;
+        } else if (char == '#') {
+          url.username = base.username;
+          url.password = base.password;
+          url.host = base.host;
+          url.port = base.port;
+          url.path = base.path.slice();
+          url.query = base.query;
+          url.fragment = '';
+          state = FRAGMENT;
+        } else {
+          url.username = base.username;
+          url.password = base.password;
+          url.host = base.host;
+          url.port = base.port;
+          url.path = base.path.slice();
+          url.path.pop();
+          state = PATH;
+          continue;
+        } break;
+
+      case RELATIVE_SLASH:
+        if (isSpecial(url) && (char == '/' || char == '\\')) {
+          state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
+        } else if (char == '/') {
+          state = AUTHORITY;
+        } else {
+          url.username = base.username;
+          url.password = base.password;
+          url.host = base.host;
+          url.port = base.port;
+          state = PATH;
+          continue;
+        } break;
+
+      case SPECIAL_AUTHORITY_SLASHES:
+        state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
+        if (char != '/' || buffer.charAt(pointer + 1) != '/') continue;
+        pointer++;
+        break;
+
+      case SPECIAL_AUTHORITY_IGNORE_SLASHES:
+        if (char != '/' && char != '\\') {
+          state = AUTHORITY;
+          continue;
+        } break;
+
+      case AUTHORITY:
+        if (char == '@') {
+          if (seenAt) buffer = '%40' + buffer;
+          seenAt = true;
+          bufferCodePoints = arrayFrom(buffer);
+          for (var i = 0; i < bufferCodePoints.length; i++) {
+            var codePoint = bufferCodePoints[i];
+            if (codePoint == ':' && !seenPasswordToken) {
+              seenPasswordToken = true;
+              continue;
+            }
+            var encodedCodePoints = percentEncode(codePoint, userinfoPercentEncodeSet);
+            if (seenPasswordToken) url.password += encodedCodePoints;
+            else url.username += encodedCodePoints;
+          }
+          buffer = '';
+        } else if (
+          char == EOF || char == '/' || char == '?' || char == '#' ||
+          (char == '\\' && isSpecial(url))
+        ) {
+          if (seenAt && buffer == '') return INVALID_AUTHORITY;
+          pointer -= arrayFrom(buffer).length + 1;
+          buffer = '';
+          state = HOST;
+        } else buffer += char;
+        break;
+
+      case HOST:
+      case HOSTNAME:
+        if (stateOverride && url.scheme == 'file') {
+          state = FILE_HOST;
+          continue;
+        } else if (char == ':' && !seenBracket) {
+          if (buffer == '') return INVALID_HOST;
+          failure = parseHost(url, buffer);
+          if (failure) return failure;
+          buffer = '';
+          state = PORT;
+          if (stateOverride == HOSTNAME) return;
+        } else if (
+          char == EOF || char == '/' || char == '?' || char == '#' ||
+          (char == '\\' && isSpecial(url))
+        ) {
+          if (isSpecial(url) && buffer == '') return INVALID_HOST;
+          if (stateOverride && buffer == '' && (includesCredentials(url) || url.port !== null)) return;
+          failure = parseHost(url, buffer);
+          if (failure) return failure;
+          buffer = '';
+          state = PATH_START;
+          if (stateOverride) return;
+          continue;
+        } else {
+          if (char == '[') seenBracket = true;
+          else if (char == ']') seenBracket = false;
+          buffer += char;
+        } break;
+
+      case PORT:
+        if (DIGIT.test(char)) {
+          buffer += char;
+        } else if (
+          char == EOF || char == '/' || char == '?' || char == '#' ||
+          (char == '\\' && isSpecial(url)) ||
+          stateOverride
+        ) {
+          if (buffer != '') {
+            var port = parseInt(buffer, 10);
+            if (port > 0xFFFF) return INVALID_PORT;
+            url.port = (isSpecial(url) && port === specialSchemes[url.scheme]) ? null : port;
+            buffer = '';
+          }
+          if (stateOverride) return;
+          state = PATH_START;
+          continue;
+        } else return INVALID_PORT;
+        break;
+
+      case FILE:
+        url.scheme = 'file';
+        if (char == '/' || char == '\\') state = FILE_SLASH;
+        else if (base && base.scheme == 'file') {
+          if (char == EOF) {
+            url.host = base.host;
+            url.path = base.path.slice();
+            url.query = base.query;
+          } else if (char == '?') {
+            url.host = base.host;
+            url.path = base.path.slice();
+            url.query = '';
+            state = QUERY;
+          } else if (char == '#') {
+            url.host = base.host;
+            url.path = base.path.slice();
+            url.query = base.query;
+            url.fragment = '';
+            state = FRAGMENT;
+          } else {
+            if (!startsWithWindowsDriveLetter(codePoints.slice(pointer).join(''))) {
+              url.host = base.host;
+              url.path = base.path.slice();
+              shortenURLsPath(url);
+            }
+            state = PATH;
+            continue;
+          }
+        } else {
+          state = PATH;
+          continue;
+        } break;
+
+      case FILE_SLASH:
+        if (char == '/' || char == '\\') {
+          state = FILE_HOST;
+          break;
+        }
+        if (base && base.scheme == 'file' && !startsWithWindowsDriveLetter(codePoints.slice(pointer).join(''))) {
+          if (isWindowsDriveLetter(base.path[0], true)) url.path.push(base.path[0]);
+          else url.host = base.host;
+        }
+        state = PATH;
+        continue;
+
+      case FILE_HOST:
+        if (char == EOF || char == '/' || char == '\\' || char == '?' || char == '#') {
+          if (!stateOverride && isWindowsDriveLetter(buffer)) {
+            state = PATH;
+          } else if (buffer == '') {
+            url.host = '';
+            if (stateOverride) return;
+            state = PATH_START;
+          } else {
+            failure = parseHost(url, buffer);
+            if (failure) return failure;
+            if (url.host == 'localhost') url.host = '';
+            if (stateOverride) return;
+            buffer = '';
+            state = PATH_START;
+          } continue;
+        } else buffer += char;
+        break;
+
+      case PATH_START:
+        if (isSpecial(url)) {
+          state = PATH;
+          if (char != '/' && char != '\\') continue;
+        } else if (!stateOverride && char == '?') {
+          url.query = '';
+          state = QUERY;
+        } else if (!stateOverride && char == '#') {
+          url.fragment = '';
+          state = FRAGMENT;
+        } else if (char != EOF) {
+          state = PATH;
+          if (char != '/') continue;
+        } break;
+
+      case PATH:
+        if (
+          char == EOF || char == '/' ||
+          (char == '\\' && isSpecial(url)) ||
+          (!stateOverride && (char == '?' || char == '#'))
+        ) {
+          if (isDoubleDot(buffer)) {
+            shortenURLsPath(url);
+            if (char != '/' && !(char == '\\' && isSpecial(url))) {
+              url.path.push('');
+            }
+          } else if (isSingleDot(buffer)) {
+            if (char != '/' && !(char == '\\' && isSpecial(url))) {
+              url.path.push('');
+            }
+          } else {
+            if (url.scheme == 'file' && !url.path.length && isWindowsDriveLetter(buffer)) {
+              if (url.host) url.host = '';
+              buffer = buffer.charAt(0) + ':'; // normalize windows drive letter
+            }
+            url.path.push(buffer);
+          }
+          buffer = '';
+          if (url.scheme == 'file' && (char == EOF || char == '?' || char == '#')) {
+            while (url.path.length > 1 && url.path[0] === '') {
+              url.path.shift();
+            }
+          }
+          if (char == '?') {
+            url.query = '';
+            state = QUERY;
+          } else if (char == '#') {
+            url.fragment = '';
+            state = FRAGMENT;
+          }
+        } else {
+          buffer += percentEncode(char, pathPercentEncodeSet);
+        } break;
+
+      case CANNOT_BE_A_BASE_URL_PATH:
+        if (char == '?') {
+          url.query = '';
+          state = QUERY;
+        } else if (char == '#') {
+          url.fragment = '';
+          state = FRAGMENT;
+        } else if (char != EOF) {
+          url.path[0] += percentEncode(char, C0ControlPercentEncodeSet);
+        } break;
+
+      case QUERY:
+        if (!stateOverride && char == '#') {
+          url.fragment = '';
+          state = FRAGMENT;
+        } else if (char != EOF) {
+          if (char == "'" && isSpecial(url)) url.query += '%27';
+          else if (char == '#') url.query += '%23';
+          else url.query += percentEncode(char, C0ControlPercentEncodeSet);
+        } break;
+
+      case FRAGMENT:
+        if (char != EOF) url.fragment += percentEncode(char, fragmentPercentEncodeSet);
+        break;
+    }
+
+    pointer++;
+  }
+};
+
+// `URL` constructor
+// https://url.spec.whatwg.org/#url-class
+var URLConstructor = function URL(url /* , base */) {
+  var that = anInstance(this, URLConstructor, 'URL');
+  var base = arguments.length > 1 ? arguments[1] : undefined;
+  var urlString = $toString(url);
+  var state = setInternalState(that, { type: 'URL' });
+  var baseState, failure;
+  if (base !== undefined) {
+    if (base instanceof URLConstructor) baseState = getInternalURLState(base);
+    else {
+      failure = parseURL(baseState = {}, $toString(base));
+      if (failure) throw TypeError(failure);
+    }
+  }
+  failure = parseURL(state, urlString, null, baseState);
+  if (failure) throw TypeError(failure);
+  var searchParams = state.searchParams = new URLSearchParams();
+  var searchParamsState = getInternalSearchParamsState(searchParams);
+  searchParamsState.updateSearchParams(state.query);
+  searchParamsState.updateURL = function () {
+    state.query = String(searchParams) || null;
+  };
+  if (!DESCRIPTORS) {
+    that.href = serializeURL.call(that);
+    that.origin = getOrigin.call(that);
+    that.protocol = getProtocol.call(that);
+    that.username = getUsername.call(that);
+    that.password = getPassword.call(that);
+    that.host = getHost.call(that);
+    that.hostname = getHostname.call(that);
+    that.port = getPort.call(that);
+    that.pathname = getPathname.call(that);
+    that.search = getSearch.call(that);
+    that.searchParams = getSearchParams.call(that);
+    that.hash = getHash.call(that);
+  }
+};
+
+var URLPrototype = URLConstructor.prototype;
+
+var serializeURL = function () {
+  var url = getInternalURLState(this);
+  var scheme = url.scheme;
+  var username = url.username;
+  var password = url.password;
+  var host = url.host;
+  var port = url.port;
+  var path = url.path;
+  var query = url.query;
+  var fragment = url.fragment;
+  var output = scheme + ':';
+  if (host !== null) {
+    output += '//';
+    if (includesCredentials(url)) {
+      output += username + (password ? ':' + password : '') + '@';
+    }
+    output += serializeHost(host);
+    if (port !== null) output += ':' + port;
+  } else if (scheme == 'file') output += '//';
+  output += url.cannotBeABaseURL ? path[0] : path.length ? '/' + path.join('/') : '';
+  if (query !== null) output += '?' + query;
+  if (fragment !== null) output += '#' + fragment;
+  return output;
+};
+
+var getOrigin = function () {
+  var url = getInternalURLState(this);
+  var scheme = url.scheme;
+  var port = url.port;
+  if (scheme == 'blob') try {
+    return new URLConstructor(scheme.path[0]).origin;
+  } catch (error) {
+    return 'null';
+  }
+  if (scheme == 'file' || !isSpecial(url)) return 'null';
+  return scheme + '://' + serializeHost(url.host) + (port !== null ? ':' + port : '');
+};
+
+var getProtocol = function () {
+  return getInternalURLState(this).scheme + ':';
+};
+
+var getUsername = function () {
+  return getInternalURLState(this).username;
+};
+
+var getPassword = function () {
+  return getInternalURLState(this).password;
+};
+
+var getHost = function () {
+  var url = getInternalURLState(this);
+  var host = url.host;
+  var port = url.port;
+  return host === null ? ''
+    : port === null ? serializeHost(host)
+    : serializeHost(host) + ':' + port;
+};
+
+var getHostname = function () {
+  var host = getInternalURLState(this).host;
+  return host === null ? '' : serializeHost(host);
+};
+
+var getPort = function () {
+  var port = getInternalURLState(this).port;
+  return port === null ? '' : String(port);
+};
+
+var getPathname = function () {
+  var url = getInternalURLState(this);
+  var path = url.path;
+  return url.cannotBeABaseURL ? path[0] : path.length ? '/' + path.join('/') : '';
+};
+
+var getSearch = function () {
+  var query = getInternalURLState(this).query;
+  return query ? '?' + query : '';
+};
+
+var getSearchParams = function () {
+  return getInternalURLState(this).searchParams;
+};
+
+var getHash = function () {
+  var fragment = getInternalURLState(this).fragment;
+  return fragment ? '#' + fragment : '';
+};
+
+var accessorDescriptor = function (getter, setter) {
+  return { get: getter, set: setter, configurable: true, enumerable: true };
+};
+
+if (DESCRIPTORS) {
+  defineProperties(URLPrototype, {
+    // `URL.prototype.href` accessors pair
+    // https://url.spec.whatwg.org/#dom-url-href
+    href: accessorDescriptor(serializeURL, function (href) {
+      var url = getInternalURLState(this);
+      var urlString = $toString(href);
+      var failure = parseURL(url, urlString);
+      if (failure) throw TypeError(failure);
+      getInternalSearchParamsState(url.searchParams).updateSearchParams(url.query);
+    }),
+    // `URL.prototype.origin` getter
+    // https://url.spec.whatwg.org/#dom-url-origin
+    origin: accessorDescriptor(getOrigin),
+    // `URL.prototype.protocol` accessors pair
+    // https://url.spec.whatwg.org/#dom-url-protocol
+    protocol: accessorDescriptor(getProtocol, function (protocol) {
+      var url = getInternalURLState(this);
+      parseURL(url, $toString(protocol) + ':', SCHEME_START);
+    }),
+    // `URL.prototype.username` accessors pair
+    // https://url.spec.whatwg.org/#dom-url-username
+    username: accessorDescriptor(getUsername, function (username) {
+      var url = getInternalURLState(this);
+      var codePoints = arrayFrom($toString(username));
+      if (cannotHaveUsernamePasswordPort(url)) return;
+      url.username = '';
+      for (var i = 0; i < codePoints.length; i++) {
+        url.username += percentEncode(codePoints[i], userinfoPercentEncodeSet);
+      }
+    }),
+    // `URL.prototype.password` accessors pair
+    // https://url.spec.whatwg.org/#dom-url-password
+    password: accessorDescriptor(getPassword, function (password) {
+      var url = getInternalURLState(this);
+      var codePoints = arrayFrom($toString(password));
+      if (cannotHaveUsernamePasswordPort(url)) return;
+      url.password = '';
+      for (var i = 0; i < codePoints.length; i++) {
+        url.password += percentEncode(codePoints[i], userinfoPercentEncodeSet);
+      }
+    }),
+    // `URL.prototype.host` accessors pair
+    // https://url.spec.whatwg.org/#dom-url-host
+    host: accessorDescriptor(getHost, function (host) {
+      var url = getInternalURLState(this);
+      if (url.cannotBeABaseURL) return;
+      parseURL(url, $toString(host), HOST);
+    }),
+    // `URL.prototype.hostname` accessors pair
+    // https://url.spec.whatwg.org/#dom-url-hostname
+    hostname: accessorDescriptor(getHostname, function (hostname) {
+      var url = getInternalURLState(this);
+      if (url.cannotBeABaseURL) return;
+      parseURL(url, $toString(hostname), HOSTNAME);
+    }),
+    // `URL.prototype.port` accessors pair
+    // https://url.spec.whatwg.org/#dom-url-port
+    port: accessorDescriptor(getPort, function (port) {
+      var url = getInternalURLState(this);
+      if (cannotHaveUsernamePasswordPort(url)) return;
+      port = $toString(port);
+      if (port == '') url.port = null;
+      else parseURL(url, port, PORT);
+    }),
+    // `URL.prototype.pathname` accessors pair
+    // https://url.spec.whatwg.org/#dom-url-pathname
+    pathname: accessorDescriptor(getPathname, function (pathname) {
+      var url = getInternalURLState(this);
+      if (url.cannotBeABaseURL) return;
+      url.path = [];
+      parseURL(url, $toString(pathname), PATH_START);
+    }),
+    // `URL.prototype.search` accessors pair
+    // https://url.spec.whatwg.org/#dom-url-search
+    search: accessorDescriptor(getSearch, function (search) {
+      var url = getInternalURLState(this);
+      search = $toString(search);
+      if (search == '') {
+        url.query = null;
+      } else {
+        if ('?' == search.charAt(0)) search = search.slice(1);
+        url.query = '';
+        parseURL(url, search, QUERY);
+      }
+      getInternalSearchParamsState(url.searchParams).updateSearchParams(url.query);
+    }),
+    // `URL.prototype.searchParams` getter
+    // https://url.spec.whatwg.org/#dom-url-searchparams
+    searchParams: accessorDescriptor(getSearchParams),
+    // `URL.prototype.hash` accessors pair
+    // https://url.spec.whatwg.org/#dom-url-hash
+    hash: accessorDescriptor(getHash, function (hash) {
+      var url = getInternalURLState(this);
+      hash = $toString(hash);
+      if (hash == '') {
+        url.fragment = null;
+        return;
+      }
+      if ('#' == hash.charAt(0)) hash = hash.slice(1);
+      url.fragment = '';
+      parseURL(url, hash, FRAGMENT);
+    })
+  });
+}
+
+// `URL.prototype.toJSON` method
+// https://url.spec.whatwg.org/#dom-url-tojson
+redefine(URLPrototype, 'toJSON', function toJSON() {
+  return serializeURL.call(this);
+}, { enumerable: true });
+
+// `URL.prototype.toString` method
+// https://url.spec.whatwg.org/#URL-stringification-behavior
+redefine(URLPrototype, 'toString', function toString() {
+  return serializeURL.call(this);
+}, { enumerable: true });
+
+if (NativeURL) {
+  var nativeCreateObjectURL = NativeURL.createObjectURL;
+  var nativeRevokeObjectURL = NativeURL.revokeObjectURL;
+  // `URL.createObjectURL` method
+  // https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL
+  // eslint-disable-next-line no-unused-vars -- required for `.length`
+  if (nativeCreateObjectURL) redefine(URLConstructor, 'createObjectURL', function createObjectURL(blob) {
+    return nativeCreateObjectURL.apply(NativeURL, arguments);
+  });
+  // `URL.revokeObjectURL` method
+  // https://developer.mozilla.org/en-US/docs/Web/API/URL/revokeObjectURL
+  // eslint-disable-next-line no-unused-vars -- required for `.length`
+  if (nativeRevokeObjectURL) redefine(URLConstructor, 'revokeObjectURL', function revokeObjectURL(url) {
+    return nativeRevokeObjectURL.apply(NativeURL, arguments);
+  });
+}
+
+setToStringTag(URLConstructor, 'URL');
+
+$({ global: true, forced: !USE_NATIVE_URL, sham: !DESCRIPTORS }, {
+  URL: URLConstructor
+});
+
+
+/***/ }),
+
+/***/ 462:
+/***/ (() => {
+
+/* (ignored) */
+
+/***/ }),
+
+/***/ 6029:
+/***/ (() => {
+
+/* (ignored) */
+
+/***/ })
+
+/******/ 	});
+/************************************************************************/
+/******/ 	// The module cache
+/******/ 	var __webpack_module_cache__ = {};
+/******/ 	
+/******/ 	// The require function
+/******/ 	function __webpack_require__(moduleId) {
+/******/ 		// Check if module is in cache
+/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
+/******/ 		if (cachedModule !== undefined) {
+/******/ 			return cachedModule.exports;
+/******/ 		}
+/******/ 		// Create a new module (and put it into the cache)
+/******/ 		var module = __webpack_module_cache__[moduleId] = {
+/******/ 			// no module.id needed
+/******/ 			// no module.loaded needed
+/******/ 			exports: {}
+/******/ 		};
+/******/ 	
+/******/ 		// Execute the module function
+/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
+/******/ 	
+/******/ 		// Return the exports of the module
+/******/ 		return module.exports;
+/******/ 	}
+/******/ 	
+/************************************************************************/
+/******/ 	/* webpack/runtime/compat get default export */
+/******/ 	(() => {
+/******/ 		// getDefaultExport function for compatibility with non-harmony modules
+/******/ 		__webpack_require__.n = (module) => {
+/******/ 			var getter = module && module.__esModule ?
+/******/ 				() => (module['default']) :
+/******/ 				() => (module);
+/******/ 			__webpack_require__.d(getter, { a: getter });
+/******/ 			return getter;
+/******/ 		};
+/******/ 	})();
+/******/ 	
+/******/ 	/* webpack/runtime/define property getters */
+/******/ 	(() => {
+/******/ 		// define getter functions for harmony exports
+/******/ 		__webpack_require__.d = (exports, definition) => {
+/******/ 			for(var key in definition) {
+/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
+/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
+/******/ 				}
+/******/ 			}
+/******/ 		};
+/******/ 	})();
+/******/ 	
+/******/ 	/* webpack/runtime/global */
+/******/ 	(() => {
+/******/ 		__webpack_require__.g = (function() {
+/******/ 			if (typeof globalThis === 'object') return globalThis;
+/******/ 			try {
+/******/ 				return this || new Function('return this')();
+/******/ 			} catch (e) {
+/******/ 				if (typeof window === 'object') return window;
+/******/ 			}
+/******/ 		})();
+/******/ 	})();
+/******/ 	
+/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
+/******/ 	(() => {
+/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
+/******/ 	})();
+/******/ 	
+/******/ 	/* webpack/runtime/make namespace object */
+/******/ 	(() => {
+/******/ 		// define __esModule on exports
+/******/ 		__webpack_require__.r = (exports) => {
+/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
+/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
+/******/ 			}
+/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
+/******/ 		};
+/******/ 	})();
+/******/ 	
+/************************************************************************/
+var __webpack_exports__ = {};
+// This entry need to be wrapped in an IIFE because it need to be in strict mode.
+(() => {
+"use strict";
+// ESM COMPAT FLAG
+__webpack_require__.r(__webpack_exports__);
+
+// EXPORTS
+__webpack_require__.d(__webpack_exports__, {
+  "AACDepay": () => (/* reexport */ AACDepay),
+  "BasicDepay": () => (/* reexport */ BasicDepay),
+  "CanvasSink": () => (/* reexport */ CanvasSink),
+  "H264Depay": () => (/* reexport */ H264Depay),
+  "Html5CanvasPipeline": () => (/* reexport */ Html5CanvasPipeline),
+  "Html5VideoMetadataPipeline": () => (/* reexport */ Html5VideoMetadataPipeline),
+  "Html5VideoPipeline": () => (/* reexport */ Html5VideoPipeline),
+  "HttpMsePipeline": () => (/* reexport */ HttpMsePipeline),
+  "HttpSource": () => (/* reexport */ HttpSource),
+  "Inspector": () => (/* reexport */ Inspector),
+  "JPEGDepay": () => (/* reexport */ JPEGDepay),
+  "MessageType": () => (/* reexport */ MessageType),
+  "MetadataPipeline": () => (/* reexport */ MetadataPipeline),
+  "Mp4Capture": () => (/* reexport */ Mp4Capture),
+  "Mp4Muxer": () => (/* reexport */ Mp4Muxer),
+  "MseSink": () => (/* reexport */ MseSink),
+  "ONVIFDepay": () => (/* reexport */ ONVIFDepay),
+  "Pipeline": () => (/* reexport */ Pipeline),
+  "RTCPPacketType": () => (/* reexport */ RTCPPacketType),
+  "RTSPResponseError": () => (/* reexport */ RTSPResponseError),
+  "RTSP_METHOD": () => (/* reexport */ RTSP_METHOD),
+  "RtspMjpegPipeline": () => (/* reexport */ RtspMjpegPipeline),
+  "RtspMp4Pipeline": () => (/* reexport */ RtspMp4Pipeline),
+  "RtspParser": () => (/* reexport */ RtspParser),
+  "RtspPipeline": () => (/* reexport */ RtspPipeline),
+  "RtspSession": () => (/* reexport */ RtspSession),
+  "SDESItem": () => (/* reexport */ SDESItem),
+  "SR": () => (/* reexport */ SR),
+  "Scheduler": () => (/* reexport */ Scheduler),
+  "Sink": () => (/* reexport */ Sink),
+  "Source": () => (/* reexport */ Source),
+  "Tube": () => (/* reexport */ Tube),
+  "WSSource": () => (/* reexport */ WSSource),
+  "WsSdpPipeline": () => (/* reexport */ WsSdpPipeline),
+  "addRTSPRetry": () => (/* reexport */ addRTSPRetry),
+  "bodyOffset": () => (/* reexport */ bodyOffset),
+  "cSrc": () => (/* reexport */ cSrc),
+  "cSrcCount": () => (/* reexport */ cSrcCount),
+  "components": () => (/* reexport */ index_browser_namespaceObject),
+  "connectionEnded": () => (/* reexport */ connectionEnded),
+  "contentBase": () => (/* reexport */ contentBase),
+  "contentLocation": () => (/* reexport */ contentLocation),
+  "createTransform": () => (/* reexport */ createTransform),
+  "extHeader": () => (/* reexport */ extHeader),
+  "extHeaderLength": () => (/* reexport */ extHeaderLength),
+  "extension": () => (/* reexport */ extension),
+  "extractHeaderValue": () => (/* reexport */ extractHeaderValue),
+  "extractURIs": () => (/* reexport */ extractURIs),
+  "getTime": () => (/* reexport */ getTime),
+  "isRtcpApp": () => (/* reexport */ isRtcpApp),
+  "isRtcpBye": () => (/* reexport */ isRtcpBye),
+  "isRtcpRR": () => (/* reexport */ isRtcpRR),
+  "isRtcpSDES": () => (/* reexport */ isRtcpSDES),
+  "isRtcpSR": () => (/* reexport */ isRtcpSR),
+  "marker": () => (/* reexport */ marker),
+  "messageFromBuffer": () => (/* reexport */ messageFromBuffer),
+  "padding": () => (/* reexport */ padding),
+  "parse": () => (/* reexport */ sdp_parse),
+  "parseRtcp": () => (/* reexport */ parseRtcp),
+  "payload": () => (/* reexport */ payload),
+  "payloadType": () => (/* reexport */ payloadType),
+  "pipelines": () => (/* reexport */ pipelines_index_browser_namespaceObject),
+  "range": () => (/* reexport */ range),
+  "rtcpMessageFromBuffer": () => (/* reexport */ rtcpMessageFromBuffer),
+  "sSrc": () => (/* reexport */ sSrc),
+  "sequence": () => (/* reexport */ sequence),
+  "sequenceNumber": () => (/* reexport */ sequenceNumber),
+  "sessionId": () => (/* reexport */ sessionId),
+  "sessionTimeout": () => (/* reexport */ sessionTimeout),
+  "statusCode": () => (/* reexport */ statusCode),
+  "timestamp": () => (/* reexport */ timestamp),
+  "utils": () => (/* reexport */ utils_index_browser_namespaceObject),
+  "version": () => (/* reexport */ version)
+});
+
+// NAMESPACE OBJECT: ./lib/components/index.browser.ts
+var index_browser_namespaceObject = {};
+__webpack_require__.r(index_browser_namespaceObject);
+__webpack_require__.d(index_browser_namespaceObject, {
+  "AACDepay": () => (AACDepay),
+  "BasicDepay": () => (BasicDepay),
+  "CanvasSink": () => (CanvasSink),
+  "H264Depay": () => (H264Depay),
+  "HttpSource": () => (HttpSource),
+  "Inspector": () => (Inspector),
+  "JPEGDepay": () => (JPEGDepay),
+  "MessageType": () => (MessageType),
+  "Mp4Capture": () => (Mp4Capture),
+  "Mp4Muxer": () => (Mp4Muxer),
+  "MseSink": () => (MseSink),
+  "ONVIFDepay": () => (ONVIFDepay),
+  "RTSPResponseError": () => (RTSPResponseError),
+  "RTSP_METHOD": () => (RTSP_METHOD),
+  "RtspParser": () => (RtspParser),
+  "RtspSession": () => (RtspSession),
+  "Sink": () => (Sink),
+  "Source": () => (Source),
+  "Tube": () => (Tube),
+  "WSSource": () => (WSSource),
+  "createTransform": () => (createTransform)
+});
+
+// NAMESPACE OBJECT: ./lib/pipelines/index.browser.ts
+var pipelines_index_browser_namespaceObject = {};
+__webpack_require__.r(pipelines_index_browser_namespaceObject);
+__webpack_require__.d(pipelines_index_browser_namespaceObject, {
+  "Html5CanvasPipeline": () => (Html5CanvasPipeline),
+  "Html5VideoMetadataPipeline": () => (Html5VideoMetadataPipeline),
+  "Html5VideoPipeline": () => (Html5VideoPipeline),
+  "HttpMsePipeline": () => (HttpMsePipeline),
+  "MetadataPipeline": () => (MetadataPipeline),
+  "Pipeline": () => (Pipeline),
+  "RtspMjpegPipeline": () => (RtspMjpegPipeline),
+  "RtspMp4Pipeline": () => (RtspMp4Pipeline),
+  "RtspPipeline": () => (RtspPipeline),
+  "WsSdpPipeline": () => (WsSdpPipeline)
+});
+
+// NAMESPACE OBJECT: ./lib/utils/index.browser.ts
+var utils_index_browser_namespaceObject = {};
+__webpack_require__.r(utils_index_browser_namespaceObject);
+__webpack_require__.d(utils_index_browser_namespaceObject, {
+  "RTCPPacketType": () => (RTCPPacketType),
+  "SDESItem": () => (SDESItem),
+  "SR": () => (SR),
+  "Scheduler": () => (Scheduler),
+  "addRTSPRetry": () => (addRTSPRetry),
+  "bodyOffset": () => (bodyOffset),
+  "cSrc": () => (cSrc),
+  "cSrcCount": () => (cSrcCount),
+  "connectionEnded": () => (connectionEnded),
+  "contentBase": () => (contentBase),
+  "contentLocation": () => (contentLocation),
+  "extHeader": () => (extHeader),
+  "extHeaderLength": () => (extHeaderLength),
+  "extension": () => (extension),
+  "extractHeaderValue": () => (extractHeaderValue),
+  "extractURIs": () => (extractURIs),
+  "getTime": () => (getTime),
+  "isRtcpApp": () => (isRtcpApp),
+  "isRtcpBye": () => (isRtcpBye),
+  "isRtcpRR": () => (isRtcpRR),
+  "isRtcpSDES": () => (isRtcpSDES),
+  "isRtcpSR": () => (isRtcpSR),
+  "marker": () => (marker),
+  "messageFromBuffer": () => (messageFromBuffer),
+  "padding": () => (padding),
+  "parse": () => (sdp_parse),
+  "parseRtcp": () => (parseRtcp),
+  "payload": () => (payload),
+  "payloadType": () => (payloadType),
+  "range": () => (range),
+  "rtcpMessageFromBuffer": () => (rtcpMessageFromBuffer),
+  "sSrc": () => (sSrc),
+  "sequence": () => (sequence),
+  "sequenceNumber": () => (sequenceNumber),
+  "sessionId": () => (sessionId),
+  "sessionTimeout": () => (sessionTimeout),
+  "statusCode": () => (statusCode),
+  "timestamp": () => (timestamp),
+  "version": () => (version)
+});
+
+// EXTERNAL MODULE: ./.yarn/unplugged/core-js-npm-3.16.2-c7ce9e8d48/node_modules/core-js/modules/es.object.set-prototype-of.js
+var es_object_set_prototype_of = __webpack_require__(1511);
+// EXTERNAL MODULE: ./.yarn/unplugged/core-js-npm-3.16.2-c7ce9e8d48/node_modules/core-js/modules/es.object.get-prototype-of.js
+var es_object_get_prototype_of = __webpack_require__(8400);
+// EXTERNAL MODULE: ./.yarn/unplugged/core-js-npm-3.16.2-c7ce9e8d48/node_modules/core-js/modules/es.reflect.construct.js
+var es_reflect_construct = __webpack_require__(6259);
+// EXTERNAL MODULE: ./.yarn/unplugged/core-js-npm-3.16.2-c7ce9e8d48/node_modules/core-js/modules/es.symbol.js
+var es_symbol = __webpack_require__(7404);
+// EXTERNAL MODULE: ./.yarn/unplugged/core-js-npm-3.16.2-c7ce9e8d48/node_modules/core-js/modules/es.symbol.description.js
+var es_symbol_description = __webpack_require__(8787);
+// EXTERNAL MODULE: ./.yarn/unplugged/core-js-npm-3.16.2-c7ce9e8d48/node_modules/core-js/modules/es.object.to-string.js
+var es_object_to_string = __webpack_require__(74);
+// EXTERNAL MODULE: ./.yarn/unplugged/core-js-npm-3.16.2-c7ce9e8d48/node_modules/core-js/modules/es.symbol.iterator.js
+var es_symbol_iterator = __webpack_require__(5753);
+// EXTERNAL MODULE: ./.yarn/unplugged/core-js-npm-3.16.2-c7ce9e8d48/node_modules/core-js/modules/es.array.iterator.js
+var es_array_iterator = __webpack_require__(2837);
+// EXTERNAL MODULE: ./.yarn/unplugged/core-js-npm-3.16.2-c7ce9e8d48/node_modules/core-js/modules/es.string.iterator.js
+var es_string_iterator = __webpack_require__(6949);
+// EXTERNAL MODULE: ./.yarn/unplugged/core-js-npm-3.16.2-c7ce9e8d48/node_modules/core-js/modules/web.dom-collections.iterator.js
+var web_dom_collections_iterator = __webpack_require__(9773);
+// EXTERNAL MODULE: ./.yarn/cache/stream-browserify-npm-3.0.0-4c0bd97245-4c47ef64d6.zip/node_modules/stream-browserify/index.js
+var stream_browserify = __webpack_require__(8981);
+// EXTERNAL MODULE: ./.yarn/unplugged/core-js-npm-3.16.2-c7ce9e8d48/node_modules/core-js/modules/es.object.assign.js
+var es_object_assign = __webpack_require__(5940);
+// EXTERNAL MODULE: ./.yarn/unplugged/core-js-npm-3.16.2-c7ce9e8d48/node_modules/core-js/modules/es.regexp.to-string.js
+var es_regexp_to_string = __webpack_require__(5699);
+;// CONCATENATED MODULE: ./lib/components/helpers/stream-factory.ts
+/* provided dependency */ var Buffer = __webpack_require__(7866)["Buffer"];
+
+
+
+
+function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
+
+function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
+
+function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }
+
+
+
+var StreamFactory = /*#__PURE__*/function () {
+  function StreamFactory() {
+    _classCallCheck(this, StreamFactory);
+  }
+
+  _createClass(StreamFactory, null, [{
+    key: "consumer",
+    value:
+    /**
+     * Creates a writable stream that sends all messages written to the stream
+     * to a callback function and then considers it written.
+     * @param fn  The callback to be invoked on the message
+     */
+    function consumer() {
+      var fn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {
+        /* */
+      };
+      return new stream_browserify.Writable({
+        objectMode: true,
+        write: function write(msg, _encoding, callback) {
+          fn(msg);
+          callback();
+        }
+      });
+    }
+  }, {
+    key: "peeker",
+    value: function peeker(fn) {
+      if (typeof fn !== 'function') {
+        throw new Error('you must supply a function');
+      }
+
+      return new stream_browserify.Transform({
+        objectMode: true,
+        transform: function transform(msg, _encoding, callback) {
+          fn(msg);
+          callback(undefined, msg);
+        }
+      });
+    }
+    /**
+     * Creates a readable stream that sends a message for each element of an array.
+     * @param arr  The array with elements to be turned into a stream.
+     */
+
+  }, {
+    key: "producer",
+    value: function producer(messages) {
+      var counter = 0;
+      return new stream_browserify.Readable({
+        objectMode: true,
+        read: function read() {
+          if (messages !== undefined) {
+            if (counter < messages.length) {
+              this.push(messages[counter++]);
+            } else {
+              // End the stream
+              this.push(null);
+            }
+          }
+        }
+      });
+    }
+  }, {
+    key: "recorder",
+    value: function recorder(type, fileStream) {
+      return new stream_browserify.Transform({
+        objectMode: true,
+        transform: function transform(msg, encoding, callback) {
+          var timestamp = Date.now(); // Replace binary data with base64 string
+
+          var message = Object.assign({}, msg, {
+            data: msg.data.toString('base64')
+          });
+          fileStream.write(JSON.stringify({
+            type: type,
+            timestamp: timestamp,
+            message: message
+          }, null, 2));
+          fileStream.write(',\n');
+          callback(undefined, msg);
+        }
+      });
+    }
+    /**
+     * Yield binary messages from JSON packet array until depleted.
+     * @return {Generator} Returns a JSON packet iterator.
+     */
+
+  }, {
+    key: "replayer",
+    value: function replayer(packets) {
+      var packetCounter = 0;
+      var lastTimestamp = packets[0].timestamp;
+      return new stream_browserify.Readable({
+        objectMode: true,
+        read: function read() {
+          var packet = packets[packetCounter++];
+
+          if (packet) {
+            var type = packet.type,
+                timestamp = packet.timestamp,
+                message = packet.message;
+            var delay = timestamp - lastTimestamp;
+            lastTimestamp = timestamp;
+
+            if (message) {
+              var data = message.data ? Buffer.from(message.data, 'base64') : Buffer.alloc(0);
+
+              var _msg = Object.assign({}, message, {
+                data: data
+              });
+
+              this.push({
+                type: type,
+                delay: delay,
+                msg: _msg
+              });
+            } else {
+              this.push({
+                type: type,
+                delay: delay,
+                msg: null
+              });
+            }
+          } else {
+            this.push(null);
+          }
+        }
+      });
+    }
+  }]);
+
+  return StreamFactory;
+}();
+
+
+;// CONCATENATED MODULE: ./lib/components/component.ts
+function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }
+
+
+
+
+
+
+
+
+
+
+
+
+function component_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
+
+function component_createClass(Constructor, protoProps, staticProps) { if (protoProps) component_defineProperties(Constructor.prototype, protoProps); if (staticProps) component_defineProperties(Constructor, staticProps); return Constructor; }
+
+function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }
+
+function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
+
+function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
+
+function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }
+
+function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
+
+function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
+
+function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
+
+function component_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
+
+function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+
+
+
+/**
+ * Component
+ *
+ * A component is a set of bi-directional streams consisting of an 'incoming'
+ * and 'outgoing' stream.
+ *
+ * They contain references to other components so they can form a linked list of
+ * components, i.e. a pipeline. When linking components, the incoming and
+ * outgoing streams are piped, so that data flowing through the incoming stream
+ * is transfered to the next component, and data in the outgoing stream flows
+ * to the previous component.
+ *
+ * Components at the end of such a pipeline typically connect the incoming and
+ * outgoing streams to a data source or data sink.
+ *
+ * Typically, for a component that is connected to two other components, both
+ * incoming and outgoing will be Transform streams. For a source, 'incoming'
+ * will be a Readable stream and 'outgoing' a Writable stream, while for a sink
+ * it is reversed. Both source and sink could also use a single Duplex stream,
+ * with incoming === outgoing.
+ *
+ * server end-point                          client end-point
+ *  /-------------      -----------------      -------------\
+ *  |  Writable  |  <-  |   Transform   |  <-  |  Readable  |
+ *  |   source   |      |      tube     |      |    sink    |
+ *  |  Readable  |  ->  |   Transform   |  ->  |  Writable  |
+ *  \-------------      -----------------      -------------/
+ */
+var AbstractComponent = function AbstractComponent() {
+  component_classCallCheck(this, AbstractComponent);
+
+  _defineProperty(this, "incoming", void 0);
+
+  _defineProperty(this, "outgoing", void 0);
+
+  _defineProperty(this, "next", void 0);
+
+  _defineProperty(this, "prev", void 0);
+
+  _defineProperty(this, "_incomingErrorHandler", void 0);
+
+  _defineProperty(this, "_outgoingErrorHandler", void 0);
+};
+/**
+ * Source component
+ *
+ * A component that can only have a next component connected (no previous) and
+ * where the incoming and outgoing streams are connected to an external data
+ * source.
+ */
+
+
+var Source = /*#__PURE__*/function (_AbstractComponent) {
+  _inherits(Source, _AbstractComponent);
+
+  var _super = _createSuper(Source);
+
+  function Source() {
+    var _this;
+
+    var incoming = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new stream_browserify.Readable({
+      objectMode: true
+    });
+    var outgoing = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new stream_browserify.Writable({
+      objectMode: true
+    });
+
+    component_classCallCheck(this, Source);
+
+    _this = _super.call(this);
+
+    _defineProperty(_assertThisInitialized(_this), "incoming", void 0);
+
+    _defineProperty(_assertThisInitialized(_this), "outgoing", void 0);
+
+    _defineProperty(_assertThisInitialized(_this), "next", void 0);
+
+    _defineProperty(_assertThisInitialized(_this), "prev", void 0);
+
+    _this.incoming = incoming;
+    _this.outgoing = outgoing;
+    _this.next = null;
+    _this.prev = null;
+    return _this;
+  }
+  /**
+   * Attach another component so the the 'down' stream flows into the
+   * next component 'down' stream and the 'up' stream of the other component
+   * flows into the 'up' stream of this component. This is what establishes the
+   * meaning of 'up' and 'down'.
+   * @param  next - The component to connect.
+   * @return A reference to the connected component.
+   *
+   *      -------------- pipe --------------
+   *  <-  |  outgoing  |  <-  |  outgoing  | <-
+   *      |    this    |      |    next    |
+   *  ->  |  incoming  |  ->  |  incoming  | ->
+   *      -------------- pipe --------------
+   */
+
+
+  component_createClass(Source, [{
+    key: "connect",
+    value: function connect(next) {
+      var _this2 = this;
+
+      // If the next component is not there, we want to return this component
+      // so that it is possible to continue to chain. If there is a next component,
+      // but this component already has a next one, or the next one already has a
+      // previous component, throw an error.
+      if (next === null) {
+        return this;
+      } else if (this.next !== null || next.prev !== null) {
+        throw new Error('connection failed: component(s) already connected');
+      }
+
+      if (!this.incoming.readable || !this.outgoing.writable) {
+        throw new Error('connection failed: this component not compatible');
+      }
+
+      if (!next.incoming.writable || !next.outgoing.readable) {
+        throw new Error('connection failed: next component not compatible');
+      }
+
+      try {
+        this.incoming.pipe(next.incoming);
+        next.outgoing.pipe(this.outgoing);
+      } catch (e) {
+        throw new Error("connection failed: ".concat(e.message));
+      }
+      /**
+       * Propagate errors back upstream, this assures an error will be propagated
+       * to all previous streams (but not further than any endpoints). What happens
+       * when an error is emitted on a stream is up to the stream's implementation.
+       */
+
+
+      var incomingErrorHandler = function incomingErrorHandler(err) {
+        _this2.incoming.emit('error', err);
+      };
+
+      next.incoming.on('error', incomingErrorHandler);
+
+      var outgoingErrorHandler = function outgoingErrorHandler(err) {
+        next.outgoing.emit('error', err);
+      };
+
+      this.outgoing.on('error', outgoingErrorHandler); // Keep a bidirectional linked list of components by storing
+      // a reference to the next component and the listeners that we set up.
+
+      this.next = next;
+      next.prev = this;
+      this._incomingErrorHandler = incomingErrorHandler;
+      this._outgoingErrorHandler = outgoingErrorHandler;
+      return next;
+    }
+    /**
+     * Disconnect the next connected component. When there is no next component
+     * the function will just do nothing.
+     * @return {Component} - A reference to this component.
+     */
+
+  }, {
+    key: "disconnect",
+    value: function disconnect() {
+      var next = this.next;
+
+      if (next !== null) {
+        this.incoming.unpipe(next.incoming);
+        next.outgoing.unpipe(this.outgoing);
+
+        if (typeof this._incomingErrorHandler !== 'undefined') {
+          next.incoming.removeListener('error', this._incomingErrorHandler);
+        }
+
+        if (typeof this._outgoingErrorHandler !== 'undefined') {
+          this.outgoing.removeListener('error', this._outgoingErrorHandler);
+        }
+
+        this.next = null;
+        next.prev = null;
+        delete this._incomingErrorHandler;
+        delete this._outgoingErrorHandler;
+      }
+
+      return this;
+    }
+  }], [{
+    key: "fromMessages",
+    value:
+    /**
+     * Set up a source component that has a message list as data source.
+     *
+     * @param messages - List of objects (with data property) to emit on the
+     * incoming stream
+     */
+    function fromMessages(messages) {
+      var component = new Source(StreamFactory.producer(messages), StreamFactory.consumer());
+      return component;
+    }
+  }]);
+
+  return Source;
+}(AbstractComponent);
+/**
+ * Tube component
+ *
+ * A component where both incoming and outgoing streams are Duplex streams, and
+ * can be connected to a previous and next component, typically in the middle of
+ * a pipeline.
+ */
+
+var Tube = /*#__PURE__*/function (_Source) {
+  _inherits(Tube, _Source);
+
+  var _super2 = _createSuper(Tube);
+
+  function Tube() {
+    var _this3;
+
+    var incoming = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new stream_browserify.PassThrough({
+      objectMode: true
+    });
+    var outgoing = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new stream_browserify.PassThrough({
+      objectMode: true
+    });
+
+    component_classCallCheck(this, Tube);
+
+    _this3 = _super2.call(this, incoming, outgoing);
+
+    _defineProperty(_assertThisInitialized(_this3), "incoming", void 0);
+
+    _defineProperty(_assertThisInitialized(_this3), "outgoing", void 0);
+
+    _this3.incoming = incoming;
+    _this3.outgoing = outgoing;
+    return _this3;
+  }
+
+  component_createClass(Tube, null, [{
+    key: "fromHandlers",
+    value:
+    /**
+     * Create a component that calls a handler function for each message passing
+     * through, but otherwise just passes data through.
+     *
+     * Can be used to log messages passing through a pipeline.
+     */
+    function fromHandlers(fnIncoming, fnOutgoing) {
+      var incomingStream = fnIncoming ? StreamFactory.peeker(fnIncoming) : undefined;
+      var outgoingStream = fnOutgoing ? StreamFactory.peeker(fnOutgoing) : undefined;
+      return new Tube(incomingStream, outgoingStream);
+    }
+  }]);
+
+  return Tube;
+}(Source);
+/**
+ * Sink component
+ *
+ * A component that can only have a previous component connected (no next) and
+ * where the incoming and outgoing streams are connected to an external data
+ * source.
+ */
+
+var Sink = /*#__PURE__*/function (_AbstractComponent2) {
+  _inherits(Sink, _AbstractComponent2);
+
+  var _super3 = _createSuper(Sink);
+
+  function Sink() {
+    var _this4;
+
+    var incoming = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new stream_browserify.Writable({
+      objectMode: true
+    });
+    var outgoing = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new stream_browserify.Readable({
+      objectMode: true
+    });
+
+    component_classCallCheck(this, Sink);
+
+    _this4 = _super3.call(this);
+
+    _defineProperty(_assertThisInitialized(_this4), "incoming", void 0);
+
+    _defineProperty(_assertThisInitialized(_this4), "outgoing", void 0);
+
+    _defineProperty(_assertThisInitialized(_this4), "next", void 0);
+
+    _defineProperty(_assertThisInitialized(_this4), "prev", void 0);
+
+    _this4.incoming = incoming;
+    _this4.outgoing = outgoing;
+    _this4.next = null;
+    _this4.prev = null;
+    return _this4;
+  }
+
+  component_createClass(Sink, [{
+    key: "connect",
+    value: function connect() {
+      throw new Error('connection failed: attempting to connect after a sink');
+    }
+  }, {
+    key: "disconnect",
+    value: function disconnect() {
+      return this;
+    }
+  }], [{
+    key: "fromHandler",
+    value:
+    /**
+     * Create a component that swallows incoming data (calling fn on it).  To
+     * print data, you would use fn = console.log.
+     *
+     * @param fn - The callback to use for the incoming data.
+     */
+    function fromHandler(fn) {
+      var component = new Sink(StreamFactory.consumer(fn), StreamFactory.producer(undefined)); // A sink should propagate when stream is ending.
+
+      component.incoming.on('finish', function () {
+        component.outgoing.push(null);
+      });
+      return component;
+    }
+  }]);
+
+  return Sink;
+}(AbstractComponent);
+// EXTERNAL MODULE: ./.yarn/unplugged/core-js-npm-3.16.2-c7ce9e8d48/node_modules/core-js/modules/es.number.constructor.js
+var es_number_constructor = __webpack_require__(3729);
+// EXTERNAL MODULE: ./.yarn/unplugged/core-js-npm-3.16.2-c7ce9e8d48/node_modules/core-js/modules/es.array.slice.js
+var es_array_slice = __webpack_require__(1122);
+// EXTERNAL MODULE: ./.yarn/unplugged/core-js-npm-3.16.2-c7ce9e8d48/node_modules/core-js/modules/es.function.name.js
+var es_function_name = __webpack_require__(2656);
+// EXTERNAL MODULE: ./.yarn/unplugged/core-js-npm-3.16.2-c7ce9e8d48/node_modules/core-js/modules/es.array.from.js
+var es_array_from = __webpack_require__(1917);
+;// CONCATENATED MODULE: ./lib/utils/bits.ts
+var POS = [0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01];
+;// CONCATENATED MODULE: ./lib/utils/protocols/rtp.ts
+/* provided dependency */ var rtp_Buffer = __webpack_require__(7866)["Buffer"];
+
+ // Real Time Protocol (RTP)
+// https://tools.ietf.org/html/rfc3550#section-5.1
+
+/*
+RTP Fixed Header Fields
+
+  0               1               2               3
+  0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7
+  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  |V=2|P|X|  CC   |M|     PT      |       sequence number         |
+  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  |                           timestamp                           |
+  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  |           synchronization source (SSRC) identifier            |
+  +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
+  |            contributing source (CSRC) identifiers             |
+  |                             ....                              |
+  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  |   profile-specific ext. id    | profile-specific ext. length  |
+  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  |                 profile-specific extension                    |
+  |                             ....                              |
+  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+*/
+
+var version = function version(buffer) {
+  return buffer[0] >>> 6;
+};
+var padding = function padding(buffer) {
+  return !!(buffer[0] & POS[2]);
+};
+var extension = function extension(buffer) {
+  return !!(buffer[0] & POS[3]);
+};
+var cSrcCount = function cSrcCount(buffer) {
+  return buffer[0] & 0x0f;
+};
+var marker = function marker(buffer) {
+  return !!(buffer[1] & POS[0]);
+};
+var payloadType = function payloadType(buffer) {
+  return buffer[1] & 0x7f;
+};
+var sequenceNumber = function sequenceNumber(buffer) {
+  return buffer.readUInt16BE(2);
+};
+var timestamp = function timestamp(buffer) {
+  return buffer.readUInt32BE(4);
+};
+var sSrc = function sSrc(buffer) {
+  return buffer.readUInt32BE(8);
+};
+var cSrc = function cSrc(buffer) {
+  var rank = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
+  return cSrcCount(buffer) > rank ? buffer.readUInt32BE(12 + rank * 4) : 0;
+};
+var extHeaderLength = function extHeaderLength(buffer) {
+  return !extension(buffer) ? 0 : buffer.readUInt16BE(12 + cSrcCount(buffer) * 4 + 2);
+};
+var extHeader = function extHeader(buffer) {
+  return extHeaderLength(buffer) === 0 ? rtp_Buffer.from([]) : buffer.slice(12 + cSrcCount(buffer) * 4, 12 + cSrcCount(buffer) * 4 + 4 + extHeaderLength(buffer) * 4);
+};
+var payload = function payload(buffer) {
+  return !extension(buffer) ? buffer.slice(12 + cSrcCount(buffer) * 4) : buffer.slice(12 + cSrcCount(buffer) * 4 + 4 + extHeaderLength(buffer) * 4);
+};
+;// CONCATENATED MODULE: ./lib/components/message.ts
+var MessageType;
+
+(function (MessageType) {
+  MessageType[MessageType["UNKNOWN"] = 0] = "UNKNOWN";
+  MessageType[MessageType["RAW"] = 1] = "RAW";
+  MessageType[MessageType["RTP"] = 2] = "RTP";
+  MessageType[MessageType["RTCP"] = 3] = "RTCP";
+  MessageType[MessageType["RTSP"] = 4] = "RTSP";
+  MessageType[MessageType["SDP"] = 5] = "SDP";
+  MessageType[MessageType["ELEMENTARY"] = 6] = "ELEMENTARY";
+  MessageType[MessageType["H264"] = 7] = "H264";
+  MessageType[MessageType["ISOM"] = 8] = "ISOM";
+  MessageType[MessageType["XML"] = 9] = "XML";
+  MessageType[MessageType["JPEG"] = 10] = "JPEG";
+})(MessageType || (MessageType = {}));
+;// CONCATENATED MODULE: ./lib/components/aacdepay/parser.ts
+
+
+
+/*
+From RFC 3640 https://tools.ietf.org/html/rfc3640
+  2.11.  Global Structure of Payload Format
+
+     The RTP payload following the RTP header, contains three octet-
+     aligned data sections, of which the first two MAY be empty, see
+     Figure 1.
+
+           +---------+-----------+-----------+---------------+
+           | RTP     | AU Header | Auxiliary | Access Unit   |
+           | Header  | Section   | Section   | Data Section  |
+           +---------+-----------+-----------+---------------+
+
+                     <----------RTP Packet Payload----------->
+
+              Figure 1: Data sections within an RTP packet
+Note that auxilary section is empty for AAC-hbr
+
+  3.2.1.  The AU Header Section
+
+   When present, the AU Header Section consists of the AU-headers-length
+   field, followed by a number of AU-headers, see Figure 2.
+
+      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- .. -+-+-+-+-+-+-+-+-+-+
+      |AU-headers-length|AU-header|AU-header|      |AU-header|padding|
+      |                 |   (1)   |   (2)   |      |   (n)   | bits  |
+      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- .. -+-+-+-+-+-+-+-+-+-+
+
+                   Figure 2: The AU Header Section
+*/
+
+function parse(rtp, hasHeader, callback) {
+  var buffer = payload(rtp.data);
+  var headerLength = 0;
+
+  if (hasHeader) {
+    var auHeaderLengthInBits = buffer.readUInt16BE(0);
+    headerLength = 2 + (auHeaderLengthInBits + auHeaderLengthInBits % 8) / 8; // Add padding
+  }
+
+  var packet = {
+    type: MessageType.ELEMENTARY,
+    data: buffer.slice(headerLength),
+    payloadType: payloadType(rtp.data),
+    timestamp: timestamp(rtp.data),
+    ntpTimestamp: rtp.ntpTimestamp
+  };
+  callback(packet);
+}
+;// CONCATENATED MODULE: ./lib/components/messageStreams.ts
+
+var createTransform = function createTransform(transform) {
+  return new stream_browserify.Transform({
+    objectMode: true,
+    transform: transform
+  });
+};
+;// CONCATENATED MODULE: ./lib/components/aacdepay/index.ts
+function aacdepay_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { aacdepay_typeof = function _typeof(obj) { return typeof obj; }; } else { aacdepay_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return aacdepay_typeof(obj); }
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
+
+function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
+
+function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
+
+function aacdepay_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
+
+function aacdepay_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) aacdepay_setPrototypeOf(subClass, superClass); }
+
+function aacdepay_setPrototypeOf(o, p) { aacdepay_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return aacdepay_setPrototypeOf(o, p); }
+
+function aacdepay_createSuper(Derived) { var hasNativeReflectConstruct = aacdepay_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = aacdepay_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = aacdepay_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return aacdepay_possibleConstructorReturn(this, result); }; }
+
+function aacdepay_possibleConstructorReturn(self, call) { if (call && (aacdepay_typeof(call) === "object" || typeof call === "function")) { return call; } return aacdepay_assertThisInitialized(self); }
+
+function aacdepay_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
+
+function aacdepay_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
+
+function aacdepay_getPrototypeOf(o) { aacdepay_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return aacdepay_getPrototypeOf(o); }
+
+
+
+
+
+
+/*
+media: [{ type: 'video',
+   port: '0',
+   proto: 'RTP/AVP',
+   fmt: '96',
+   rtpmap: '96 H264/90000',
+   fmtp: {
+      format: '96',
+      parameters: {
+        'packetization-mode': '1',
+        'profile-level-id': '4d0029',
+        'sprop-parameter-sets': 'Z00AKeKQDwBE/LgLcBAQGkHiRFQ=,aO48gA==',
+      },
+    },
+   control: 'rtsp://hostname/axis-media/media.amp/stream=0?audio=1&video=1',
+   framerate: '25.000000',
+   transform: [[1, 0, 0], [0, 0.75, 0], [0, 0, 1]] },
+   { type: 'audio',
+     port: '0',
+     proto: 'RTP/AVP',
+     fmt: '97',
+     fmtp: {
+       parameters: {
+         bitrate: '32000',
+         config: '1408',
+         indexdeltalength: '3',
+         indexlength: '3',
+         mode: 'AAC-hbr',
+         'profile-level-id': '2',
+         sizelength: '13',
+         streamtype: '5'
+       },
+       format: '97'
+     },
+     rtpmap: '97 MPEG4-GENERIC/16000/1',
+     control: 'rtsp://hostname/axis-media/media.amp/stream=1?audio=1&video=1' }]
+*/
+
+var AACDepay = /*#__PURE__*/function (_Tube) {
+  aacdepay_inherits(AACDepay, _Tube);
+
+  var _super = aacdepay_createSuper(AACDepay);
+
+  function AACDepay() {
+    aacdepay_classCallCheck(this, AACDepay);
+
+    var AACPayloadType;
+    var hasHeader;
+    var incoming = createTransform(function (msg, encoding, callback) {
+      if (msg.type === MessageType.SDP) {
+        // Check if there is an AAC track in the SDP
+        var validMedia;
+
+        var _iterator = _createForOfIteratorHelper(msg.sdp.media),
+            _step;
+
+        try {
+          for (_iterator.s(); !(_step = _iterator.n()).done;) {
+            var media = _step.value;
+
+            if (media.type === 'audio' && media.fmtp && media.fmtp.parameters && media.fmtp.parameters.mode === 'AAC-hbr') {
+              validMedia = media;
+            }
+          }
+        } catch (err) {
+          _iterator.e(err);
+        } finally {
+          _iterator.f();
+        }
+
+        if (validMedia && validMedia.rtpmap !== undefined) {
+          AACPayloadType = Number(validMedia.rtpmap.payloadType);
+          var parameters = validMedia.fmtp.parameters; // Required
+
+          var sizeLength = Number(parameters.sizelength) || 0;
+          var indexLength = Number(parameters.indexlength) || 0;
+          var indexDeltaLength = Number(parameters.indexdeltalength) || 0; // Optionals
+
+          var CTSDeltaLength = Number(parameters.ctsdeltalength) || 0;
+          var DTSDeltaLength = Number(parameters.dtsdeltalength) || 0;
+          var RandomAccessIndication = Number(parameters.randomaccessindication) || 0;
+          var StreamStateIndication = Number(parameters.streamstateindication) || 0;
+          var AuxiliaryDataSizeLength = Number(parameters.auxiliarydatasizelength) || 0;
+          hasHeader = sizeLength + Math.max(indexLength, indexDeltaLength) + CTSDeltaLength + DTSDeltaLength + RandomAccessIndication + StreamStateIndication + AuxiliaryDataSizeLength > 0;
+        }
+
+        callback(undefined, msg);
+      } else if (msg.type === MessageType.RTP && payloadType(msg.data) === AACPayloadType) {
+        parse(msg, hasHeader, this.push.bind(this));
+        callback();
+      } else {
+        // Not a message we should handle
+        callback(undefined, msg);
+      }
+    }); // outgoing will be defaulted to a PassThrough stream
+
+    return _super.call(this, incoming);
+  }
+
+  return AACDepay;
+}(Tube);
+// EXTERNAL MODULE: ./.yarn/unplugged/core-js-npm-3.16.2-c7ce9e8d48/node_modules/core-js/modules/es.array.concat.js
+var es_array_concat = __webpack_require__(6218);
+;// CONCATENATED MODULE: ./lib/components/basicdepay/index.ts
+/* provided dependency */ var basicdepay_Buffer = __webpack_require__(7866)["Buffer"];
+function basicdepay_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { basicdepay_typeof = function _typeof(obj) { return typeof obj; }; } else { basicdepay_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return basicdepay_typeof(obj); }
+
+
+
+
+
+
+
+
+
+
+
+
+
+function basicdepay_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
+
+function basicdepay_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) basicdepay_setPrototypeOf(subClass, superClass); }
+
+function basicdepay_setPrototypeOf(o, p) { basicdepay_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return basicdepay_setPrototypeOf(o, p); }
+
+function basicdepay_createSuper(Derived) { var hasNativeReflectConstruct = basicdepay_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = basicdepay_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = basicdepay_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return basicdepay_possibleConstructorReturn(this, result); }; }
+
+function basicdepay_possibleConstructorReturn(self, call) { if (call && (basicdepay_typeof(call) === "object" || typeof call === "function")) { return call; } return basicdepay_assertThisInitialized(self); }
+
+function basicdepay_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
+
+function basicdepay_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
+
+function basicdepay_getPrototypeOf(o) { basicdepay_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return basicdepay_getPrototypeOf(o); }
+
+
+
+
+
+var BasicDepay = /*#__PURE__*/function (_Tube) {
+  basicdepay_inherits(BasicDepay, _Tube);
+
+  var _super = basicdepay_createSuper(BasicDepay);
+
+  function BasicDepay(rtpPayloadType) {
+    basicdepay_classCallCheck(this, BasicDepay);
+
+    if (rtpPayloadType === undefined) {
+      throw new Error('you must supply a payload type to BasicDepayComponent');
+    }
+
+    var buffer = basicdepay_Buffer.alloc(0);
+    var incoming = createTransform(function (msg, encoding, callback) {
+      if (msg.type === MessageType.RTP && payloadType(msg.data) === rtpPayloadType) {
+        var rtpPayload = payload(msg.data);
+        buffer = basicdepay_Buffer.concat([buffer, rtpPayload]);
+
+        if (marker(msg.data)) {
+          if (buffer.length > 0) {
+            this.push({
+              data: buffer,
+              timestamp: timestamp(msg.data),
+              ntpTimestamp: msg.ntpTimestamp,
+              payloadType: payloadType(msg.data),
+              type: MessageType.ELEMENTARY
+            });
+          }
+
+          buffer = basicdepay_Buffer.alloc(0);
+        }
+
+        callback();
+      } else {
+        // Not a message we should handle
+        callback(undefined, msg);
+      }
+    }); // outgoing will be defaulted to a PassThrough stream
+
+    return _super.call(this, incoming);
+  }
+
+  return BasicDepay;
+}(Tube);
+// EXTERNAL MODULE: ./.yarn/unplugged/core-js-npm-3.16.2-c7ce9e8d48/node_modules/core-js/modules/web.url.js
+var web_url = __webpack_require__(2743);
+// EXTERNAL MODULE: ./.yarn/unplugged/core-js-npm-3.16.2-c7ce9e8d48/node_modules/core-js/modules/es.array.find.js
+var es_array_find = __webpack_require__(6582);
+;// CONCATENATED MODULE: ./lib/utils/clock.ts
+function clock_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
+
+function clock_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
+
+function clock_createClass(Constructor, protoProps, staticProps) { if (protoProps) clock_defineProperties(Constructor.prototype, protoProps); if (staticProps) clock_defineProperties(Constructor, staticProps); return Constructor; }
+
+function clock_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+/**
+ * Clock
+ *
+ * A simple timer to keep track of elapsed time,
+ * which can be retrieved with the `now` method.
+ * The clock is initially in a stopped state, during
+ * which the elapsed time does not increase. When
+ * started, the clock will return the total elapsed
+ * time since the first start / last reset.
+ *
+ * As a convenience, start/stop are aliased as
+ * play/pause, to mimic a media element (for use
+ * as a playback clock). The `currentTime` getter
+ * returns the elapsed time in seconds (floating
+ * point), also as a convenienve to closely match
+ * the behaviour of a video element.
+ */
+var Clock = /*#__PURE__*/function () {
+  function Clock() {
+    clock_classCallCheck(this, Clock);
+
+    clock_defineProperty(this, "started", void 0);
+
+    clock_defineProperty(this, "stopped", void 0);
+
+    clock_defineProperty(this, "elapsed", void 0);
+
+    this.elapsed = 0;
+    this.started = 0;
+    this.stopped = true;
+  }
+
+  clock_createClass(Clock, [{
+    key: "start",
+    value: function start() {
+      if (this.stopped) {
+        this.started = window.performance.now();
+        this.stopped = false;
+      }
+    }
+  }, {
+    key: "stop",
+    value: function stop() {
+      if (!this.stopped) {
+        this.elapsed = this.now();
+        this.stopped = true;
+      }
+    }
+  }, {
+    key: "reset",
+    value: function reset() {
+      this.elapsed = 0;
+      this.started = 0;
+      this.stopped = true;
+    } // Gives the elapsed time in milliseconds since the
+    // clock was first started (after last reset).
+
+  }, {
+    key: "now",
+    value: function now() {
+      if (this.stopped) {
+        return this.elapsed;
+      } else {
+        return this.elapsed + (window.performance.now() - this.started);
+      }
+    }
+  }, {
+    key: "play",
+    value: function play() {
+      this.start();
+    }
+  }, {
+    key: "pause",
+    value: function pause() {
+      this.stop();
+    } // Gives the elapsed time in seconds since last reset.
+
+  }, {
+    key: "currentTime",
+    get: function get() {
+      return this.now() / 1000;
+    }
+  }]);
+
+  return Clock;
+}();
+;// CONCATENATED MODULE: ./lib/utils/scheduler.ts
+function scheduler_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
+
+function scheduler_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
+
+function scheduler_createClass(Constructor, protoProps, staticProps) { if (protoProps) scheduler_defineProperties(Constructor.prototype, protoProps); if (staticProps) scheduler_defineProperties(Constructor, staticProps); return Constructor; }
+
+function scheduler_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+// The default tolerance for matching the handler
+// invocation to clock presentation time.
+var DEFAULT_TOLERANCE = 10;
+/**
+ * A scheduler that can decide when to execute a certain
+ * timestamped callback so that it happens in sync with a video
+ * element.
+ *
+ * To use it:
+ *
+ * (1) Initialize a new Scheduler with a clock (to synchronize
+ * against) and a callback (to be called when a message is in
+ * sync with the video). The clock can be a HTMLVideoElement,
+ * or anything that has a `currentTime` property which gives
+ * the current presentation time in seconds, and a `pause` and
+ * `play` method to control playback.
+ *
+ * (2) Call the `run` method every time a new message arrives
+ * that you want to schedule (it needs to have an ntpTimestamp).
+ * As soon at the presentation time is known, call the `init`
+ * method and pass in that time, so that the scheduler can
+ * start to schedule the callbacks. From then on, whenever
+ * a message in the queue has a timestamp that matches the
+ * current presentation time of the video, your callback will
+ * fire.
+ */
+
+var Scheduler = /*#__PURE__*/function () {
+  /**
+   * Creates an instance of Scheduler.
+   * @param clock - The clock to use (so we can control playback)
+   * @param handler - The callback to invoke when a message is in sync
+   * @param tolerance - The milliseconds defining "in sync" (default = 10)
+   */
+  function Scheduler(clock, handler) {
+    var tolerance = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_TOLERANCE;
+
+    scheduler_classCallCheck(this, Scheduler);
+
+    scheduler_defineProperty(this, "_clock", void 0);
+
+    scheduler_defineProperty(this, "_handler", void 0);
+
+    scheduler_defineProperty(this, "_tolerance", void 0);
+
+    scheduler_defineProperty(this, "_nextRun", void 0);
+
+    scheduler_defineProperty(this, "_nextPlay", void 0);
+
+    scheduler_defineProperty(this, "_fifo", void 0);
+
+    scheduler_defineProperty(this, "_ntpPresentationTime", void 0);
+
+    scheduler_defineProperty(this, "_suspended", void 0);
+
+    this._clock = clock;
+    this._handler = handler;
+    this._tolerance = tolerance;
+    this._nextRun = 0;
+    this._nextPlay = 0;
+    this._fifo = [];
+    this._ntpPresentationTime = 0;
+    this._suspended = false;
+  }
+  /**
+   * Bring the scheduler back to it's initial state.
+   */
+
+
+  scheduler_createClass(Scheduler, [{
+    key: "reset",
+    value: function reset() {
+      clearTimeout(this._nextRun);
+      clearTimeout(this._nextPlay);
+      this._fifo = [];
+      this._ntpPresentationTime = 0;
+      this._suspended = false;
+    }
+    /**
+     * Initialize the scheduler.
+     *
+     * @param ntpPresentationTime - The offset representing the start of the presentation
+     */
+
+  }, {
+    key: "init",
+    value: function init(ntpPresentationTime) {
+      this._ntpPresentationTime = ntpPresentationTime;
+    }
+    /**
+     * Suspend the scheduler.
+     *
+     * This releases control of the clock and stops any scheduling activity.
+     * Note that this doesn't mean the clock will be in a particular state
+     * (could be started or stopped), just that the scheduler will no longer
+     * control it.
+     */
+
+  }, {
+    key: "suspend",
+    value: function suspend() {
+      clearTimeout(this._nextPlay);
+      this._suspended = true;
+    }
+    /**
+     * Resume the scheduler.
+     *
+     * This gives back control of the clock and the ability
+     * to schedule messages. The scheduler will immediately
+     * try to do that on resume.
+     */
+
+  }, {
+    key: "resume",
+    value: function resume() {
+      this._suspended = false;
+      this.run(undefined);
+    }
+    /**
+     * Run the scheduler.
+     *
+     * @param newMessage - New message to schedule.
+     */
+
+  }, {
+    key: "run",
+    value: function run(newMessage) {
+      var _this = this;
+
+      clearTimeout(this._nextRun); // If there is no way to schedule anything, just return.
+      // The first schedule will happen for the first .run that
+      // is called after the presentation time has been initialized.
+
+      if (typeof this._ntpPresentationTime === 'undefined') {
+        return;
+      } // If there is a new message, add it to the FIFO queue
+
+
+      if (typeof newMessage !== 'undefined') {
+        this._fifo.push(newMessage);
+      } // If the scheduler is suspended, we can only keep the
+      // messages and not do anything with them.
+
+
+      if (this._suspended) {
+        return;
+      } // If there are no messages, we don't need to bother or
+      // even re-schedule, because the new call to .run() will
+      // have to come from outside with a new message.
+
+
+      if (this._fifo.length === 0) {
+        return;
+      } // There is at least one message in the FIFO queue, either
+      // display it, or re-schedule the method for later execution
+
+
+      var timeToPresent = 0;
+      var currentMessage;
+
+      do {
+        var _msg = this._fifo.shift();
+
+        if (_msg === undefined) {
+          throw new Error('internal error: message should never be undefined');
+        }
+
+        currentMessage = _msg;
+        var ntpTimestamp = currentMessage.ntpTimestamp;
+
+        if (ntpTimestamp === undefined) {
+          continue;
+        }
+
+        var presentationTime = ntpTimestamp - this._ntpPresentationTime;
+        timeToPresent = presentationTime - this._clock.currentTime * 1000; // If the message is within a tolerance of the presentation time
+        // then call the handler.
+
+        if (Math.abs(timeToPresent) < this._tolerance) {
+          this._handler && this._handler(currentMessage);
+        }
+      } while (timeToPresent < this._tolerance && this._fifo.length > 0);
+
+      if (timeToPresent < -this._tolerance) {
+        // We ran out of messages, delay the video with the same amount
+        // of delay as the last message had on the FIFO queue.
+        // Since we don't have any messages in the queue right now,
+        // the only way for anything to happen is if scheduler.run
+        // is called.
+        clearTimeout(this._nextPlay);
+
+        this._clock.pause();
+
+        this._nextPlay = window.setTimeout(function () {
+          return _this._clock.play();
+        }, -timeToPresent);
+      } else if (timeToPresent > this._tolerance) {
+        // message is later than video, add it back to the queue and
+        // re-run the scheduling at a later point in time
+        this._fifo.unshift(currentMessage);
+
+        this._nextRun = window.setTimeout(function () {
+          return _this.run(undefined);
+        }, timeToPresent);
+      }
+    }
+  }]);
+
+  return Scheduler;
+}();
+;// CONCATENATED MODULE: ./lib/components/canvas/index.ts
+function canvas_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { canvas_typeof = function _typeof(obj) { return typeof obj; }; } else { canvas_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return canvas_typeof(obj); }
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+function canvas_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
+
+function canvas_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
+
+function canvas_createClass(Constructor, protoProps, staticProps) { if (protoProps) canvas_defineProperties(Constructor.prototype, protoProps); if (staticProps) canvas_defineProperties(Constructor, staticProps); return Constructor; }
+
+function canvas_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) canvas_setPrototypeOf(subClass, superClass); }
+
+function canvas_setPrototypeOf(o, p) { canvas_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return canvas_setPrototypeOf(o, p); }
+
+function canvas_createSuper(Derived) { var hasNativeReflectConstruct = canvas_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = canvas_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = canvas_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return canvas_possibleConstructorReturn(this, result); }; }
+
+function canvas_possibleConstructorReturn(self, call) { if (call && (canvas_typeof(call) === "object" || typeof call === "function")) { return call; } return canvas_assertThisInitialized(self); }
+
+function canvas_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
+
+function canvas_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
+
+function canvas_getPrototypeOf(o) { canvas_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return canvas_getPrototypeOf(o); }
+
+function canvas_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+
+
+
+
+
+
+var resetInfo = function resetInfo(info) {
+  info.bitrate = 0;
+  info.framerate = 0;
+  info.renderedFrames = 0;
+};
+
+var generateUpdateInfo = function generateUpdateInfo(clockrate) {
+  var cumulativeByteLength = 0;
+  var cumulativeDuration = 0;
+  var cumulativeFrames = 0;
+  return function (info, _ref) {
+    var byteLength = _ref.byteLength,
+        duration = _ref.duration;
+    cumulativeByteLength += byteLength;
+    cumulativeDuration += duration;
+    cumulativeFrames++; // Update the cumulative number size (bytes) and duration (ticks), and if
+    // the duration exceeds the clockrate (meaning longer than 1 second of info),
+    // then compute a new bitrate and reset cumulative size and duration.
+
+    if (cumulativeDuration >= clockrate) {
+      var bits = 8 * cumulativeByteLength;
+      var frames = cumulativeFrames;
+      var seconds = cumulativeDuration / clockrate;
+      info.bitrate = bits / seconds;
+      info.framerate = frames / seconds;
+      cumulativeByteLength = 0;
+      cumulativeDuration = 0;
+      cumulativeFrames = 0;
+    }
+  };
+};
+/**
+ * Canvas component
+ *
+ * Draws an incoming stream of JPEG images onto a <canvas> element.
+ * The RTP timestamps are used to schedule the drawing of the images.
+ * An instance can be used as a 'clock' itself, e.g. with a scheduler.
+ *
+ * The following handlers can be set on a component instance:
+ *  - onCanplay: will be called when the first frame is ready and
+ *               the correct frame size has been set on the canvas.
+ *               At this point, the clock can be started by calling
+ *               `.play()` method on the component.
+ *  - onSync: will be called when the presentation time offset is
+ *            known, with the latter as argument (in UNIX milliseconds)
+ *
+ */
+
+
+var CanvasSink = /*#__PURE__*/function (_Sink) {
+  canvas_inherits(CanvasSink, _Sink);
+
+  var _super = canvas_createSuper(CanvasSink);
+
+  /**
+   * @param  el - The <canvas> element to draw incoming JPEG messages on.
+   */
+  function CanvasSink(el) {
+    var _this;
+
+    canvas_classCallCheck(this, CanvasSink);
+
+    if (el === undefined) {
+      throw new Error('canvas element argument missing');
+    }
+
+    var firstTimestamp = 0;
+    var lastTimestamp = 0;
+    var clockrate = 0;
+    var info = {
+      bitrate: 0,
+      framerate: 0,
+      renderedFrames: 0
+    };
+    var updateInfo; // The createImageBitmap function is supported in Chrome and Firefox
+    // (https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/createImageBitmap)
+    // Note: drawImage can also be used instead of transferFromImageBitmap, but it caused
+    // very large memory use in Chrome (goes up to ~2-3GB, then drops again).
+    // Do do not call el.getContext twice, safari returns null for second call
+
+    var ctx = null;
+
+    if (window.createImageBitmap !== undefined) {
+      ctx = el.getContext('bitmaprenderer');
+    }
+
+    if (ctx === null) {
+      ctx = el.getContext('2d');
+    } // Set up the drawing callback to be used by the scheduler,
+    // it receives a blob of a JPEG image.
+
+
+    var drawImageBlob;
+
+    if (ctx === null) {
+      drawImageBlob = function drawImageBlob() {
+        /** NOOP */
+      };
+    } else if ('transferFromImageBitmap' in ctx) {
+      var ctxBitmaprenderer = ctx;
+
+      drawImageBlob = function drawImageBlob(_ref2) {
+        var blob = _ref2.blob;
+        info.renderedFrames++;
+        window.createImageBitmap(blob).then(function (imageBitmap) {
+          ctxBitmaprenderer.transferFromImageBitmap(imageBitmap);
+        }).catch(function () {
+          /** ignore */
+        });
+      };
+    } else {
+      var ctx2d = ctx;
+      var img = new Image();
+
+      img.onload = function () {
+        ctx2d.drawImage(img, 0, 0);
+      };
+
+      drawImageBlob = function drawImageBlob(_ref3) {
+        var blob = _ref3.blob;
+        info.renderedFrames++;
+        var url = window.URL.createObjectURL(blob);
+        img.src = url;
+      };
+    } // Because we don't have an element that plays video for us,
+    // we have to use our own clock. The clock can be started/stopped
+    // with the `play` and `pause` methods, and has a `currentTime`
+    // property that keeps track of the presentation time.
+    // The scheduler will use the clock (instead of e.g. a video element)
+    // to determine when to display the JPEG images.
+
+
+    var clock = new Clock();
+    var scheduler = new Scheduler(clock, drawImageBlob);
+    var ntpPresentationTime = 0;
+
+    var onCanplay = function onCanplay() {
+      _this.onCanplay && _this.onCanplay();
+    };
+
+    var onSync = function onSync(ntpPresentationTime) {
+      _this.onSync && _this.onSync(ntpPresentationTime);
+    }; // Set up an incoming stream and attach it to the image drawing function.
+
+
+    var incoming = new stream_browserify.Writable({
+      objectMode: true,
+      write: function write(msg, encoding, callback) {
+        if (msg.type === MessageType.SDP) {
+          // start of a new movie, reset timers
+          clock.reset();
+          scheduler.reset(); // Initialize first timestamp and clockrate
+
+          firstTimestamp = 0;
+          var jpegMedia = msg.sdp.media.find(function (media) {
+            return media.type === 'video' && media.rtpmap !== undefined && media.rtpmap.encodingName === 'JPEG';
+          });
+
+          if (jpegMedia !== undefined && jpegMedia.rtpmap !== undefined) {
+            clockrate = jpegMedia.rtpmap.clockrate; // Initialize the framerate/bitrate data
+
+            resetInfo(info);
+            updateInfo = generateUpdateInfo(clockrate);
+          }
+
+          callback();
+        } else if (msg.type === MessageType.JPEG) {
+          var timestamp = msg.timestamp,
+              ntpTimestamp = msg.ntpTimestamp; // If first frame, store its timestamp, initialize
+          // the scheduler with 0 and start the clock.
+          // Also set the proper size on the canvas.
+
+          if (!firstTimestamp) {
+            // Initialize timing
+            firstTimestamp = timestamp;
+            lastTimestamp = timestamp; // Initialize frame size
+
+            var _msg$framesize = msg.framesize,
+                width = _msg$framesize.width,
+                height = _msg$framesize.height;
+            el.width = width;
+            el.height = height; // Notify that we can play at this point
+
+            scheduler.init(0);
+          } // Compute millisecond presentation time (with offset 0
+          // as we initialized the scheduler with 0).
+
+
+          var presentationTime = 1000 * (timestamp - firstTimestamp) / clockrate;
+          var blob = new window.Blob([msg.data], {
+            type: 'image/jpeg'
+          }); // If the actual UTC time of the start of presentation isn't known yet,
+          // and we do have an ntpTimestamp, then compute it here and notify.
+
+          if (!ntpPresentationTime && ntpTimestamp) {
+            ntpPresentationTime = ntpTimestamp - presentationTime;
+            onSync(ntpPresentationTime);
+          }
+
+          scheduler.run({
+            ntpTimestamp: presentationTime,
+            blob: blob
+          }); // Notify that we can now start the clock.
+
+          if (timestamp === firstTimestamp) {
+            onCanplay();
+          } // Update bitrate/framerate
+
+
+          updateInfo(info, {
+            byteLength: msg.data.length,
+            duration: timestamp - lastTimestamp
+          });
+          lastTimestamp = timestamp;
+          callback();
+        } else {
+          callback();
+        }
+      }
+    }); // Set up an outgoing stream.
+
+    var outgoing = new stream_browserify.Readable({
+      objectMode: true,
+      read: function read() {//
+      }
+    }); // When an error is sent on the outgoing stream, whine about it.
+
+    outgoing.on('error', function () {
+      console.warn('outgoing stream broke somewhere');
+    });
+    _this = _super.call(this, incoming, outgoing);
+
+    canvas_defineProperty(canvas_assertThisInitialized(_this), "onCanplay", void 0);
+
+    canvas_defineProperty(canvas_assertThisInitialized(_this), "onSync", void 0);
+
+    canvas_defineProperty(canvas_assertThisInitialized(_this), "_clock", void 0);
+
+    canvas_defineProperty(canvas_assertThisInitialized(_this), "_scheduler", void 0);
+
+    canvas_defineProperty(canvas_assertThisInitialized(_this), "_info", void 0);
+
+    _this._clock = clock;
+    _this._scheduler = scheduler;
+    _this._info = info;
+    _this.onCanplay = undefined;
+    _this.onSync = undefined;
+    return _this;
+  }
+  /**
+   * Retrieve the current presentation time (seconds)
+   */
+
+
+  canvas_createClass(CanvasSink, [{
+    key: "currentTime",
+    get: function get() {
+      return this._clock.currentTime;
+    }
+    /**
+     * Pause the presentation.
+     */
+
+  }, {
+    key: "pause",
+    value: function pause() {
+      this._scheduler.suspend();
+
+      this._clock.pause();
+    }
+    /**
+     * Start the presentation.
+     */
+
+  }, {
+    key: "play",
+    value: function play() {
+      this._clock.play();
+
+      this._scheduler.resume();
+    }
+  }, {
+    key: "bitrate",
+    get: function get() {
+      return this._info.bitrate;
+    }
+  }, {
+    key: "framerate",
+    get: function get() {
+      return this._info.framerate;
+    }
+  }]);
+
+  return CanvasSink;
+}(Sink);
+// EXTERNAL MODULE: ./.yarn/unplugged/core-js-npm-3.16.2-c7ce9e8d48/node_modules/core-js/modules/es.object.keys.js
+var es_object_keys = __webpack_require__(9835);
+// EXTERNAL MODULE: ./.yarn/unplugged/core-js-npm-3.16.2-c7ce9e8d48/node_modules/core-js/modules/es.array.filter.js
+var es_array_filter = __webpack_require__(3324);
+// EXTERNAL MODULE: ./.yarn/unplugged/core-js-npm-3.16.2-c7ce9e8d48/node_modules/core-js/modules/es.object.get-own-property-descriptor.js
+var es_object_get_own_property_descriptor = __webpack_require__(2512);
+// EXTERNAL MODULE: ./.yarn/unplugged/core-js-npm-3.16.2-c7ce9e8d48/node_modules/core-js/modules/web.dom-collections.for-each.js
+var web_dom_collections_for_each = __webpack_require__(31);
+// EXTERNAL MODULE: ./.yarn/unplugged/core-js-npm-3.16.2-c7ce9e8d48/node_modules/core-js/modules/es.object.get-own-property-descriptors.js
+var es_object_get_own_property_descriptors = __webpack_require__(8574);
+// EXTERNAL MODULE: ./.yarn/__virtual__/debug-virtual-c8b34b81df/0/cache/debug-npm-4.3.2-f0148b6afe-820ea160e2.zip/node_modules/debug/src/browser.js
+var browser = __webpack_require__(7997);
+var browser_default = /*#__PURE__*/__webpack_require__.n(browser);
+;// CONCATENATED MODULE: ./lib/components/h264depay/parser.ts
+/* provided dependency */ var parser_Buffer = __webpack_require__(7866)["Buffer"];
+
+
+
+function parser_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
+
+function parser_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
+
+function parser_createClass(Constructor, protoProps, staticProps) { if (protoProps) parser_defineProperties(Constructor.prototype, protoProps); if (staticProps) parser_defineProperties(Constructor, staticProps); return Constructor; }
+
+function parser_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+
+
+
+var NAL_TYPES;
+/*
+First byte in payload (rtp payload header):
+      +---------------+
+      |0|1|2|3|4|5|6|7|
+      +-+-+-+-+-+-+-+-+
+      |F|NRI|  Type   |
+      +---------------+
+
+2nd byte in payload: FU header (if type in first byte is 28)
+      +---------------+
+      |0|1|2|3|4|5|6|7|
+      +-+-+-+-+-+-+-+-+
+      |S|E|R|  Type   | S = start, E = end
+      +---------------+
+*/
+
+(function (NAL_TYPES) {
+  NAL_TYPES[NAL_TYPES["UNSPECIFIED"] = 0] = "UNSPECIFIED";
+  NAL_TYPES[NAL_TYPES["NON_IDR_PICTURE"] = 1] = "NON_IDR_PICTURE";
+  NAL_TYPES[NAL_TYPES["IDR_PICTURE"] = 5] = "IDR_PICTURE";
+  NAL_TYPES[NAL_TYPES["SPS"] = 7] = "SPS";
+  NAL_TYPES[NAL_TYPES["PPS"] = 8] = "PPS";
+})(NAL_TYPES || (NAL_TYPES = {}));
+
+var h264Debug = browser_default()('msl:h264depay');
+var H264DepayParser = /*#__PURE__*/function () {
+  function H264DepayParser() {
+    parser_classCallCheck(this, H264DepayParser);
+
+    parser_defineProperty(this, "_buffer", void 0);
+
+    this._buffer = parser_Buffer.alloc(0);
+  }
+
+  parser_createClass(H264DepayParser, [{
+    key: "parse",
+    value: function parse(rtp) {
+      var rtpPayload = payload(rtp.data);
+      var type = rtpPayload[0] & 0x1f;
+
+      if (type === 28) {
+        /* FU-A NALU */
+        var fuIndicator = rtpPayload[0];
+        var fuHeader = rtpPayload[1];
+        var startBit = !!(fuHeader >> 7);
+        var nalType = fuHeader & 0x1f;
+        var nal = fuIndicator & 0xe0 | nalType;
+        var stopBit = fuHeader & 64;
+
+        if (startBit) {
+          this._buffer = parser_Buffer.concat([parser_Buffer.from([0, 0, 0, 0, nal]), rtpPayload.slice(2)]);
+          return null;
+        } else if (stopBit) {
+          /* receieved end bit */
+          var h264frame = parser_Buffer.concat([this._buffer, rtpPayload.slice(2)]);
+          h264frame.writeUInt32BE(h264frame.length - 4, 0);
+          var msg = {
+            data: h264frame,
+            type: MessageType.H264,
+            timestamp: timestamp(rtp.data),
+            ntpTimestamp: rtp.ntpTimestamp,
+            payloadType: payloadType(rtp.data),
+            nalType: nalType
+          };
+          this._buffer = parser_Buffer.alloc(0);
+          return msg;
+        } else {
+          // Put the received data on the buffer and cut the header bytes
+          this._buffer = parser_Buffer.concat([this._buffer, rtpPayload.slice(2)]);
+          return null;
+        }
+      } else if ((type === NAL_TYPES.NON_IDR_PICTURE || type === NAL_TYPES.IDR_PICTURE) && this._buffer.length === 0) {
+        /* Single NALU */
+        var _h264frame = parser_Buffer.concat([parser_Buffer.from([0, 0, 0, 0]), rtpPayload]);
+
+        _h264frame.writeUInt32BE(_h264frame.length - 4, 0);
+
+        var _msg = {
+          data: _h264frame,
+          type: MessageType.H264,
+          timestamp: timestamp(rtp.data),
+          ntpTimestamp: rtp.ntpTimestamp,
+          payloadType: payloadType(rtp.data),
+          nalType: type
+        };
+        this._buffer = parser_Buffer.alloc(0);
+        return _msg;
+      } else {
+        h264Debug("H264depayComponent can only extract types 1,5 and 28, got ".concat(type));
+        this._buffer = parser_Buffer.alloc(0);
+        return null;
+      }
+    }
+  }]);
+
+  return H264DepayParser;
+}();
+;// CONCATENATED MODULE: ./lib/components/h264depay/index.ts
+/* provided dependency */ var h264depay_Buffer = __webpack_require__(7866)["Buffer"];
+function h264depay_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { h264depay_typeof = function _typeof(obj) { return typeof obj; }; } else { h264depay_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return h264depay_typeof(obj); }
+
+function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }
+
+function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { h264depay_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
+
+function h264depay_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+function h264depay_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
+
+function h264depay_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) h264depay_setPrototypeOf(subClass, superClass); }
+
+function h264depay_setPrototypeOf(o, p) { h264depay_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return h264depay_setPrototypeOf(o, p); }
+
+function h264depay_createSuper(Derived) { var hasNativeReflectConstruct = h264depay_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = h264depay_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = h264depay_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return h264depay_possibleConstructorReturn(this, result); }; }
+
+function h264depay_possibleConstructorReturn(self, call) { if (call && (h264depay_typeof(call) === "object" || typeof call === "function")) { return call; } return h264depay_assertThisInitialized(self); }
+
+function h264depay_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
+
+function h264depay_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
+
+function h264depay_getPrototypeOf(o) { h264depay_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return h264depay_getPrototypeOf(o); }
+
+
+
+
+
+
+var H264Depay = /*#__PURE__*/function (_Tube) {
+  h264depay_inherits(H264Depay, _Tube);
+
+  var _super = h264depay_createSuper(H264Depay);
+
+  function H264Depay() {
+    h264depay_classCallCheck(this, H264Depay);
+
+    var h264PayloadType;
+    var idrFound = false;
+    var packets = [];
+    var h264DepayParser = new H264DepayParser(); // Incoming
+
+    var incoming = new stream_browserify.Transform({
+      objectMode: true,
+      transform: function transform(msg, _encoding, callback) {
+        // Get correct payload types from sdp to identify video and audio
+        if (msg.type === MessageType.SDP) {
+          var h264Media = msg.sdp.media.find(function (media) {
+            return media.type === 'video' && media.rtpmap !== undefined && media.rtpmap.encodingName === 'H264';
+          });
+
+          if (h264Media !== undefined && h264Media.rtpmap !== undefined) {
+            h264PayloadType = h264Media.rtpmap.payloadType;
+          }
+
+          callback(undefined, msg); // Pass on the original SDP message
+        } else if (msg.type === MessageType.RTP && payloadType(msg.data) === h264PayloadType) {
+          var endOfFrame = marker(msg.data);
+          var h264Message = h264DepayParser.parse(msg); // Skip if not a full H264 frame, or when there hasn't been an I-frame yet
+
+          if (h264Message === null || !idrFound && h264Message.nalType !== NAL_TYPES.IDR_PICTURE) {
+            callback();
+            return;
+          }
+
+          idrFound = true; // H.264 over RTP uses the RTP marker bit to indicate a complete
+          // frame.  At this point, the packets can be used to construct a
+          // complete message.
+
+          packets.push(h264Message.data);
+
+          if (endOfFrame) {
+            this.push(_objectSpread(_objectSpread({}, h264Message), {}, {
+              data: packets.length === 1 ? packets[0] : h264depay_Buffer.concat(packets)
+            }));
+            packets = [];
+          }
+
+          callback();
+        } else {
+          // Not a message we should handle
+          callback(undefined, msg);
+        }
+      }
+    }); // outgoing will be defaulted to a PassThrough stream
+
+    return _super.call(this, incoming);
+  }
+
+  return H264Depay;
+}(Tube);
+// EXTERNAL MODULE: ./.yarn/unplugged/core-js-npm-3.16.2-c7ce9e8d48/node_modules/core-js/modules/es.promise.js
+var es_promise = __webpack_require__(1337);
+;// CONCATENATED MODULE: ./lib/components/http-source/index.ts
+/* provided dependency */ var http_source_Buffer = __webpack_require__(7866)["Buffer"];
+function http_source_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { http_source_typeof = function _typeof(obj) { return typeof obj; }; } else { http_source_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return http_source_typeof(obj); }
+
+function http_source_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }
+
+function http_source_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { http_source_ownKeys(Object(source), true).forEach(function (key) { http_source_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { http_source_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+function http_source_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
+
+function http_source_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
+
+function http_source_createClass(Constructor, protoProps, staticProps) { if (protoProps) http_source_defineProperties(Constructor.prototype, protoProps); if (staticProps) http_source_defineProperties(Constructor, staticProps); return Constructor; }
+
+function http_source_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) http_source_setPrototypeOf(subClass, superClass); }
+
+function http_source_setPrototypeOf(o, p) { http_source_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return http_source_setPrototypeOf(o, p); }
+
+function http_source_createSuper(Derived) { var hasNativeReflectConstruct = http_source_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = http_source_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = http_source_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return http_source_possibleConstructorReturn(this, result); }; }
+
+function http_source_possibleConstructorReturn(self, call) { if (call && (http_source_typeof(call) === "object" || typeof call === "function")) { return call; } return http_source_assertThisInitialized(self); }
+
+function http_source_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
+
+function http_source_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
+
+function http_source_getPrototypeOf(o) { http_source_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return http_source_getPrototypeOf(o); }
+
+function http_source_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+
+
+
+
+var debug = browser_default()('msl:http-source');
+var HttpSource = /*#__PURE__*/function (_Source) {
+  http_source_inherits(HttpSource, _Source);
+
+  var _super = http_source_createSuper(HttpSource);
+
+  /**
+   * Create an HTTP component.
+   *
+   * The constructor sets a single readable stream from a fetch.
+   */
+  function HttpSource(config) {
+    var _this;
+
+    http_source_classCallCheck(this, HttpSource);
+
+    var uri = config.uri,
+        options = config.options;
+    /**
+     * Set up an incoming stream and attach it to the socket.
+     */
+
+    var incoming = new stream_browserify.Readable({
+      objectMode: true,
+      read: function read() {//
+      }
+    }); // When an error is sent on the incoming stream, close the socket.
+
+    incoming.on('error', function (e) {
+      console.warn('closing socket due to incoming error', e);
+      _this._reader && _this._reader.cancel();
+    });
+    /**
+     * initialize the component.
+     */
+
+    _this = _super.call(this, incoming); // When a read is requested, continue to pull data
+
+    http_source_defineProperty(http_source_assertThisInitialized(_this), "uri", void 0);
+
+    http_source_defineProperty(http_source_assertThisInitialized(_this), "options", void 0);
+
+    http_source_defineProperty(http_source_assertThisInitialized(_this), "length", void 0);
+
+    http_source_defineProperty(http_source_assertThisInitialized(_this), "onHeaders", void 0);
+
+    http_source_defineProperty(http_source_assertThisInitialized(_this), "onServerClose", void 0);
+
+    http_source_defineProperty(http_source_assertThisInitialized(_this), "_reader", void 0);
+
+    http_source_defineProperty(http_source_assertThisInitialized(_this), "_abortController", void 0);
+
+    http_source_defineProperty(http_source_assertThisInitialized(_this), "_allDone", void 0);
+
+    incoming._read = function () {
+      _this._pull();
+    };
+
+    _this.uri = uri;
+    _this.options = options;
+    _this._allDone = false;
+    return _this;
+  }
+
+  http_source_createClass(HttpSource, [{
+    key: "play",
+    value: function play() {
+      var _this2 = this;
+
+      if (this.uri === undefined) {
+        throw new Error('cannot start playing when there is no URI');
+      }
+
+      this._abortController = new AbortController();
+      this.length = 0;
+      fetch(this.uri, http_source_objectSpread({
+        credentials: 'include',
+        signal: this._abortController.signal
+      }, this.options)).then(function (rsp) {
+        if (rsp.body === null) {
+          throw new Error('empty response body');
+        }
+
+        _this2.onHeaders && _this2.onHeaders(rsp.headers);
+        _this2._reader = rsp.body.getReader();
+
+        _this2._pull();
+      }).catch(function (err) {
+        console.error('http-source: fetch failed: ', err);
+      });
+    }
+  }, {
+    key: "abort",
+    value: function abort() {
+      this._reader && this._reader.cancel().catch(function (err) {
+        console.log('http-source: cancel reader failed: ', err);
+      });
+      this._abortController && this._abortController.abort();
+    }
+  }, {
+    key: "_isClosed",
+    value: function _isClosed() {
+      return this._allDone;
+    }
+  }, {
+    key: "_close",
+    value: function _close() {
+      var _this$onServerClose;
+
+      this._reader = undefined;
+      this._allDone = true;
+      this.incoming.push(null);
+      (_this$onServerClose = this.onServerClose) === null || _this$onServerClose === void 0 ? void 0 : _this$onServerClose.call(this);
+    }
+  }, {
+    key: "_pull",
+    value: function _pull() {
+      var _this3 = this;
+
+      if (this._reader === undefined) {
+        return;
+      }
+
+      this._reader.read().then(function (_ref) {
+        var done = _ref.done,
+            value = _ref.value;
+
+        if (done) {
+          if (!_this3._isClosed()) {
+            debug('fetch completed, total downloaded: ', _this3.length, ' bytes');
+
+            _this3._close();
+          }
+
+          return;
+        }
+
+        if (value === undefined) {
+          throw new Error('expected value to be defined');
+        }
+
+        if (_this3.length === undefined) {
+          throw new Error('expected length to be defined');
+        }
+
+        _this3.length += value.length;
+        var buffer = http_source_Buffer.from(value);
+
+        if (!_this3.incoming.push({
+          data: buffer,
+          type: MessageType.RAW
+        })) {
+          // Something happened down stream that it is no longer processing the
+          // incoming data, and the stream buffer got full.
+          // This could be because we are downloading too much data at once,
+          // or because the downstream is frozen. The latter is most likely
+          // when dealing with a live stream (as in that case we would expect
+          // downstream to be able to handle the data).
+          debug('downstream back pressure: pausing read');
+        } else {
+          // It's ok to read more data
+          _this3._pull();
+        }
+      }).catch(function (err) {
+        debug('http-source: read failed: ', err);
+
+        if (!_this3._isClosed()) {
+          _this3._close();
+        }
+      });
+    }
+  }]);
+
+  return HttpSource;
+}(Source);
+;// CONCATENATED MODULE: ./lib/components/inspector/index.ts
+function inspector_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { inspector_typeof = function _typeof(obj) { return typeof obj; }; } else { inspector_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return inspector_typeof(obj); }
+
+function inspector_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
+
+function inspector_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) inspector_setPrototypeOf(subClass, superClass); }
+
+function inspector_setPrototypeOf(o, p) { inspector_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return inspector_setPrototypeOf(o, p); }
+
+function inspector_createSuper(Derived) { var hasNativeReflectConstruct = inspector_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = inspector_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = inspector_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return inspector_possibleConstructorReturn(this, result); }; }
+
+function inspector_possibleConstructorReturn(self, call) { if (call && (inspector_typeof(call) === "object" || typeof call === "function")) { return call; } return inspector_assertThisInitialized(self); }
+
+function inspector_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
+
+function inspector_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
+
+function inspector_getPrototypeOf(o) { inspector_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return inspector_getPrototypeOf(o); }
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+var generateLogger = function generateLogger(prefix, type) {
+  var lastTimestamp = Date.now();
+
+  var log = function log(msg) {
+    var timestamp = Date.now();
+    console.log("".concat(prefix, ": +").concat(timestamp - lastTimestamp, "ms"), msg);
+    lastTimestamp = timestamp;
+  };
+
+  if (type === undefined) {
+    return log;
+  } else {
+    return function (msg) {
+      return msg.type === type && log(msg);
+    };
+  }
+};
+/**
+ * Component that logs whatever is passing through.
+ */
+
+
+var Inspector = /*#__PURE__*/function (_Tube) {
+  inspector_inherits(Inspector, _Tube);
+
+  var _super = inspector_createSuper(Inspector);
+
+  /**
+   * Create a new inspector component.
+   * @argument {String} type  The type of message to log (default is to log all).
+   * @return {undefined}
+   */
+  function Inspector(type) {
+    inspector_classCallCheck(this, Inspector);
+
+    var incomingLogger = generateLogger('incoming', type);
+    var incoming = new stream_browserify.Transform({
+      objectMode: true,
+      transform: function transform(msg, encoding, callback) {
+        incomingLogger(msg);
+        callback(undefined, msg);
+      }
+    });
+    var outgoingLogger = generateLogger('outgoing', type);
+    var outgoing = new stream_browserify.Transform({
+      objectMode: true,
+      transform: function transform(msg, encoding, callback) {
+        outgoingLogger(msg);
+        callback(undefined, msg);
+      }
+    });
+    return _super.call(this, incoming, outgoing);
+  }
+
+  return Inspector;
+}(Tube);
+// EXTERNAL MODULE: ./.yarn/unplugged/core-js-npm-3.16.2-c7ce9e8d48/node_modules/core-js/modules/es.array.map.js
+var es_array_map = __webpack_require__(7316);
+;// CONCATENATED MODULE: ./lib/components/jpegdepay/headers.ts
+/* provided dependency */ var headers_Buffer = __webpack_require__(7866)["Buffer"];
+function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || headers_unsupportedIterableToArray(arr) || _nonIterableSpread(); }
+
+function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
+
+function headers_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return headers_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return headers_arrayLikeToArray(o, minLen); }
+
+function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
+
+function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return headers_arrayLikeToArray(arr); }
+
+function headers_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+/**
+ * Generate frame and scan headers that can be prepended to the
+ * RTP/JPEG data payload to produce a JPEG compressed image in
+ * interchange format.
+ *
+ * For detailed information, check Appendix A of:
+ * https://tools.ietf.org/html/rfc2435
+ */
+function makeImageHeader() {
+  return headers_Buffer.from([0xff, 0xd8]);
+}
+function makeQuantHeader(precision, qTable) {
+  var lumSize = precision & 1 ? 128 : 64;
+  var chmSize = precision & 2 ? 128 : 64;
+
+  if (qTable.length !== lumSize + chmSize) {
+    throw new Error('invalid quantization table');
+  }
+
+  var lumaPrefix = headers_Buffer.from([0xff, 0xdb, 0, lumSize + 3, 0]);
+  var chromaPrefix = headers_Buffer.from([0xff, 0xdb, 0, chmSize + 3, 1]);
+  return headers_Buffer.concat([lumaPrefix, qTable.slice(0, lumSize), chromaPrefix, qTable.slice(lumSize)]);
+}
+function makeFrameHeader(width, height, type) {
+  return headers_Buffer.from([0xff, 0xc0, // SOF_0 (Start Of Frame)
+  0, 17, 8, height >> 8, height, width >> 8, width, 3, 0, type === 0 ? 0x21 : 0x22, 0, 1, 0x11, 1, 2, 0x11, 1]);
+} // prettier-ignore
+
+var LUM_DC_CODELENS = [0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0]; // prettier-ignore
+
+var LUM_DC_SYMBOLS = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]; // prettier-ignore
+
+var LUM_AC_CODELENS = [0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 0x7d]; // prettier-ignore
+
+var LUM_AC_SYMBOLS = [0x01, 0x02, 0x03, 0x00, 0x04, 0x11, 0x05, 0x12, 0x21, 0x31, 0x41, 0x06, 0x13, 0x51, 0x61, 0x07, 0x22, 0x71, 0x14, 0x32, 0x81, 0x91, 0xa1, 0x08, 0x23, 0x42, 0xb1, 0xc1, 0x15, 0x52, 0xd1, 0xf0, 0x24, 0x33, 0x62, 0x72, 0x82, 0x09, 0x0a, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa]; // prettier-ignore
+
+var CHM_DC_CODELENS = [0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0]; // prettier-ignore
+
+var CHM_DC_SYMBOLS = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]; // prettier-ignore
+
+var CHM_AC_CODELENS = [0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 0x77]; // prettier-ignore
+
+var CHM_AC_SYMBOLS = [0x00, 0x01, 0x02, 0x03, 0x11, 0x04, 0x05, 0x21, 0x31, 0x06, 0x12, 0x41, 0x51, 0x07, 0x61, 0x71, 0x13, 0x22, 0x32, 0x81, 0x08, 0x14, 0x42, 0x91, 0xa1, 0xb1, 0xc1, 0x09, 0x23, 0x33, 0x52, 0xf0, 0x15, 0x62, 0x72, 0xd1, 0x0a, 0x16, 0x24, 0x34, 0xe1, 0x25, 0xf1, 0x17, 0x18, 0x19, 0x1a, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa];
+function makeHuffmanHeader() {
+  var LUM_DC_BUFFER = [[0xff, 0xc4, 0, 3 + LUM_DC_CODELENS.length + LUM_DC_SYMBOLS.length, 0 << 4 | 0], LUM_DC_CODELENS, LUM_DC_SYMBOLS];
+  var LUM_AC_BUFFER = [[0xff, 0xc4, 0, 3 + LUM_AC_CODELENS.length + LUM_AC_SYMBOLS.length, 1 << 4 | 0], LUM_AC_CODELENS, LUM_AC_SYMBOLS];
+  var CHM_DC_BUFFER = [[0xff, 0xc4, 0, 3 + CHM_DC_CODELENS.length + CHM_DC_SYMBOLS.length, 0 << 4 | 1], CHM_DC_CODELENS, CHM_DC_SYMBOLS];
+  var CHM_AC_BUFFER = [[0xff, 0xc4, 0, 3 + CHM_AC_CODELENS.length + CHM_AC_SYMBOLS.length, 1 << 4 | 1], CHM_AC_CODELENS, CHM_AC_SYMBOLS];
+  return headers_Buffer.concat([].concat(_toConsumableArray(LUM_DC_BUFFER.map(headers_Buffer.from)), _toConsumableArray(LUM_AC_BUFFER.map(headers_Buffer.from)), _toConsumableArray(CHM_DC_BUFFER.map(headers_Buffer.from)), _toConsumableArray(CHM_AC_BUFFER.map(headers_Buffer.from))));
+}
+function makeScanHeader() {
+  return headers_Buffer.from([0xff, 0xda, // SOS (Start Of Scan)
+  0, 12, 3, 0, 0, 1, 0x11, 2, 0x11, 0, 63, 0]);
+}
+function makeDRIHeader(dri) {
+  return headers_Buffer.from([0xff, 0xdd, 0x00, 4, dri >> 8, dri & 0xff]);
+}
+;// CONCATENATED MODULE: ./lib/utils/clamp.ts
+function clamp(val, min, max) {
+  return val > max ? max : val < min ? min : val;
+}
+;// CONCATENATED MODULE: ./lib/components/jpegdepay/make-qtable.ts
+/* provided dependency */ var make_qtable_Buffer = __webpack_require__(7866)["Buffer"];
+
+/**
+ * @function makeQtable
+ * Creating a quantization table from a Q factor
+ * Example Code from RFC 2435 Appendix A ported to TypeScript
+ *
+ * Default luminance/chrominance quantization tables in RFC example are not in zig-zag order.
+ * The RFC does not mention that default tables should be in zig-zag ordering,
+ * but they say that about the included tables. RFC sample code appears to have a mistake.
+ * All the tested cameras and LGPL projects use zig-zag default tables.
+ * So we use zig-zaged tables from ISO/IEC 10918-1 Annex K Section K.1
+ * @see https://tools.ietf.org/html/rfc2435
+ * @see https://www.iso.org/standard/18902.html
+ */
+// prettier-ignore
+
+var jpegLumaQuantizer = [16, 11, 12, 14, 12, 10, 16, 14, 13, 14, 18, 17, 16, 19, 24, 40, 26, 24, 22, 22, 24, 49, 35, 37, 29, 40, 58, 51, 61, 60, 57, 51, 56, 55, 64, 72, 92, 78, 64, 68, 87, 69, 55, 56, 80, 109, 81, 87, 95, 98, 103, 104, 103, 62, 77, 113, 121, 112, 100, 120, 92, 101, 103, 99]; // prettier-ignore
+
+var jpeChromaQuantizer = [17, 18, 18, 24, 21, 24, 47, 26, 26, 47, 99, 66, 56, 66, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99];
+function makeQtable(Q) {
+  var factor = clamp(Q, 1, 99);
+  var buffer = make_qtable_Buffer.alloc(128);
+  var S = Q < 50 ? Math.floor(5000 / factor) : 200 - factor * 2;
+
+  for (var i = 0; i < 64; i++) {
+    var lq = Math.floor((jpegLumaQuantizer[i] * S + 50) / 100);
+    var cq = Math.floor((jpeChromaQuantizer[i] * S + 50) / 100);
+    buffer.writeUInt8(clamp(lq, 1, 255), i);
+    buffer.writeUInt8(clamp(cq, 1, 255), i + 64);
+  }
+
+  return buffer;
+}
+;// CONCATENATED MODULE: ./lib/components/jpegdepay/parser.ts
+/* provided dependency */ var jpegdepay_parser_Buffer = __webpack_require__(7866)["Buffer"];
+
+
+
+
+
+
+
+
+
+
+
+
+function parser_createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = parser_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
+
+function parser_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return parser_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return parser_arrayLikeToArray(o, minLen); }
+
+function parser_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
+
+
+
+
+/**
+ * Each packet contains a special JPEG header which immediately follows
+ * the RTP header.  The first 8 bytes of this header, called the "main
+ * JPEG header", are as follows:*
+ *  0                   1                   2                   3
+ *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+ * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ * | Type-specific |              Fragment Offset                  |
+ * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ * |      Type     |       Q       |     Width     |     Height    |
+ * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ */
+
+/**
+ * Restart Marker header: when using types 64-127
+ *  0                   1                   2                   3
+ *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+ * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ * |       Restart Interval        |F|L|       Restart Count       |
+ * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ */
+
+/**
+ * Quantization Table header: when using Q values 128-255
+ *  0                   1                   2                   3
+ *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+ * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ * |      MBZ      |   Precision   |             Length            |
+ * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ * |                    Quantization Table Data                    |
+ * |                              ...                              |
+ * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ */
+
+function jpegDepayFactory() {
+  var defaultWidth = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
+  var defaultHeight = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
+  var IMAGE_HEADER = makeImageHeader();
+  var HUFFMAN_HEADER = makeHuffmanHeader();
+  var SCAN_HEADER = makeScanHeader();
+  return function jpegDepay(packets) {
+    var metadata;
+    var fragments = [];
+
+    var _iterator = parser_createForOfIteratorHelper(packets),
+        _step;
+
+    try {
+      for (_iterator.s(); !(_step = _iterator.n()).done;) {
+        var packet = _step.value;
+        var fragment = payload(packet); // Parse and extract JPEG header.
+
+        var typeSpecific = fragment.readUInt8(0);
+        var fragmentOffset = fragment.readUInt8(1) << 16 | fragment.readUInt8(2) << 8 | fragment.readUInt8(3);
+
+        var _type = fragment.readUInt8(4);
+
+        var Q = fragment.readUInt8(5);
+
+        var _width = fragment.readUInt8(6) * 8 || defaultWidth;
+
+        var _height = fragment.readUInt8(7) * 8 || defaultHeight;
+
+        fragment = fragment.slice(8); // Parse and extract Restart Marker header if present.
+
+        var DRI = 0;
+
+        if (_type >= 64 && _type <= 127) {
+          DRI = fragment.readUInt16BE(0);
+          fragment = fragment.slice(4);
+        } // Parse and extract Quantization Table header if present.
+
+
+        if (Q >= 128 && fragmentOffset === 0) {
+          // const MBZ = fragment.readUInt8()
+          var _precision = fragment.readUInt8(1);
+
+          var length = fragment.readUInt16BE(2);
+
+          var _qTable = fragment.slice(4, 4 + length);
+
+          metadata = {
+            typeSpecific: typeSpecific,
+            type: _type,
+            width: _width,
+            height: _height,
+            DRI: DRI,
+            precision: _precision,
+            qTable: _qTable
+          };
+          fragment = fragment.slice(4 + length);
+        } // Compute Quantization Table
+        else if (Q < 128 && fragmentOffset === 0) {
+            var _precision2 = 0;
+
+            var _qTable2 = makeQtable(Q);
+
+            metadata = {
+              typeSpecific: typeSpecific,
+              type: _type,
+              width: _width,
+              height: _height,
+              DRI: DRI,
+              precision: _precision2,
+              qTable: _qTable2
+            };
+          }
+
+        fragments.push(fragment);
+      }
+    } catch (err) {
+      _iterator.e(err);
+    } finally {
+      _iterator.f();
+    }
+
+    if (metadata === undefined) {
+      throw new Error('no quantization header present');
+    }
+
+    var _metadata = metadata,
+        precision = _metadata.precision,
+        qTable = _metadata.qTable,
+        type = _metadata.type,
+        width = _metadata.width,
+        height = _metadata.height;
+    var quantHeader = makeQuantHeader(precision, qTable);
+    var driHeader = metadata.DRI === 0 ? jpegdepay_parser_Buffer.alloc(0) : makeDRIHeader(metadata.DRI);
+    var frameHeader = makeFrameHeader(width, height, type);
+    return {
+      size: {
+        width: width,
+        height: height
+      },
+      data: jpegdepay_parser_Buffer.concat([IMAGE_HEADER, quantHeader, driHeader, frameHeader, HUFFMAN_HEADER, SCAN_HEADER].concat(fragments))
+    };
+  };
+}
+;// CONCATENATED MODULE: ./lib/components/jpegdepay/index.ts
+function jpegdepay_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { jpegdepay_typeof = function _typeof(obj) { return typeof obj; }; } else { jpegdepay_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return jpegdepay_typeof(obj); }
+
+function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || jpegdepay_unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
+
+function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
+
+function jpegdepay_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return jpegdepay_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return jpegdepay_arrayLikeToArray(o, minLen); }
+
+function jpegdepay_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
+
+function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }
+
+function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+function jpegdepay_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
+
+function jpegdepay_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) jpegdepay_setPrototypeOf(subClass, superClass); }
+
+function jpegdepay_setPrototypeOf(o, p) { jpegdepay_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return jpegdepay_setPrototypeOf(o, p); }
+
+function jpegdepay_createSuper(Derived) { var hasNativeReflectConstruct = jpegdepay_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = jpegdepay_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = jpegdepay_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return jpegdepay_possibleConstructorReturn(this, result); }; }
+
+function jpegdepay_possibleConstructorReturn(self, call) { if (call && (jpegdepay_typeof(call) === "object" || typeof call === "function")) { return call; } return jpegdepay_assertThisInitialized(self); }
+
+function jpegdepay_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
+
+function jpegdepay_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
+
+function jpegdepay_getPrototypeOf(o) { jpegdepay_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return jpegdepay_getPrototypeOf(o); }
+
+
+
+
+
+
+var JPEGDepay = /*#__PURE__*/function (_Tube) {
+  jpegdepay_inherits(JPEGDepay, _Tube);
+
+  var _super = jpegdepay_createSuper(JPEGDepay);
+
+  function JPEGDepay() {
+    jpegdepay_classCallCheck(this, JPEGDepay);
+
+    var jpegPayloadType;
+    var packets = [];
+    var jpegDepay;
+    var incoming = new stream_browserify.Transform({
+      objectMode: true,
+      transform: function transform(msg, encoding, callback) {
+        if (msg.type === MessageType.SDP) {
+          var jpegMedia = msg.sdp.media.find(function (media) {
+            return media.type === 'video' && media.rtpmap !== undefined && media.rtpmap.encodingName === 'JPEG';
+          });
+
+          if (jpegMedia !== undefined && jpegMedia.rtpmap !== undefined) {
+            jpegPayloadType = Number(jpegMedia.rtpmap.payloadType);
+            var framesize = jpegMedia.framesize; // `framesize` is an SDP field that is present in e.g. Axis camera's
+            // and is used because the width and height that can be sent inside
+            // the JPEG header are both limited to 2040.
+            // If present, we use this width and height as the default values
+            // to be used by the jpeg depay function, otherwise we ignore this
+            // and let the JPEG header inside the RTP packets determine this.
+
+            if (framesize !== undefined) {
+              var _framesize = _slicedToArray(framesize, 2),
+                  width = _framesize[0],
+                  height = _framesize[1]; // msg.framesize = { width, height }
+
+
+              jpegDepay = jpegDepayFactory(width, height);
+            } else {
+              jpegDepay = jpegDepayFactory();
+            }
+          }
+
+          callback(undefined, msg);
+        } else if (msg.type === MessageType.RTP && payloadType(msg.data) === jpegPayloadType) {
+          packets.push(msg.data); // JPEG over RTP uses the RTP marker bit to indicate end
+          // of fragmentation. At this point, the packets can be used
+          // to reconstruct a JPEG frame.
+
+          if (marker(msg.data) && packets.length > 0) {
+            var jpegFrame = jpegDepay(packets);
+            this.push({
+              timestamp: timestamp(msg.data),
+              ntpTimestamp: msg.ntpTimestamp,
+              payloadType: payloadType(msg.data),
+              data: jpegFrame.data,
+              framesize: jpegFrame.size,
+              type: MessageType.JPEG
+            });
+            packets = [];
+          }
+
+          callback();
+        } else {
+          // Not a message we should handle
+          callback(undefined, msg);
+        }
+      }
+    }); // outgoing will be defaulted to a PassThrough stream
+
+    return _super.call(this, incoming);
+  }
+
+  return JPEGDepay;
+}(Tube);
+;// CONCATENATED MODULE: ./lib/components/mp4capture/index.ts
+/* provided dependency */ var mp4capture_Buffer = __webpack_require__(7866)["Buffer"];
+function mp4capture_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { mp4capture_typeof = function _typeof(obj) { return typeof obj; }; } else { mp4capture_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return mp4capture_typeof(obj); }
+
+
+
+
+
+
+
+
+
+
+
+
+
+function mp4capture_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
+
+function mp4capture_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
+
+function mp4capture_createClass(Constructor, protoProps, staticProps) { if (protoProps) mp4capture_defineProperties(Constructor.prototype, protoProps); if (staticProps) mp4capture_defineProperties(Constructor, staticProps); return Constructor; }
+
+function mp4capture_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) mp4capture_setPrototypeOf(subClass, superClass); }
+
+function mp4capture_setPrototypeOf(o, p) { mp4capture_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return mp4capture_setPrototypeOf(o, p); }
+
+function mp4capture_createSuper(Derived) { var hasNativeReflectConstruct = mp4capture_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = mp4capture_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = mp4capture_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return mp4capture_possibleConstructorReturn(this, result); }; }
+
+function mp4capture_possibleConstructorReturn(self, call) { if (call && (mp4capture_typeof(call) === "object" || typeof call === "function")) { return call; } return mp4capture_assertThisInitialized(self); }
+
+function mp4capture_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
+
+function mp4capture_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
+
+function mp4capture_getPrototypeOf(o) { mp4capture_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return mp4capture_getPrototypeOf(o); }
+
+function mp4capture_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+
+
+
+
+var MAX_CAPTURE_BYTES = 225000000; // 5 min at a rate of 6 Mbit/s
+
+/**
+ * Component that records MP4 data.
+ */
+
+var Mp4Capture = /*#__PURE__*/function (_Tube) {
+  mp4capture_inherits(Mp4Capture, _Tube);
+
+  var _super = mp4capture_createSuper(Mp4Capture);
+
+  function Mp4Capture() {
+    var _this;
+
+    var maxSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : MAX_CAPTURE_BYTES;
+
+    mp4capture_classCallCheck(this, Mp4Capture);
+
+    var incoming = new stream_browserify.Transform({
+      objectMode: true,
+      transform: function transform(msg, _encoding, callback) {
+        // Arrival of ISOM with tracks indicates new movie, start recording if active.
+        if (_this._active && msg.type === MessageType.ISOM && msg.tracks !== undefined) {
+          _this._capture = true;
+        } // If capture enabled, record all ISOM (MP4) boxes
+
+
+        if (_this._capture && msg.type === MessageType.ISOM) {
+          if (_this._bufferOffset < _this._buffer.byteLength - msg.data.byteLength) {
+            msg.data.copy(_this._buffer, _this._bufferOffset);
+            _this._bufferOffset += msg.data.byteLength;
+          } else {
+            _this.stop();
+          }
+        } // Always pass on all messages
+
+
+        callback(undefined, msg);
+      }
+    }); // Stop any recording when the stream is closed.
+
+    incoming.on('finish', function () {
+      _this.stop();
+    });
+    _this = _super.call(this, incoming);
+
+    mp4capture_defineProperty(mp4capture_assertThisInitialized(_this), "_active", void 0);
+
+    mp4capture_defineProperty(mp4capture_assertThisInitialized(_this), "_capture", void 0);
+
+    mp4capture_defineProperty(mp4capture_assertThisInitialized(_this), "_captureCallback", void 0);
+
+    mp4capture_defineProperty(mp4capture_assertThisInitialized(_this), "_bufferOffset", void 0);
+
+    mp4capture_defineProperty(mp4capture_assertThisInitialized(_this), "_bufferSize", void 0);
+
+    mp4capture_defineProperty(mp4capture_assertThisInitialized(_this), "_buffer", void 0);
+
+    _this._buffer = mp4capture_Buffer.allocUnsafe(0);
+    _this._bufferSize = maxSize;
+    _this._bufferOffset = 0;
+    _this._active = false;
+    _this._capture = false;
+
+    _this._captureCallback = function () {
+      /** noop */
+    };
+
+    return _this;
+  }
+  /**
+   * Activate video capture. The capture will begin when a new movie starts,
+   * and will terminate when the movie ends or when the buffer is full. On
+   * termination, the callback you passed will be called with the captured
+   * data as argument.
+   * @param callback  Will be called when data is captured.
+   */
+
+
+  mp4capture_createClass(Mp4Capture, [{
+    key: "start",
+    value: function start(callback) {
+      if (!this._active) {
+        browser_default()('msl:capture:start')(callback);
+        this._captureCallback = callback;
+        this._buffer = mp4capture_Buffer.allocUnsafe(this._bufferSize);
+        this._bufferOffset = 0;
+        this._active = true;
+      }
+    }
+    /**
+     * Deactivate video capture. This ends an ongoing capture and prevents
+     * any further capturing.
+     */
+
+  }, {
+    key: "stop",
+    value: function stop() {
+      if (this._active) {
+        browser_default()('msl:capture:stop')("captured bytes: ".concat(this._bufferOffset));
+
+        try {
+          this._captureCallback(this._buffer.slice(0, this._bufferOffset));
+        } catch (e) {
+          console.error(e);
+        }
+
+        this._buffer = mp4capture_Buffer.allocUnsafe(0);
+        this._bufferOffset = 0;
+        this._active = false;
+        this._capture = false;
+      }
+    }
+  }]);
+
+  return Mp4Capture;
+}(Tube);
+// EXTERNAL MODULE: ./.yarn/unplugged/core-js-npm-3.16.2-c7ce9e8d48/node_modules/core-js/modules/es.array.fill.js
+var es_array_fill = __webpack_require__(8544);
+// EXTERNAL MODULE: ./.yarn/unplugged/core-js-npm-3.16.2-c7ce9e8d48/node_modules/core-js/modules/es.map.js
+var es_map = __webpack_require__(7775);
+// EXTERNAL MODULE: ./.yarn/unplugged/core-js-npm-3.16.2-c7ce9e8d48/node_modules/core-js/modules/es.string.repeat.js
+var es_string_repeat = __webpack_require__(4750);
+// EXTERNAL MODULE: ./.yarn/unplugged/core-js-npm-3.16.2-c7ce9e8d48/node_modules/core-js/modules/es.array.join.js
+var es_array_join = __webpack_require__(5691);
+// EXTERNAL MODULE: ./.yarn/unplugged/core-js-npm-3.16.2-c7ce9e8d48/node_modules/core-js/modules/es.string.pad-start.js
+var es_string_pad_start = __webpack_require__(3292);
+;// CONCATENATED MODULE: ./lib/components/mp4muxer/helpers/isom.ts
+/* provided dependency */ var isom_Buffer = __webpack_require__(7866)["Buffer"];
+function isom_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { isom_typeof = function _typeof(obj) { return typeof obj; }; } else { isom_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return isom_typeof(obj); }
+
+function isom_toConsumableArray(arr) { return isom_arrayWithoutHoles(arr) || isom_iterableToArray(arr) || isom_unsupportedIterableToArray(arr) || isom_nonIterableSpread(); }
+
+function isom_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
+
+function isom_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
+
+function isom_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return isom_arrayLikeToArray(arr); }
+
+function isom_slicedToArray(arr, i) { return isom_arrayWithHoles(arr) || isom_iterableToArrayLimit(arr, i) || isom_unsupportedIterableToArray(arr, i) || isom_nonIterableRest(); }
+
+function isom_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
+
+function isom_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }
+
+function isom_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
+
+function isom_createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = isom_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
+
+function isom_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return isom_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return isom_arrayLikeToArray(o, minLen); }
+
+function isom_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+function isom_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
+
+function isom_createClass(Constructor, protoProps, staticProps) { if (protoProps) isom_defineProperties(Constructor.prototype, protoProps); if (staticProps) isom_defineProperties(Constructor, staticProps); return Constructor; }
+
+function isom_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) isom_setPrototypeOf(subClass, superClass); }
+
+function isom_setPrototypeOf(o, p) { isom_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return isom_setPrototypeOf(o, p); }
+
+function isom_createSuper(Derived) { var hasNativeReflectConstruct = isom_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = isom_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = isom_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return isom_possibleConstructorReturn(this, result); }; }
+
+function isom_possibleConstructorReturn(self, call) { if (call && (isom_typeof(call) === "object" || typeof call === "function")) { return call; } return isom_assertThisInitialized(self); }
+
+function isom_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
+
+function isom_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
+
+function isom_getPrototypeOf(o) { isom_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return isom_getPrototypeOf(o); }
+
+function isom_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
+
+function isom_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+// Elements: parts of a box that hold values.
+// They should have a:
+// - byteLength
+// - value (can be accessed from outside to set/retrieve)
+// - store(buffer, offset) -> write the value to a buffer
+// - load(buffer, offset) -> read data and store in value
+// Constants
+var UINT32_RANGE = Math.pow(2, 32);
+
+var BoxElement = function BoxElement(size) {
+  isom_classCallCheck(this, BoxElement);
+
+  isom_defineProperty(this, "byteLength", void 0);
+
+  isom_defineProperty(this, "value", void 0);
+
+  this.byteLength = size;
+};
+
+var Empty = /*#__PURE__*/function (_BoxElement) {
+  isom_inherits(Empty, _BoxElement);
+
+  var _super = isom_createSuper(Empty);
+
+  function Empty() {
+    var _this;
+
+    var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
+
+    isom_classCallCheck(this, Empty);
+
+    _this = _super.call(this, size);
+
+    isom_defineProperty(isom_assertThisInitialized(_this), "copy", function (buffer, offset) {
+      buffer.fill(0, offset, offset + _this.byteLength);
+    });
+
+    return _this;
+  }
+
+  isom_createClass(Empty, [{
+    key: "load",
+    value: function load() {
+      /** noop */
+    }
+  }]);
+
+  return Empty;
+}(BoxElement);
+
+var CharArray = /*#__PURE__*/function (_BoxElement2) {
+  isom_inherits(CharArray, _BoxElement2);
+
+  var _super2 = isom_createSuper(CharArray);
+
+  function CharArray(s) {
+    var _this2;
+
+    isom_classCallCheck(this, CharArray);
+
+    _this2 = _super2.call(this, s.length);
+
+    isom_defineProperty(isom_assertThisInitialized(_this2), "value", void 0);
+
+    isom_defineProperty(isom_assertThisInitialized(_this2), "copy", function (buffer, offset) {
+      for (var i = 0; i < _this2.byteLength; i += 1) {
+        buffer[offset + i] = _this2.value.charCodeAt(i);
+      }
+    });
+
+    isom_defineProperty(isom_assertThisInitialized(_this2), "load", function (buffer, offset) {
+      _this2.value = buffer.slice(offset, offset + _this2.byteLength).toString('ascii');
+    });
+
+    _this2.value = s;
+    return _this2;
+  }
+
+  return CharArray;
+}(BoxElement);
+
+var UInt8 = /*#__PURE__*/function (_BoxElement3) {
+  isom_inherits(UInt8, _BoxElement3);
+
+  var _super3 = isom_createSuper(UInt8);
+
+  function UInt8() {
+    var _this3;
+
+    var scalar = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
+
+    isom_classCallCheck(this, UInt8);
+
+    _this3 = _super3.call(this, 1);
+
+    isom_defineProperty(isom_assertThisInitialized(_this3), "value", void 0);
+
+    isom_defineProperty(isom_assertThisInitialized(_this3), "copy", function (buffer, offset) {
+      buffer.writeUInt8(_this3.value, offset);
+    });
+
+    isom_defineProperty(isom_assertThisInitialized(_this3), "load", function (buffer, offset) {
+      _this3.value = buffer.readUInt8(offset);
+    });
+
+    _this3.value = scalar;
+    return _this3;
+  }
+
+  return UInt8;
+}(BoxElement);
+
+var UInt8Array = /*#__PURE__*/function (_BoxElement4) {
+  isom_inherits(UInt8Array, _BoxElement4);
+
+  var _super4 = isom_createSuper(UInt8Array);
+
+  function UInt8Array(array) {
+    var _this4;
+
+    isom_classCallCheck(this, UInt8Array);
+
+    _this4 = _super4.call(this, array.length);
+
+    isom_defineProperty(isom_assertThisInitialized(_this4), "value", void 0);
+
+    isom_defineProperty(isom_assertThisInitialized(_this4), "copy", function (buffer, offset) {
+      for (var i = 0; i < _this4.value.length; ++i) {
+        buffer.writeUInt8(_this4.value[i], offset + i);
+      }
+    });
+
+    isom_defineProperty(isom_assertThisInitialized(_this4), "load", function (buffer, offset) {
+      for (var i = 0; i < _this4.value.length; ++i) {
+        _this4.value[i] = buffer.readUInt8(offset + i);
+      }
+    });
+
+    _this4.value = array;
+    return _this4;
+  }
+
+  return UInt8Array;
+}(BoxElement);
+
+var UInt16BE = /*#__PURE__*/function (_BoxElement5) {
+  isom_inherits(UInt16BE, _BoxElement5);
+
+  var _super5 = isom_createSuper(UInt16BE);
+
+  function UInt16BE() {
+    var _this5;
+
+    var scalar = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
+
+    isom_classCallCheck(this, UInt16BE);
+
+    _this5 = _super5.call(this, 2);
+
+    isom_defineProperty(isom_assertThisInitialized(_this5), "value", void 0);
+
+    isom_defineProperty(isom_assertThisInitialized(_this5), "copy", function (buffer, offset) {
+      buffer.writeUInt16BE(_this5.value, offset);
+    });
+
+    isom_defineProperty(isom_assertThisInitialized(_this5), "load", function (buffer, offset) {
+      _this5.value = buffer.readUInt16BE(offset);
+    });
+
+    _this5.value = scalar;
+    return _this5;
+  }
+
+  return UInt16BE;
+}(BoxElement);
+
+var UInt24BE = /*#__PURE__*/function (_BoxElement6) {
+  isom_inherits(UInt24BE, _BoxElement6);
+
+  var _super6 = isom_createSuper(UInt24BE);
+
+  function UInt24BE() {
+    var _this6;
+
+    var scalar = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
+
+    isom_classCallCheck(this, UInt24BE);
+
+    _this6 = _super6.call(this, 3);
+
+    isom_defineProperty(isom_assertThisInitialized(_this6), "value", void 0);
+
+    isom_defineProperty(isom_assertThisInitialized(_this6), "copy", function (buffer, offset) {
+      buffer.writeUInt8(_this6.value >> 16 & 0xff, offset);
+      buffer.writeUInt8(_this6.value >> 8 & 0xff, offset + 1);
+      buffer.writeUInt8(_this6.value & 0xff, offset + 2);
+    });
+
+    isom_defineProperty(isom_assertThisInitialized(_this6), "load", function (buffer, offset) {
+      _this6.value = buffer.readUInt8(offset) << 16 + buffer.readUInt8(offset + 1) << 8 + buffer.readUInt8(offset + 2);
+    });
+
+    _this6.value = scalar;
+    return _this6;
+  }
+
+  return UInt24BE;
+}(BoxElement);
+
+var UInt16BEArray = /*#__PURE__*/function (_BoxElement7) {
+  isom_inherits(UInt16BEArray, _BoxElement7);
+
+  var _super7 = isom_createSuper(UInt16BEArray);
+
+  function UInt16BEArray(array) {
+    var _this7;
+
+    isom_classCallCheck(this, UInt16BEArray);
+
+    _this7 = _super7.call(this, array.length * 2);
+
+    isom_defineProperty(isom_assertThisInitialized(_this7), "value", void 0);
+
+    isom_defineProperty(isom_assertThisInitialized(_this7), "copy", function (buffer, offset) {
+      for (var i = 0; i < _this7.value.length; ++i) {
+        buffer.writeUInt16BE(_this7.value[i], offset + 2 * i);
+      }
+    });
+
+    isom_defineProperty(isom_assertThisInitialized(_this7), "load", function (buffer, offset) {
+      for (var i = 0; i < _this7.value.length; ++i) {
+        _this7.value[i] = buffer.readUInt16BE(offset + 2 * i);
+      }
+    });
+
+    _this7.value = array;
+    return _this7;
+  }
+
+  return UInt16BEArray;
+}(BoxElement);
+
+var UInt32BE = /*#__PURE__*/function (_BoxElement8) {
+  isom_inherits(UInt32BE, _BoxElement8);
+
+  var _super8 = isom_createSuper(UInt32BE);
+
+  function UInt32BE() {
+    var _this8;
+
+    var scalar = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
+
+    isom_classCallCheck(this, UInt32BE);
+
+    _this8 = _super8.call(this, 4);
+
+    isom_defineProperty(isom_assertThisInitialized(_this8), "value", void 0);
+
+    isom_defineProperty(isom_assertThisInitialized(_this8), "copy", function (buffer, offset) {
+      buffer.writeUInt32BE(_this8.value, offset);
+    });
+
+    isom_defineProperty(isom_assertThisInitialized(_this8), "load", function (buffer, offset) {
+      _this8.value = buffer.readUInt32BE(offset);
+    });
+
+    _this8.value = scalar;
+    return _this8;
+  }
+
+  return UInt32BE;
+}(BoxElement);
+
+var UInt32BEArray = /*#__PURE__*/function (_BoxElement9) {
+  isom_inherits(UInt32BEArray, _BoxElement9);
+
+  var _super9 = isom_createSuper(UInt32BEArray);
+
+  function UInt32BEArray(array) {
+    var _this9;
+
+    isom_classCallCheck(this, UInt32BEArray);
+
+    _this9 = _super9.call(this, array.length * 4);
+
+    isom_defineProperty(isom_assertThisInitialized(_this9), "value", void 0);
+
+    isom_defineProperty(isom_assertThisInitialized(_this9), "copy", function (buffer, offset) {
+      for (var i = 0; i < _this9.value.length; ++i) {
+        buffer.writeUInt32BE(_this9.value[i], offset + 4 * i);
+      }
+    });
+
+    isom_defineProperty(isom_assertThisInitialized(_this9), "load", function (buffer, offset) {
+      for (var i = 0; i < _this9.value.length; ++i) {
+        _this9.value[i] = buffer.readUInt32BE(offset + 4 * i);
+      }
+    });
+
+    _this9.value = array;
+    return _this9;
+  }
+
+  return UInt32BEArray;
+}(BoxElement);
+
+var UInt64BE = /*#__PURE__*/function (_BoxElement10) {
+  isom_inherits(UInt64BE, _BoxElement10);
+
+  var _super10 = isom_createSuper(UInt64BE);
+
+  function UInt64BE() {
+    var _this10;
+
+    var scalar = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
+
+    isom_classCallCheck(this, UInt64BE);
+
+    _this10 = _super10.call(this, 8);
+
+    isom_defineProperty(isom_assertThisInitialized(_this10), "value", void 0);
+
+    isom_defineProperty(isom_assertThisInitialized(_this10), "copy", function (buffer, offset) {
+      var high = _this10.value / UINT32_RANGE | 0;
+      var low = _this10.value - high * UINT32_RANGE;
+      buffer.writeUInt32BE(high, offset);
+      buffer.writeUInt32BE(low, offset + 4);
+    });
+
+    isom_defineProperty(isom_assertThisInitialized(_this10), "load", function (buffer, offset) {
+      var high = buffer.readUInt32BE(offset);
+      var low = buffer.readUInt32BE(offset + 4);
+      _this10.value = high * UINT32_RANGE + low;
+    });
+
+    _this10.value = scalar;
+    return _this10;
+  }
+
+  return UInt64BE;
+}(BoxElement);
+/**
+ * Class factory for a parameter set element. A parameter set groups a size,
+ * and an array of parameter sets consisting each of a size and a byte array.
+ * These elements are used by the avcC box.
+ * @param  [sizeMask=0x00]  A bit mask to use for the size.
+ * @return An element type that groups parameter sets.
+ */
+
+
+var createParameterSetArrayClass = function createParameterSetArrayClass() {
+  var sizeMask = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0x00;
+  return /*#__PURE__*/function (_BoxElement11) {
+    isom_inherits(ParameterSetArray, _BoxElement11);
+
+    var _super11 = isom_createSuper(ParameterSetArray);
+
+    /**
+     * Takes an array of byte-arrays
+     * @param  array The array of byte arrays
+     */
+    function ParameterSetArray(array) {
+      var _this11;
+
+      isom_classCallCheck(this, ParameterSetArray);
+
+      _this11 = _super11.call(this, 0); // this.setLengths = array.map((byteArray) => byteArray.length);
+
+      isom_defineProperty(isom_assertThisInitialized(_this11), "value", void 0);
+
+      isom_defineProperty(isom_assertThisInitialized(_this11), "copy", function (buffer, offset) {
+        var i = 0;
+
+        var _iterator = isom_createForOfIteratorHelper(_this11.value),
+            _step;
+
+        try {
+          for (_iterator.s(); !(_step = _iterator.n()).done;) {
+            var element = _step.value;
+            element.copy(buffer, offset + i);
+            i += element.byteLength;
+          }
+        } catch (err) {
+          _iterator.e(err);
+        } finally {
+          _iterator.f();
+        }
+      });
+
+      isom_defineProperty(isom_assertThisInitialized(_this11), "load", function () {
+        /** noop */
+      });
+
+      _this11.value = array.reduce(function (flatArray, byteArray) {
+        return flatArray.concat(new UInt16BE(byteArray.length), new UInt8Array(byteArray));
+      }, [new UInt8(sizeMask | array.length)]);
+      _this11.byteLength = _this11.value.reduce(function (total, element) {
+        return total + element.byteLength;
+      }, 0);
+      return _this11;
+    }
+
+    return ParameterSetArray;
+  }(BoxElement);
+};
+
+/**
+ * Specifications for a selection of ISO BMFF box types.
+ *
+ * Most of these are defined in ISO/IEC 14496-12,
+ * For specific boxes like avc1/avcC/mp4a/esds the exact document is specified
+ * with the appropriate box/descriptor.
+ *
+ * To add a new box, follow the same pattern: you need an object with at least
+ * the property 'box' (which is 'Box' or 'FullBox') and for non-container boxes
+ * you need also a 'body' property specifying the elements that the box contains.
+ * The values assigned to each element in the spec are used as default.
+ */
+var BOXSPEC = {
+  // File Type Box
+  ftyp: {
+    container: 'file',
+    mandatory: true,
+    quantity: 'one',
+    box: 'Box',
+    is_container: true,
+    body: [['major_brand', CharArray, 'isom'], ['minor_version', UInt32BE, 0], ['compatible_brands', CharArray, 'mp41'] // ['compatible_brands1', CharArray, 'iso2'],
+    // ['compatible_brands2', CharArray, 'dash'],
+    ]
+  },
+  // Movie Container
+  moov: {
+    container: 'file',
+    mandatory: true,
+    quantity: 'one',
+    box: 'Box',
+    is_container: true
+  },
+  // Movie Data Box
+  mdat: {
+    container: 'file',
+    mandatory: false,
+    quantity: 'any',
+    box: 'Box',
+    is_container: false,
+    body: []
+  },
+  // Movie Header Box
+  mvhd: {
+    container: 'moov',
+    mandatory: true,
+    quantity: 'one',
+    box: 'FullBox',
+    is_container: false,
+    body: [['creation_time', UInt32BE, 0], ['modification_time', UInt32BE, 0], ['timescale', UInt32BE, 1000], // time-scale for entire presentation, default = milliseconds
+    ['duration', UInt32BE, 0xffffffff], // length of entire presentation, default = undetermined
+    ['rate', UInt32BE, 0x00010000], // fixed point 16.16, preferred playback rate, default = 1.0
+    ['volume', UInt16BE, 0x0100], // fixed point 8.8, preferred playback volume, default = 1.0
+    ['reserved', Empty, 10], // transformation matrix, default = unity
+    ['matrix', UInt32BEArray, [0x00010000, 0, 0, 0, 0x00010000, 0, 0, 0, 0x40000000]], ['pre_defined', Empty, 24], ['next_track_ID', UInt32BE, 0xffffffff] // next unused track ID, default = unknown
+    ]
+  },
+  // Track Container
+  trak: {
+    container: 'moov',
+    mandatory: true,
+    quantity: 'one+',
+    box: 'Box',
+    is_container: true
+  },
+  // Track Header Box
+  tkhd: {
+    container: 'trak',
+    mandatory: true,
+    quantity: 'one',
+    box: 'FullBox',
+    is_container: false,
+    // Flag values for the track header:
+    // 0x000001 Track_enabled: track enabled (otherwise ignored)
+    // 0x000002 Track_in_movie: track used in presentation
+    // 0x000004 Track_in_preview: used when previewing presentation
+    config: {
+      flags: 0x000003 // track enabled and used in presentation
+
+    },
+    body: [['creation_time', UInt32BE, 0], ['modification_time', UInt32BE, 0], ['track_ID', UInt32BE, 1], // Track identifier, cannot be 0
+    ['reserved', Empty, 4], ['duration', UInt32BE, 0], // Duration of track using timescale of mvhd box
+    ['reserved2', Empty, 8], ['layer', UInt16BE, 0], // Front-to-back ordering, lower is closer to viewer
+    ['alternate_group', UInt16BE, 0], // Possible grouping of tracks
+    ['volume', UInt16BE, 0x0100], // Track's relative audio volume 8.8 fixed point
+    ['reserved3', Empty, 2], ['matrix', UInt32BEArray, [0x00010000, 0, 0, 0, 0x00010000, 0, 0, 0, 0x40000000]], ['width', UInt32BE, 0], // Visual presentation width, 16.16 fixed point
+    ['height', UInt32BE, 0] // Visual presentation height, 16.16 fixed point
+    ]
+  },
+  // Track Reference Box
+  tref: {
+    container: 'trak',
+    mandatory: false,
+    quantity: 'one-',
+    box: 'Box',
+    is_container: false
+  },
+  // Media Container
+  mdia: {
+    container: 'trak',
+    mandatory: false,
+    quantity: 'one',
+    box: 'Box',
+    is_container: true
+  },
+  // Media Header Box
+  mdhd: {
+    container: 'mdia',
+    mandatory: false,
+    quantity: 'one',
+    box: 'FullBox',
+    is_container: false,
+    body: [['creation_time', UInt32BE, 0], ['modification_time', UInt32BE, 0], ['timescale', UInt32BE, 1000], // time-scale for entire presentation, default = milliseconds
+    ['duration', UInt32BE, 0xffffffff], // length of entire presentation, default = undetermined
+    ['language', UInt16BE, 0], // ISO 639-2 lanugage code, three lower-case letters, stored as
+    ['pre_defined', UInt16BE, 0]]
+  },
+  // Handler Reference Box
+  hdlr: {
+    container: 'mdia',
+    mandatory: true,
+    quantity: 'one',
+    box: 'FullBox',
+    is_container: false,
+    body: [['predefined', UInt32BE, 0], ['handler_type', CharArray, 'vide'], // 'vide', 'soun', or 'hint'
+    ['reserved', Empty, 12], ['name', CharArray, 'VideoHandler\0']]
+  },
+  // Media Information Container
+  minf: {
+    container: 'mdia',
+    mandatory: true,
+    quantity: 'one',
+    box: 'Box',
+    is_container: true
+  },
+  // Video Media Header Box
+  vmhd: {
+    container: 'minf',
+    mandatory: true,
+    quantity: 'one',
+    box: 'FullBox',
+    is_container: false,
+    config: {
+      flags: 0x000001
+    },
+    body: [['graphicsmode', UInt16BE, 0], // Composition mode of the video track, 0 = overwrite
+    ['opcolor', UInt16BEArray, [0, 0, 0]] // Red green blue, for use by graphics modes
+    ]
+  },
+  // Sound Media Header Box
+  smhd: {
+    container: 'minf',
+    mandatory: true,
+    quantity: 'one',
+    box: 'FullBox',
+    is_container: false,
+    body: [// Place mono track in stereo space:
+    //  8.8 fixed point, 0 = center, -1.0 = left, 1.0 = right
+    ['balance', UInt16BE, 0x0000], ['reserved', UInt16BE]]
+  },
+  // Data Information Container
+  dinf: {
+    container: 'minf',
+    mandatory: true,
+    quantity: 'one',
+    box: 'Box',
+    is_container: true
+  },
+  // Data Reference Box
+  dref: {
+    // When adding elements to this box, update the entry_count value!
+    container: 'dinf',
+    mandatory: true,
+    quantity: 'one',
+    box: 'FullBox',
+    is_container: true,
+    body: [['entry_count', UInt32BE, 0] // Number of entries.
+    ]
+  },
+  'url ': {
+    container: 'dref',
+    mandatory: true,
+    quantity: 'one+',
+    box: 'FullBox',
+    is_container: false,
+    // Flag values:
+    // 0x000001 Local reference, which means empty URL
+    config: {
+      flags: 0x000001
+    },
+    body: [// ['location', CharArray, ''],
+    ]
+  },
+  // Sample Table Container
+  stbl: {
+    container: 'minf',
+    mandatory: true,
+    quantity: 'one',
+    box: 'Box',
+    is_container: true
+  },
+  // Decoding Time to Sample Box
+  stts: {
+    container: 'stbl',
+    mandatory: true,
+    quantity: 'one',
+    box: 'FullBox',
+    is_container: false,
+    body: [['entry_count', UInt32BE, 0] // For each entry these two elements:
+    // ['sample_count', UInt32BE, 0], // Number of consecutive samples with same delta
+    // ['sample_delta', UInt32BE, 0], // Delta of each sample
+    ]
+  },
+  stsd: {
+    container: 'stbl',
+    mandatory: true,
+    quantity: 'one',
+    box: 'FullBox',
+    is_container: true,
+    body: [['entry_count', UInt32BE, 1] // For each entry, one of these three boxes depending on the handler:
+    // VisualSampleEntry, AudioSampleEntry, HintSampleEntry
+    ]
+  },
+
+  /*
+  ISO/IEC 14496-12:2005(E) 8.16.2 (pp. 28)
+  aligned(8) abstract class SampleEntry (unsigned int(32) format)
+    extends Box(format){
+    const unsigned int(8)[6] reserved = 0;
+    unsigned int(16) data_reference_index;
+  }
+  class VisualSampleEntry(codingname) extends SampleEntry (codingname){
+    unsigned int(16) pre_defined = 0;
+    const unsigned int(16) reserved = 0;
+    unsigned int(32)[3] pre_defined = 0;
+    unsigned int(16) width;
+    unsigned int(16) height;
+    template unsigned int(32) horizresolution = 0x00480000; // 72 dpi
+    template unsigned int(32) vertresolution = 0x00480000; // 72 dpi
+    const unsigned int(32) reserved = 0;
+    template unsigned int(16) frame_count = 1;
+    string[32] compressorname;
+    template unsigned int(16) depth = 0x0018;
+    int(16) pre_defined = -1;
+  }
+  ISO/IEC 14496-15:2004(E) 5.3.4.1 (pp. 14)
+  class AVCSampleEntry() extends VisualSampleEntry (avc1){
+    AVCConfigurationBox config;
+    MPEG4BitRateBox (); // optional
+    MPEG4ExtensionDescriptorsBox (); // optional
+  }
+  */
+  avc1: {
+    container: 'stsd',
+    mandatory: false,
+    quantity: 'one',
+    box: 'Box',
+    is_container: true,
+    body: [['reserved', Empty, 6], ['data_reference_index', UInt16BE, 1], ['pre_defined', UInt16BE, 0], ['reserved2', Empty, 2], ['pre_defined2', UInt32BEArray, [0, 0, 0]], ['width', UInt16BE, 1920], ['height', UInt16BE, 1080], ['horizresolution', UInt32BE, 0x00480000], ['vertresolution', UInt32BE, 0x00480000], ['reserved3', UInt32BE, 0], ['frame_count', UInt16BE, 1], ['compressorname', UInt8Array, isom_Buffer.alloc(32)], ['depth', UInt16BE, 0x0018], ['pre_defined3', UInt16BE, 0xffff]]
+  },
+
+  /*
+  class AVCConfigurationBox extends Box(avcC) {
+    AVCDecoderConfigurationRecord() AVCConfig;
+  }
+  ISO/IEC 14496-15:2004(E) 5.2.4.1.1 (pp. 12)
+  aligned(8) class AVCDecoderConfigurationRecord {
+    unsigned int(8) configurationVersion = 1;
+    unsigned int(8) AVCProfileIndication;
+    unsigned int(8) profile_compatibility;
+    unsigned int(8) AVCLevelIndication;
+    bit(6) reserved = 111111b;
+    unsigned int(2) lengthSizeMinusOne;
+    bit(3) reserved = 111b;
+    unsigned int(5) numOfSequenceParameterSets;
+    for (i=0; i< numOfSequenceParameterSets; i++) {
+      unsigned int(16) sequenceParameterSetLength ;
+      bit(8*sequenceParameterSetLength) sequenceParameterSetNALUnit;
+    }
+    unsigned int(8) numOfPictureParameterSets;
+    for (i=0; i< numOfPictureParameterSets; i++) {
+      unsigned int(16) pictureParameterSetLength;
+      bit(8*pictureParameterSetLength) pictureParameterSetNALUnit;
+    }
+  }
+  */
+  avcC: {
+    container: 'avc1',
+    mandatory: false,
+    quantity: 'one',
+    box: 'Box',
+    is_container: false,
+    body: [['configurationVersion', UInt8, 1], ['AVCProfileIndication', UInt8, 0x4d], ['profile_compatibility', UInt8, 0x00], ['AVCLevelIndication', UInt8, 0x29], // size = reserved 0b111111 + 0b11 NALUnitLength (0b11 = 4-byte)
+    ['lengthSizeMinusOne', UInt8, 255], // Example SPS (length 20):
+    //   [0x67, 0x4d, 0x00, 0x29, 0xe2, 0x90, 0x0f, 0x00,
+    //    0x44, 0xfc, 0xb8, 0x0b, 0x70, 0x10, 0x10, 0x1a,
+    //    0x41, 0xe2, 0x44, 0x54]
+    // number of sets = reserved 0b111 + number of SPS (0b00001 = 1)
+    // ['numOfSequenceParameterSets', UInt8, 0b11100001],
+    // ['sequenceParameterSetLength', UInt16BE, 0], // Lenght in bytes of the SPS that follows
+    // ['sequenceParameterSetNALUnit', UInt8Array, []],
+    // These are packed in a single custom element:
+    ['sequenceParameterSets', createParameterSetArrayClass(0xe0), []], // Example PPS (length 4):
+    //   [0x68, 0xee, 0x3c, 0x80]
+    // ['numOfPictureParameterSets', UInt8, 1], // number of PPS
+    // ['pictureParameterSetLength', UInt16BE, 0], // Length in bytes of the PPS that follows
+    // ['pictureParameterSetNALUnit', UInt8Array, []]
+    // These are packed in a single custom element:
+    ['pictureParameterSets', createParameterSetArrayClass(), []]]
+  },
+
+  /*
+  ISO/IEC 14496-12:2005(E) 8.16.2 (pp. 28)
+  aligned(8) abstract class SampleEntry (unsigned int(32) format)
+    extends Box(format){
+    const unsigned int(8)[6] reserved = 0;
+    unsigned int(16) data_reference_index;
+  }
+  class AudioSampleEntry(codingname) extends SampleEntry (codingname){
+    const unsigned int(32)[2] reserved = 0;
+    template unsigned int(16) channelcount = 2;
+    template unsigned int(16) samplesize = 16;
+    unsigned int(16) pre_defined = 0;
+    const unsigned int(16) reserved = 0 ;
+    template unsigned int(32) samplerate = {timescale of media}<<16;
+  }
+  */
+  mp4a: {
+    container: 'stsd',
+    mandatory: false,
+    quantity: 'one',
+    box: 'Box',
+    is_container: true,
+    body: [['reserved', Empty, 6], ['data_reference_index', UInt16BE, 1], ['reserved2', UInt32BEArray, [0, 0]], ['channelcount', UInt16BE, 2], ['samplesize', UInt16BE, 16], ['pre_defined', UInt16BE, 0], ['reserved3', UInt16BE, 0], ['samplerate', UInt32BE, 0] // 16.16 bit floating point
+    ]
+  },
+
+  /* Elementary stream descriptor
+  basic box that holds only an ESDescriptor
+  reference: 'https://developer.apple.com/library/content/documentation/QuickTime/
+  QTFF/QTFFChap3/qtff3.html#//apple_ref/doc/uid/TP40000939-CH205-124774'
+  Descriptors have a tag that identifies them, specified in ISO/IEC 14496-1 8.3.12
+  ISO/IEC 14496-1 8.3.3 (pp. 24) ES_Descriptor
+  aligned(8) class ES_Descriptor : bit(8) tag=ES_DescrTag {
+    bit(8) length;
+    bit(16) ES_ID;
+    bit(1) streamDependenceFlag;
+    bit(1) URL_Flag;
+    const bit(1) reserved=1;
+    bit(5) streamPriority;
+    if (streamDependenceFlag)
+      bit(16) dependsOn_ES_ID;
+    if (URL_Flag)
+      bit(8) URLstring[length-3-(streamDependencFlag*2)];
+    ExtensionDescriptor extDescr[0 .. 255];
+    LanguageDescriptor langDescr[0 .. 1];
+    DecoderConfigDescriptor decConfigDescr;
+    SLConfigDescriptor slConfigDescr;
+    IPI_DescPointer ipiPtr[0 .. 1];
+    IP_IdentificationDataSet ipIDS[0 .. 1];
+    QoS_Descriptor qosDescr[0 .. 1];
+  }
+  aligned(8) class DecoderConfigDescriptor
+    : bit(8) tag=DecoderConfigDescrTag {
+    bit(8) length;
+    bit(8) objectProfileIndication;
+    bit(6) streamType;
+    bit(1) upStream;
+    const bit(1) reserved=1;
+    bit(24) bufferSizeDB;
+    bit(32) maxBitrate;
+    bit(32) avgBitrate;
+    DecoderSpecificInfo decSpecificInfo[];
+  }
+  aligned(8) class DecoderSpecificInfoShort extends DecoderSpecificInfo
+  : bit(8) tag=DecSpecificInfoShortTag
+  {
+    bit(8) length;
+    bit(8) specificInfo[length];
+  }
+  aligned(8) class SLConfigDescriptor : bit(8) tag=SLConfigDescrTag {
+    bit(8) length;
+    bit(8) predefined;
+    if (predefined==0) {
+      bit(1) useAccessUnitStartFlag;
+      bit(1) useAccessUnitEndFlag;
+      bit(1) useRandomAccessPointFlag;
+      bit(1) usePaddingFlag;
+      bit(1) useTimeStampsFlag;
+      bit(1) useWallClockTimeStampFlag;
+      bit(1) useIdleFlag;
+      bit(1) durationFlag;
+      bit(32) timeStampResolution;
+      bit(32) OCRResolution;
+      bit(8) timeStampLength; // must be less than 64
+      bit(8) OCRLength;
+      // must be less than 64
+      bit(8) AU_Length;
+      // must be less than 32
+      bit(8) instantBitrateLength;
+      bit(4) degradationPriorityLength;
+      bit(4) seqNumLength;
+      if (durationFlag) {
+        bit(32) timeScale;
+        bit(16) accessUnitDuration;
+        bit(16) compositionUnitDuration;
+      }
+      if (!useTimeStampsFlag) {
+        if (useWallClockTimeStampFlag)
+          double(64) wallClockTimeStamp;
+        bit(timeStampLength) startDecodingTimeStamp;
+        bit(timeStampLength) startCompositionTimeStamp;
+      }
+    }
+    aligned(8) bit(1) OCRstreamFlag;
+    const bit(7) reserved=0b1111.111;
+    if (OCRstreamFlag)
+      bit(16) OCR_ES_Id;
+  }
+  */
+  esds: {
+    container: 'mp4a',
+    mandatory: false,
+    quantity: 'one',
+    box: 'FullBox',
+    is_container: false,
+    body: [['ES_DescrTag', UInt8, 3], // length of the remainder of this descriptor in byte,
+    // excluding trailing embedded descriptors.
+    ['ES_DescrLength', UInt8, 25], ['ES_ID', UInt16BE, 1], ['flagsAndStreamPriority', UInt8, 0], ['DecoderConfigDescrTag', UInt8, 4], // length of the remainder of this descriptor in bytes,
+    // excluding trailing embedded descriptors.
+    ['DecoderConfigDescrLength', UInt8, 17], ['objectProfileIndication', UInt8, 0x40], ['streamTypeUpstreamReserved', UInt8, 0x15], ['bufferSizeDB', UInt8Array, [0, 0, 0]], ['maxBitRate', UInt32BE, 0], ['avgBitRate', UInt32BE, 0], ['DecSpecificInfoShortTag', UInt8, 5], ['DecSpecificInfoShortLength', UInt8, 2], ['audioConfigBytes', UInt16BE, 0], ['SLConfigDescrTag', UInt8, 6], ['SLConfigDescrLength', UInt8, 1], ['SLConfigDescrPredefined', UInt8, 0x02] // ISO use
+    ]
+  },
+  // Sample Size Box
+  stsz: {
+    container: 'stbl',
+    mandatory: true,
+    quantity: 'one',
+    box: 'FullBox',
+    is_container: false,
+    body: [['sample_size', UInt32BE, 0], ['sample_count', UInt32BE, 0] // For each sample up to sample_count, append an entry_size:
+    // ['entry_size', UInt32BE, ],
+    ]
+  },
+  // Sample To Chunk Box
+  stsc: {
+    container: 'stbl',
+    mandatory: true,
+    quantity: 'one',
+    box: 'FullBox',
+    is_container: false,
+    body: [['entry_count', UInt32BE, 0] // For each entry up to entry_count, append these elements:
+    // ['first_chunk', UInt32BE, ],
+    // ['samples_per_chunk', UInt32BE, ],
+    // ['samples_description_index', UInt32BE, ],
+    ]
+  },
+  // Chunk Offset Box
+  stco: {
+    container: 'stbl',
+    mandatory: true,
+    quantity: 'one',
+    box: 'FullBox',
+    is_container: false,
+    body: [['entry_count', UInt32BE, 0] // For each entry up to entry_count, append an element:
+    // ['chunk_offset', UInt32BE, ],
+    ]
+  },
+  // Sync Sample Box
+  stss: {
+    container: 'stbl',
+    mandatory: false,
+    quantity: 'one-',
+    box: 'FullBox',
+    is_container: false,
+    body: [['entry_count', UInt32BE, 0] // For each entry up to entry_count, append an element:
+    // ['sample_number', UInt32BE, ],
+    ]
+  },
+  // Edit Box
+  edts: {
+    container: 'trak',
+    mandatory: false,
+    quantity: 'one-',
+    box: 'Box',
+    is_container: true
+  },
+  // Edit List Box
+  elst: {
+    container: 'edts',
+    mandatory: false,
+    quantity: 'one-',
+    box: 'FullBox',
+    is_container: false,
+    body: [['entry_count', UInt32BE, 1], ['segment_duration', UInt32BE, 0], ['media_time', UInt32BE, 0xffffffff], ['media_rate_integer', UInt16BE, 1], ['media_rate_fraction', UInt16BE, 0]]
+  },
+  mvex: {
+    container: 'moov',
+    mandatory: false,
+    quantity: 'one-',
+    box: 'Box',
+    is_container: true
+  },
+  mehd: {
+    container: 'mvex',
+    mandatory: false,
+    quantity: 'one-',
+    box: 'FullBox',
+    is_container: false,
+    body: [['fragment_duration', UInt32BE, 0] // Total duration of movie
+    ]
+  },
+  trex: {
+    container: 'mvex',
+    mandatory: true,
+    quantity: 'one+',
+    box: 'FullBox',
+    is_container: false,
+    body: [['track_ID', UInt32BE, 1], // The track to which this data is applicable
+    ['default_sample_description_index', UInt32BE, 1], ['default_sample_duration', UInt32BE, 0], ['default_sample_size', UInt32BE, 0], ['default_sample_flags', UInt32BE, 0]]
+  },
+  moof: {
+    container: 'file',
+    mandatory: false,
+    quantity: 'zero+',
+    box: 'Box',
+    is_container: false
+  },
+  mfhd: {
+    container: 'moof',
+    mandatory: true,
+    quantity: 'one',
+    box: 'FullBox',
+    is_container: false,
+    body: [['sequence_number', UInt32BE, 0] // A number associated with this fragment
+    ]
+  },
+  traf: {
+    container: 'moof',
+    mandatory: false,
+    quantity: 'zero+',
+    box: 'Box',
+    is_container: true
+  },
+  tfhd: {
+    container: 'traf',
+    mandatory: true,
+    quantity: 'one',
+    box: 'FullBox',
+    is_container: false,
+    // Flag values for the track fragment header:
+    // 0x000001 base-data-offset-present
+    // 0x000002 sample-description-index-present
+    // 0x000008 default-sample-duration-present
+    // 0x000010 default-sample-size-present
+    // 0x000020 default-sample-flags-present
+    // 0x010000 duration-is-empty
+    // 0x020000 default-base-is-moof
+    config: {
+      flags: 0x000020 // default sample flags present
+
+    },
+    body: [['track_ID', UInt32BE, 1], // The track to which this data is applicable
+    // ['base_data_offset', UInt64BE, 0],
+    // ['default_sample_description_index', UInt32BE, 0],
+    // ['default_sample_duration', UInt32BE, 0],
+    // ['default_sample_size', UInt32BE, 0],
+    ['default_sample_flags', UInt32BE, 0]]
+  },
+  tfdt: {
+    container: 'traf',
+    mandatory: false,
+    quantity: 'one-',
+    box: 'FullBox',
+    is_container: false,
+    config: {
+      version: 1 // Version 1 uses 64-bit value for baseMediaDecodeTime
+
+    },
+    body: [['baseMediaDecodeTime', UInt64BE, 0]]
+  },
+  trun: {
+    container: 'traf',
+    mandatory: false,
+    quantity: 'zero+',
+    box: 'FullBox',
+    is_container: false,
+    // Flag values for the track fragment header:
+    // 0x000001 data-offset-present
+    // 0x000004 first-sample-flags-present
+    // 0x000100 sample-duration-present
+    // 0x000200 sample-size-present
+    // 0x000400 sample-flags-present
+    // 0x000800 sample-composition-time-offsets-present
+    config: {
+      flags: 0x000305 // default sample flags present
+
+    },
+    body: [['sample_count', UInt32BE, 1], // How many samples there are
+    ['data_offset', UInt32BE, 0], ['first_sample_flags', UInt32BE, 0], ['sample_duration', UInt32BE, 0], ['sample_size', UInt32BE, 0] // ['sample_flags', UInt32BE, 0],
+    // ['sample_composition_time_offset', UInt32BE, 0],
+    ]
+  },
+  // Unknown Box, used for parsing
+  '....': {
+    box: 'Box',
+    is_container: false,
+    body: []
+  },
+  // File Box, special box without any headers
+  file: {
+    box: 'None',
+    is_container: true,
+    mandatory: true,
+    quantity: 'one'
+  }
+};
+/**
+ * Helper functions to generate some standard elements that are needed by
+ * all types of boxes.
+ * All boxes have a length and type, where so-called full boxes have an
+ * additional 4-bytes (1-byte version and 3-byte flags fields).
+ */
+
+var Header = /*#__PURE__*/function () {
+  function Header() {
+    isom_classCallCheck(this, Header);
+  }
+
+  isom_createClass(Header, null, [{
+    key: "None",
+    value: function None() {
+      return [];
+    }
+  }, {
+    key: "Box",
+    value: function Box(type) {
+      return [['size', UInt32BE, 0], ['type', CharArray, type]];
+    }
+  }, {
+    key: "FullBox",
+    value: function FullBox(type) {
+      return [].concat(this.Box(type), [['version', UInt8, 0x00], ['flags', UInt24BE, 0x000000]]);
+    }
+  }]);
+
+  return Header;
+}();
+/**
+ * Box class.
+ *
+ * Defines a box as an entity similar to a C struct, where the struct is
+ * represented by a Map of elements.
+ * Each element is an object with at least:
+ *  - a 'byteLength' property (size of element in bytes)
+ *  - a 'copy' method (BufferMutation signature)
+ */
+
+
+var Box = /*#__PURE__*/function (_BoxElement12) {
+  isom_inherits(Box, _BoxElement12);
+
+  var _super12 = isom_createSuper(Box);
+
+  /**
+   * Create a new Box.
+   * @param  type   4-character ASCII string
+   * @param  config Configuration holding (key: value) fields
+   */
+  function Box(type, config) {
+    var _this12;
+
+    isom_classCallCheck(this, Box);
+
+    _this12 = _super12.call(this, 0);
+
+    isom_defineProperty(isom_assertThisInitialized(_this12), "type", void 0);
+
+    isom_defineProperty(isom_assertThisInitialized(_this12), "config", void 0);
+
+    isom_defineProperty(isom_assertThisInitialized(_this12), "struct", void 0);
+
+    _this12.type = type;
+    var spec = BOXSPEC[_this12.type];
+
+    if (spec === undefined) {
+      throw new Error("unknown box type: ".concat(type));
+    }
+
+    _this12.config = Object.assign({}, spec.config, config);
+    var header = Header[spec.box](_this12.type);
+    var body = spec.body || []; // Uglify changes the name of the original class, so this doesn't work.
+    // TODO: find a better way to check for this.
+    // if (spec.body === undefined && this.constructor.name !== 'Container') {
+    //   throw new Error(`Body missing but '${type}' is not a container box`);
+    // }
+    // Initialize all elements, an element is something with a byteLength
+
+    _this12.struct = new Map();
+    var offset = 0;
+
+    var _iterator2 = isom_createForOfIteratorHelper([].concat(header, body)),
+        _step2;
+
+    try {
+      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
+        var _step2$value = isom_slicedToArray(_step2.value, 3),
+            _key = _step2$value[0],
+            Type = _step2$value[1],
+            defaultValue = _step2$value[2];
+
+        if (_this12.has(_key)) {
+          throw new Error('Trying to add existing key');
+        }
+
+        var value = defaultValue;
+
+        if (_this12.config[_key]) {
+          value = _this12.config[_key];
+        }
+
+        var element = new Type(value);
+
+        _this12.struct.set(_key, {
+          offset: offset,
+          element: element
+        });
+
+        offset += element.byteLength;
+      }
+    } catch (err) {
+      _iterator2.e(err);
+    } finally {
+      _iterator2.f();
+    }
+
+    _this12.byteLength = offset;
+    return _this12;
+  }
+  /**
+   * Get access to an element based on it's name.
+   * @param  key The element's name
+   * @return Object with 'byteLength' property and 'copy' method
+   */
+
+
+  isom_createClass(Box, [{
+    key: "element",
+    value: function element(key) {
+      var value = this.struct.get(key);
+
+      if (value === undefined) {
+        throw new Error('invalid key');
+      }
+
+      return value.element;
+    }
+    /**
+     * Set an element's value.
+     * @param  key The element's name
+     * @param  value The element's (new) value
+     */
+
+  }, {
+    key: "set",
+    value: function set(key, value) {
+      this.element(key).value = value;
+    }
+    /**
+     * Get an element's value.
+     * @param  key The element's name
+     * @return The element's value
+     */
+
+  }, {
+    key: "get",
+    value: function get(key) {
+      return this.element(key).value;
+    }
+    /**
+     * Get an element's offset.
+     * @param  key The element's name
+     * @return The element's offset
+     */
+
+  }, {
+    key: "offset",
+    value: function offset(key) {
+      var value = this.struct.get(key);
+
+      if (value === undefined) {
+        throw new Error('invalid key');
+      }
+
+      return value.offset;
+    }
+    /**
+     * Check if a certain element exists
+     * @param  key The element's name
+     * @return true if the element is known, false if not
+     */
+
+  }, {
+    key: "has",
+    value: function has(key) {
+      return this.struct.has(key);
+    }
+    /**
+     * Add a new element to the box.
+     * @param key     A _new_ non-existing element name.
+     * @param element Something with a 'byteLength' property and 'copy' method.
+     * @return this box, so that 'add' can be used in a chain
+     */
+
+  }, {
+    key: "add",
+    value: function add(key, element) {
+      if (this.has(key)) {
+        throw new Error('Trying to add existing key');
+      }
+
+      this.struct.set(key, {
+        offset: this.byteLength,
+        element: element
+      });
+      this.byteLength += element.byteLength;
+      return this;
+    }
+    /**
+     * Create a buffer and copy all element values to it.
+     * @return Data representing the box.
+     */
+
+  }, {
+    key: "buffer",
+    value: function buffer() {
+      var buffer = isom_Buffer.allocUnsafe(this.byteLength);
+      this.copy(buffer);
+      return buffer;
+    }
+    /**
+     * Copy all values of the box into an existing buffer.
+     * @param  buffer     The target buffer to accept the box data
+     * @param  [offset=0] The number of bytes into the target to start at.
+     */
+
+  }, {
+    key: "copy",
+    value: function copy(buffer) {
+      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
+      // Before writing, make sure the size property is set correctly.
+      this.set('size', this.byteLength);
+
+      var _iterator3 = isom_createForOfIteratorHelper(this.struct.values()),
+          _step3;
+
+      try {
+        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
+          var entry = _step3.value;
+          entry.element.copy(buffer, offset + entry.offset);
+        }
+      } catch (err) {
+        _iterator3.e(err);
+      } finally {
+        _iterator3.f();
+      }
+    }
+    /**
+     * Read element values from a box's data representation.
+     * @param  buffer     The source buffer with box data
+     * @param  [offset=0] The number of bytes into the source to start at.
+     */
+
+  }, {
+    key: "load",
+    value: function load(buffer) {
+      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
+
+      var _iterator4 = isom_createForOfIteratorHelper(this.struct.values()),
+          _step4;
+
+      try {
+        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
+          var entry = _step4.value;
+
+          if (entry.element.load !== undefined) {
+            entry.element.load(buffer, offset + entry.offset);
+          }
+        }
+      } catch (err) {
+        _iterator4.e(err);
+      } finally {
+        _iterator4.f();
+      }
+    }
+    /**
+     * Pretty-format an entire box as an element/box hierarchy.
+     * @param  [indent=0] How large an indentation to use for the hierarchy
+     */
+
+  }, {
+    key: "format",
+    value: function format() {
+      var indent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
+      var lines = [' '.repeat(indent) + "[".concat(this.type, "] (").concat(this.byteLength, ")")];
+
+      var _iterator5 = isom_createForOfIteratorHelper(this.struct),
+          _step5;
+
+      try {
+        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
+          var _step5$value = isom_slicedToArray(_step5.value, 2),
+              _key2 = _step5$value[0],
+              entry = _step5$value[1];
+
+          var element = entry.element;
+
+          if (element.format !== undefined) {
+            lines.push(element.format(indent + 2));
+          } else {
+            lines.push(' '.repeat(indent + 2) + "".concat(_key2, " = ").concat(element.value, " (").concat(element.byteLength, ")"));
+          }
+        }
+      } catch (err) {
+        _iterator5.e(err);
+      } finally {
+        _iterator5.f();
+      }
+
+      return lines.join('\n');
+    }
+    /**
+     * Pretty-print an entire box as an element/box hierarchy.
+     * @param  [indent=0] How large an indentation to use for the hierarchy
+     */
+
+  }, {
+    key: "print",
+    value: function print(indent) {
+      console.warn(this.format(indent));
+    }
+  }]);
+
+  return Box;
+}(BoxElement);
+/**
+ * Container class
+ *
+ * special box with an 'add' method which allows appending of other boxes,
+ * and a 'parse' method to extract contained boxes.
+ */
+
+var Container = /*#__PURE__*/function (_Box) {
+  isom_inherits(Container, _Box);
+
+  var _super13 = isom_createSuper(Container);
+
+  /**
+   * Create a new container box
+   * @param  type   4-character ASCII string
+   * @param  config Configuration holding (key: value) fields
+   * @param  boxes  One or more boxes to append.
+   */
+  function Container(type, config) {
+    var _this14;
+
+    var _this13;
+
+    isom_classCallCheck(this, Container);
+
+    _this13 = _super13.call(this, type, config);
+
+    isom_defineProperty(isom_assertThisInitialized(_this13), "boxSize", void 0);
+
+    _this13.boxSize = 0;
+
+    for (var _len = arguments.length, boxes = new Array(_len > 2 ? _len - 2 : 0), _key3 = 2; _key3 < _len; _key3++) {
+      boxes[_key3 - 2] = arguments[_key3];
+    }
+
+    (_this14 = _this13).append.apply(_this14, boxes);
+
+    return _this13;
+  }
+  /**
+   * Add one or more boxes to the container.
+   * @param boxes The box(es) to append
+   * @return this container, so that add can be used in a chain
+   */
+
+
+  isom_createClass(Container, [{
+    key: "append",
+    value: function append() {
+      for (var _len2 = arguments.length, boxes = new Array(_len2), _key4 = 0; _key4 < _len2; _key4++) {
+        boxes[_key4] = arguments[_key4];
+      }
+
+      for (var _i2 = 0, _boxes = boxes; _i2 < _boxes.length; _i2++) {
+        var box = _boxes[_i2];
+        this.add("box_".concat(this.boxSize++), box);
+      }
+
+      return this;
+    }
+    /**
+     * Parse a container box by looking for boxes that it contains, and
+     * recursively proceed when it is another container.
+     *
+     * FIXME: this cannot properly handle different versions of the FullBox,
+     * currenlty the loader is hardcoded to the version used in this file.
+     * Also, appearance of an esds box is assumed to be AAC audio information,
+     * while the avcC box signals H.264 video information.
+     *
+     * @param  data The data to parse.
+     */
+
+  }, {
+    key: "parse",
+    value: function parse(data) {
+      var tracks = [];
+
+      while (data.byteLength > 0) {
+        var type = new CharArray('....');
+        type.load(data, 4);
+        var boxType = type.value;
+        var spec = BOXSPEC[boxType];
+        var box = void 0;
+
+        if (spec !== undefined) {
+          if (spec.is_container) {
+            box = new Container(boxType);
+            box.load(data);
+            var boxTracks = box.parse(data.slice(box.byteLength, box.get('size')));
+            tracks.push.apply(tracks, isom_toConsumableArray(boxTracks));
+          } else {
+            box = new Box(boxType);
+            box.load(data); // Handle 2 kinds of tracks with streaming MP4: video or audio
+
+            if (boxType === 'avcC') {
+              var profile = box.element('AVCProfileIndication').value.toString(16).padStart(2, 0);
+              var compat = box.element('profile_compatibility').value.toString(16).padStart(2, 0);
+              var level = box.element('AVCLevelIndication').value.toString(16).padStart(2, 0);
+              tracks.push({
+                type: 'video',
+                mime: "avc1.".concat(profile).concat(compat).concat(level)
+              });
+            } else if (boxType === 'esds') {
+              var audioConfigBytes = box.element('audioConfigBytes').value;
+              var objectTypeIndication = audioConfigBytes >>> 11 & 0x001f;
+              tracks.push({
+                type: 'audio',
+                mime: "mp4a.40.".concat(objectTypeIndication)
+              });
+            }
+          }
+        } else {
+          box = new Box('....');
+          box.load(data);
+          box.type = box.get('type');
+        }
+
+        this.append(box);
+        data = data.slice(box.get('size'));
+      }
+
+      return tracks;
+    }
+  }]);
+
+  return Container;
+}(Box);
+;// CONCATENATED MODULE: ./lib/components/mp4muxer/helpers/aacSettings.ts
+
+
+
+ // All audio object types defined in ISO/IEC 14496-3 pp. 40
+
+var AUDIO_OBJECT_TYPE_NAMES = {
+  1: 'AAC Main',
+  2: 'AAC LC'
+}; // All frequencies defined in ISO/IEC 14496-3 pp. 42
+
+var FREQUENCY_VALUES = {
+  0: '96 kHz',
+  1: '88.2 kHz',
+  2: '64 kHz',
+  3: '48 kHz',
+  4: '44.1 kHz',
+  5: '32 kHz',
+  6: '24 kHz',
+  7: '22.05 kHz',
+  8: '16 kHz',
+  9: '12 kHz',
+  10: '11.025 kHz',
+  11: '8 kHz',
+  12: '7.35 kHz'
+}; // All channels defined in ISO/IEC 14496-3 pp. 42
+
+var CHANNEL_CONFIG_NAMES = {
+  1: 'Mono',
+  2: 'Stereo'
+};
+
+var aacEncodingName = function aacEncodingName(audioConfigBytes) {
+  var audioObjectType = audioConfigBytes >>> 11 & 0x001f;
+  var frequencyIndex = audioConfigBytes >>> 7 & 0x000f;
+  var channelConfig = audioConfigBytes >>> 3 & 0x000f;
+  var audioType = AUDIO_OBJECT_TYPE_NAMES[audioObjectType] || "AAC (".concat(audioObjectType, ")");
+  var samplingRate = FREQUENCY_VALUES[frequencyIndex] || 'unknown';
+  var channels = CHANNEL_CONFIG_NAMES[channelConfig] || channelConfig.toString();
+  return {
+    coding: audioType,
+    samplingRate: samplingRate,
+    channels: channels
+  };
+};
+
+var aacSettings = function aacSettings(media, date, trackId) {
+  /*
+   * Example SDP media segment for MPEG4-GENERIC audio:
+   *
+   {
+     "type": "audio",
+     "port": "0",
+     "proto": "RTP/AVP",
+     "fmt": "97",
+     "connectionData": {
+       "netType": "IN",
+       "addrType": "IP4",
+       "connectionAddress": "0.0.0.0"
+     },
+     "bwtype": "AS",
+     "bandwidth": "32",
+     "rtpmap": {
+       "payloadType": "97",
+       "encodingName": "MPEG4-GENERIC",
+       "clockrate": "16000",
+       "encodingParameters": "1"
+     },
+     "fmtp": {
+       "format": "97",
+       "parameters": {
+         "streamtype": "5",
+         "profile-level-id": "2",
+         "mode": "AAC-hbr",
+         "config": "1408",
+         "sizelength": "13",
+         "indexlength": "3",
+         "indexdeltalength": "3",
+         "bitrate": "32000"
+       }
+     },
+     "control": "rtsp://hostname/axis-media/media.amp/stream=1?audio=1"
+   }
+    */
+  var bitrate = Number(media.fmtp.parameters.bitrate) || 320000; // sometimes AAC fmtp.parameters.config much more that expected UInt16
+
+  /*
+              {
+                "bandwidth": "128",
+                "bwtype": "AS",
+                "control": "trackID=1",
+                "fmt": 97,
+                "fmtp": {
+                    "format": "97",
+                    "parameters": {
+                        "config": "121056E500",
+                        "indexdeltalength": "3",
+                        "indexlength": "3",
+                        "mode": "AAC-hbr",
+                        "profile-level-id": "1",
+                        "sizelength": "13"
+                    }
+                },
+                "port": 0,
+                "protocol": "RTP/AVP",
+                "rtpmap": {
+                    "clockrate": 44100,
+                    "encodingName": "MPEG4-GENERIC",
+                    "encodingParameters": "2",
+                    "payloadType": 97
+                },
+                "type": "audio"
+            }
+  */
+  // const audioConfigBytes = parseInt(media.fmtp.parameters.config, 16);
+
+  var audioConfigBytes = parseInt(media.fmtp.parameters.config.substr(0, 4), 16);
+  var audioObjectType = audioConfigBytes >>> 11 & 0x001f;
+  return {
+    tkhd: {
+      track_ID: trackId,
+      creation_time: date,
+      modification_time: date,
+      width: 0,
+      height: 0,
+      volume: 1
+    },
+    mdhd: {
+      timescale: Number(media.rtpmap.clockrate),
+      creation_time: date,
+      modification_time: date,
+      duration: 0
+    },
+    hdlr: {
+      handler_type: 'soun',
+      name: 'SoundHandler\0' // 00 soundhandler, add 00 if things screws up
+
+    },
+    mediaHeaderBox: new Box('smhd'),
+    sampleEntryBox: new Container('mp4a', {
+      samplerate: media.rtpmap.clockrate << 16 >>> 0 // FIXME: Is this  correct?
+
+    }, new Box('esds', {
+      audioConfigBytes: audioConfigBytes,
+      // Converting from hex string to int
+      maxBitRate: bitrate,
+      avgBitRate: bitrate
+    })),
+
+    /*
+    https://wiki.multimedia.cx/index.php/Understanding_AAC
+    AAC is a variable bitrate (VBR) block-based codec where each block decodes
+    to 1024 time-domain samples, which means that a single block (or frame?) is
+    1024 ticks long, which we take as default here.
+    */
+    defaultFrameDuration: 1024,
+    // MIME type
+    mime: "mp4a.40.".concat(audioObjectType),
+    codec: aacEncodingName(audioConfigBytes)
+  };
+};
+// EXTERNAL MODULE: ./.yarn/unplugged/core-js-npm-3.16.2-c7ce9e8d48/node_modules/core-js/modules/es.number.to-fixed.js
+var es_number_to_fixed = __webpack_require__(5957);
+// EXTERNAL MODULE: ./.yarn/unplugged/core-js-npm-3.16.2-c7ce9e8d48/node_modules/core-js/modules/es.regexp.exec.js
+var es_regexp_exec = __webpack_require__(1818);
+// EXTERNAL MODULE: ./.yarn/unplugged/core-js-npm-3.16.2-c7ce9e8d48/node_modules/core-js/modules/es.string.split.js
+var es_string_split = __webpack_require__(1661);
+// EXTERNAL MODULE: ./.yarn/unplugged/core-js-npm-3.16.2-c7ce9e8d48/node_modules/core-js/modules/es.string.replace.js
+var es_string_replace = __webpack_require__(4449);
+// EXTERNAL MODULE: ./.yarn/unplugged/core-js-npm-3.16.2-c7ce9e8d48/node_modules/core-js/modules/es.array-buffer.slice.js
+var es_array_buffer_slice = __webpack_require__(9722);
+// EXTERNAL MODULE: ./.yarn/unplugged/core-js-npm-3.16.2-c7ce9e8d48/node_modules/core-js/modules/es.typed-array.uint8-array.js
+var es_typed_array_uint8_array = __webpack_require__(6747);
+// EXTERNAL MODULE: ./.yarn/unplugged/core-js-npm-3.16.2-c7ce9e8d48/node_modules/core-js/modules/es.typed-array.copy-within.js
+var es_typed_array_copy_within = __webpack_require__(77);
+// EXTERNAL MODULE: ./.yarn/unplugged/core-js-npm-3.16.2-c7ce9e8d48/node_modules/core-js/modules/es.typed-array.every.js
+var es_typed_array_every = __webpack_require__(9038);
+// EXTERNAL MODULE: ./.yarn/unplugged/core-js-npm-3.16.2-c7ce9e8d48/node_modules/core-js/modules/es.typed-array.fill.js
+var es_typed_array_fill = __webpack_require__(7522);
+// EXTERNAL MODULE: ./.yarn/unplugged/core-js-npm-3.16.2-c7ce9e8d48/node_modules/core-js/modules/es.typed-array.filter.js
+var es_typed_array_filter = __webpack_require__(6534);
+// EXTERNAL MODULE: ./.yarn/unplugged/core-js-npm-3.16.2-c7ce9e8d48/node_modules/core-js/modules/es.typed-array.find.js
+var es_typed_array_find = __webpack_require__(538);
+// EXTERNAL MODULE: ./.yarn/unplugged/core-js-npm-3.16.2-c7ce9e8d48/node_modules/core-js/modules/es.typed-array.find-index.js
+var es_typed_array_find_index = __webpack_require__(1888);
+// EXTERNAL MODULE: ./.yarn/unplugged/core-js-npm-3.16.2-c7ce9e8d48/node_modules/core-js/modules/es.typed-array.for-each.js
+var es_typed_array_for_each = __webpack_require__(1613);
+// EXTERNAL MODULE: ./.yarn/unplugged/core-js-npm-3.16.2-c7ce9e8d48/node_modules/core-js/modules/es.typed-array.includes.js
+var es_typed_array_includes = __webpack_require__(2744);
+// EXTERNAL MODULE: ./.yarn/unplugged/core-js-npm-3.16.2-c7ce9e8d48/node_modules/core-js/modules/es.typed-array.index-of.js
+var es_typed_array_index_of = __webpack_require__(5066);
+// EXTERNAL MODULE: ./.yarn/unplugged/core-js-npm-3.16.2-c7ce9e8d48/node_modules/core-js/modules/es.typed-array.iterator.js
+var es_typed_array_iterator = __webpack_require__(2315);
+// EXTERNAL MODULE: ./.yarn/unplugged/core-js-npm-3.16.2-c7ce9e8d48/node_modules/core-js/modules/es.typed-array.join.js
+var es_typed_array_join = __webpack_require__(5288);
+// EXTERNAL MODULE: ./.yarn/unplugged/core-js-npm-3.16.2-c7ce9e8d48/node_modules/core-js/modules/es.typed-array.last-index-of.js
+var es_typed_array_last_index_of = __webpack_require__(5503);
+// EXTERNAL MODULE: ./.yarn/unplugged/core-js-npm-3.16.2-c7ce9e8d48/node_modules/core-js/modules/es.typed-array.map.js
+var es_typed_array_map = __webpack_require__(9969);
+// EXTERNAL MODULE: ./.yarn/unplugged/core-js-npm-3.16.2-c7ce9e8d48/node_modules/core-js/modules/es.typed-array.reduce.js
+var es_typed_array_reduce = __webpack_require__(2103);
+// EXTERNAL MODULE: ./.yarn/unplugged/core-js-npm-3.16.2-c7ce9e8d48/node_modules/core-js/modules/es.typed-array.reduce-right.js
+var es_typed_array_reduce_right = __webpack_require__(1587);
+// EXTERNAL MODULE: ./.yarn/unplugged/core-js-npm-3.16.2-c7ce9e8d48/node_modules/core-js/modules/es.typed-array.reverse.js
+var es_typed_array_reverse = __webpack_require__(5109);
+// EXTERNAL MODULE: ./.yarn/unplugged/core-js-npm-3.16.2-c7ce9e8d48/node_modules/core-js/modules/es.typed-array.set.js
+var es_typed_array_set = __webpack_require__(1418);
+// EXTERNAL MODULE: ./.yarn/unplugged/core-js-npm-3.16.2-c7ce9e8d48/node_modules/core-js/modules/es.typed-array.slice.js
+var es_typed_array_slice = __webpack_require__(9760);
+// EXTERNAL MODULE: ./.yarn/unplugged/core-js-npm-3.16.2-c7ce9e8d48/node_modules/core-js/modules/es.typed-array.some.js
+var es_typed_array_some = __webpack_require__(4948);
+// EXTERNAL MODULE: ./.yarn/unplugged/core-js-npm-3.16.2-c7ce9e8d48/node_modules/core-js/modules/es.typed-array.sort.js
+var es_typed_array_sort = __webpack_require__(727);
+// EXTERNAL MODULE: ./.yarn/unplugged/core-js-npm-3.16.2-c7ce9e8d48/node_modules/core-js/modules/es.typed-array.subarray.js
+var es_typed_array_subarray = __webpack_require__(5448);
+// EXTERNAL MODULE: ./.yarn/unplugged/core-js-npm-3.16.2-c7ce9e8d48/node_modules/core-js/modules/es.typed-array.to-locale-string.js
+var es_typed_array_to_locale_string = __webpack_require__(6179);
+// EXTERNAL MODULE: ./.yarn/unplugged/core-js-npm-3.16.2-c7ce9e8d48/node_modules/core-js/modules/es.typed-array.to-string.js
+var es_typed_array_to_string = __webpack_require__(5694);
+;// CONCATENATED MODULE: ./lib/components/mp4muxer/helpers/utils.ts
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+function b64ToUint6(nChr) {
+  return nChr > 64 && nChr < 91 ? nChr - 65 : nChr > 96 && nChr < 123 ? nChr - 71 : nChr > 47 && nChr < 58 ? nChr + 4 : nChr === 43 ? 62 : nChr === 47 ? 63 : 0;
+} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Base64_encoding_and_decoding
+
+function base64DecToArr(sBase64, nBlocksSize) {
+  var sB64Enc = sBase64.replace(/[^A-Za-z0-9+/]/g, '');
+  var nInLen = sB64Enc.length;
+  var nOutLen = nBlocksSize ? Math.ceil((nInLen * 3 + 1 >> 2) / nBlocksSize) * nBlocksSize : nInLen * 3 + 1 >> 2;
+  var taBytes = new Uint8Array(nOutLen);
+  var nMod3;
+  var nMod4;
+  var nUint24 = 0;
+  var nOutIdx = 0;
+
+  for (var nInIdx = 0; nInIdx < nInLen; nInIdx++) {
+    nMod4 = nInIdx & 3;
+    nUint24 |= b64ToUint6(sB64Enc.charCodeAt(nInIdx)) << 18 - 6 * nMod4;
+
+    if (nMod4 === 3 || nInLen - nInIdx === 1) {
+      for (nMod3 = 0; nMod3 < 3 && nOutIdx < nOutLen; nMod3++, nOutIdx++) {
+        taBytes[nOutIdx] = nUint24 >>> (16 >>> nMod3 & 24) & 255;
+      }
+
+      nUint24 = 0;
+    }
+  }
+
+  return taBytes;
+}
+// EXTERNAL MODULE: ./.yarn/unplugged/core-js-npm-3.16.2-c7ce9e8d48/node_modules/core-js/modules/es.array.includes.js
+var es_array_includes = __webpack_require__(4270);
+;// CONCATENATED MODULE: ./lib/components/mp4muxer/helpers/bufferreader.ts
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+function bufferreader_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
+
+function bufferreader_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
+
+function bufferreader_createClass(Constructor, protoProps, staticProps) { if (protoProps) bufferreader_defineProperties(Constructor.prototype, protoProps); if (staticProps) bufferreader_defineProperties(Constructor, staticProps); return Constructor; }
+
+function bufferreader_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+/**
+ * Defines functions for reading from a binary buffer. Works similair to the
+ * DataView object, but uses bitshifts instead for performance.
+ * @class BufferReader
+ * @constructor
+ * @param buffer - An ArrayBuffer to be read from.
+ */
+var BufferReader = /*#__PURE__*/function () {
+  function BufferReader(buffer) {
+    bufferreader_classCallCheck(this, BufferReader);
+
+    bufferreader_defineProperty(this, "_buffer", void 0);
+
+    bufferreader_defineProperty(this, "_dataView", void 0);
+
+    bufferreader_defineProperty(this, "_offset", void 0);
+
+    bufferreader_defineProperty(this, "_bitpos", void 0);
+
+    bufferreader_defineProperty(this, "_byte", void 0);
+
+    this._buffer = buffer;
+    this._dataView = new DataView(this._buffer);
+    this._offset = 0;
+    this._bitpos = 0;
+    this._byte = 0;
+  }
+  /**
+   * Reads 8-bit of data from the buffer.
+   * @method readUint8
+   * @param  offset - Index in the buffer.
+   * @return An unsigned 8-bit integer.
+   */
+
+
+  bufferreader_createClass(BufferReader, [{
+    key: "readUint8",
+    value: function readUint8(offset) {
+      return this._dataView.getUint8(offset);
+    }
+    /**
+     * Reads 16-bit of data from the buffer.
+     * @method readUint16
+     * @param  offset - Index in the buffer.
+     * @return An unsigned 16-bit integer.
+     */
+
+  }, {
+    key: "readUint16",
+    value: function readUint16(offset) {
+      return this._dataView.getUint16(offset);
+    }
+    /**
+     * Reads 32-bit of data from the buffer.
+     * @method readUint32
+     * @param  offset - Index in the buffer.
+     * @return An unsigned 32-bit integer.
+     */
+
+  }, {
+    key: "readUint32",
+    value: function readUint32(offset) {
+      return this._dataView.getUint32(offset);
+    }
+    /**
+     * Reads the next byte of data from the buffer and increaments the offset.
+     * @method readNext
+     * @return {Number} An unsigned 8-bit integer.
+     */
+
+  }, {
+    key: "readNext",
+    value: function readNext() {
+      var value = this.readUint8(this._offset);
+      this._offset += 1;
+      return value;
+    }
+  }, {
+    key: "readBits",
+    value: function readBits(length) {
+      if (length > 32 || length === 0) {
+        throw new Error('length has to be between 0 - 31 bits');
+      }
+
+      var result = 0;
+
+      for (var i = 1; i <= length; ++i) {
+        if (this._bitpos === 0) {
+          /* Previous byte all read out. Get a new one. */
+          this._byte = this.readNext();
+        }
+        /* Shift result one left to make room for another bit,
+        then add the next bit on the stream. */
+
+
+        result = result << 1 | this._byte >> 8 - ++this._bitpos & 0x01;
+        this._bitpos %= 8;
+      }
+
+      return result;
+    }
+  }, {
+    key: "readUnsignedExpGolomb",
+    value: function readUnsignedExpGolomb() {
+      var bitsToRead = 0;
+
+      while (this.readBits(1) !== 1) {
+        bitsToRead++;
+      }
+
+      if (bitsToRead === 0) {
+        return 0;
+        /* Easy peasy, just a single 1. This is 0 in exp golomb */
+      }
+
+      if (bitsToRead >= 31) {
+        throw new Error('read unsigned exponential Golomb: internal error');
+      }
+      /* Read all bits part of this number */
+
+
+      var n = this.readBits(bitsToRead);
+      /* Move in the 1 read by while-statement above */
+
+      n |= 0x1 << bitsToRead;
+      return n - 1;
+      /* Because result in exp golomb is one larger */
+    }
+  }, {
+    key: "readSignedExpGolomb",
+    value: function readSignedExpGolomb() {
+      var r = this.readUnsignedExpGolomb();
+
+      if (r & 0x01) {
+        r = r + 1 >> 1;
+      } else {
+        r = -(r >> 1);
+      }
+
+      return r;
+    }
+    /**
+     * Returns the size of the buffer
+     * @method readSize
+     * @return {Number} The buffer size.
+     */
+
+  }, {
+    key: "size",
+    value: function size() {
+      return this._buffer.byteLength;
+    }
+    /**
+     * Returns an instance of the buffer as an unsigned 8-bit integer array.
+     * @method getUint8Array
+     * @return {Uint8Array} Unsigned 8-bit integer representation of the buffer
+     */
+
+  }, {
+    key: "getUint8Array",
+    value: function getUint8Array() {
+      return new Uint8Array(this._buffer);
+    }
+    /**
+     * Returns the buffer object
+     * @method getArrayBuffer
+     * @return {ArrayBuffer} The buffer used the BufferReader
+     */
+
+  }, {
+    key: "getArrayBuffer",
+    value: function getArrayBuffer() {
+      return this._buffer;
+    }
+  }]);
+
+  return BufferReader;
+}();
+;// CONCATENATED MODULE: ./lib/components/mp4muxer/helpers/spsparser.ts
+
+
+function spsparser_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
+
+function spsparser_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
+
+function spsparser_createClass(Constructor, protoProps, staticProps) { if (protoProps) spsparser_defineProperties(Constructor.prototype, protoProps); if (staticProps) spsparser_defineProperties(Constructor, staticProps); return Constructor; }
+
+function spsparser_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+
+var SPSParser = /*#__PURE__*/function () {
+  function SPSParser(buffer) {
+    spsparser_classCallCheck(this, SPSParser);
+
+    spsparser_defineProperty(this, "reader", void 0);
+
+    this.reader = new BufferReader(buffer);
+  }
+
+  spsparser_createClass(SPSParser, [{
+    key: "parse",
+    value: function parse() {
+      // nalhdr
+      this.reader.readNext();
+      var profile = this.reader.readNext(); // constraints
+
+      this.reader.readNext();
+      var level = this.reader.readNext(); // seqParameterSetId
+
+      this.reader.readUnsignedExpGolomb();
+
+      if ([100, 110, 122, 244, 44, 83, 86, 118].includes(profile)) {
+        var chromaFormat = this.reader.readUnsignedExpGolomb();
+
+        if (chromaFormat === 3) {
+          // Separate color plane flag
+          this.reader.readBits(1);
+        } // bitDepthLumaMinus8
+
+
+        this.reader.readUnsignedExpGolomb(); // bitDepthChromaMinus8
+
+        this.reader.readUnsignedExpGolomb(); // qpPrimeYZeroTransformBypassFlag
+
+        this.reader.readBits(1);
+        var seqScalingMatrix = this.reader.readBits(1);
+
+        if (seqScalingMatrix) {
+          for (var k = 0; k < (chromaFormat !== 3 ? 8 : 12); k++) {
+            // seqScalingListPresentFlag
+            this.reader.readBits(1); // TODO: More logic goes here..
+          }
+        }
+      } // log2MaxFrameNumMinus4
+
+
+      this.reader.readUnsignedExpGolomb();
+      var picOrderCntType = this.reader.readUnsignedExpGolomb();
+
+      if (picOrderCntType === 0) {
+        // log2MaxPicOrderCntLsbMinus4
+        this.reader.readUnsignedExpGolomb();
+      } else if (picOrderCntType === 1) {
+        var numRefFramesInPic = 0;
+        this.reader.readBits(1);
+        this.reader.readSignedExpGolomb();
+        this.reader.readSignedExpGolomb();
+        numRefFramesInPic = this.reader.readUnsignedExpGolomb();
+
+        for (var i = 0; i < numRefFramesInPic; i++) {
+          this.reader.readSignedExpGolomb();
+        }
+      } // maxNumRefFrames
+
+
+      this.reader.readUnsignedExpGolomb(); // gapsInFrameNumValueAllowedFlag
+
+      this.reader.readBits(1);
+      var picWidthInMbsMinus1 = this.reader.readUnsignedExpGolomb();
+      var picHeightInMapUnitsMinus1 = this.reader.readUnsignedExpGolomb();
+      var picFrameMbsOnlyFlag = this.reader.readBits(1); // direct8x8InferenceFlag
+
+      this.reader.readBits(1);
+      var frameCroppingFlag = this.reader.readBits(1);
+      var frameCropLeftOffset = frameCroppingFlag ? this.reader.readUnsignedExpGolomb() : 0;
+      var frameCropRightOffset = frameCroppingFlag ? this.reader.readUnsignedExpGolomb() : 0;
+      var frameCropTopOffset = frameCroppingFlag ? this.reader.readUnsignedExpGolomb() : 0;
+      var frameCropBottomOffset = frameCroppingFlag ? this.reader.readUnsignedExpGolomb() : 0;
+      var w = (picWidthInMbsMinus1 + 1) * 16 - frameCropLeftOffset * 2 - frameCropRightOffset * 2;
+      var h = (2 - picFrameMbsOnlyFlag) * (picHeightInMapUnitsMinus1 + 1) * 16 - frameCropTopOffset * 2 - frameCropBottomOffset * 2;
+      return {
+        profile: profile,
+        level: level / 10.0,
+        width: w,
+        height: h
+      };
+    }
+  }]);
+
+  return SPSParser;
+}();
+;// CONCATENATED MODULE: ./lib/components/mp4muxer/helpers/h264Settings.ts
+
+
+
+
+
+
+
+
+
+
+
+var PROFILE_NAMES = {
+  66: 'Baseline',
+  77: 'Main',
+  100: 'High'
+};
+
+var h264EncodingName = function h264EncodingName(profileLevelId) {
+  var profileCode = parseInt(profileLevelId.substr(0, 2), 16);
+  var levelCode = parseInt(profileLevelId.substr(4, 2), 16);
+  var profile = PROFILE_NAMES[profileCode] || profileCode.toString();
+  var level = (levelCode / 10).toFixed(1);
+  return {
+    coding: 'H.264',
+    profile: profile,
+    level: level
+  };
+};
+
+var h264Settings = function h264Settings(media, date, trackId) {
+  /*
+   * Example SDP media segment for H264 audio:
+   *
+    {
+     "type": "video",
+     "port": "0",
+     "proto": "RTP/AVP",
+     "fmt": "96",
+     "connectionData": {
+       "netType": "IN",
+       "addrType": "IP4",
+       "connectionAddress": "0.0.0.0"
+     },
+     "bwtype": "AS",
+     "bandwidth": "50000",
+     "rtpmap": {
+       "payloadType": "96",
+       "encodingName": "H264",
+       "clockrate": "90000"
+     },
+     "fmtp": {
+       "format": "96",
+       "parameters": {
+         "packetization-mode": "1",
+         "profile-level-id": "4d0029",
+         "sprop-parameter-sets": "Z00AKeKQDwBE/LgLcBAQGkHiRFQ=,aO48gA=="
+       }
+     },
+     "control": "rtsp://hostname/axis-media/media.amp/stream=0?audio=1",
+     "framerate": "25.000000",
+     "transform": [[1,0,0],[0,1,0],[0,0,1]]
+   },
+    */
+  var profileLevelId = media.fmtp.parameters['profile-level-id'];
+  var parameterSets = media.fmtp.parameters['sprop-parameter-sets'].split(',').map(base64DecToArr); // We assume the first set is _the_ SPS (no support for multiple).
+
+  var sps = parameterSets.slice(0, 1); // The remaining sets are all PPS to support more than one.
+
+  var pps = parameterSets.slice(1);
+  var parsedSps = new SPSParser(sps[0].buffer).parse(); // If media framerate is missing in SDP, it is not possible to calculate
+  // the frame duration. Use a fallback value (90000 Hz / 25 fps)
+
+  var FALLBACK_FRAME_DURATION = 3600;
+  return {
+    mediaHeaderBox: new Box('vmhd'),
+    sampleEntryBox: new Container('avc1', {
+      width: parsedSps.width,
+      height: parsedSps.height
+    }, new Box('avcC', {
+      AVCProfileIndication: sps[0][1],
+      profile_compatibility: sps[0][2],
+      AVCLevelIndication: sps[0][3],
+      sequenceParameterSets: sps,
+      pictureParameterSets: pps
+    })),
+    tkhd: {
+      track_ID: trackId,
+      creation_time: date,
+      modification_time: date,
+      width: parsedSps.width << 16,
+      height: parsedSps.height << 16,
+      volume: 0
+    },
+    hdlr: {},
+    mdhd: {
+      timescale: media.rtpmap.clockrate,
+      creation_time: date,
+      modification_time: date,
+      duration: 0
+    },
+    // (ticks / s) / (frames / s) = ticks / frame, e.g. frame duration in ticks
+    defaultFrameDuration: media.framerate !== undefined && media.framerate > 0 ? Number(media.rtpmap.clockrate) / Number(media.framerate) || FALLBACK_FRAME_DURATION : FALLBACK_FRAME_DURATION,
+    // MIME type
+    mime: "avc1.".concat(profileLevelId),
+    codec: h264EncodingName(profileLevelId)
+  };
+};
+;// CONCATENATED MODULE: ./lib/components/mp4muxer/helpers/boxbuilder.ts
+
+
+
+function boxbuilder_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
+
+function boxbuilder_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
+
+function boxbuilder_createClass(Constructor, protoProps, staticProps) { if (protoProps) boxbuilder_defineProperties(Constructor.prototype, protoProps); if (staticProps) boxbuilder_defineProperties(Constructor, staticProps); return Constructor; }
+
+function boxbuilder_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+
+
+
+var formatDefaults = {
+  'MPEG4-GENERIC': aacSettings,
+  H264: h264Settings
+};
+
+var createTrackData = function createTrackData() {
+  return {
+    lastTimestamp: 0,
+    baseMediaDecodeTime: 0,
+    defaultFrameDuration: 0,
+    clockrate: 0,
+    bitrate: 0,
+    framerate: 0,
+    cumulativeByteLength: 0,
+    cumulativeDuration: 0,
+    cumulativeFrames: 0
+  };
+};
+
+var updateRateInfo = function updateRateInfo(trackData, _ref) {
+  var byteLength = _ref.byteLength,
+      duration = _ref.duration;
+  trackData.cumulativeByteLength += byteLength;
+  trackData.cumulativeDuration += duration;
+  trackData.cumulativeFrames++; // Update the cumulative number size (bytes) and duration (ticks), and if
+  // the duration exceeds the clockrate (meaning longer than 1 second of data),
+  // then compute a new bitrate and reset cumulative size and duration.
+
+  if (trackData.cumulativeDuration >= trackData.clockrate) {
+    var bits = 8 * trackData.cumulativeByteLength;
+    var frames = trackData.cumulativeFrames;
+    var seconds = trackData.cumulativeDuration / trackData.clockrate;
+    trackData.bitrate = bits / seconds;
+    trackData.framerate = frames / seconds;
+    trackData.cumulativeByteLength = 0;
+    trackData.cumulativeDuration = 0;
+    trackData.cumulativeFrames = 0;
+  }
+};
+/**
+ * Create boxes for a stream initiated by an sdp object
+ *
+ * @class BoxBuilder
+ */
+
+
+var BoxBuilder = /*#__PURE__*/function () {
+  function BoxBuilder() {
+    boxbuilder_classCallCheck(this, BoxBuilder);
+
+    boxbuilder_defineProperty(this, "trackIdMap", void 0);
+
+    boxbuilder_defineProperty(this, "sequenceNumber", void 0);
+
+    boxbuilder_defineProperty(this, "ntpPresentationTime", void 0);
+
+    boxbuilder_defineProperty(this, "trackData", void 0);
+
+    boxbuilder_defineProperty(this, "videoTrackId", void 0);
+
+    this.trackIdMap = {};
+    this.sequenceNumber = 0;
+    this.ntpPresentationTime = 0;
+    this.trackData = [];
+  }
+
+  boxbuilder_createClass(BoxBuilder, [{
+    key: "trak",
+    value: function trak(settings) {
+      var trak = new Container('trak');
+      var mdia = new Container('mdia');
+      var minf = new Container('minf');
+      var dinf = new Container('dinf');
+      var dref = new Container('dref');
+      var stbl = new Container('stbl');
+      dref.set('entry_count', 1);
+      trak.append(new Box('tkhd', settings.tkhd), mdia.append(new Box('mdhd', settings.mdhd), new Box('hdlr', settings.hdlr), minf.append(settings.mediaHeaderBox, // vmhd or smhd box (video or sound)
+      dinf.append(dref.append(new Box('url '))), stbl.append(new Container('stsd', undefined, settings.sampleEntryBox), new Box('stts'), new Box('stsc'), new Box('stco'), new Box('stsz'), new Box('stss')))));
+      return trak;
+    }
+    /**
+     * Creates a Moov box from the provided options.
+     * @method moov
+     * @param  sdp - The session description protocol
+     * @param  date - The creation/modification time of the movie
+     * @return Moov object
+     */
+
+  }, {
+    key: "moov",
+    value: function moov(sdp, date) {
+      var _this = this;
+
+      var moov = new Container('moov');
+      moov.append(new Box('mvhd', {
+        creation_time: date,
+        modification_time: date,
+        duration: 0
+      }));
+      var mvex = new Container('mvex'); // For each of the media segments in the SDP structure, we will set up
+      // a track in the MP4 file. For each track, a 'trak' box is added to the
+      // 'moov' box and a 'trex' box is added to the 'mvex' box.
+
+      this.trackIdMap = {};
+      this.sequenceNumber = 0;
+      this.ntpPresentationTime = 0;
+      var trackId = 0;
+      this.trackData = [];
+      sdp.media.forEach(function (media) {
+        if (media.rtpmap === undefined) {
+          return;
+        }
+
+        var payloadType = media.rtpmap.payloadType;
+        var encoding = media.rtpmap.encodingName;
+        console.log("encoding ".concat(encoding, ", payloadType: ").concat(payloadType, ", format: ").concat(formatDefaults[encoding]));
+
+        if (formatDefaults[encoding] !== undefined) {
+          // We know how to handle this encoding, add a new track for it, and
+          // register the track for this payloadType.
+          _this.trackIdMap[payloadType] = ++trackId; // Mark the video track
+
+          if (media.type.toLowerCase() === 'video') {
+            _this.videoTrackId = trackId;
+          } // Extract the settings from the SDP media information based on
+          // the encoding name (H264, MPEG4-GENERIC, ...).
+
+
+          var settings = formatDefaults[encoding](media, date, trackId);
+          media.mime = settings.mime; // add MIME type to the SDP media
+
+          media.codec = settings.codec; // add human readable codec string to the SDP media
+
+          var trackData = createTrackData();
+          trackData.clockrate = media.rtpmap.clockrate; // Set default frame duration (in ticks) for later use
+
+          trackData.defaultFrameDuration = settings.defaultFrameDuration;
+
+          _this.trackData.push(trackData);
+
+          var trak = _this.trak(settings);
+
+          moov.append(trak);
+          mvex.append(new Box('trex', {
+            track_ID: trackId
+          }));
+        }
+      });
+      moov.append(mvex);
+      return moov;
+    }
+    /**
+     * Boxes that carry actual elementary stream fragment metadata + data.
+     */
+
+    /**
+     * Creates a moof box from the provided fragment metadata.
+     * @method moof
+     * @param  metadata - Track ID, timestamp, bytelength
+     * @return moof Container
+     */
+
+  }, {
+    key: "moof",
+    value: function moof(metadata) {
+      var trackId = metadata.trackId,
+          timestamp = metadata.timestamp,
+          byteLength = metadata.byteLength;
+      var trackOffset = trackId - 1;
+      var trackData = this.trackData[trackOffset]; // The RTP timestamps are unsigned 32 bit and will overflow
+      // at some point. We can guard against the overflow by ORing with 0,
+      // which will bring any difference back into signed 32-bit domain.
+
+      var _duration = trackData.lastTimestamp !== 0 ? timestamp - trackData.lastTimestamp | 0 : trackData.defaultFrameDuration; // if (_duration < 0) {
+      //   console.log(`MOOF duration ${_duration}, ts: ${trackData.lastTimestamp} -> ${timestamp}, default: ${trackData.defaultFrameDuration}`);
+      // }
+
+
+      var duration = _duration > 0 ? _duration : trackData.defaultFrameDuration;
+      trackData.lastTimestamp = _duration > 0 ? timestamp : trackData.lastTimestamp + duration;
+      var moof = new Container('moof');
+      var traf = new Container('traf');
+      var trun = new Box('trun', {
+        sample_duration: duration,
+        sample_size: byteLength,
+        first_sample_flags: 0x40
+      });
+      moof.append(new Box('mfhd', {
+        sequence_number: this.sequenceNumber++
+      }), traf.append(new Box('tfhd', {
+        track_ID: trackId
+      }), new Box('tfdt', {
+        baseMediaDecodeTime: trackData.baseMediaDecodeTime
+      }), trun));
+      trackData.baseMediaDecodeTime += duration; // Correct the trun data offset
+
+      trun.set('data_offset', moof.byteLength + 8);
+      updateRateInfo(trackData, {
+        byteLength: byteLength,
+        duration: duration
+      });
+      return moof;
+    }
+    /**
+     * Creates an mdat box containing the elementary stream data.
+     * @param  data - Elementary stream data
+     * @return mdat Box
+     */
+
+  }, {
+    key: "mdat",
+    value: function mdat(data) {
+      var box = new Box('mdat');
+      box.add('data', data);
+      return box;
+    }
+  }, {
+    key: "setPresentationTime",
+    value: function setPresentationTime(trackId, ntpTimestamp) {
+      // Before updating the baseMediaDecodeTime, we check if
+      // there is already a base NTP time to use as a reference
+      // for computing presentation times.
+      if (!this.ntpPresentationTime && ntpTimestamp && trackId === this.videoTrackId) {
+        var trackOffset = trackId - 1;
+        var trackData = this.trackData[trackOffset];
+        this.ntpPresentationTime = ntpTimestamp - 1000 * (trackData.baseMediaDecodeTime / trackData.clockrate);
+      }
+    }
+  }]);
+
+  return BoxBuilder;
+}();
+;// CONCATENATED MODULE: ./lib/components/mp4muxer/index.ts
+/* provided dependency */ var mp4muxer_Buffer = __webpack_require__(7866)["Buffer"];
+function mp4muxer_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { mp4muxer_typeof = function _typeof(obj) { return typeof obj; }; } else { mp4muxer_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return mp4muxer_typeof(obj); }
+
+
+
+
+
+
+
+
+
+
+
+
+
+function mp4muxer_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
+
+function mp4muxer_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
+
+function mp4muxer_createClass(Constructor, protoProps, staticProps) { if (protoProps) mp4muxer_defineProperties(Constructor.prototype, protoProps); if (staticProps) mp4muxer_defineProperties(Constructor, staticProps); return Constructor; }
+
+function mp4muxer_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) mp4muxer_setPrototypeOf(subClass, superClass); }
+
+function mp4muxer_setPrototypeOf(o, p) { mp4muxer_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return mp4muxer_setPrototypeOf(o, p); }
+
+function mp4muxer_createSuper(Derived) { var hasNativeReflectConstruct = mp4muxer_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = mp4muxer_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = mp4muxer_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return mp4muxer_possibleConstructorReturn(this, result); }; }
+
+function mp4muxer_possibleConstructorReturn(self, call) { if (call && (mp4muxer_typeof(call) === "object" || typeof call === "function")) { return call; } return mp4muxer_assertThisInitialized(self); }
+
+function mp4muxer_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
+
+function mp4muxer_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
+
+function mp4muxer_getPrototypeOf(o) { mp4muxer_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return mp4muxer_getPrototypeOf(o); }
+
+function mp4muxer_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+
+
+
+
+
+
+
+/**
+ * Component that converts elementary stream data into MP4 boxes honouring
+ * the ISO BMFF Byte Stream (Some extra restrictions are involved).
+ */
+
+var Mp4Muxer = /*#__PURE__*/function (_Tube) {
+  mp4muxer_inherits(Mp4Muxer, _Tube);
+
+  var _super = mp4muxer_createSuper(Mp4Muxer);
+
+  /**
+   * Create a new mp4muxer component.
+   * @return {undefined}
+   */
+  function Mp4Muxer() {
+    var _this;
+
+    mp4muxer_classCallCheck(this, Mp4Muxer);
+
+    var boxBuilder = new BoxBuilder();
+
+    var onSync = function onSync(ntpPresentationTime) {
+      _this.onSync && _this.onSync(ntpPresentationTime);
+    };
+
+    var incoming = new stream_browserify.Transform({
+      objectMode: true,
+      transform: function transform(msg, encoding, callback) {
+        if (msg.type === MessageType.SDP) {
+          /**
+           * Arrival of SDP signals the beginning of a new movie.
+           * Set up the ftyp and moov boxes.
+           */
+          // Why is this here? These should be default inside the mvhd box?
+          var now = Math.floor(new Date().getTime() / 1000 + 2082852000);
+          var ftyp = new Box('ftyp');
+          var moov = boxBuilder.moov(msg.sdp, now);
+          var data = mp4muxer_Buffer.allocUnsafe(ftyp.byteLength + moov.byteLength);
+          ftyp.copy(data, 0);
+          moov.copy(data, ftyp.byteLength);
+          browser_default()('msl:mp4:isom')("ftyp: ".concat(ftyp.format()));
+          browser_default()('msl:mp4:isom')("moov: ".concat(moov.format())); // Set up a list of tracks that contain info about
+          // the type of media, encoding, and codec are present.
+
+          var tracks = msg.sdp.media.map(function (media) {
+            return {
+              type: media.type,
+              encoding: media.rtpmap && media.rtpmap.encodingName,
+              mime: media.mime,
+              codec: media.codec
+            };
+          });
+          this.push({
+            type: MessageType.ISOM,
+            data: data,
+            tracks: tracks,
+            ftyp: ftyp,
+            moov: moov
+          });
+        } else if (msg.type === MessageType.ELEMENTARY || msg.type === MessageType.H264) {
+          /**
+           * Otherwise we are getting some elementary stream data.
+           * Set up the moof and mdat boxes.
+           */
+          var payloadType = msg.payloadType,
+              timestamp = msg.timestamp,
+              ntpTimestamp = msg.ntpTimestamp;
+          var trackId = boxBuilder.trackIdMap[payloadType];
+
+          if (trackId) {
+            if (!boxBuilder.ntpPresentationTime) {
+              boxBuilder.setPresentationTime(trackId, ntpTimestamp);
+
+              if (boxBuilder.ntpPresentationTime) {
+                onSync(boxBuilder.ntpPresentationTime);
+              }
+            }
+
+            var checkpointTime;
+            var idrPicture = msg.type === MessageType.H264 ? msg.nalType === NAL_TYPES.IDR_PICTURE : undefined;
+
+            if (boxBuilder.ntpPresentationTime && idrPicture && msg.ntpTimestamp !== undefined) {
+              checkpointTime = (msg.ntpTimestamp - boxBuilder.ntpPresentationTime) / 1000;
+            }
+
+            var byteLength = msg.data.byteLength;
+            var moof = boxBuilder.moof({
+              trackId: trackId,
+              timestamp: timestamp,
+              byteLength: byteLength
+            });
+            var mdat = boxBuilder.mdat(msg.data);
+
+            var _data = mp4muxer_Buffer.allocUnsafe(moof.byteLength + mdat.byteLength);
+
+            moof.copy(_data, 0);
+            mdat.copy(_data, moof.byteLength);
+            this.push({
+              type: MessageType.ISOM,
+              data: _data,
+              moof: moof,
+              mdat: mdat,
+              ntpTimestamp: ntpTimestamp,
+              checkpointTime: checkpointTime
+            });
+          }
+        } else {
+          // No message type we recognize, pass it on.
+          this.push(msg);
+        }
+
+        callback();
+      }
+    });
+    _this = _super.call(this, incoming);
+
+    mp4muxer_defineProperty(mp4muxer_assertThisInitialized(_this), "boxBuilder", void 0);
+
+    mp4muxer_defineProperty(mp4muxer_assertThisInitialized(_this), "onSync", void 0);
+
+    _this.boxBuilder = boxBuilder;
+    return _this;
+  }
+
+  mp4muxer_createClass(Mp4Muxer, [{
+    key: "bitrate",
+    get: function get() {
+      return this.boxBuilder.trackData && this.boxBuilder.trackData.map(function (data) {
+        return data.bitrate;
+      });
+    }
+  }, {
+    key: "framerate",
+    get: function get() {
+      return this.boxBuilder.trackData && this.boxBuilder.trackData.map(function (data) {
+        return data.framerate;
+      });
+    }
+  }, {
+    key: "ntpPresentationTime",
+    get: function get() {
+      return this.boxBuilder.ntpPresentationTime;
+    }
+  }]);
+
+  return Mp4Muxer;
+}(Tube);
+// EXTERNAL MODULE: ./.yarn/cache/regenerator-runtime-npm-0.13.9-6d02340eec-65ed455fe5.zip/node_modules/regenerator-runtime/runtime.js
+var runtime = __webpack_require__(9210);
+;// CONCATENATED MODULE: ./lib/utils/protocols/rtcp.ts
+
+
+
+
+
+
+
+
+
+
+function rtcp_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }
+
+function rtcp_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { rtcp_ownKeys(Object(source), true).forEach(function (key) { rtcp_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { rtcp_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
+
+function rtcp_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+
+ // Real Time Control Protocol (RTCP)
+// https://tools.ietf.org/html/rfc3550#section-6
+
+/*
+Common RTCP packed header:
+
+        0                   1                   2                   3
+        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+header |V=2|P|    RC   |   PT=SR=200   |             length            |
+       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+*/
+
+var RTCPPacketType;
+
+(function (RTCPPacketType) {
+  RTCPPacketType[RTCPPacketType["SR"] = 200] = "SR";
+  RTCPPacketType[RTCPPacketType["RR"] = 201] = "RR";
+  RTCPPacketType[RTCPPacketType["SDES"] = 202] = "SDES";
+  RTCPPacketType[RTCPPacketType["BYE"] = 203] = "BYE";
+  RTCPPacketType[RTCPPacketType["APP"] = 204] = "APP";
+})(RTCPPacketType || (RTCPPacketType = {}));
+
+var parseBase = function parseBase(buffer) {
+  return {
+    version: buffer[0] >>> 6,
+    padding: !!(buffer[0] & POS[2]),
+    count: buffer[0] & 0x1f,
+    packetType: buffer.readUInt8(1),
+    length: buffer.readUInt16BE(2)
+  };
+};
+
+var parseRtcp = function parseRtcp(buffer) {
+  var base = parseBase(buffer);
+
+  switch (base.packetType) {
+    case RTCPPacketType.SR:
+      return parseSR(buffer, base);
+
+    case RTCPPacketType.RR:
+      return parseRR(buffer, base);
+
+    case RTCPPacketType.SDES:
+      return parseSDES(buffer, base);
+
+    case RTCPPacketType.BYE:
+      return parseBYE(buffer, base);
+
+    case RTCPPacketType.APP:
+      return parseAPP(buffer, base);
+
+    default:
+      return base;
+  }
+};
+var rtcpMessageFromBuffer = function rtcpMessageFromBuffer(channel, buffer) {
+  return {
+    type: MessageType.RTCP,
+    data: buffer,
+    channel: channel,
+    rtcp: parseRtcp(buffer)
+  };
+};
+/*
+SR: Sender Report RTCP Packet
+
+        0                   1                   2                   3
+        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+header |V=2|P|    RC   |   PT=SR=200   |             length            |
+       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+       |                         SSRC of sender                        |
+       +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
+sender |              NTP timestamp, most significant word             |
+info   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+       |             NTP timestamp, least significant word             |
+       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+       |                         RTP timestamp                         |
+       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+       |                     sender's packet count                     |
+       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+       |                      sender's octet count                     |
+       +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
+report |                 SSRC_1 (SSRC of first source)                 |
+block  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  1    | fraction lost |       cumulative number of packets lost       |
+       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+       |           extended highest sequence number received           |
+       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+       |                      interarrival jitter                      |
+       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+       |                         last SR (LSR)                         |
+       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+       |                   delay since last SR (DLSR)                  |
+       +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
+report |                 SSRC_2 (SSRC of second source)                |
+block  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  2    :                               ...                             :
+       +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
+       |                  profile-specific extensions                  |
+       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+*/
+
+var SR = {
+  packetType: 200
+};
+
+var parseReportBlocks = function parseReportBlocks(count, buffer, offset) {
+  var reports = [];
+
+  for (var reportNumber = 0; reportNumber < count; reportNumber++) {
+    var o = offset + reportNumber * 24;
+    reports.push({
+      syncSource: buffer.readUInt32BE(o + 0),
+      fractionLost: buffer.readUInt8(o + 4),
+      cumulativeNumberOfPacketsLost: buffer.readUIntBE(o + 5, 3),
+      extendedHighestSequenceNumberReceived: buffer.readUInt32BE(o + 8),
+      interarrivalJitter: buffer.readUInt32BE(o + 12),
+      lastSRTimestamp: buffer.readUInt32BE(o + 16),
+      delaySinceLastSR: buffer.readUInt32BE(o + 20)
+    });
+  }
+
+  return reports;
+};
+
+var parseSR = function parseSR(buffer, base) {
+  return rtcp_objectSpread(rtcp_objectSpread({}, base), {}, {
+    syncSource: buffer.readUInt32BE(4),
+    ntpMost: buffer.readUInt32BE(8),
+    ntpLeast: buffer.readUInt32BE(12),
+    rtpTimestamp: buffer.readUInt32BE(16),
+    sendersPacketCount: buffer.readUInt32BE(20),
+    sendersOctetCount: buffer.readUInt32BE(24),
+    reports: parseReportBlocks(base.count, buffer, 28)
+  });
+};
+
+var isRtcpSR = function isRtcpSR(rtcp) {
+  return rtcp.packetType === RTCPPacketType.SR;
+};
+/*
+RR: Receiver Report RTCP Packet
+
+        0                   1                   2                   3
+        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+header |V=2|P|    RC   |   PT=RR=201   |             length            |
+       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+       |                     SSRC of packet sender                     |
+       +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
+report |                 SSRC_1 (SSRC of first source)                 |
+block  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  1    | fraction lost |       cumulative number of packets lost       |
+       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+       |           extended highest sequence number received           |
+       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+       |                      interarrival jitter                      |
+       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+       |                         last SR (LSR)                         |
+       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+       |                   delay since last SR (DLSR)                  |
+       +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
+report |                 SSRC_2 (SSRC of second source)                |
+block  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  2    :                               ...                             :
+       +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
+       |                  profile-specific extensions                  |
+       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+*/
+
+var parseRR = function parseRR(buffer, base) {
+  return rtcp_objectSpread(rtcp_objectSpread({}, base), {}, {
+    syncSource: buffer.readUInt32BE(4),
+    reports: parseReportBlocks(base.count, buffer, 8)
+  });
+};
+
+var isRtcpRR = function isRtcpRR(rtcp) {
+  return rtcp.packetType === RTCPPacketType.RR;
+};
+/*
+SDES: Source Description RTCP Packet
+
+        0                   1                   2                   3
+        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+header |V=2|P|    SC   |  PT=SDES=202  |             length            |
+       +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
+chunk  |                          SSRC/CSRC_1                          |
+  1    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+       |                           SDES items                          |
+       |                              ...                              |
+       +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
+chunk  |                          SSRC/CSRC_2                          |
+  2    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+       |                           SDES items                          |
+       |                              ...                              |
+       +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
+*/
+
+var SDESItem;
+
+(function (SDESItem) {
+  SDESItem[SDESItem["CNAME"] = 1] = "CNAME";
+  SDESItem[SDESItem["NAME"] = 2] = "NAME";
+  SDESItem[SDESItem["EMAIL"] = 3] = "EMAIL";
+  SDESItem[SDESItem["PHONE"] = 4] = "PHONE";
+  SDESItem[SDESItem["LOC"] = 5] = "LOC";
+  SDESItem[SDESItem["TOOL"] = 6] = "TOOL";
+  SDESItem[SDESItem["NOTE"] = 7] = "NOTE";
+  SDESItem[SDESItem["PRIV"] = 8] = "PRIV";
+})(SDESItem || (SDESItem = {}));
+
+var parseSDES = function parseSDES(buffer, base) {
+  var sourceDescriptions = [];
+  var offset = 4;
+
+  for (var block = 0; block < base.count; block++) {
+    var chunk = {
+      source: buffer.readUInt32BE(offset),
+      items: []
+    };
+    offset += 4;
+
+    while (true) {
+      var itemType = buffer.readUInt8(offset++);
+
+      if (itemType === 0) {
+        // start next block at word boundary
+        if (offset % 4 !== 0) {
+          offset += 4 - offset % 4;
+        }
+
+        break;
+      }
+
+      var length = buffer.readUInt8(offset++);
+
+      if (itemType === SDESItem.PRIV) {
+        var prefixLength = buffer.readUInt8(offset);
+        var prefix = buffer.toString('utf8', offset + 1, offset + 1 + prefixLength);
+        var value = buffer.toString('utf8', offset + 1 + prefixLength, offset + length);
+        chunk.items.push([SDESItem.PRIV, prefix, value]);
+      } else {
+        var _value = buffer.toString('utf8', offset, offset + length);
+
+        chunk.items.push([itemType, _value]);
+      }
+
+      offset += length;
+    }
+
+    sourceDescriptions.push(chunk);
+  }
+
+  return rtcp_objectSpread(rtcp_objectSpread({}, base), {}, {
+    syncSource: buffer.readUInt32BE(4),
+    sourceDescriptions: sourceDescriptions
+  });
+};
+
+var isRtcpSDES = function isRtcpSDES(rtcp) {
+  return rtcp.packetType === RTCPPacketType.SDES;
+};
+/*
+BYE: Goodbye RTCP Packet
+
+       0                   1                   2                   3
+       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+      |V=2|P|    SC   |   PT=BYE=203  |             length            |
+      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+      |                           SSRC/CSRC                           |
+      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+      :                              ...                              :
+      +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
+(opt) |     length    |               reason for leaving            ...
+      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+*/
+
+var parseBYE = function parseBYE(buffer, base) {
+  var sources = [];
+
+  for (var block = 0; block < base.count; block++) {
+    sources.push(buffer.readUInt32BE(4 + 4 * block));
+  }
+
+  var reason;
+
+  if (base.length > base.count) {
+    var start = 4 + 4 * base.count;
+    var length = buffer.readUInt8(start);
+    reason = buffer.toString('utf-8', start + 1, start + 1 + length);
+  }
+
+  return rtcp_objectSpread(rtcp_objectSpread({}, base), {}, {
+    sources: sources,
+    reason: reason
+  });
+};
+
+var isRtcpBye = function isRtcpBye(rtcp) {
+  return rtcp.packetType === RTCPPacketType.BYE;
+};
+/*
+APP: Application-Defined RTCP Packet
+
+    0                   1                   2                   3
+    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+   |V=2|P| subtype |   PT=APP=204  |             length            |
+   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+   |                           SSRC/CSRC                           |
+   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+   |                          name (ASCII)                         |
+   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+   |                   application-dependent data                ...
+   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+
+*/
+
+var parseAPP = function parseAPP(buffer, base) {
+  return rtcp_objectSpread(rtcp_objectSpread({}, base), {}, {
+    subtype: base.count,
+    source: buffer.readUInt32BE(4),
+    name: buffer.toString('ascii', 8, 12),
+    data: buffer.slice(12)
+  });
+};
+
+var isRtcpApp = function isRtcpApp(rtcp) {
+  return rtcp.packetType === RTCPPacketType.APP;
+};
+;// CONCATENATED MODULE: ./lib/components/mse/index.ts
+function mse_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { mse_typeof = function _typeof(obj) { return typeof obj; }; } else { mse_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return mse_typeof(obj); }
+
+
+
+function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
+
+function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+function mse_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
+
+function mse_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
+
+function mse_createClass(Constructor, protoProps, staticProps) { if (protoProps) mse_defineProperties(Constructor.prototype, protoProps); if (staticProps) mse_defineProperties(Constructor, staticProps); return Constructor; }
+
+function mse_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) mse_setPrototypeOf(subClass, superClass); }
+
+function mse_setPrototypeOf(o, p) { mse_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return mse_setPrototypeOf(o, p); }
+
+function mse_createSuper(Derived) { var hasNativeReflectConstruct = mse_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = mse_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = mse_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return mse_possibleConstructorReturn(this, result); }; }
+
+function mse_possibleConstructorReturn(self, call) { if (call && (mse_typeof(call) === "object" || typeof call === "function")) { return call; } return mse_assertThisInitialized(self); }
+
+function mse_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
+
+function mse_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
+
+function mse_getPrototypeOf(o) { mse_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return mse_getPrototypeOf(o); }
+
+function mse_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+
+
+
+
+
+var TRIGGER_THRESHOLD = 100;
+var mse_debug = browser_default()('msl:mse');
+var MseSink = /*#__PURE__*/function (_Sink) {
+  mse_inherits(MseSink, _Sink);
+
+  var _super = mse_createSuper(MseSink);
+
+  /**
+   * Create a Media component.
+   *
+   * The constructor sets up two streams and connects them to the MediaSource.
+   *
+   * @param el - A video element to connect the media source to
+   */
+  function MseSink(el) {
+    var _this;
+
+    mse_classCallCheck(this, MseSink);
+
+    if (el === undefined) {
+      throw new Error('video element argument missing');
+    }
+
+    var mse;
+    var sourceBuffer;
+    /**
+     * Set up an incoming stream and attach it to the sourceBuffer.
+     */
+
+    var incoming = new stream_browserify.Writable({
+      objectMode: true,
+      write: function write(msg, _, callback) {
+        if (msg.type === MessageType.ISOM) {
+          // ISO BMFF Byte Stream data to be added to the source buffer
+          _this._done = callback;
+
+          if (msg.tracks !== undefined || msg.mime !== undefined) {
+            var _msg$tracks, _msg$mime;
+
+            var _tracks = (_msg$tracks = msg.tracks) !== null && _msg$tracks !== void 0 ? _msg$tracks : []; // MIME codecs: https://tools.ietf.org/html/rfc6381
+
+
+            var mimeCodecs = _tracks.map(function (track) {
+              return track.mime;
+            }).filter(function (mime) {
+              return mime;
+            });
+
+            var codecs = mimeCodecs.length !== 0 ? mimeCodecs.join(', ') : 'avc1.640029, mp4a.40.2'; // Take MIME type directly from the message, or constructed
+            // from the tracks (with a default fallback to basic H.264).
+
+            var mimeType = (_msg$mime = msg.mime) !== null && _msg$mime !== void 0 ? _msg$mime : "video/mp4; codecs=\"".concat(codecs, "\"");
+
+            if (!MediaSource.isTypeSupported(mimeType)) {
+              incoming.emit('error', "unsupported media type: ".concat(mimeType));
+              return;
+            } // Start a new movie (new SDP info available)
+
+
+            _this._lastCheckpointTime = 0; // Start a new mediaSource and prepare it with a sourceBuffer.
+            // When ready, this component's .onSourceOpen callback will be called
+            // with the mediaSource, and a list of valid/ignored media.
+
+            mse = new MediaSource();
+            el.src = window.URL.createObjectURL(mse);
+
+            var handler = function handler() {
+              if (mse === undefined) {
+                incoming.emit('error', 'no MediaSource instance');
+                return;
+              } // revoke the object URL to avoid a memory leak
+
+
+              window.URL.revokeObjectURL(el.src);
+              mse.removeEventListener('sourceopen', handler);
+              _this.onSourceOpen && _this.onSourceOpen(mse, _tracks);
+              sourceBuffer = _this.addSourceBuffer(el, mse, mimeType);
+
+              sourceBuffer.onerror = function (e) {
+                console.error('error on SourceBuffer: ', e);
+                incoming.emit('error');
+              };
+
+              try {
+                sourceBuffer.appendBuffer(msg.data);
+              } catch (err) {
+                mse_debug('failed to append to SourceBuffer: ', err, msg);
+              }
+            };
+
+            mse.addEventListener('sourceopen', handler);
+          } else {
+            // Continue current movie
+            _this._lastCheckpointTime = msg.checkpointTime !== undefined ? msg.checkpointTime : _this._lastCheckpointTime;
+
+            try {
+              var _sourceBuffer;
+
+              (_sourceBuffer = sourceBuffer) === null || _sourceBuffer === void 0 ? void 0 : _sourceBuffer.appendBuffer(msg.data);
+            } catch (e) {
+              mse_debug('failed to append to SourceBuffer: ', e, msg);
+            }
+          }
+        } else if (msg.type === MessageType.RTCP) {
+          if (isRtcpBye(msg.rtcp)) {
+            var _mse;
+
+            ((_mse = mse) === null || _mse === void 0 ? void 0 : _mse.readyState) === 'open' && mse.endOfStream();
+          }
+
+          callback();
+        } else {
+          callback();
+        }
+      }
+    });
+    incoming.on('finish', function () {
+      console.warn('incoming stream finished: end stream');
+      mse && mse.readyState === 'open' && mse.endOfStream();
+    }); // When an error is sent on the incoming stream, close it.
+
+    incoming.on('error', function (msg) {
+      console.error('error on incoming stream: ', msg);
+
+      if (sourceBuffer && sourceBuffer.updating) {
+        sourceBuffer.addEventListener('updateend', function () {
+          var _mse2;
+
+          ((_mse2 = mse) === null || _mse2 === void 0 ? void 0 : _mse2.readyState) === 'open' && mse.endOfStream();
+        });
+      } else {
+        var _mse3;
+
+        ((_mse3 = mse) === null || _mse3 === void 0 ? void 0 : _mse3.readyState) === 'open' && mse.endOfStream();
+      }
+    });
+    /**
+     * Set up outgoing stream.
+     */
+
+    var outgoing = new stream_browserify.Readable({
+      objectMode: true,
+      read: function read() {//
+      }
+    }); // When an error is sent on the outgoing stream, whine about it.
+
+    outgoing.on('error', function () {
+      console.warn('outgoing stream broke somewhere');
+    });
+    /**
+     * initialize the component.
+     */
+
+    _this = _super.call(this, incoming, outgoing);
+
+    mse_defineProperty(mse_assertThisInitialized(_this), "_videoEl", void 0);
+
+    mse_defineProperty(mse_assertThisInitialized(_this), "_done", void 0);
+
+    mse_defineProperty(mse_assertThisInitialized(_this), "_lastCheckpointTime", void 0);
+
+    mse_defineProperty(mse_assertThisInitialized(_this), "onSourceOpen", void 0);
+
+    _this._videoEl = el;
+    _this._lastCheckpointTime = 0;
+    return _this;
+  }
+  /**
+   * Add a new sourceBuffer to the mediaSource and remove old ones.
+   * @param el - The media element holding the media source.
+   * @param mse - The media source the buffer should be attached to.
+   * @param mimeType - MIME type and codecs, e.g.: 'video/mp4; codecs="avc1.4D0029, mp4a.40.2"'
+   */
+
+
+  mse_createClass(MseSink, [{
+    key: "addSourceBuffer",
+    value: function addSourceBuffer(el, mse, mimeType) {
+      var _this2 = this;
+
+      var sourceBuffer = mse.addSourceBuffer(mimeType);
+      var trigger = 0;
+
+      var onUpdateEndHandler = function onUpdateEndHandler() {
+        ++trigger;
+
+        if (trigger > TRIGGER_THRESHOLD && sourceBuffer.buffered.length) {
+          trigger = 0;
+          var index = sourceBuffer.buffered.length - 1;
+          var start = sourceBuffer.buffered.start(index);
+          var end = Math.min(el.currentTime, _this2._lastCheckpointTime) - 10;
+
+          try {
+            // remove all material up to 10 seconds before current time
+            if (end > start) {
+              sourceBuffer.remove(start, end);
+              return; // this._done() will be called on the next updateend event!
+            }
+          } catch (e) {
+            console.warn(e);
+          }
+        }
+
+        _this2._done && _this2._done();
+      };
+
+      sourceBuffer.addEventListener('updateend', onUpdateEndHandler);
+      return sourceBuffer;
+    }
+  }, {
+    key: "currentTime",
+    get: function get() {
+      return this._videoEl.currentTime;
+    }
+  }, {
+    key: "play",
+    value: function () {
+      var _play = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
+        return regeneratorRuntime.wrap(function _callee$(_context) {
+          while (1) {
+            switch (_context.prev = _context.next) {
+              case 0:
+                _context.next = 2;
+                return this._videoEl.play();
+
+              case 2:
+                return _context.abrupt("return", _context.sent);
+
+              case 3:
+              case "end":
+                return _context.stop();
+            }
+          }
+        }, _callee, this);
+      }));
+
+      function play() {
+        return _play.apply(this, arguments);
+      }
+
+      return play;
+    }()
+  }, {
+    key: "pause",
+    value: function pause() {
+      return this._videoEl.pause();
+    }
+  }]);
+
+  return MseSink;
+}(Sink);
+;// CONCATENATED MODULE: ./lib/components/onvifdepay/index.ts
+/* provided dependency */ var onvifdepay_Buffer = __webpack_require__(7866)["Buffer"];
+function onvifdepay_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { onvifdepay_typeof = function _typeof(obj) { return typeof obj; }; } else { onvifdepay_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return onvifdepay_typeof(obj); }
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+function onvifdepay_createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = onvifdepay_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
+
+function onvifdepay_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return onvifdepay_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return onvifdepay_arrayLikeToArray(o, minLen); }
+
+function onvifdepay_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
+
+function onvifdepay_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
+
+function onvifdepay_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) onvifdepay_setPrototypeOf(subClass, superClass); }
+
+function onvifdepay_setPrototypeOf(o, p) { onvifdepay_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return onvifdepay_setPrototypeOf(o, p); }
+
+function onvifdepay_createSuper(Derived) { var hasNativeReflectConstruct = onvifdepay_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = onvifdepay_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = onvifdepay_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return onvifdepay_possibleConstructorReturn(this, result); }; }
+
+function onvifdepay_possibleConstructorReturn(self, call) { if (call && (onvifdepay_typeof(call) === "object" || typeof call === "function")) { return call; } return onvifdepay_assertThisInitialized(self); }
+
+function onvifdepay_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
+
+function onvifdepay_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
+
+function onvifdepay_getPrototypeOf(o) { onvifdepay_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return onvifdepay_getPrototypeOf(o); }
+
+
+
+
+
+var ONVIFDepay = /*#__PURE__*/function (_Tube) {
+  onvifdepay_inherits(ONVIFDepay, _Tube);
+
+  var _super = onvifdepay_createSuper(ONVIFDepay);
+
+  function ONVIFDepay() {
+    onvifdepay_classCallCheck(this, ONVIFDepay);
+
+    var XMLPayloadType;
+    var packets = [];
+    var incoming = new stream_browserify.Transform({
+      objectMode: true,
+      transform: function transform(msg, encoding, callback) {
+        if (msg.type === MessageType.SDP) {
+          var validMedia;
+
+          var _iterator = onvifdepay_createForOfIteratorHelper(msg.sdp.media),
+              _step;
+
+          try {
+            for (_iterator.s(); !(_step = _iterator.n()).done;) {
+              var media = _step.value;
+
+              if (media.type === 'application' && media.rtpmap && media.rtpmap.encodingName === 'VND.ONVIF.METADATA') {
+                validMedia = media;
+              }
+            }
+          } catch (err) {
+            _iterator.e(err);
+          } finally {
+            _iterator.f();
+          }
+
+          if (validMedia && validMedia.rtpmap) {
+            XMLPayloadType = Number(validMedia.rtpmap.payloadType);
+          }
+
+          callback(undefined, msg);
+        } else if (msg.type === MessageType.RTP && payloadType(msg.data) === XMLPayloadType) {
+          // Add payload to packet stack
+          packets.push(payload(msg.data)); // XML over RTP uses the RTP marker bit to indicate end
+          // of fragmentation. At this point, the packets can be used
+          // to reconstruct an XML packet.
+
+          if (marker(msg.data) && packets.length > 0) {
+            var xmlMsg = {
+              timestamp: timestamp(msg.data),
+              ntpTimestamp: msg.ntpTimestamp,
+              payloadType: payloadType(msg.data),
+              data: onvifdepay_Buffer.concat(packets),
+              type: MessageType.XML
+            };
+            callback(undefined, xmlMsg);
+            packets = [];
+            return;
+          }
+
+          callback();
+        } else {
+          // Not a message we should handle
+          callback(undefined, msg);
+        }
+      }
+    }); // outgoing will be defaulted to a PassThrough stream
+
+    return _super.call(this, incoming);
+  }
+
+  return ONVIFDepay;
+}(Tube);
+// EXTERNAL MODULE: ./.yarn/unplugged/core-js-npm-3.16.2-c7ce9e8d48/node_modules/core-js/modules/es.object.entries.js
+var es_object_entries = __webpack_require__(5916);
+;// CONCATENATED MODULE: ./lib/components/rtsp-parser/builder.ts
+/* provided dependency */ var builder_Buffer = __webpack_require__(7866)["Buffer"];
+function builder_slicedToArray(arr, i) { return builder_arrayWithHoles(arr) || builder_iterableToArrayLimit(arr, i) || builder_unsupportedIterableToArray(arr, i) || builder_nonIterableRest(); }
+
+function builder_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
+
+function builder_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return builder_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return builder_arrayLikeToArray(o, minLen); }
+
+function builder_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
+
+function builder_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }
+
+function builder_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+var DEFAULT_PROTOCOL = 'RTSP/1.0';
+var builder = function builder(msg) {
+  if (!msg.method || !msg.uri) {
+    throw new Error('message needs to contain a method and a uri');
+  }
+
+  var protocol = msg.protocol || DEFAULT_PROTOCOL;
+  var headers = msg.headers || {};
+  var messageString = ["".concat(msg.method, " ").concat(msg.uri, " ").concat(protocol), Object.entries(headers).map(function (_ref) {
+    var _ref2 = builder_slicedToArray(_ref, 2),
+        key = _ref2[0],
+        value = _ref2[1];
+
+    return key + ': ' + value;
+  }).join('\r\n'), '\r\n'].join('\r\n');
+  browser_default()('msl:rtsp:outgoing')(messageString);
+  return builder_Buffer.from(messageString);
+};
+// EXTERNAL MODULE: ./.yarn/unplugged/core-js-npm-3.16.2-c7ce9e8d48/node_modules/core-js/modules/es.string.trim.js
+var es_string_trim = __webpack_require__(9340);
+// EXTERNAL MODULE: ./.yarn/unplugged/core-js-npm-3.16.2-c7ce9e8d48/node_modules/core-js/modules/es.string.match.js
+var es_string_match = __webpack_require__(7505);
+;// CONCATENATED MODULE: ./lib/utils/protocols/sdp.ts
+function sdp_createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = sdp_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
+
+function _toArray(arr) { return sdp_arrayWithHoles(arr) || sdp_iterableToArray(arr) || sdp_unsupportedIterableToArray(arr) || sdp_nonIterableRest(); }
+
+function sdp_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
+
+function sdp_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+function sdp_slicedToArray(arr, i) { return sdp_arrayWithHoles(arr) || sdp_iterableToArrayLimit(arr, i) || sdp_unsupportedIterableToArray(arr, i) || sdp_nonIterableRest(); }
+
+function sdp_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
+
+function sdp_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return sdp_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return sdp_arrayLikeToArray(o, minLen); }
+
+function sdp_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
+
+function sdp_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }
+
+function sdp_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+var extractLineVals = function extractLineVals(buffer, lineStart) {
+  var start = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
+  var anchor = "\n".concat(lineStart);
+  start = buffer.indexOf(anchor, start);
+  var end = 0;
+  var ret = [];
+
+  while (start >= 0) {
+    end = buffer.indexOf('\n', start + anchor.length);
+    ret.push(buffer.toString('ascii', start + anchor.length, end).trim());
+    start = buffer.indexOf(anchor, end);
+  }
+
+  return ret;
+}; // SDP parsing
+
+/**
+ * Identify the start of a session-level or media-level section.
+ * @param  line - The line to parse
+ */
+
+
+var newMediaLevel = function newMediaLevel(line) {
+  return line.match(/^m=/);
+};
+
+var splitOnFirst = function splitOnFirst(c, text) {
+  var p = text.indexOf(c);
+
+  if (p < 0) {
+    return [text.slice(0)];
+  } else {
+    return [text.slice(0, p), text.slice(p + 1)];
+  }
+};
+
+var attributeParsers = {
+  fmtp: function fmtp(value) {
+    var _splitOnFirst = splitOnFirst(' ', value),
+        _splitOnFirst2 = sdp_slicedToArray(_splitOnFirst, 2),
+        format = _splitOnFirst2[0],
+        stringParameters = _splitOnFirst2[1];
+
+    switch (format) {
+      default:
+        var pairs = stringParameters.trim().split(';');
+        var parameters = {};
+        pairs.forEach(function (pair) {
+          var _splitOnFirst3 = splitOnFirst('=', pair),
+              _splitOnFirst4 = sdp_slicedToArray(_splitOnFirst3, 2),
+              key = _splitOnFirst4[0],
+              val = _splitOnFirst4[1];
+
+          var normalizedKey = key.trim().toLowerCase();
+
+          if (normalizedKey !== '') {
+            parameters[normalizedKey] = val.trim();
+          }
+        });
+        return {
+          format: format,
+          parameters: parameters
+        };
+    }
+  },
+  framerate: Number,
+  rtpmap: function rtpmap(value) {
+    var _splitOnFirst5 = splitOnFirst(' ', value),
+        _splitOnFirst6 = sdp_slicedToArray(_splitOnFirst5, 2),
+        payloadType = _splitOnFirst6[0],
+        encoding = _splitOnFirst6[1];
+
+    var _encoding$toUpperCase = encoding.toUpperCase().split('/'),
+        _encoding$toUpperCase2 = sdp_slicedToArray(_encoding$toUpperCase, 3),
+        encodingName = _encoding$toUpperCase2[0],
+        clockrate = _encoding$toUpperCase2[1],
+        encodingParameters = _encoding$toUpperCase2[2];
+
+    if (encodingParameters === undefined) {
+      return {
+        payloadType: Number(payloadType),
+        encodingName: encodingName,
+        clockrate: Number(clockrate)
+      };
+    } else {
+      return {
+        payloadType: Number(payloadType),
+        encodingName: encodingName,
+        clockrate: Number(clockrate),
+        encodingParameters: encodingParameters
+      };
+    }
+  },
+  transform: function transform(value) {
+    return value.split(';').map(function (row) {
+      return row.split(',').map(Number);
+    });
+  },
+  'x-sensor-transform': function xSensorTransform(value) {
+    return value.split(';').map(function (row) {
+      return row.split(',').map(Number);
+    });
+  },
+  framesize: function framesize(value) {
+    return value.split(' ')[1].split('-').map(Number);
+  }
+};
+
+var parseAttribute = function parseAttribute(body) {
+  var _splitOnFirst7 = splitOnFirst(':', body),
+      _splitOnFirst8 = sdp_slicedToArray(_splitOnFirst7, 2),
+      attribute = _splitOnFirst8[0],
+      value = _splitOnFirst8[1];
+
+  if (value === undefined) {
+    return sdp_defineProperty({}, attribute, true);
+  } else {
+    if (attributeParsers[attribute] !== undefined) {
+      return sdp_defineProperty({}, attribute, attributeParsers[attribute](value));
+    } else {
+      return sdp_defineProperty({}, attribute, value);
+    }
+  }
+};
+
+var extractField = function extractField(line) {
+  var prefix = line.slice(0, 1);
+  var body = line.slice(2);
+
+  switch (prefix) {
+    case 'v':
+      return {
+        version: body
+      };
+
+    case 'o':
+      var _body$split = body.split(' '),
+          _body$split2 = sdp_slicedToArray(_body$split, 6),
+          username = _body$split2[0],
+          sessionId = _body$split2[1],
+          sessionVersion = _body$split2[2],
+          netType = _body$split2[3],
+          addrType = _body$split2[4],
+          unicastAddress = _body$split2[5];
+
+      return {
+        origin: {
+          addrType: addrType,
+          netType: netType,
+          sessionId: sessionId,
+          sessionVersion: sessionVersion,
+          unicastAddress: unicastAddress,
+          username: username
+        }
+      };
+
+    case 's':
+      return {
+        sessionName: body
+      };
+
+    case 'i':
+      return {
+        sessionInformation: body
+      };
+
+    case 'u':
+      return {
+        uri: body
+      };
+
+    case 'e':
+      return {
+        email: body
+      };
+
+    case 'p':
+      return {
+        phone: body
+      };
+    // c=<nettype> <addrtype> <connection-address>
+
+    case 'c':
+      var _body$split3 = body.split(' '),
+          _body$split4 = sdp_slicedToArray(_body$split3, 3),
+          connectionNetType = _body$split4[0],
+          connectionAddrType = _body$split4[1],
+          connectionAddress = _body$split4[2];
+
+      return {
+        connectionData: {
+          addrType: connectionAddrType,
+          connectionAddress: connectionAddress,
+          netType: connectionNetType
+        }
+      };
+    // b=<bwtype>:<bandwidth>
+
+    case 'b':
+      var _body$split5 = body.split(':'),
+          _body$split6 = sdp_slicedToArray(_body$split5, 2),
+          bwtype = _body$split6[0],
+          bandwidth = _body$split6[1];
+
+      return {
+        bwtype: bwtype,
+        bandwidth: bandwidth
+      };
+    // t=<start-time> <stop-time>
+
+    case 't':
+      var _body$split$map = body.split(' ').map(Number),
+          _body$split$map2 = sdp_slicedToArray(_body$split$map, 2),
+          startTime = _body$split$map2[0],
+          stopTime = _body$split$map2[1];
+
+      return {
+        time: {
+          startTime: startTime,
+          stopTime: stopTime
+        }
+      };
+    // r=<repeat interval> <active duration> <offsets from start-time>
+
+    case 'r':
+      var _body$split$map3 = body.split(' ').map(Number),
+          _body$split$map4 = _toArray(_body$split$map3),
+          repeatInterval = _body$split$map4[0],
+          activeDuration = _body$split$map4[1],
+          offsets = _body$split$map4.slice(2);
+
+      return {
+        repeatTimes: {
+          repeatInterval: repeatInterval,
+          activeDuration: activeDuration,
+          offsets: offsets
+        }
+      };
+    // z=<adjustment time> <offset> <adjustment time> <offset> ....
+
+    case 'z':
+      return;
+    // k=<method>
+    // k=<method>:<encryption key>
+
+    case 'k':
+      return;
+    // a=<attribute>
+    // a=<attribute>:<value>
+
+    case 'a':
+      return parseAttribute(body);
+
+    case 'm':
+      // Only the first fmt field is parsed!
+      var _body$split7 = body.split(' '),
+          _body$split8 = sdp_slicedToArray(_body$split7, 4),
+          type = _body$split8[0],
+          port = _body$split8[1],
+          protocol = _body$split8[2],
+          fmt = _body$split8[3];
+
+      return {
+        type: type,
+        port: Number(port),
+        protocol: protocol,
+        fmt: Number(fmt)
+      };
+
+    default: // console.log('unknown SDP prefix ', prefix);
+
+  }
+};
+
+var extractURIs = function extractURIs(buffer) {
+  // There is a control URI above the m= line, which should not be used
+  var seekFrom = buffer.indexOf('\nm=');
+  return extractLineVals(buffer, 'a=control:', seekFrom);
+};
+/**
+ * Parse an SDP text into a data structure with session and media objects.
+ *
+ * @param  buffer - The buffer containing the SDP plain text
+ * @return Structured SDP data
+ */
+
+var sdp_parse = function parse(buffer) {
+  var sdp = buffer.toString('ascii').split('\n').map(function (s) {
+    return s.trim();
+  });
+  var struct = {
+    session: {},
+    media: []
+  };
+  var mediaCounter = 0;
+  var current = struct.session;
+
+  var _iterator = sdp_createForOfIteratorHelper(sdp),
+      _step;
+
+  try {
+    for (_iterator.s(); !(_step = _iterator.n()).done;) {
+      var line = _step.value;
+
+      if (newMediaLevel(line)) {
+        struct.media[mediaCounter] = {};
+        current = struct.media[mediaCounter];
+        ++mediaCounter;
+      }
+
+      current = Object.assign(current, extractField(line));
+    }
+  } catch (err) {
+    _iterator.e(err);
+  } finally {
+    _iterator.f();
+  }
+
+  return struct;
+};
+var messageFromBuffer = function messageFromBuffer(buffer) {
+  return {
+    type: MessageType.SDP,
+    data: buffer,
+    sdp: sdp_parse(buffer)
+  };
+};
+;// CONCATENATED MODULE: ./lib/utils/protocols/rtsp.ts
+
+
+
+
+
+
+
+
+
+/*
+ * The RTSP response format is defined in RFC 7826,
+ * using ABNF notation specified in RFC 5234.
+ * Strings in ABNF rules ("...") are always case insensitive!
+ *
+ * Basic rules to help with the headers below:
+ * ====
+ * CR              =  %x0D ; US-ASCII CR, carriage return (13)
+ * LF              =  %x0A  ; US-ASCII LF, linefeed (10)
+ * SP              =  %x20  ; US-ASCII SP, space (32)
+ * HT              =  %x09  ; US-ASCII HT, horizontal-tab (9)
+ * CRLF            =  CR LF
+ * LWS             =  [CRLF] 1*( SP / HT ) ; Line-breaking whitespace
+ * SWS             =  [LWS] ; Separating whitespace
+ * HCOLON          =  *( SP / HT ) ":" SWS
+ *
+ * RTSP response rules (a `*` means zero or more):
+ * ====
+ * Status-Line  = RTSP-Version SP Status-Code SP Reason-Phrase CRLF
+ * Response     = Status-Line
+ *                *((general-header
+ *                /  response-header
+ *                /  message-body-header) CRLF)
+ *                CRLF
+ *                [ message-body-data ]
+ *
+ * Example response:
+ * ====
+ * RTSP/1.0 200 OK
+ * CSeq: 3
+ * Content-Type: application/sdp
+ * Content-Base: rtsp://192.168.0.3/axis-media/media.amp/
+ * Server: GStreamer RTSP server
+ * Date: Wed, 03 Jun 2015 14:23:42 GMT
+ * Content-Length: 623
+ *
+ * v=0
+ * ....
+ */
+
+/**
+ * Extract the value of a header.
+ *
+ * @param buffer The response bytes
+ * @param header The header to search for
+ */
+var extractHeaderValue = function extractHeaderValue(buffer, header) {
+  var anchor = "\n".concat(header.toLowerCase(), ": ");
+  var start = buffer.toString().toLowerCase().indexOf(anchor);
+
+  if (start >= 0) {
+    var end = buffer.indexOf('\n', start + anchor.length);
+    var headerValue = buffer.toString('ascii', start + anchor.length, end).trim();
+    return headerValue;
+  }
+
+  return null;
+};
+var sequence = function sequence(buffer) {
+  /**
+   * CSeq           =  "CSeq" HCOLON cseq-nr
+   * cseq-nr        =  1*9DIGIT
+   */
+  var val = extractHeaderValue(buffer, 'CSeq');
+
+  if (val !== null) {
+    return Number(val);
+  }
+
+  return null;
+};
+var sessionId = function sessionId(buffer) {
+  /**
+   * Session          =  "Session" HCOLON session-id
+   *                     [ SEMI "timeout" EQUAL delta-seconds ]
+   * session-id        =  1*256( ALPHA / DIGIT / safe )
+   * delta-seconds     =  1*19DIGIT
+   */
+  var val = extractHeaderValue(buffer, 'Session');
+  return val ? val.split(';')[0] : null;
+};
+var sessionTimeout = function sessionTimeout(buffer) {
+  /**
+   * Session          =  "Session" HCOLON session-id
+   *                     [ SEMI "timeout" EQUAL delta-seconds ]
+   * session-id        =  1*256( ALPHA / DIGIT / safe )
+   * delta-seconds     =  1*19DIGIT
+   */
+  var val = extractHeaderValue(buffer, 'Session');
+
+  if (val === null) {
+    return null;
+  }
+
+  var defaultTimeout = 60;
+  var timeoutToken = 'timeout=';
+  var timeoutPosition = val.toLowerCase().indexOf(timeoutToken);
+
+  if (timeoutPosition !== -1) {
+    var timeoutVal = val.substring(timeoutPosition + timeoutToken.length);
+    timeoutVal = timeoutVal.split(';')[0];
+    var parsedTimeout = parseInt(timeoutVal);
+    return isNaN(parsedTimeout) ? defaultTimeout : parsedTimeout;
+  }
+
+  return defaultTimeout;
+};
+var statusCode = function statusCode(buffer) {
+  return Number(buffer.toString('ascii', 9, 12));
+};
+var contentBase = function contentBase(buffer) {
+  /**
+   * Content-Base       =  "Content-Base" HCOLON RTSP-URI
+   */
+  return extractHeaderValue(buffer, 'Content-Base');
+};
+var contentLocation = function contentLocation(buffer) {
+  /**
+   * Content-Location   =  "Content-Location" HCOLON RTSP-REQ-Ref
+   */
+  return extractHeaderValue(buffer, 'Content-Location');
+};
+var connectionEnded = function connectionEnded(buffer) {
+  /**
+   * Connection         =  "Connection" HCOLON connection-token
+   *                       *(COMMA connection-token)
+   * connection-token   =  "close" / token
+   */
+  var connectionToken = extractHeaderValue(buffer, 'Connection');
+  return connectionToken !== null && connectionToken.toLowerCase() === 'close';
+};
+var range = function range(buffer) {
+  /**
+   * Range              =  "Range" HCOLON ranges-spec
+   * ranges-spec        =  npt-range / utc-range / smpte-range
+   *                       /  range-ext
+   * npt-range        =  "npt" [EQUAL npt-range-spec]
+   * npt-range-spec   =  ( npt-time "-" [ npt-time ] ) / ( "-" npt-time )
+   * npt-time         =  "now" / npt-sec / npt-hhmmss / npt-hhmmss-comp
+   * npt-sec          =  1*19DIGIT [ "." 1*9DIGIT ]
+   * npt-hhmmss       =  npt-hh ":" npt-mm ":" npt-ss [ "." 1*9DIGIT ]
+   * npt-hh           =  2*19DIGIT   ; any positive number
+   * npt-mm           =  2*2DIGIT  ; 0-59
+   * npt-ss           =  2*2DIGIT  ; 0-59
+   * npt-hhmmss-comp  =  npt-hh-comp ":" npt-mm-comp ":" npt-ss-comp
+   *                     [ "." 1*9DIGIT ] ; Compatibility format
+   * npt-hh-comp      =  1*19DIGIT   ; any positive number
+   * npt-mm-comp      =  1*2DIGIT  ; 0-59
+   * npt-ss-comp      =  1*2DIGIT  ; 0-59
+   */
+  // Example range headers:
+  // Range: npt=now-
+  // Range: npt=1154.598701-3610.259146
+  var npt = extractHeaderValue(buffer, 'Range');
+
+  if (npt !== null) {
+    return npt.split('=')[1].split('-');
+  }
+
+  return undefined;
+};
+/**
+ * Determine the offset of the RTSP body, where the header ends.
+ * If there is no header ending, -1 is returned
+ * @param  chunk - A piece of data
+ * @return The body offset, or -1 if no header end found
+ */
+
+var bodyOffset = function bodyOffset(chunk) {
+  /**
+   * Strictly speaking, it seems RTSP MUST have CRLF and doesn't allow CR or LF on its own.
+   * That means that the end of the header part should be a pair of CRLF, but we're being
+   * flexible here and also allow LF LF or CR CR instead of CRLF CRLF.
+   */
+  var bodyOffsets = ['\n\n', '\r\r', '\r\n\r\n'].map(function (s) {
+    var offset = chunk.indexOf(s);
+
+    if (offset !== -1) {
+      return offset + s.length;
+    }
+
+    return offset;
+  }).filter(function (offset) {
+    return offset !== -1;
+  });
+
+  if (bodyOffsets.length > 0) {
+    return bodyOffsets.reduce(function (acc, offset) {
+      return Math.min(acc, offset);
+    });
+  } else {
+    return -1;
+  }
+};
+;// CONCATENATED MODULE: ./lib/components/rtsp-parser/parser.ts
+/* provided dependency */ var rtsp_parser_parser_Buffer = __webpack_require__(7866)["Buffer"];
+
+
+
+
+
+function rtsp_parser_parser_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
+
+function rtsp_parser_parser_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
+
+function rtsp_parser_parser_createClass(Constructor, protoProps, staticProps) { if (protoProps) rtsp_parser_parser_defineProperties(Constructor.prototype, protoProps); if (staticProps) rtsp_parser_parser_defineProperties(Constructor, staticProps); return Constructor; }
+
+function rtsp_parser_parser_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+
+
+
+
+/**
+ * The different possible internal parser states.
+ */
+
+var STATE;
+
+(function (STATE) {
+  STATE[STATE["IDLE"] = 0] = "IDLE";
+  STATE[STATE["INTERLEAVED"] = 1] = "INTERLEAVED";
+  STATE[STATE["RTSP"] = 2] = "RTSP";
+})(STATE || (STATE = {}));
+
+var INTERLEAVED_HEADER_BYTES = 4;
+var ASCII_DOLLAR = 0x24;
+
+/**
+ * Extract packet information from the interleaved header
+ * (4-byte section before the RTP packet).
+ * @param  chunks - Buffers constituting the data.
+ * @return Packet information (channel, begin, end).
+ */
+var rtpPacketInfo = function rtpPacketInfo(chunks) {
+  var header = rtsp_parser_parser_Buffer.alloc(INTERLEAVED_HEADER_BYTES);
+  var i = 0;
+  var bytesRead = 0;
+
+  while (bytesRead < header.length) {
+    var chunk = chunks[i++];
+    var bytesToRead = Math.min(chunk.length, header.length - bytesRead);
+    chunk.copy(header, bytesRead, 0, bytesToRead);
+    bytesRead += bytesToRead;
+  }
+
+  var channel = header[1];
+  var begin = header.length;
+  var length = header.readUInt16BE(2);
+  var end = begin + length;
+  return {
+    channel: channel,
+    begin: begin,
+    end: end
+  };
+};
+/**
+ * Parser class with a public method that takes a data chunk and
+ * returns an array of RTP/RTSP/RTCP message objects. The parser
+ * keeps track of the added chunks internally in an array and only
+ * concatenates chunks when data is needed to construct a message.
+ * @type {[type]}
+ */
+
+
+var Parser = /*#__PURE__*/function () {
+  /**
+   * Create a new Parser object.
+   * @return {undefined}
+   */
+  function Parser() {
+    rtsp_parser_parser_classCallCheck(this, Parser);
+
+    rtsp_parser_parser_defineProperty(this, "_chunks", []);
+
+    rtsp_parser_parser_defineProperty(this, "_length", 0);
+
+    rtsp_parser_parser_defineProperty(this, "_state", STATE.IDLE);
+
+    rtsp_parser_parser_defineProperty(this, "_packet", void 0);
+
+    this._init();
+  }
+  /**
+   * Initialize the internal properties to their default starting
+   * values.
+   * @return {undefined}
+   */
+
+
+  rtsp_parser_parser_createClass(Parser, [{
+    key: "_init",
+    value: function _init() {
+      this._chunks = [];
+      this._length = 0;
+      this._state = STATE.IDLE;
+    }
+  }, {
+    key: "_push",
+    value: function _push(chunk) {
+      this._chunks.push(chunk);
+
+      this._length += chunk.length;
+    }
+    /**
+     * Extract RTSP messages.
+     * @return {Array} An array of messages, possibly empty.
+     */
+
+  }, {
+    key: "_parseRtsp",
+    value: function _parseRtsp() {
+      var messages = [];
+      var buffer = rtsp_parser_parser_Buffer.concat(this._chunks);
+      var chunkBodyOffset = bodyOffset(buffer); // If last added chunk does not have the end of the header, return.
+
+      if (chunkBodyOffset === -1) {
+        return messages;
+      }
+
+      var rtspHeaderLength = chunkBodyOffset;
+      var contentLength = extractHeaderValue(buffer, 'Content-Length');
+
+      if (contentLength && parseInt(contentLength) > buffer.length - rtspHeaderLength) {
+        // we do not have the whole body
+        return messages;
+      }
+
+      this._init(); // resets this._chunks and this._length
+
+
+      if (rtspHeaderLength === buffer.length || buffer[rtspHeaderLength] === ASCII_DOLLAR) {
+        // No body in this chunk, assume there is no body?
+        var packet = buffer.slice(0, rtspHeaderLength);
+        messages.push({
+          type: MessageType.RTSP,
+          data: packet
+        }); // Add the remaining data to the chunk stack.
+
+        var trailing = buffer.slice(rtspHeaderLength);
+
+        this._push(trailing);
+      } else {
+        // Body is assumed to be the remaining data of the last chunk.
+        var _packet = buffer;
+        var body = buffer.slice(rtspHeaderLength);
+        messages.push({
+          type: MessageType.RTSP,
+          data: _packet
+        });
+        messages.push(messageFromBuffer(body));
+      }
+
+      return messages;
+    }
+    /**
+     * Extract RTP/RTCP messages.
+     * @return {Array} An array of messages, possibly empty.
+     */
+
+  }, {
+    key: "_parseInterleaved",
+    value: function _parseInterleaved() {
+      var messages = []; // Skip as long as we don't have the first 4 bytes
+
+      if (this._length < INTERLEAVED_HEADER_BYTES) {
+        return messages;
+      } // Enough bytes to construct the header and extract packet info.
+
+
+      if (!this._packet) {
+        this._packet = rtpPacketInfo(this._chunks);
+      } // As long as we don't have enough chunks, skip.
+
+
+      if (this._length < this._packet.end) {
+        return messages;
+      } // We have enough data to extract the packet.
+
+
+      var buffer = rtsp_parser_parser_Buffer.concat(this._chunks);
+      var packet = buffer.slice(this._packet.begin, this._packet.end);
+      var trailing = buffer.slice(this._packet.end);
+      var channel = this._packet.channel;
+      delete this._packet; // Prepare next bit.
+
+      this._init();
+
+      this._push(trailing); // Extract messages
+
+
+      if (channel % 2 === 0) {
+        // Even channels 0, 2, ...
+        messages.push({
+          type: MessageType.RTP,
+          data: packet,
+          channel: channel
+        });
+      } else {
+        // Odd channels 1, 3, ...
+        var rtcpPackets = packet;
+
+        do {
+          // RTCP packets can be packed together, unbundle them:
+          var rtcpByteSize = rtcpPackets.readUInt16BE(2) * 4 + 4;
+          messages.push(rtcpMessageFromBuffer(channel, rtcpPackets.slice(0, rtcpByteSize)));
+          rtcpPackets = rtcpPackets.slice(rtcpByteSize);
+        } while (rtcpPackets.length > 0);
+      }
+
+      return messages;
+    }
+    /**
+     * Set the internal state based on the type of the first chunk
+     */
+
+  }, {
+    key: "_setState",
+    value: function _setState() {
+      // Remove leading 0-sized chunks.
+      while (this._chunks.length > 0 && this._chunks[0].length === 0) {
+        this._chunks.shift();
+      }
+
+      var firstChunk = this._chunks[0];
+
+      if (this._chunks.length === 0) {
+        this._state = STATE.IDLE;
+      } else if (firstChunk[0] === ASCII_DOLLAR) {
+        this._state = STATE.INTERLEAVED;
+      } else if (firstChunk.toString('ascii', 0, 4) === 'RTSP') {
+        this._state = STATE.RTSP;
+      } else {
+        throw new Error("Unknown chunk of length ".concat(firstChunk.length));
+      }
+    }
+    /**
+     * Add the next chunk of data to the parser and extract messages.
+     * If no message can be extracted, an empty array is returned, otherwise
+     * an array of messages is returned.
+     * @param  chunk - The next piece of data.
+     * @return An array of messages, possibly empty.
+     */
+
+  }, {
+    key: "parse",
+    value: function parse(chunk) {
+      this._push(chunk);
+
+      if (this._state === STATE.IDLE) {
+        this._setState();
+      }
+
+      var messages = [];
+      var done = false;
+
+      while (!done) {
+        var extracted = [];
+
+        switch (this._state) {
+          case STATE.IDLE:
+            break;
+
+          case STATE.INTERLEAVED:
+            extracted = this._parseInterleaved();
+            break;
+
+          case STATE.RTSP:
+            extracted = this._parseRtsp();
+            break;
+
+          default:
+            throw new Error('internal error: unknown state');
+        }
+
+        if (extracted.length > 0) {
+          messages = messages.concat(extracted);
+        } else {
+          done = true;
+        }
+
+        this._setState();
+      }
+
+      return messages;
+    }
+  }]);
+
+  return Parser;
+}();
+;// CONCATENATED MODULE: ./lib/components/rtsp-parser/index.ts
+function rtsp_parser_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { rtsp_parser_typeof = function _typeof(obj) { return typeof obj; }; } else { rtsp_parser_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return rtsp_parser_typeof(obj); }
+
+
+
+
+
+
+
+
+
+
+
+
+
+function rtsp_parser_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
+
+function rtsp_parser_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) rtsp_parser_setPrototypeOf(subClass, superClass); }
+
+function rtsp_parser_setPrototypeOf(o, p) { rtsp_parser_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return rtsp_parser_setPrototypeOf(o, p); }
+
+function rtsp_parser_createSuper(Derived) { var hasNativeReflectConstruct = rtsp_parser_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = rtsp_parser_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = rtsp_parser_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return rtsp_parser_possibleConstructorReturn(this, result); }; }
+
+function rtsp_parser_possibleConstructorReturn(self, call) { if (call && (rtsp_parser_typeof(call) === "object" || typeof call === "function")) { return call; } return rtsp_parser_assertThisInitialized(self); }
+
+function rtsp_parser_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
+
+function rtsp_parser_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
+
+function rtsp_parser_getPrototypeOf(o) { rtsp_parser_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return rtsp_parser_getPrototypeOf(o); }
+
+
+
+
+
+
+/**
+ * A component that converts raw binary data into RTP/RTSP/RTCP packets on the
+ * incoming stream, and converts RTSP commands to raw binary data on the outgoing
+ * stream. The component is agnostic of any RTSP session details (you need an
+ * RTSP session component in the pipeline).
+ * @extends {Component}
+ */
+
+var RtspParser = /*#__PURE__*/function (_Tube) {
+  rtsp_parser_inherits(RtspParser, _Tube);
+
+  var _super = rtsp_parser_createSuper(RtspParser);
+
+  /**
+   * Create a new RTSP parser component.
+   * @return {undefined}
+   */
+  function RtspParser() {
+    rtsp_parser_classCallCheck(this, RtspParser);
+
+    var parser = new Parser(); // Incoming stream
+
+    var incoming = new stream_browserify.Transform({
+      objectMode: true,
+      transform: function transform(msg, encoding, callback) {
+        if (msg.type === MessageType.RAW) {
+          try {
+            parser.parse(msg.data).forEach(function (message) {
+              return incoming.push(message);
+            });
+            callback();
+          } catch (e) {
+            callback(e);
+          }
+        } else {
+          // Not a message we should handle
+          callback(undefined, msg);
+        }
+      }
+    }); // Outgoing stream
+
+    var outgoing = new stream_browserify.Transform({
+      objectMode: true,
+      transform: function transform(msg, encoding, callback) {
+        if (msg.type === MessageType.RTSP) {
+          var data = builder(msg);
+          callback(undefined, {
+            type: MessageType.RAW,
+            data: data
+          });
+        } else {
+          // don't touch other types
+          callback(undefined, msg);
+        }
+      }
+    });
+    return _super.call(this, incoming, outgoing);
+  }
+
+  return RtspParser;
+}(Tube);
+;// CONCATENATED MODULE: ./lib/utils/config.ts
+
+
+
+
+
+
+
+
+
+
+function config_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { config_typeof = function _typeof(obj) { return typeof obj; }; } else { config_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return config_typeof(obj); }
+
+/**
+ * Flat merge of objects, ignoring undefined override values.
+ * @param  template - The object with default values
+ * @param  override - The object with override values.
+ * @return The template object with override merged in.
+ */
+var merge = function merge(template, override) {
+  var cleanOverride;
+
+  if (override !== undefined) {
+    if (config_typeof(override) !== 'object') {
+      throw new Error('merge expects override to be an object!');
+    } else {
+      cleanOverride = Object.keys(override).reduce(function (acc, key) {
+        if (override[key] !== undefined) {
+          acc[key] = override[key];
+        }
+
+        return acc;
+      }, {});
+    }
+  }
+
+  return Object.assign({}, template, cleanOverride);
+};
+;// CONCATENATED MODULE: ./lib/utils/protocols/ntp.ts
+// NTP is offset from 01.01.1900
+var NTP_UNIX_EPOCH_OFFSET = Date.UTC(1900, 0, 1); // Convenience types
+
+/**
+ * Convert NTP time to milliseconds since January 1, 1970, 00:00:00 UTC (Unix Epoch)
+ * @param ntpMost - Seconds since 01.01.1900
+ * @param ntpLeast - Fractions since 01.01.1900
+ */
+function getTime(ntpMost, ntpLeast) {
+  var ntpMilliSeconds = (ntpMost + ntpLeast / 0x100000000) * 1000;
+  return NTP_UNIX_EPOCH_OFFSET + ntpMilliSeconds;
+}
+;// CONCATENATED MODULE: ./lib/components/rtsp-session/index.ts
+/* provided dependency */ var rtsp_session_Buffer = __webpack_require__(7866)["Buffer"];
+function rtsp_session_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { rtsp_session_typeof = function _typeof(obj) { return typeof obj; }; } else { rtsp_session_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return rtsp_session_typeof(obj); }
+
+function rtsp_session_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
+
+function rtsp_session_createClass(Constructor, protoProps, staticProps) { if (protoProps) rtsp_session_defineProperties(Constructor.prototype, protoProps); if (staticProps) rtsp_session_defineProperties(Constructor, staticProps); return Constructor; }
+
+function rtsp_session_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
+
+function rtsp_session_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) rtsp_session_setPrototypeOf(subClass, superClass); }
+
+function rtsp_session_createSuper(Derived) { var hasNativeReflectConstruct = rtsp_session_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = rtsp_session_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = rtsp_session_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return rtsp_session_possibleConstructorReturn(this, result); }; }
+
+function rtsp_session_possibleConstructorReturn(self, call) { if (call && (rtsp_session_typeof(call) === "object" || typeof call === "function")) { return call; } return rtsp_session_assertThisInitialized(self); }
+
+function rtsp_session_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
+
+function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, rtsp_session_getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return rtsp_session_setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }
+
+function _construct(Parent, args, Class) { if (rtsp_session_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) rtsp_session_setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }
+
+function rtsp_session_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
+
+function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }
+
+function rtsp_session_setPrototypeOf(o, p) { rtsp_session_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return rtsp_session_setPrototypeOf(o, p); }
+
+function rtsp_session_getPrototypeOf(o) { rtsp_session_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return rtsp_session_getPrototypeOf(o); }
+
+function rtsp_session_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+function isAbsolute(url) {
+  return /^[^:]+:\/\//.test(url);
+}
+
+var rtsp_session_STATE;
+
+(function (STATE) {
+  STATE["IDLE"] = "idle";
+  STATE["PLAYING"] = "playing";
+  STATE["PAUSED"] = "paused";
+})(rtsp_session_STATE || (rtsp_session_STATE = {}));
+
+var RTSP_METHOD;
+
+(function (RTSP_METHOD) {
+  RTSP_METHOD["OPTIONS"] = "OPTIONS";
+  RTSP_METHOD["DESCRIBE"] = "DESCRIBE";
+  RTSP_METHOD["SETUP"] = "SETUP";
+  RTSP_METHOD["PLAY"] = "PLAY";
+  RTSP_METHOD["PAUSE"] = "PAUSE";
+  RTSP_METHOD["TEARDOWN"] = "TEARDOWN";
+})(RTSP_METHOD || (RTSP_METHOD = {}));
+
+var MIN_SESSION_TIMEOUT = 5; // minimum timeout for a rtsp session in seconds
+
+// Default RTSP configuration
+var defaultConfig = function defaultConfig() {
+  var hostname = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : typeof window === 'undefined' ? '' : window.location.hostname;
+  var parameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
+  var uri = parameters.length > 0 ? "rtsp://".concat(hostname, "/axis-media/media.amp?").concat(parameters.join('&')) : "rtsp://".concat(hostname, "/axis-media/media.amp");
+  return {
+    uri: uri
+  };
+};
+
+var RTSPResponseError = /*#__PURE__*/function (_Error) {
+  rtsp_session_inherits(RTSPResponseError, _Error);
+
+  var _super = rtsp_session_createSuper(RTSPResponseError);
+
+  function RTSPResponseError(message, code) {
+    var _this;
+
+    rtsp_session_classCallCheck(this, RTSPResponseError);
+
+    _this = _super.call(this, message);
+
+    rtsp_session_defineProperty(rtsp_session_assertThisInitialized(_this), "code", void 0);
+
+    _this.name = 'RTSPResponseError';
+    _this.code = code;
+    return _this;
+  }
+
+  return RTSPResponseError;
+}( /*#__PURE__*/_wrapNativeSuper(Error));
+/**
+ * A component that sets up a command queue in order to interact with the RTSP
+ * server. Allows control over the RTSP session by listening to incoming messages
+ * and sending request on the outgoing stream.
+ *
+ * The following handlers can be set on the component:
+ *  - onSdp: will be called when an SDP object is sent with the object as argument
+ *  - onPlay: will be called when an RTSP PLAY response is sent with the media range
+ *            as argument. The latter is an array [start, stop], where start is "now"
+ *            (for live) or a time in seconds, and stop is undefined (for live or
+ *            ongoing streams) or a time in seconds.
+ * @extends {Component}
+ */
+
+var RtspSession = /*#__PURE__*/function (_Tube) {
+  rtsp_session_inherits(RtspSession, _Tube);
+
+  var _super2 = rtsp_session_createSuper(RtspSession);
+
+  /**
+   * Create a new RTSP session controller component.
+   * @param  [config] Details about the session.
+   * @param  [config.hostname] The RTSP server hostname
+   * @param  [config.parameters] The RTSP URI parameters
+   * @param  [config.uri] The full RTSP URI (overrides any hostname/parameters)
+   * @param  [config.defaultHeaders] Default headers to use (for all methods).
+   * @param  [config.headers] Headers to use (mapped to each method).
+   */
+  function RtspSession() {
+    var _this2;
+
+    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
+
+    rtsp_session_classCallCheck(this, RtspSession);
+
+    var _merge = merge(defaultConfig(config.hostname, config.parameters), config),
+        uri = _merge.uri,
+        headers = _merge.headers,
+        defaultHeaders = _merge.defaultHeaders;
+
+    var incoming = new stream_browserify.Transform({
+      objectMode: true,
+      transform: function transform(msg, _, callback) {
+        if (msg.type === MessageType.RTSP) {
+          _this2._onRtsp(msg);
+
+          callback(); // Consumes the RTSP packages
+        } else if (msg.type === MessageType.RTCP) {
+          _this2._onRtcp(msg); // Execute externally registered SDP handler
+
+
+          _this2.onRtcp && _this2.onRtcp(msg.rtcp); // Pass SDP forward
+
+          callback(undefined, msg);
+        } else if (msg.type === MessageType.RTP) {
+          _this2._onRtp(msg);
+
+          callback(undefined, msg);
+        } else if (msg.type === MessageType.SDP) {
+          _this2._onSdp(msg); // Execute externally registered SDP handler
+
+
+          _this2.onSdp && _this2.onSdp(msg.sdp); // Pass SDP forward
+
+          callback(undefined, msg);
+        } else {
+          // Not a message we should handle
+          callback(undefined, msg);
+        }
+      }
+    });
+    incoming.on('end', function () {
+      // Incoming was ended, assume that outgoing is closed as well
+      _this2._outgoingClosed = true;
+    });
+    _this2 = _super2.call(this, incoming);
+
+    rtsp_session_defineProperty(rtsp_session_assertThisInitialized(_this2), "uri", void 0);
+
+    rtsp_session_defineProperty(rtsp_session_assertThisInitialized(_this2), "headers", void 0);
+
+    rtsp_session_defineProperty(rtsp_session_assertThisInitialized(_this2), "defaultHeaders", void 0);
+
+    rtsp_session_defineProperty(rtsp_session_assertThisInitialized(_this2), "t0", void 0);
+
+    rtsp_session_defineProperty(rtsp_session_assertThisInitialized(_this2), "n0", void 0);
+
+    rtsp_session_defineProperty(rtsp_session_assertThisInitialized(_this2), "clockrates", void 0);
+
+    rtsp_session_defineProperty(rtsp_session_assertThisInitialized(_this2), "startTime", void 0);
+
+    rtsp_session_defineProperty(rtsp_session_assertThisInitialized(_this2), "onRtcp", void 0);
+
+    rtsp_session_defineProperty(rtsp_session_assertThisInitialized(_this2), "onSdp", void 0);
+
+    rtsp_session_defineProperty(rtsp_session_assertThisInitialized(_this2), "onError", void 0);
+
+    rtsp_session_defineProperty(rtsp_session_assertThisInitialized(_this2), "onPlay", void 0);
+
+    rtsp_session_defineProperty(rtsp_session_assertThisInitialized(_this2), "retry", void 0);
+
+    rtsp_session_defineProperty(rtsp_session_assertThisInitialized(_this2), "_outgoingClosed", void 0);
+
+    rtsp_session_defineProperty(rtsp_session_assertThisInitialized(_this2), "_sequence", void 0);
+
+    rtsp_session_defineProperty(rtsp_session_assertThisInitialized(_this2), "_callStack", void 0);
+
+    rtsp_session_defineProperty(rtsp_session_assertThisInitialized(_this2), "_callHistory", void 0);
+
+    rtsp_session_defineProperty(rtsp_session_assertThisInitialized(_this2), "_state", void 0);
+
+    rtsp_session_defineProperty(rtsp_session_assertThisInitialized(_this2), "_waiting", void 0);
+
+    rtsp_session_defineProperty(rtsp_session_assertThisInitialized(_this2), "_contentBase", void 0);
+
+    rtsp_session_defineProperty(rtsp_session_assertThisInitialized(_this2), "_contentLocation", void 0);
+
+    rtsp_session_defineProperty(rtsp_session_assertThisInitialized(_this2), "_sessionId", void 0);
+
+    rtsp_session_defineProperty(rtsp_session_assertThisInitialized(_this2), "_sessionControlURL", void 0);
+
+    rtsp_session_defineProperty(rtsp_session_assertThisInitialized(_this2), "_renewSessionInterval", void 0);
+
+    _this2._outgoingClosed = false;
+
+    _this2._reset();
+
+    _this2.update(uri, headers, defaultHeaders);
+
+    _this2._sessionControlURL = _this2._controlURL();
+    return _this2;
+  }
+  /**
+   * Update the cached RTSP uri and headers.
+   * @param  uri - The RTSP URI.
+   * @param  headers - Maps commands to headers.
+   * @param  defaultHeaders - Default headers.
+   */
+
+
+  rtsp_session_createClass(RtspSession, [{
+    key: "update",
+    value: function update(uri) {
+      var _Object$assign;
+
+      var headers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
+      var defaultHeaders = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
+
+      if (uri === undefined) {
+        throw new Error('You must supply an uri when creating a RtspSessionComponent');
+      }
+
+      this.uri = uri;
+      this.defaultHeaders = defaultHeaders;
+      this.headers = Object.assign((_Object$assign = {}, rtsp_session_defineProperty(_Object$assign, RTSP_METHOD.OPTIONS, {}), rtsp_session_defineProperty(_Object$assign, RTSP_METHOD.PLAY, {}), rtsp_session_defineProperty(_Object$assign, RTSP_METHOD.SETUP, {
+        Blocksize: '64000'
+      }), rtsp_session_defineProperty(_Object$assign, RTSP_METHOD.DESCRIBE, {
+        Accept: 'application/sdp'
+      }), rtsp_session_defineProperty(_Object$assign, RTSP_METHOD.PAUSE, {}), _Object$assign), headers);
+    }
+    /**
+     * Restore the initial values to the state they were in before any RTSP
+     * connection was made.
+     */
+
+  }, {
+    key: "_reset",
+    value: function _reset() {
+      this._sequence = 1;
+
+      this.retry = function () {
+        return console.error("No request sent, can't retry");
+      };
+
+      this._callStack = [];
+      this._callHistory = [];
+      this._state = rtsp_session_STATE.IDLE;
+      this._waiting = false;
+      this._contentBase = null;
+      this._sessionId = null;
+
+      if (this._renewSessionInterval !== null) {
+        clearInterval(this._renewSessionInterval);
+      }
+
+      this._renewSessionInterval = null;
+      this.t0 = undefined;
+      this.n0 = undefined;
+      this.clockrates = undefined;
+    }
+  }, {
+    key: "_controlURL",
+    value: function _controlURL(attribute) {
+      var _ref, _this$_contentBase;
+
+      if (attribute !== undefined && isAbsolute(attribute)) {
+        return attribute;
+      } // Not defined or not absolute, we need a base URI
+
+
+      var baseURL = (_ref = (_this$_contentBase = this._contentBase) !== null && _this$_contentBase !== void 0 ? _this$_contentBase : this._contentLocation) !== null && _ref !== void 0 ? _ref : this.uri;
+
+      if (baseURL === null || baseURL === undefined) {
+        throw new Error('relative or missing control attribute but no base URL available');
+      }
+
+      if (attribute === undefined || attribute === '*') {
+        return baseURL;
+      }
+
+      return new URL(attribute, baseURL).href;
+    }
+    /**
+     * Handles incoming RTSP messages and send the next command in the queue.
+     * @param  msg - An incoming RTSP message.
+     */
+
+  }, {
+    key: "_onRtsp",
+    value: function _onRtsp(msg) {
+      var _this3 = this;
+
+      this._waiting = false;
+      var status = statusCode(msg.data);
+      var ended = connectionEnded(msg.data);
+      var seq = sequence(msg.data);
+
+      if (seq === null) {
+        throw new Error('rtsp: expected sequence number');
+      }
+
+      if (this._callHistory === undefined) {
+        throw new Error('rtsp: internal error');
+      }
+
+      var method = this._callHistory[seq - 1];
+      browser_default()('msl:rtsp:incoming')("".concat(msg.data));
+
+      if (!this._sessionId && !ended) {
+        // Response on first SETUP
+        this._sessionId = sessionId(msg.data);
+
+        var _sessionTimeout = sessionTimeout(msg.data);
+
+        if (_sessionTimeout !== null) {
+          // The server specified that sessions will timeout if not renewed.
+          // In order to keep it alive we need periodically send a RTSP_OPTIONS message
+          if (this._renewSessionInterval !== null) {
+            clearInterval(this._renewSessionInterval);
+          }
+
+          this._renewSessionInterval = setInterval(function () {
+            _this3._enqueue({
+              method: RTSP_METHOD.OPTIONS
+            });
+
+            _this3._dequeue();
+          }, Math.max(MIN_SESSION_TIMEOUT, _sessionTimeout - 5) * 1000);
+        }
+      }
+
+      if (!this._contentBase) {
+        this._contentBase = contentBase(msg.data);
+      }
+
+      if (!this._contentLocation) {
+        this._contentLocation = contentLocation(msg.data);
+      }
+
+      if (status >= 400) {
+        // TODO: Retry in certain cases?
+        this.onError && this.onError(new RTSPResponseError(msg.data.toString('ascii'), status));
+      }
+
+      if (method === RTSP_METHOD.PLAY) {
+        // When starting to play, send the actual range to an external handler.
+        this.onPlay && this.onPlay(range(msg.data));
+      }
+
+      if (ended) {
+        browser_default()('msl:rtsp:incoming')("RTSP Session ".concat(this._sessionId, " ended with statusCode: ").concat(status));
+        this._sessionId = null;
+      }
+
+      this._dequeue();
+    }
+  }, {
+    key: "_onRtcp",
+    value: function _onRtcp(msg) {
+      if (this.t0 === undefined || this.n0 === undefined) {
+        throw new Error('rtsp: internal error');
+      }
+
+      if (isRtcpSR(msg.rtcp)) {
+        var rtpChannel = msg.channel - 1;
+        this.t0[rtpChannel] = msg.rtcp.rtpTimestamp;
+        this.n0[rtpChannel] = getTime(msg.rtcp.ntpMost, msg.rtcp.ntpLeast);
+      }
+    }
+  }, {
+    key: "_onRtp",
+    value: function _onRtp(msg) {
+      if (this.t0 === undefined || this.n0 === undefined || this.clockrates === undefined) {
+        throw new Error('rtsp: internal error');
+      }
+
+      var rtpChannel = msg.channel;
+      var t0 = this.t0[rtpChannel];
+      var n0 = this.n0[rtpChannel];
+
+      if (typeof t0 !== 'undefined' && typeof n0 !== 'undefined') {
+        var clockrate = this.clockrates[rtpChannel];
+        var t = timestamp(msg.data); // The RTP timestamps are unsigned 32 bit and will overflow
+        // at some point. We can guard against the overflow by ORing with 0,
+        // which will bring any difference back into signed 32-bit domain.
+
+        var dt = t - t0 | 0;
+        msg.ntpTimestamp = dt / clockrate * 1000 + n0;
+      }
+    }
+    /**
+     * Handles incoming SDP messages, reply with SETUP and optionally PLAY.
+     * @param  msg - An incoming SDP message.
+     */
+
+  }, {
+    key: "_onSdp",
+    value: function _onSdp(msg) {
+      var _this4 = this;
+
+      this.n0 = {};
+      this.t0 = {};
+      this.clockrates = {};
+      this._sessionControlURL = this._controlURL(msg.sdp.session.control);
+      msg.sdp.media.forEach(function (media, index) {
+        // We should actually be able to handle
+        // non-dynamic payload types, but ignored for now.
+        if (media.rtpmap === undefined) {
+          return;
+        }
+
+        var clockrate = media.rtpmap.clockrate;
+        var rtp = index * 2;
+        var rtcp = rtp + 1;
+        var uri = media.control === undefined ? _this4._sessionControlURL : _this4._controlURL(media.control);
+
+        _this4._enqueue({
+          method: RTSP_METHOD.SETUP,
+          headers: {
+            Transport: 'RTP/AVP/TCP;unicast;interleaved=' + rtp + '-' + rtcp
+          },
+          uri: uri
+        }); // TODO: see if we can get rid of this check somehow
+
+
+        if (_this4.clockrates === undefined) {
+          return;
+        }
+
+        _this4.clockrates[rtp] = clockrate;
+      });
+
+      if (this._state === rtsp_session_STATE.PLAYING) {
+        this._enqueue({
+          method: RTSP_METHOD.PLAY,
+          headers: {
+            Range: "npt=".concat(this.startTime || 0, "-")
+          },
+          uri: this._sessionControlURL
+        });
+      }
+
+      this._dequeue();
+    }
+    /**
+     * Set up command queue in order to start playing, i.e. PLAY optionally
+     * preceeded by OPTIONS/DESCRIBE commands. If not waiting, immediately
+     * start sending.
+     * @param  startTime - Time (seconds) at which to start playing
+     */
+
+  }, {
+    key: "play",
+    value: function play() {
+      var startTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
+
+      if (this._state === rtsp_session_STATE.IDLE) {
+        this.startTime = Number(startTime) || 0;
+
+        this._enqueue({
+          method: RTSP_METHOD.OPTIONS
+        });
+
+        this._enqueue({
+          method: RTSP_METHOD.DESCRIBE
+        });
+      } else if (this._state === rtsp_session_STATE.PAUSED) {
+        if (this._sessionId === null || this._sessionId === undefined) {
+          throw new Error('rtsp: internal error');
+        }
+
+        this._enqueue({
+          method: RTSP_METHOD.PLAY,
+          headers: {
+            Session: this._sessionId
+          },
+          uri: this._sessionControlURL
+        });
+      }
+
+      this._state = rtsp_session_STATE.PLAYING;
+
+      this._dequeue();
+    }
+    /**
+     * Queue a pause command, and send if not waiting.
+     * @return {undefined}
+     */
+
+  }, {
+    key: "pause",
+    value: function pause() {
+      this._enqueue({
+        method: RTSP_METHOD.PAUSE
+      });
+
+      this._state = rtsp_session_STATE.PAUSED;
+
+      this._dequeue();
+    }
+    /**
+     * End the session if there is one, otherwise just cancel
+     * any outstanding calls on the stack.
+     * @return {undefined}
+     */
+
+  }, {
+    key: "stop",
+    value: function stop() {
+      if (this._sessionId) {
+        this._enqueue({
+          method: RTSP_METHOD.TEARDOWN
+        });
+      } else {
+        this._callStack = [];
+      }
+
+      this._state = rtsp_session_STATE.IDLE;
+
+      if (this._renewSessionInterval !== null) {
+        clearInterval(this._renewSessionInterval);
+        this._renewSessionInterval = null;
+      }
+
+      this._dequeue();
+    }
+    /**
+     * Pushes an RTSP request onto the outgoing stream.
+     * @param  cmd - The details about the command to send.
+     */
+
+  }, {
+    key: "send",
+    value: function send(cmd) {
+      var method = cmd.method,
+          headers = cmd.headers,
+          uri = cmd.uri;
+
+      if (method === undefined) {
+        throw new Error('missing method when send request');
+      }
+
+      this._waiting = true;
+      this.retry = this.send.bind(this, cmd);
+
+      if (this._sequence === undefined || this.headers === undefined || this._callHistory === undefined) {
+        throw new Error('rtsp: internal error');
+      }
+
+      var message = Object.assign({
+        type: MessageType.RTSP,
+        uri: uri || this._sessionControlURL,
+        data: rtsp_session_Buffer.alloc(0) // data is a mandatory field. Not used by session -> parser messages.
+
+      }, {
+        method: method,
+        headers: headers
+      }, {
+        headers: Object.assign({
+          CSeq: this._sequence++
+        }, this.defaultHeaders, // default headers (for all methods)
+        this.headers[method], // preset headers for this method
+        headers // headers that came with the invokation
+        )
+      });
+      this._sessionId && (message.headers.Session = this._sessionId);
+
+      this._callHistory.push(method);
+
+      if (!this._outgoingClosed) {
+        this.outgoing.push(message);
+      } else {
+        // If the socket is closed, dont attempt to send any data
+        browser_default()('msl:rtsp:outgoing')("Unable to send ".concat(method, ", connection closed"));
+      }
+    }
+    /**
+     * Push a command onto the call stack.
+     * @param  cmd - The command to queue
+     */
+
+  }, {
+    key: "_enqueue",
+    value: function _enqueue(cmd) {
+      if (this._callStack === undefined) {
+        throw new Error('rtsp: internal error');
+      }
+
+      this._callStack.push(cmd);
+    }
+    /**
+     * If possible, send the next command on the call stack.
+     */
+
+  }, {
+    key: "_dequeue",
+    value: function _dequeue() {
+      if (this._callStack === undefined) {
+        throw new Error('rtsp: internal error');
+      }
+
+      if (!this._waiting && this._callStack.length > 0) {
+        var cmd = this._callStack.shift();
+
+        if (cmd !== undefined) {
+          this.send(cmd);
+        }
+      }
+    }
+  }]);
+
+  return RtspSession;
+}(Tube);
+;// CONCATENATED MODULE: ./lib/components/ws-source/openwebsocket.ts
+
+
+function openwebsocket_asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
+
+function openwebsocket_asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { openwebsocket_asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { openwebsocket_asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
+
+
+
+
+
+ // Time in milliseconds we want to wait for a websocket to open
+
+var WEBSOCKET_TIMEOUT = 10007;
+
+// Default configuration
+var openwebsocket_defaultConfig = function defaultConfig() {
+  var host = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window.location.host;
+  var scheme = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window.location.protocol;
+  var wsScheme = scheme === 'https:' ? 'wss:' : 'ws:';
+  return {
+    uri: "".concat(wsScheme, "//").concat(host, "/rtsp-over-websocket"),
+    tokenUri: "".concat(scheme, "//").concat(host, "/axis-cgi/rtspwssession.cgi"),
+    protocol: 'binary',
+    timeout: WEBSOCKET_TIMEOUT
+  };
+};
+/**
+ * Open a new WebSocket, fallback to token-auth on failure and retry.
+ * @param  [config]  WebSocket configuration.
+ * @param  [config.host]  Specify different host
+ * @param  [config.sheme]  Specify different scheme.
+ * @param  [config.uri]  Full uri for websocket connection
+ * @param  [config.tokenUri]  Full uri for token API
+ * @param  [config.protocol] Websocket protocol
+ * @param  [config.timeout] Websocket connection timeout
+ */
+
+
+var openWebSocket = /*#__PURE__*/function () {
+  var _ref = openwebsocket_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
+    var config,
+        _merge,
+        uri,
+        tokenUri,
+        protocol,
+        timeout,
+        _args = arguments;
+
+    return regeneratorRuntime.wrap(function _callee$(_context) {
+      while (1) {
+        switch (_context.prev = _context.next) {
+          case 0:
+            config = _args.length > 0 && _args[0] !== undefined ? _args[0] : {};
+            _merge = merge(openwebsocket_defaultConfig(config.host, config.scheme), config), uri = _merge.uri, tokenUri = _merge.tokenUri, protocol = _merge.protocol, timeout = _merge.timeout;
+
+            if (!(uri === undefined)) {
+              _context.next = 4;
+              break;
+            }
+
+            throw new Error('ws: internal error');
+
+          case 4:
+            _context.next = 6;
+            return new Promise(function (resolve, reject) {
+              try {
+                var ws = new WebSocket(uri, protocol);
+                var countdown = setTimeout(function () {
+                  clearTimeout(countdown);
+
+                  if (ws.readyState === WebSocket.CONNECTING) {
+                    ws.onerror = null;
+                    reject(new Error('websocket connection timed out'));
+                  }
+                }, timeout);
+                ws.binaryType = 'arraybuffer';
+
+                ws.onerror = function (originalError) {
+                  clearTimeout(countdown); // try fetching an authentication token
+
+                  // try fetching an authentication token
+                  function onLoadToken() {
+                    if (this.status >= 400) {
+                      console.warn('failed to load token', this.status, this.responseText);
+                      reject(originalError);
+                      return;
+                    }
+
+                    var token = this.responseText.trim(); // We have a token! attempt to open a WebSocket again.
+
+                    // We have a token! attempt to open a WebSocket again.
+                    var newUri = "".concat(uri, "?rtspwssession=").concat(token);
+                    var ws2 = new WebSocket(newUri, protocol);
+                    ws2.binaryType = 'arraybuffer';
+
+                    ws2.onerror = function (err) {
+                      reject(err);
+                    };
+
+                    ws2.onopen = function () {
+                      return resolve(ws2);
+                    };
+                  }
+
+                  var request = new XMLHttpRequest();
+                  request.addEventListener('load', onLoadToken);
+                  request.addEventListener('error', function (err) {
+                    console.warn('failed to get token');
+                    reject(err);
+                  });
+                  request.addEventListener('abort', function () {
+                    return reject(originalError);
+                  });
+                  request.open('GET', "".concat(tokenUri, "?").concat(Date.now()));
+
+                  try {
+                    request.send();
+                  } catch (error) {
+                    reject(originalError);
+                  }
+                };
+
+                ws.onopen = function () {
+                  clearTimeout(countdown);
+                  resolve(ws);
+                };
+              } catch (e) {
+                reject(e);
+              }
+            });
+
+          case 6:
+            return _context.abrupt("return", _context.sent);
+
+          case 7:
+          case "end":
+            return _context.stop();
+        }
+      }
+    }, _callee);
+  }));
+
+  return function openWebSocket() {
+    return _ref.apply(this, arguments);
+  };
+}();
+;// CONCATENATED MODULE: ./lib/components/ws-source/index.ts
+/* provided dependency */ var ws_source_Buffer = __webpack_require__(7866)["Buffer"];
+function ws_source_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { ws_source_typeof = function _typeof(obj) { return typeof obj; }; } else { ws_source_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return ws_source_typeof(obj); }
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+function ws_source_asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
+
+function ws_source_asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { ws_source_asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { ws_source_asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
+
+function ws_source_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
+
+function ws_source_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
+
+function ws_source_createClass(Constructor, protoProps, staticProps) { if (protoProps) ws_source_defineProperties(Constructor.prototype, protoProps); if (staticProps) ws_source_defineProperties(Constructor, staticProps); return Constructor; }
+
+function ws_source_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) ws_source_setPrototypeOf(subClass, superClass); }
+
+function ws_source_setPrototypeOf(o, p) { ws_source_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return ws_source_setPrototypeOf(o, p); }
+
+function ws_source_createSuper(Derived) { var hasNativeReflectConstruct = ws_source_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = ws_source_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = ws_source_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return ws_source_possibleConstructorReturn(this, result); }; }
+
+function ws_source_possibleConstructorReturn(self, call) { if (call && (ws_source_typeof(call) === "object" || typeof call === "function")) { return call; } return ws_source_assertThisInitialized(self); }
+
+function ws_source_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
+
+function ws_source_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
+
+function ws_source_getPrototypeOf(o) { ws_source_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return ws_source_getPrototypeOf(o); }
+
+function ws_source_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+
+
+
+
+ // Named status codes for CloseEvent, see:
+// https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent
+
+var CLOSE_GOING_AWAY = 1001;
+var WSSource = /*#__PURE__*/function (_Source) {
+  ws_source_inherits(WSSource, _Source);
+
+  var _super = ws_source_createSuper(WSSource);
+
+  /**
+   * Create a WebSocket component.
+   *
+   * The constructor sets up two streams and connects them to the socket as
+   * soon as the socket is available (and open).
+   *
+   * @param socket - an open WebSocket.
+   */
+  function WSSource(socket) {
+    var _this;
+
+    ws_source_classCallCheck(this, WSSource);
+
+    if (socket === undefined) {
+      throw new Error('socket argument missing');
+    }
+    /**
+     * Set up an incoming stream and attach it to the socket.
+     * @type {Readable}
+     */
+
+
+    var incoming = new stream_browserify.Readable({
+      objectMode: true,
+      read: function read() {//
+      }
+    });
+
+    socket.onmessage = function (msg) {
+      var buffer = ws_source_Buffer.from(msg.data);
+
+      if (!incoming.push({
+        data: buffer,
+        type: MessageType.RAW
+      })) {
+        // Something happened down stream that it is no longer processing the
+        // incoming data, and the stream buffer got full. In this case it is
+        // best to just close the socket instead of throwing away data in the
+        // hope that the situation will get resolved.
+        if (socket.readyState === WebSocket.OPEN) {
+          browser_default()('msl:websocket:incoming')('downstream frozen');
+          socket.close();
+        }
+      }
+    }; // When an error is sent on the incoming stream, close the socket.
+
+
+    incoming.on('error', function (e) {
+      console.warn('closing socket due to incoming error', e);
+      socket.close();
+    });
+    /**
+     * Set up outgoing stream and attach it to the socket.
+     * @type {Writable}
+     */
+
+    var outgoing = new stream_browserify.Writable({
+      objectMode: true,
+      write: function write(msg, encoding, callback) {
+        try {
+          socket.send(msg.data);
+        } catch (e) {
+          console.warn('message lost during send:', msg);
+        }
+
+        callback();
+      }
+    }); // When an error happens on the outgoing stream, just warn.
+
+    outgoing.on('error', function (e) {
+      console.warn('error during websocket send, ignoring:', e);
+    }); // When there is no more data going to be written, close!
+
+    outgoing.on('finish', function () {
+      browser_default()('msl:websocket:outgoing')('finish');
+
+      if (socket.readyState !== WebSocket.CLOSED) {
+        socket.close();
+      }
+    });
+    /**
+     * Handler for when WebSocket is CLOSED
+     * @param  e - The event associated with a close
+     * @param  e.code The status code sent by the server
+     *   Possible codes are documented here:
+     *   https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent
+     */
+
+    socket.onclose = function (e) {
+      browser_default()('msl:websocket:close')("".concat(e.code));
+
+      if (e.code === CLOSE_GOING_AWAY) {
+        _this.onServerClose && _this.onServerClose();
+      } // Terminate the streams.
+
+
+      incoming.push(null);
+      outgoing.end();
+    };
+    /**
+     * initialize the component.
+     */
+
+
+    _this = _super.call(this, incoming, outgoing);
+
+    ws_source_defineProperty(ws_source_assertThisInitialized(_this), "onServerClose", void 0);
+
+    return _this;
+  }
+  /**
+   * Expose websocket opener as a class method that returns a promise which
+   * resolves with a new WebSocketComponent.
+   */
+
+
+  ws_source_createClass(WSSource, null, [{
+    key: "open",
+    value: function () {
+      var _open = ws_source_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(config) {
+        return regeneratorRuntime.wrap(function _callee$(_context) {
+          while (1) {
+            switch (_context.prev = _context.next) {
+              case 0:
+                _context.next = 2;
+                return openWebSocket(config).then(function (socket) {
+                  return new WSSource(socket);
+                });
+
+              case 2:
+                return _context.abrupt("return", _context.sent);
+
+              case 3:
+              case "end":
+                return _context.stop();
+            }
+          }
+        }, _callee);
+      }));
+
+      function open(_x) {
+        return _open.apply(this, arguments);
+      }
+
+      return open;
+    }()
+  }]);
+
+  return WSSource;
+}(Source);
+;// CONCATENATED MODULE: ./lib/components/index.browser.ts
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+// EXTERNAL MODULE: ./.yarn/unplugged/core-js-npm-3.16.2-c7ce9e8d48/node_modules/core-js/modules/es.set.js
+var es_set = __webpack_require__(461);
+;// CONCATENATED MODULE: ./lib/pipelines/pipeline.ts
+
+
+
+
+
+
+
+
+function pipeline_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
+
+function pipeline_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
+
+function pipeline_createClass(Constructor, protoProps, staticProps) { if (protoProps) pipeline_defineProperties(Constructor.prototype, protoProps); if (staticProps) pipeline_defineProperties(Constructor, staticProps); return Constructor; }
+
+function pipeline_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+/**
+ * Pipeline
+ *
+ * A pipeline is a linked list of components with some convenience methods to
+ * handle inserting or removing components from the linked list.
+ *
+ * A internal set keeps track of which components the pipeline contains, while
+ * any order is completely determined by the component's connectedness.
+ */
+var Pipeline = /*#__PURE__*/function () {
+  /**
+   * @param components - The components of the pipeline in order.
+   */
+  function Pipeline() {
+    pipeline_classCallCheck(this, Pipeline);
+
+    pipeline_defineProperty(this, "firstComponent", void 0);
+
+    pipeline_defineProperty(this, "lastComponent", void 0);
+
+    pipeline_defineProperty(this, "_set", void 0);
+
+    for (var _len = arguments.length, components = new Array(_len), _key = 0; _key < _len; _key++) {
+      components[_key] = arguments[_key];
+    }
+
+    var car = components[0],
+        cdr = components.slice(1);
+    this._set = new Set(components);
+    this.firstComponent = car;
+    this.lastComponent = cdr.reduce(function (last, component) {
+      return last.connect(component);
+    }, car);
+  }
+  /**
+   * @param components - The components of the pipeline in order.
+   */
+
+
+  pipeline_createClass(Pipeline, [{
+    key: "init",
+    value: function init() {
+      for (var _len2 = arguments.length, components = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
+        components[_key2] = arguments[_key2];
+      }
+
+      var car = components[0],
+          cdr = components.slice(1);
+      this._set = new Set(components);
+      this.firstComponent = car;
+      this.lastComponent = cdr.reduce(function (last, component) {
+        return last.connect(component);
+      }, car);
+    }
+    /**
+     * Inserts a component into the pipeline.
+     *
+     * @param component - Tube or Source behind which to insert a new component.
+     * @param component - Tube or Sink to insert.
+     */
+
+  }, {
+    key: "insertAfter",
+    value: function insertAfter(component, newComponent) {
+      if (!this._set.has(component)) {
+        throw new Error('insertion point not part of pipeline');
+      }
+
+      if (this._set.has(newComponent)) {
+        throw new Error('new component already in the pipeline');
+      }
+
+      var cdr = component.next;
+
+      if (cdr === null) {
+        component.connect(newComponent);
+        this.lastComponent = newComponent;
+      } else {
+        component.disconnect();
+        component.connect(newComponent).connect(cdr);
+      }
+
+      this._set.add(newComponent);
+
+      return this;
+    }
+    /**
+     * Inserts a component into the pipeline.
+     *
+     * @param component - Tube or Sink in front of which to insert a new component.
+     * @param component - Tube or Source to insert.
+     */
+
+  }, {
+    key: "insertBefore",
+    value: function insertBefore(component, newComponent) {
+      if (!this._set.has(component)) {
+        throw new Error('insertion point not part of pipeline');
+      }
+
+      if (this._set.has(newComponent)) {
+        throw new Error('new component already in the pipeline');
+      }
+
+      var car = component.prev;
+
+      if (car === null) {
+        newComponent.connect(component);
+        this.firstComponent = newComponent;
+      } else {
+        car.disconnect();
+        car.connect(newComponent).connect(component);
+      }
+
+      this._set.add(newComponent);
+
+      return this;
+    }
+    /**
+     * Removes a component from the pipeline.
+     *
+     * @param component - Component to remove.
+     */
+
+  }, {
+    key: "remove",
+    value: function remove(component) {
+      if (!this._set.has(component)) {
+        throw new Error('component not part of pipeline');
+      }
+
+      var car = component.prev;
+      var cdr = component.next;
+
+      if (car === null && cdr === null) {
+        throw new Error('cannot remove last component');
+      } else if (car === null && cdr !== null) {
+        component.disconnect();
+        this.firstComponent = cdr;
+      } else if (car !== null && cdr === null) {
+        car.disconnect();
+        this.lastComponent = car;
+      } else if (car !== null && cdr !== null) {
+        car.disconnect();
+        component.disconnect();
+        car.connect(cdr);
+      }
+
+      this._set.delete(component);
+
+      return this;
+    }
+    /**
+     * Inserts a component at the end of the pipeline.
+     *
+     * @param component - Tube or Sink to insert.
+     */
+
+  }, {
+    key: "append",
+    value: function append() {
+      var _this = this;
+
+      for (var _len3 = arguments.length, components = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
+        components[_key3] = arguments[_key3];
+      }
+
+      components.forEach(function (component) {
+        _this.insertAfter(_this.lastComponent, component);
+      });
+      return this;
+    }
+    /**
+     * Inserts a component at the beginning of the pipeline.
+     *
+     * @param component - Tube or Source to insert.
+     */
+
+  }, {
+    key: "prepend",
+    value: function prepend() {
+      var _this2 = this;
+
+      for (var _len4 = arguments.length, components = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
+        components[_key4] = arguments[_key4];
+      }
+
+      components.forEach(function (component) {
+        _this2.insertBefore(_this2.firstComponent, component);
+      });
+      return this;
+    }
+  }]);
+
+  return Pipeline;
+}();
+;// CONCATENATED MODULE: ./lib/pipelines/rtsp-pipeline.ts
+function rtsp_pipeline_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { rtsp_pipeline_typeof = function _typeof(obj) { return typeof obj; }; } else { rtsp_pipeline_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return rtsp_pipeline_typeof(obj); }
+
+
+
+
+
+
+
+
+
+
+
+
+function rtsp_pipeline_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
+
+function rtsp_pipeline_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) rtsp_pipeline_setPrototypeOf(subClass, superClass); }
+
+function rtsp_pipeline_setPrototypeOf(o, p) { rtsp_pipeline_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return rtsp_pipeline_setPrototypeOf(o, p); }
+
+function rtsp_pipeline_createSuper(Derived) { var hasNativeReflectConstruct = rtsp_pipeline_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = rtsp_pipeline_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = rtsp_pipeline_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return rtsp_pipeline_possibleConstructorReturn(this, result); }; }
+
+function rtsp_pipeline_possibleConstructorReturn(self, call) { if (call && (rtsp_pipeline_typeof(call) === "object" || typeof call === "function")) { return call; } return rtsp_pipeline_assertThisInitialized(self); }
+
+function rtsp_pipeline_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
+
+function rtsp_pipeline_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
+
+function rtsp_pipeline_getPrototypeOf(o) { rtsp_pipeline_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return rtsp_pipeline_getPrototypeOf(o); }
+
+function rtsp_pipeline_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+
+
+
+
+/**
+ * RtspPipeline
+ *
+ * A pipeline that converts interleaved RTSP/RTP into a series of RTP, RTCP, and
+ * RTSP packets.  The pipeline exposes the RTSP session component as
+ * `this.session`, and wraps its play, pause and stop methods.
+ *
+ * The following handlers can be defined:
+ * - onSdp: called when the session descript protocol is available, with the SDP
+ *   object as argument
+ * - onPlay: called when a response from the PLAY command arrives, with the play
+ *   range as argument
+ */
+var RtspPipeline = /*#__PURE__*/function (_Pipeline) {
+  rtsp_pipeline_inherits(RtspPipeline, _Pipeline);
+
+  var _super = rtsp_pipeline_createSuper(RtspPipeline);
+
+  function RtspPipeline(rtspConfig) {
+    var _this;
+
+    rtsp_pipeline_classCallCheck(this, RtspPipeline);
+
+    var rtspParser = new RtspParser();
+    var rtspSession = new RtspSession(rtspConfig);
+
+    rtspSession.onSdp = function (sdp) {
+      _this.onSdp && _this.onSdp(sdp);
+    };
+
+    rtspSession.onPlay = function (range) {
+      _this.onPlay && _this.onPlay(range);
+    };
+
+    _this = _super.call(this, rtspParser, rtspSession); // Expose session for external use
+
+    rtsp_pipeline_defineProperty(rtsp_pipeline_assertThisInitialized(_this), "onSdp", void 0);
+
+    rtsp_pipeline_defineProperty(rtsp_pipeline_assertThisInitialized(_this), "onPlay", void 0);
+
+    rtsp_pipeline_defineProperty(rtsp_pipeline_assertThisInitialized(_this), "rtsp", void 0);
+
+    _this.rtsp = rtspSession;
+    return _this;
+  }
+
+  return RtspPipeline;
+}(Pipeline);
+;// CONCATENATED MODULE: ./lib/pipelines/rtsp-mp4-pipeline.ts
+function rtsp_mp4_pipeline_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { rtsp_mp4_pipeline_typeof = function _typeof(obj) { return typeof obj; }; } else { rtsp_mp4_pipeline_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return rtsp_mp4_pipeline_typeof(obj); }
+
+
+
+
+
+
+
+
+
+
+
+
+function rtsp_mp4_pipeline_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
+
+function rtsp_mp4_pipeline_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
+
+function rtsp_mp4_pipeline_createClass(Constructor, protoProps, staticProps) { if (protoProps) rtsp_mp4_pipeline_defineProperties(Constructor.prototype, protoProps); if (staticProps) rtsp_mp4_pipeline_defineProperties(Constructor, staticProps); return Constructor; }
+
+function rtsp_mp4_pipeline_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) rtsp_mp4_pipeline_setPrototypeOf(subClass, superClass); }
+
+function rtsp_mp4_pipeline_setPrototypeOf(o, p) { rtsp_mp4_pipeline_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return rtsp_mp4_pipeline_setPrototypeOf(o, p); }
+
+function rtsp_mp4_pipeline_createSuper(Derived) { var hasNativeReflectConstruct = rtsp_mp4_pipeline_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = rtsp_mp4_pipeline_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = rtsp_mp4_pipeline_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return rtsp_mp4_pipeline_possibleConstructorReturn(this, result); }; }
+
+function rtsp_mp4_pipeline_possibleConstructorReturn(self, call) { if (call && (rtsp_mp4_pipeline_typeof(call) === "object" || typeof call === "function")) { return call; } return rtsp_mp4_pipeline_assertThisInitialized(self); }
+
+function rtsp_mp4_pipeline_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
+
+function rtsp_mp4_pipeline_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
+
+function rtsp_mp4_pipeline_getPrototypeOf(o) { rtsp_mp4_pipeline_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return rtsp_mp4_pipeline_getPrototypeOf(o); }
+
+function rtsp_mp4_pipeline_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+
+
+
+
+/**
+ * RtspMp4Pipeline
+ *
+ * A pipeline that can process H264/AAC RTP data, and converts it to streaming
+ * MP4 format (ISO BMFF bytestream).
+ *
+ * The following handlers can be defined:
+ * - all handlers from the RtspPipeline
+ * - `onSync`: called when the NTP time of the first frame is known, with the
+ *   timestamp as argument (the timestamp is UNIX milliseconds)
+ */
+
+var RtspMp4Pipeline = /*#__PURE__*/function (_RtspPipeline) {
+  rtsp_mp4_pipeline_inherits(RtspMp4Pipeline, _RtspPipeline);
+
+  var _super = rtsp_mp4_pipeline_createSuper(RtspMp4Pipeline);
+
+  function RtspMp4Pipeline(rtspConfig) {
+    var _this;
+
+    rtsp_mp4_pipeline_classCallCheck(this, RtspMp4Pipeline);
+
+    _this = _super.call(this, rtspConfig);
+
+    rtsp_mp4_pipeline_defineProperty(rtsp_mp4_pipeline_assertThisInitialized(_this), "onSync", void 0);
+
+    rtsp_mp4_pipeline_defineProperty(rtsp_mp4_pipeline_assertThisInitialized(_this), "_mp4Muxer", void 0);
+
+    var h264Depay = new H264Depay();
+    var aacDepay = new AACDepay();
+    var mp4Muxer = new Mp4Muxer();
+
+    mp4Muxer.onSync = function (ntpPresentationTime) {
+      _this.onSync && _this.onSync(ntpPresentationTime);
+    };
+
+    _this.append(h264Depay, aacDepay, mp4Muxer);
+
+    _this._mp4Muxer = mp4Muxer;
+    return _this;
+  }
+
+  rtsp_mp4_pipeline_createClass(RtspMp4Pipeline, [{
+    key: "bitrate",
+    get: function get() {
+      return this._mp4Muxer.bitrate;
+    }
+  }, {
+    key: "framerate",
+    get: function get() {
+      return this._mp4Muxer.framerate;
+    }
+  }]);
+
+  return RtspMp4Pipeline;
+}(RtspPipeline);
+;// CONCATENATED MODULE: ./lib/pipelines/rtsp-mjpeg-pipeline.ts
+function rtsp_mjpeg_pipeline_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { rtsp_mjpeg_pipeline_typeof = function _typeof(obj) { return typeof obj; }; } else { rtsp_mjpeg_pipeline_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return rtsp_mjpeg_pipeline_typeof(obj); }
+
+
+
+
+
+
+
+
+
+
+
+
+function rtsp_mjpeg_pipeline_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
+
+function rtsp_mjpeg_pipeline_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) rtsp_mjpeg_pipeline_setPrototypeOf(subClass, superClass); }
+
+function rtsp_mjpeg_pipeline_setPrototypeOf(o, p) { rtsp_mjpeg_pipeline_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return rtsp_mjpeg_pipeline_setPrototypeOf(o, p); }
+
+function rtsp_mjpeg_pipeline_createSuper(Derived) { var hasNativeReflectConstruct = rtsp_mjpeg_pipeline_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = rtsp_mjpeg_pipeline_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = rtsp_mjpeg_pipeline_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return rtsp_mjpeg_pipeline_possibleConstructorReturn(this, result); }; }
+
+function rtsp_mjpeg_pipeline_possibleConstructorReturn(self, call) { if (call && (rtsp_mjpeg_pipeline_typeof(call) === "object" || typeof call === "function")) { return call; } return rtsp_mjpeg_pipeline_assertThisInitialized(self); }
+
+function rtsp_mjpeg_pipeline_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
+
+function rtsp_mjpeg_pipeline_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
+
+function rtsp_mjpeg_pipeline_getPrototypeOf(o) { rtsp_mjpeg_pipeline_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return rtsp_mjpeg_pipeline_getPrototypeOf(o); }
+
+
+
+/**
+ * RtspMjpegPipeline
+ *
+ * A pipeline that can process JPEG RTP data, and converts it to streaming
+ * motion JPEG format (sequence of JPEG images).
+ *
+ * The following handlers can be defined:
+ * - all handlers from the RtspPipeline
+ */
+
+var RtspMjpegPipeline = /*#__PURE__*/function (_RtspPipeline) {
+  rtsp_mjpeg_pipeline_inherits(RtspMjpegPipeline, _RtspPipeline);
+
+  var _super = rtsp_mjpeg_pipeline_createSuper(RtspMjpegPipeline);
+
+  function RtspMjpegPipeline(rtspConfig) {
+    var _this;
+
+    rtsp_mjpeg_pipeline_classCallCheck(this, RtspMjpegPipeline);
+
+    _this = _super.call(this, rtspConfig);
+    var jpegDepay = new JPEGDepay();
+
+    _this.append(jpegDepay);
+
+    return _this;
+  }
+
+  return RtspMjpegPipeline;
+}(RtspPipeline);
+// EXTERNAL MODULE: ./.yarn/cache/ts-md5-npm-1.2.9-8ae03cfacf-e631e781a3.zip/node_modules/ts-md5/dist/md5.js
+var md5 = __webpack_require__(2993);
+;// CONCATENATED MODULE: ./lib/components/auth/digest.ts
+
+
+
+
+
+
+
+
+
+
+
+function digest_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
+
+function digest_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+// https://tools.ietf.org/html/rfc2617#section-3.2.1
+
+var DigestAuth = function DigestAuth(params, username, password) {
+  var _this = this;
+
+  digest_classCallCheck(this, DigestAuth);
+
+  digest_defineProperty(this, "realm", void 0);
+
+  digest_defineProperty(this, "nonce", void 0);
+
+  digest_defineProperty(this, "opaque", void 0);
+
+  digest_defineProperty(this, "algorithm", void 0);
+
+  digest_defineProperty(this, "qop", void 0);
+
+  digest_defineProperty(this, "username", void 0);
+
+  digest_defineProperty(this, "ha1Base", void 0);
+
+  digest_defineProperty(this, "count", void 0);
+
+  digest_defineProperty(this, "nc", function () {
+    ++_this.count;
+    return _this.count.toString(16).padStart(8, '0');
+  });
+
+  digest_defineProperty(this, "cnonce", function () {
+    return new Array(4).fill(0).map(function () {
+      return Math.floor(Math.random() * 256);
+    }).map(function (n) {
+      return n.toString(16);
+    }).join('');
+  });
+
+  digest_defineProperty(this, "ha1", function (cnonce) {
+    var ha1 = _this.ha1Base;
+
+    if (_this.algorithm === 'md5-sess') {
+      ha1 = new md5/* Md5 */.V().appendStr("".concat(ha1, ":").concat(_this.nonce, ":").concat(cnonce)).end().toString();
+    }
+
+    return ha1;
+  });
+
+  digest_defineProperty(this, "ha2", function (method, uri) {
+    var body = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
+    var ha2 = new md5/* Md5 */.V().appendStr("".concat(method, ":").concat(uri)).end().toString();
+
+    if (_this.algorithm === 'md5-sess') {
+      var hbody = new md5/* Md5 */.V().appendStr(body).end().toString();
+      ha2 = new md5/* Md5 */.V().appendStr("".concat(method, ":").concat(uri, ":").concat(hbody)).end().toString();
+    }
+
+    return ha2;
+  });
+
+  digest_defineProperty(this, "authorization", function () {
+    var method = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'GET';
+    var uri = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
+    var body = arguments.length > 2 ? arguments[2] : undefined;
+
+    // Increase count
+    var nc = _this.nc();
+
+    var cnonce = _this.cnonce();
+
+    var ha1 = _this.ha1(cnonce);
+
+    var ha2 = _this.ha2(method, uri, body);
+
+    var response = _this.qop === undefined ? new md5/* Md5 */.V().appendStr("".concat(ha1, ":").concat(_this.nonce, ":").concat(ha2)).end().toString() : new md5/* Md5 */.V().appendStr("".concat(ha1, ":").concat(_this.nonce, ":").concat(nc, ":").concat(cnonce, ":").concat(_this.qop, ":").concat(ha2)).end().toString();
+    var authorizationParams = [];
+    authorizationParams.push("username=\"".concat(_this.username, "\""));
+    authorizationParams.push("realm=\"".concat(_this.realm, "\""));
+    authorizationParams.push("nonce=\"".concat(_this.nonce, "\""));
+    authorizationParams.push("uri=\"".concat(uri, "\""));
+
+    if (_this.qop !== undefined) {
+      authorizationParams.push("qop=".concat(_this.qop));
+      authorizationParams.push("nc=".concat(nc));
+      authorizationParams.push("cnonce=\"".concat(cnonce, "\""));
+    }
+
+    authorizationParams.push("response=\"".concat(response, "\""));
+
+    if (_this.opaque !== undefined) {
+      authorizationParams.push("opaque=\"".concat(_this.opaque, "\""));
+    }
+
+    return "Digest ".concat(authorizationParams.join(', '));
+  });
+
+  var realm = params.get('realm');
+
+  if (realm === undefined) {
+    throw new Error('no realm in digest challenge');
+  }
+
+  this.realm = realm;
+  this.ha1Base = new md5/* Md5 */.V().appendStr("".concat(username, ":").concat(realm, ":").concat(password)).end().toString();
+  var nonce = params.get('nonce');
+
+  if (nonce === undefined) {
+    throw new Error('no nonce in digest challenge');
+  }
+
+  this.nonce = nonce;
+  this.opaque = params.get('opaque');
+  var algorithm = params.get('algorithm');
+
+  if (algorithm !== undefined) {
+    if (algorithm === 'md5') {
+      this.algorithm = 'md5';
+    } else if (algorithm === 'md5-sess') {
+      this.algorithm = 'md5-sess';
+    }
+  } else {
+    this.algorithm = 'md5';
+  }
+
+  var qop = params.get('qop');
+
+  if (qop !== undefined) {
+    var possibleQops = qop.split(',').map(function (qopType) {
+      return qopType.trim();
+    });
+
+    if (possibleQops.some(function (qopValue) {
+      return qopValue === 'auth';
+    })) {
+      this.qop = 'auth';
+    } else if (possibleQops.some(function (qopValue) {
+      return qopValue === 'auth-int';
+    })) {
+      this.qop = 'auth-int';
+    }
+  }
+
+  this.count = 0;
+  this.username = username;
+};
+;// CONCATENATED MODULE: ./lib/components/auth/www-authenticate.ts
+function www_authenticate_slicedToArray(arr, i) { return www_authenticate_arrayWithHoles(arr) || www_authenticate_iterableToArrayLimit(arr, i) || www_authenticate_unsupportedIterableToArray(arr, i) || www_authenticate_nonIterableRest(); }
+
+function www_authenticate_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+function www_authenticate_toArray(arr) { return www_authenticate_arrayWithHoles(arr) || www_authenticate_iterableToArray(arr) || www_authenticate_unsupportedIterableToArray(arr) || www_authenticate_nonIterableRest(); }
+
+function www_authenticate_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
+
+function www_authenticate_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return www_authenticate_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return www_authenticate_arrayLikeToArray(o, minLen); }
+
+function www_authenticate_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
+
+function www_authenticate_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
+
+function www_authenticate_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
+
+var parseWWWAuthenticate = function parseWWWAuthenticate(header) {
+  var _header$split = header.split(' '),
+      _header$split2 = www_authenticate_toArray(_header$split),
+      type = _header$split2[1],
+      challenge = _header$split2.slice(2);
+
+  var pairs = [];
+  var re = /\s*([^=]+)="([^"]*)",?/gm;
+  var match;
+
+  do {
+    match = re.exec(challenge.join(' '));
+
+    if (match !== null) {
+      var _match = match,
+          _match2 = www_authenticate_slicedToArray(_match, 3),
+          key = _match2[1],
+          value = _match2[2];
+
+      pairs.push([key, value]);
+    }
+  } while (match !== null);
+
+  var params = new Map(pairs);
+  return {
+    type: type.toLowerCase(),
+    params: params
+  };
+};
+;// CONCATENATED MODULE: ./lib/components/auth/index.ts
+/* provided dependency */ var auth_Buffer = __webpack_require__(7866)["Buffer"];
+function auth_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { auth_typeof = function _typeof(obj) { return typeof obj; }; } else { auth_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return auth_typeof(obj); }
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+function auth_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
+
+function auth_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) auth_setPrototypeOf(subClass, superClass); }
+
+function auth_setPrototypeOf(o, p) { auth_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return auth_setPrototypeOf(o, p); }
+
+function auth_createSuper(Derived) { var hasNativeReflectConstruct = auth_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = auth_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = auth_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return auth_possibleConstructorReturn(this, result); }; }
+
+function auth_possibleConstructorReturn(self, call) { if (call && (auth_typeof(call) === "object" || typeof call === "function")) { return call; } return auth_assertThisInitialized(self); }
+
+function auth_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
+
+function auth_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
+
+function auth_getPrototypeOf(o) { auth_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return auth_getPrototypeOf(o); }
+
+
+
+
+
+
+
+
+var UNAUTHORIZED = 401;
+var DEFAULT_CONFIG = {
+  username: 'root',
+  password: 'pass'
+};
+/*
+ * This component currently only supports Basic authentication
+ * It should be placed between the RTSP parser and the RTSP Session.
+ */
+
+var Auth = /*#__PURE__*/function (_Tube) {
+  auth_inherits(Auth, _Tube);
+
+  var _super = auth_createSuper(Auth);
+
+  function Auth() {
+    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
+
+    auth_classCallCheck(this, Auth);
+
+    var _merge = merge(DEFAULT_CONFIG, config),
+        username = _merge.username,
+        password = _merge.password;
+
+    if (username === undefined || password === undefined) {
+      throw new Error('need username and password');
+    }
+
+    var lastSentMessage;
+    var authHeader;
+    var outgoing = createTransform(function (msg, encoding, callback) {
+      if (msg.type === MessageType.RTSP) {
+        lastSentMessage = msg;
+
+        if (authHeader && msg.headers) {
+          msg.headers.Authorization = authHeader;
+        }
+      }
+
+      callback(undefined, msg);
+    });
+    var incoming = createTransform(function (msg, encoding, callback) {
+      if (msg.type === MessageType.RTSP && statusCode(msg.data) === UNAUTHORIZED) {
+        var headers = msg.data.toString().split('\n');
+        var wwwAuth = headers.find(function (header) {
+          return /WWW-Auth/i.test(header);
+        });
+
+        if (wwwAuth === undefined) {
+          throw new Error('cannot find WWW-Authenticate header');
+        }
+
+        var challenge = parseWWWAuthenticate(wwwAuth);
+
+        if (challenge.type === 'basic') {
+          authHeader = 'Basic ' + auth_Buffer.from(username + ':' + password).toString('base64');
+        } else if (challenge.type === 'digest') {
+          var digest = new DigestAuth(challenge.params, username, password);
+          authHeader = digest.authorization(lastSentMessage.method, lastSentMessage.uri);
+        } else {
+          // unkown authentication type, give up
+          return;
+        } // Retry last RTSP message
+        // Write will fire our outgoing transform function.
+
+
+        outgoing.write(lastSentMessage, function () {
+          return callback();
+        });
+      } else {
+        // Not a message we should handle
+        callback(undefined, msg);
+      }
+    });
+    return _super.call(this, incoming, outgoing);
+  }
+
+  return Auth;
+}(Tube);
+;// CONCATENATED MODULE: ./lib/pipelines/html5-canvas-pipeline.ts
+function html5_canvas_pipeline_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { html5_canvas_pipeline_typeof = function _typeof(obj) { return typeof obj; }; } else { html5_canvas_pipeline_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return html5_canvas_pipeline_typeof(obj); }
+
+
+
+
+
+
+
+
+
+
+
+
+function html5_canvas_pipeline_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
+
+function html5_canvas_pipeline_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
+
+function html5_canvas_pipeline_createClass(Constructor, protoProps, staticProps) { if (protoProps) html5_canvas_pipeline_defineProperties(Constructor.prototype, protoProps); if (staticProps) html5_canvas_pipeline_defineProperties(Constructor, staticProps); return Constructor; }
+
+function html5_canvas_pipeline_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) html5_canvas_pipeline_setPrototypeOf(subClass, superClass); }
+
+function html5_canvas_pipeline_setPrototypeOf(o, p) { html5_canvas_pipeline_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return html5_canvas_pipeline_setPrototypeOf(o, p); }
+
+function html5_canvas_pipeline_createSuper(Derived) { var hasNativeReflectConstruct = html5_canvas_pipeline_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = html5_canvas_pipeline_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = html5_canvas_pipeline_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return html5_canvas_pipeline_possibleConstructorReturn(this, result); }; }
+
+function html5_canvas_pipeline_possibleConstructorReturn(self, call) { if (call && (html5_canvas_pipeline_typeof(call) === "object" || typeof call === "function")) { return call; } return html5_canvas_pipeline_assertThisInitialized(self); }
+
+function html5_canvas_pipeline_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
+
+function html5_canvas_pipeline_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
+
+function html5_canvas_pipeline_getPrototypeOf(o) { html5_canvas_pipeline_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return html5_canvas_pipeline_getPrototypeOf(o); }
+
+function html5_canvas_pipeline_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+
+
+
+
+
+/**
+ * Html5CanvasPipeline
+ *
+ * A pipeline that connects to an RTSP server over a WebSocket connection and
+ * can process JPEG RTP data to produce an motion JPEG data stream that is sent
+ * to a HTML canvas element.
+ *
+ * Handlers that can be set on the pipeline:
+ * - all handlers inherited from the RtspMjpegPipeline
+ * - `onSync`: called when the NTP time of the first frame is known, with the
+ *   timestamp as argument (the timestamp is UNIX milliseconds)
+ * - `onServerClose`: called when the WebSocket server closes the connection
+ *   (only then, not when the connection is closed in a different way)
+ */
+var Html5CanvasPipeline = /*#__PURE__*/function (_RtspMjpegPipeline) {
+  html5_canvas_pipeline_inherits(Html5CanvasPipeline, _RtspMjpegPipeline);
+
+  var _super = html5_canvas_pipeline_createSuper(Html5CanvasPipeline);
+
+  function Html5CanvasPipeline(config) {
+    var _this;
+
+    html5_canvas_pipeline_classCallCheck(this, Html5CanvasPipeline);
+
+    var wsConfig = config.ws,
+        rtspConfig = config.rtsp,
+        mediaElement = config.mediaElement,
+        authConfig = config.auth;
+    _this = _super.call(this, rtspConfig);
+
+    html5_canvas_pipeline_defineProperty(html5_canvas_pipeline_assertThisInitialized(_this), "onCanplay", void 0);
+
+    html5_canvas_pipeline_defineProperty(html5_canvas_pipeline_assertThisInitialized(_this), "onSync", void 0);
+
+    html5_canvas_pipeline_defineProperty(html5_canvas_pipeline_assertThisInitialized(_this), "onServerClose", void 0);
+
+    html5_canvas_pipeline_defineProperty(html5_canvas_pipeline_assertThisInitialized(_this), "ready", void 0);
+
+    html5_canvas_pipeline_defineProperty(html5_canvas_pipeline_assertThisInitialized(_this), "_src", void 0);
+
+    html5_canvas_pipeline_defineProperty(html5_canvas_pipeline_assertThisInitialized(_this), "_sink", void 0);
+
+    if (authConfig) {
+      var auth = new Auth(authConfig);
+
+      _this.insertBefore(_this.rtsp, auth);
+    }
+
+    var canvasSink = new CanvasSink(mediaElement);
+
+    canvasSink.onCanplay = function () {
+      canvasSink.play();
+      _this.onCanplay && _this.onCanplay();
+    };
+
+    canvasSink.onSync = function (ntpPresentationTime) {
+      _this.onSync && _this.onSync(ntpPresentationTime);
+    };
+
+    _this.append(canvasSink);
+
+    _this._sink = canvasSink;
+    var waitForWs = WSSource.open(wsConfig);
+    _this.ready = waitForWs.then(function (wsSource) {
+      wsSource.onServerClose = function () {
+        _this.onServerClose && _this.onServerClose();
+      };
+
+      _this.prepend(wsSource);
+
+      _this._src = wsSource;
+    });
+    return _this;
+  }
+
+  html5_canvas_pipeline_createClass(Html5CanvasPipeline, [{
+    key: "close",
+    value: function close() {
+      this._src && this._src.outgoing.end();
+    }
+  }, {
+    key: "currentTime",
+    get: function get() {
+      return this._sink.currentTime;
+    }
+  }, {
+    key: "play",
+    value: function play() {
+      return this._sink.play();
+    }
+  }, {
+    key: "pause",
+    value: function pause() {
+      return this._sink.pause();
+    }
+  }, {
+    key: "bitrate",
+    get: function get() {
+      return this._sink.bitrate;
+    }
+  }, {
+    key: "framerate",
+    get: function get() {
+      return this._sink.framerate;
+    }
+  }]);
+
+  return Html5CanvasPipeline;
+}(RtspMjpegPipeline);
+;// CONCATENATED MODULE: ./lib/pipelines/html5-video-pipeline.ts
+function html5_video_pipeline_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { html5_video_pipeline_typeof = function _typeof(obj) { return typeof obj; }; } else { html5_video_pipeline_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return html5_video_pipeline_typeof(obj); }
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+function html5_video_pipeline_asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
+
+function html5_video_pipeline_asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { html5_video_pipeline_asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { html5_video_pipeline_asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
+
+function html5_video_pipeline_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
+
+function html5_video_pipeline_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
+
+function html5_video_pipeline_createClass(Constructor, protoProps, staticProps) { if (protoProps) html5_video_pipeline_defineProperties(Constructor.prototype, protoProps); if (staticProps) html5_video_pipeline_defineProperties(Constructor, staticProps); return Constructor; }
+
+function html5_video_pipeline_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) html5_video_pipeline_setPrototypeOf(subClass, superClass); }
+
+function html5_video_pipeline_setPrototypeOf(o, p) { html5_video_pipeline_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return html5_video_pipeline_setPrototypeOf(o, p); }
+
+function html5_video_pipeline_createSuper(Derived) { var hasNativeReflectConstruct = html5_video_pipeline_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = html5_video_pipeline_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = html5_video_pipeline_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return html5_video_pipeline_possibleConstructorReturn(this, result); }; }
+
+function html5_video_pipeline_possibleConstructorReturn(self, call) { if (call && (html5_video_pipeline_typeof(call) === "object" || typeof call === "function")) { return call; } return html5_video_pipeline_assertThisInitialized(self); }
+
+function html5_video_pipeline_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
+
+function html5_video_pipeline_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
+
+function html5_video_pipeline_getPrototypeOf(o) { html5_video_pipeline_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return html5_video_pipeline_getPrototypeOf(o); }
+
+function html5_video_pipeline_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+
+
+
+
+
+/*
+ * Html5VideoPipeline
+ *
+ * A pipeline that connects to an RTSP server over a WebSocket connection and
+ * can process H.264/AAC RTP data to produce an MP4 data stream that is sent to
+ * a HTML video element.
+ *
+ * Handlers that can be set on the pipeline:
+ * - all handlers inherited from the RtspMp4Pipeline
+ * - `onServerClose`: called when the WebSocket server closes the connection
+ *   (only then, not when the connection is closed in a different way)
+ *
+ */
+var Html5VideoPipeline = /*#__PURE__*/function (_RtspMp4Pipeline) {
+  html5_video_pipeline_inherits(Html5VideoPipeline, _RtspMp4Pipeline);
+
+  var _super = html5_video_pipeline_createSuper(Html5VideoPipeline);
+
+  function Html5VideoPipeline(config) {
+    var _this;
+
+    html5_video_pipeline_classCallCheck(this, Html5VideoPipeline);
+
+    var wsConfig = config.ws,
+        rtspConfig = config.rtsp,
+        mediaElement = config.mediaElement,
+        authConfig = config.auth;
+    _this = _super.call(this, rtspConfig);
+
+    html5_video_pipeline_defineProperty(html5_video_pipeline_assertThisInitialized(_this), "onSourceOpen", void 0);
+
+    html5_video_pipeline_defineProperty(html5_video_pipeline_assertThisInitialized(_this), "onServerClose", void 0);
+
+    html5_video_pipeline_defineProperty(html5_video_pipeline_assertThisInitialized(_this), "ready", void 0);
+
+    html5_video_pipeline_defineProperty(html5_video_pipeline_assertThisInitialized(_this), "tracks", void 0);
+
+    html5_video_pipeline_defineProperty(html5_video_pipeline_assertThisInitialized(_this), "_src", void 0);
+
+    html5_video_pipeline_defineProperty(html5_video_pipeline_assertThisInitialized(_this), "_sink", void 0);
+
+    if (authConfig) {
+      var auth = new Auth(authConfig);
+
+      _this.insertBefore(_this.rtsp, auth);
+    }
+
+    var mseSink = new MseSink(mediaElement);
+
+    mseSink.onSourceOpen = function (mse, tracks) {
+      _this.tracks = tracks;
+      _this.onSourceOpen && _this.onSourceOpen(mse, tracks);
+    };
+
+    _this.append(mseSink);
+
+    _this._sink = mseSink;
+    var waitForWs = WSSource.open(wsConfig);
+    _this.ready = waitForWs.then(function (wsSource) {
+      wsSource.onServerClose = function () {
+        _this.onServerClose && _this.onServerClose();
+      };
+
+      _this.prepend(wsSource);
+
+      _this._src = wsSource;
+    });
+    return _this;
+  }
+
+  html5_video_pipeline_createClass(Html5VideoPipeline, [{
+    key: "close",
+    value: function close() {
+      this._src && this._src.outgoing.end();
+    }
+  }, {
+    key: "currentTime",
+    get: function get() {
+      return this._sink.currentTime;
+    }
+  }, {
+    key: "play",
+    value: function () {
+      var _play = html5_video_pipeline_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
+        return regeneratorRuntime.wrap(function _callee$(_context) {
+          while (1) {
+            switch (_context.prev = _context.next) {
+              case 0:
+                _context.next = 2;
+                return this._sink.play();
+
+              case 2:
+                return _context.abrupt("return", _context.sent);
+
+              case 3:
+              case "end":
+                return _context.stop();
+            }
+          }
+        }, _callee, this);
+      }));
+
+      function play() {
+        return _play.apply(this, arguments);
+      }
+
+      return play;
+    }()
+  }, {
+    key: "pause",
+    value: function pause() {
+      return this._sink.pause();
+    }
+  }]);
+
+  return Html5VideoPipeline;
+}(RtspMp4Pipeline);
+;// CONCATENATED MODULE: ./lib/pipelines/html5-video-metadata-pipeline.ts
+function html5_video_metadata_pipeline_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { html5_video_metadata_pipeline_typeof = function _typeof(obj) { return typeof obj; }; } else { html5_video_metadata_pipeline_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return html5_video_metadata_pipeline_typeof(obj); }
+
+
+
+
+
+
+
+
+
+
+
+
+function html5_video_metadata_pipeline_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
+
+function html5_video_metadata_pipeline_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) html5_video_metadata_pipeline_setPrototypeOf(subClass, superClass); }
+
+function html5_video_metadata_pipeline_setPrototypeOf(o, p) { html5_video_metadata_pipeline_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return html5_video_metadata_pipeline_setPrototypeOf(o, p); }
+
+function html5_video_metadata_pipeline_createSuper(Derived) { var hasNativeReflectConstruct = html5_video_metadata_pipeline_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = html5_video_metadata_pipeline_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = html5_video_metadata_pipeline_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return html5_video_metadata_pipeline_possibleConstructorReturn(this, result); }; }
+
+function html5_video_metadata_pipeline_possibleConstructorReturn(self, call) { if (call && (html5_video_metadata_pipeline_typeof(call) === "object" || typeof call === "function")) { return call; } return html5_video_metadata_pipeline_assertThisInitialized(self); }
+
+function html5_video_metadata_pipeline_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
+
+function html5_video_metadata_pipeline_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
+
+function html5_video_metadata_pipeline_getPrototypeOf(o) { html5_video_metadata_pipeline_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return html5_video_metadata_pipeline_getPrototypeOf(o); }
+
+
+
+
+
+
+/*
+ * Html5VideoPipeline
+ *
+ * A pipeline that connects to an RTSP server over a WebSocket connection and
+ * can process H.264/AAC RTP data to produce an MP4 data stream that is sent to
+ * a HTML video element.  Additionally, this pipeline passes XML metadata sent
+ * in the same stream to a separate handler.
+ *
+ * Handlers that can be set on the pipeline:
+ * - all handlers inherited from the Html5VideoPipeline
+ *
+ */
+var Html5VideoMetadataPipeline = /*#__PURE__*/function (_Html5VideoPipeline) {
+  html5_video_metadata_pipeline_inherits(Html5VideoMetadataPipeline, _Html5VideoPipeline);
+
+  var _super = html5_video_metadata_pipeline_createSuper(Html5VideoMetadataPipeline);
+
+  function Html5VideoMetadataPipeline(config) {
+    var _this;
+
+    html5_video_metadata_pipeline_classCallCheck(this, Html5VideoMetadataPipeline);
+
+    var metadataHandler = config.metadataHandler;
+    _this = _super.call(this, config);
+    var onvifDepay = new ONVIFDepay();
+
+    _this.insertAfter(_this.rtsp, onvifDepay);
+
+    var onvifHandlerPipe = Tube.fromHandlers(function (msg) {
+      if (msg.type === MessageType.XML) {
+        metadataHandler(msg);
+      }
+    }, undefined);
+
+    _this.insertAfter(onvifDepay, onvifHandlerPipe);
+
+    return _this;
+  }
+
+  return Html5VideoMetadataPipeline;
+}(Html5VideoPipeline);
+;// CONCATENATED MODULE: ./lib/pipelines/metadata-pipeline.ts
+function metadata_pipeline_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { metadata_pipeline_typeof = function _typeof(obj) { return typeof obj; }; } else { metadata_pipeline_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return metadata_pipeline_typeof(obj); }
+
+
+
+
+
+
+
+
+
+
+
+
+
+function metadata_pipeline_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
+
+function metadata_pipeline_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
+
+function metadata_pipeline_createClass(Constructor, protoProps, staticProps) { if (protoProps) metadata_pipeline_defineProperties(Constructor.prototype, protoProps); if (staticProps) metadata_pipeline_defineProperties(Constructor, staticProps); return Constructor; }
+
+function metadata_pipeline_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) metadata_pipeline_setPrototypeOf(subClass, superClass); }
+
+function metadata_pipeline_setPrototypeOf(o, p) { metadata_pipeline_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return metadata_pipeline_setPrototypeOf(o, p); }
+
+function metadata_pipeline_createSuper(Derived) { var hasNativeReflectConstruct = metadata_pipeline_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = metadata_pipeline_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = metadata_pipeline_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return metadata_pipeline_possibleConstructorReturn(this, result); }; }
+
+function metadata_pipeline_possibleConstructorReturn(self, call) { if (call && (metadata_pipeline_typeof(call) === "object" || typeof call === "function")) { return call; } return metadata_pipeline_assertThisInitialized(self); }
+
+function metadata_pipeline_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
+
+function metadata_pipeline_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
+
+function metadata_pipeline_getPrototypeOf(o) { metadata_pipeline_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return metadata_pipeline_getPrototypeOf(o); }
+
+function metadata_pipeline_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+
+
+
+
+ // Default configuration for XML event stream
+
+var DEFAULT_RTSP_PARAMETERS = {
+  parameters: ['audio=0', 'video=0', 'event=on', 'ptz=all']
+};
+
+/*
+ * MetadataPipeline
+ *
+ * A pipeline that connects to an RTSP server over a WebSocket connection and
+ * can process XML RTP data and calls a handler to process the XML messages.
+ *
+ * Handlers that can be set on the pipeline:
+ * - all handlers inherited from the RtspPipeline
+ * - `onServerClose`: called when the WebSocket server closes the connection
+ *   (only then, not when the connection is closed in a different way)
+ *
+ */
+var MetadataPipeline = /*#__PURE__*/function (_RtspPipeline) {
+  metadata_pipeline_inherits(MetadataPipeline, _RtspPipeline);
+
+  var _super = metadata_pipeline_createSuper(MetadataPipeline);
+
+  function MetadataPipeline(config) {
+    var _this;
+
+    metadata_pipeline_classCallCheck(this, MetadataPipeline);
+
+    var wsConfig = config.ws,
+        rtspConfig = config.rtsp,
+        metadataHandler = config.metadataHandler;
+    _this = _super.call(this, Object.assign({}, DEFAULT_RTSP_PARAMETERS, rtspConfig));
+
+    metadata_pipeline_defineProperty(metadata_pipeline_assertThisInitialized(_this), "onServerClose", void 0);
+
+    metadata_pipeline_defineProperty(metadata_pipeline_assertThisInitialized(_this), "ready", void 0);
+
+    metadata_pipeline_defineProperty(metadata_pipeline_assertThisInitialized(_this), "_src", void 0);
+
+    var onvifDepay = new ONVIFDepay();
+
+    _this.append(onvifDepay);
+
+    var handlerSink = Sink.fromHandler(function (msg) {
+      if (msg.type === MessageType.XML) {
+        metadataHandler(msg);
+      }
+    });
+
+    _this.append(handlerSink);
+
+    var waitForWs = WSSource.open(wsConfig);
+    _this.ready = waitForWs.then(function (wsSource) {
+      wsSource.onServerClose = function () {
+        _this.onServerClose && _this.onServerClose();
+      };
+
+      _this.prepend(wsSource);
+
+      _this._src = wsSource;
+    });
+    return _this;
+  }
+
+  metadata_pipeline_createClass(MetadataPipeline, [{
+    key: "close",
+    value: function close() {
+      this._src && this._src.outgoing.end();
+    }
+  }]);
+
+  return MetadataPipeline;
+}(RtspPipeline);
+;// CONCATENATED MODULE: ./lib/pipelines/ws-sdp-pipeline.ts
+function ws_sdp_pipeline_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { ws_sdp_pipeline_typeof = function _typeof(obj) { return typeof obj; }; } else { ws_sdp_pipeline_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return ws_sdp_pipeline_typeof(obj); }
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+function ws_sdp_pipeline_asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
+
+function ws_sdp_pipeline_asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { ws_sdp_pipeline_asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { ws_sdp_pipeline_asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
+
+function ws_sdp_pipeline_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
+
+function ws_sdp_pipeline_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
+
+function ws_sdp_pipeline_createClass(Constructor, protoProps, staticProps) { if (protoProps) ws_sdp_pipeline_defineProperties(Constructor.prototype, protoProps); if (staticProps) ws_sdp_pipeline_defineProperties(Constructor, staticProps); return Constructor; }
+
+function ws_sdp_pipeline_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) ws_sdp_pipeline_setPrototypeOf(subClass, superClass); }
+
+function ws_sdp_pipeline_setPrototypeOf(o, p) { ws_sdp_pipeline_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return ws_sdp_pipeline_setPrototypeOf(o, p); }
+
+function ws_sdp_pipeline_createSuper(Derived) { var hasNativeReflectConstruct = ws_sdp_pipeline_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = ws_sdp_pipeline_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = ws_sdp_pipeline_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return ws_sdp_pipeline_possibleConstructorReturn(this, result); }; }
+
+function ws_sdp_pipeline_possibleConstructorReturn(self, call) { if (call && (ws_sdp_pipeline_typeof(call) === "object" || typeof call === "function")) { return call; } return ws_sdp_pipeline_assertThisInitialized(self); }
+
+function ws_sdp_pipeline_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
+
+function ws_sdp_pipeline_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
+
+function ws_sdp_pipeline_getPrototypeOf(o) { ws_sdp_pipeline_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return ws_sdp_pipeline_getPrototypeOf(o); }
+
+function ws_sdp_pipeline_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+
+
+
+
+
+/**
+ * WsSdpPipeline
+ *
+ * Pipeline requesting an SDP object from an RTSP server and then
+ * immediately tears down the RTSP session.
+ */
+var WsSdpPipeline = /*#__PURE__*/function (_RtspPipeline) {
+  ws_sdp_pipeline_inherits(WsSdpPipeline, _RtspPipeline);
+
+  var _super = ws_sdp_pipeline_createSuper(WsSdpPipeline);
+
+  function WsSdpPipeline(config) {
+    var _this;
+
+    ws_sdp_pipeline_classCallCheck(this, WsSdpPipeline);
+
+    var wsConfig = config.ws,
+        rtspConfig = config.rtsp,
+        authConfig = config.auth;
+    _this = _super.call(this, rtspConfig);
+
+    ws_sdp_pipeline_defineProperty(ws_sdp_pipeline_assertThisInitialized(_this), "onServerClose", void 0);
+
+    ws_sdp_pipeline_defineProperty(ws_sdp_pipeline_assertThisInitialized(_this), "ready", void 0);
+
+    ws_sdp_pipeline_defineProperty(ws_sdp_pipeline_assertThisInitialized(_this), "_src", void 0);
+
+    if (authConfig) {
+      var auth = new Auth(authConfig);
+
+      _this.insertBefore(_this.rtsp, auth);
+    }
+
+    var waitForWs = WSSource.open(wsConfig);
+    _this.ready = waitForWs.then(function (wsSource) {
+      wsSource.onServerClose = function () {
+        _this.onServerClose && _this.onServerClose();
+      };
+
+      _this.prepend(wsSource);
+
+      _this._src = wsSource;
+    });
+    return _this;
+  }
+
+  ws_sdp_pipeline_createClass(WsSdpPipeline, [{
+    key: "close",
+    value: function close() {
+      this._src && this._src.outgoing.end();
+    }
+  }, {
+    key: "sdp",
+    get: function get() {
+      var _this2 = this;
+
+      return this.ready.then( /*#__PURE__*/ws_sdp_pipeline_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
+        var sdpPromise;
+        return regeneratorRuntime.wrap(function _callee$(_context) {
+          while (1) {
+            switch (_context.prev = _context.next) {
+              case 0:
+                sdpPromise = new Promise(function (resolve) {
+                  _this2.rtsp.onSdp = resolve;
+                });
+
+                _this2.rtsp.send({
+                  method: RTSP_METHOD.DESCRIBE
+                });
+
+                _this2.rtsp.send({
+                  method: RTSP_METHOD.TEARDOWN
+                });
+
+                return _context.abrupt("return", sdpPromise);
+
+              case 4:
+              case "end":
+                return _context.stop();
+            }
+          }
+        }, _callee);
+      })));
+    }
+  }]);
+
+  return WsSdpPipeline;
+}(RtspPipeline);
+;// CONCATENATED MODULE: ./lib/components/http-mp4/index.ts
+/* provided dependency */ var http_mp4_Buffer = __webpack_require__(7866)["Buffer"];
+function http_mp4_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { http_mp4_typeof = function _typeof(obj) { return typeof obj; }; } else { http_mp4_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return http_mp4_typeof(obj); }
+
+function http_mp4_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }
+
+function http_mp4_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { http_mp4_ownKeys(Object(source), true).forEach(function (key) { http_mp4_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { http_mp4_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+function http_mp4_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
+
+function http_mp4_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
+
+function http_mp4_createClass(Constructor, protoProps, staticProps) { if (protoProps) http_mp4_defineProperties(Constructor.prototype, protoProps); if (staticProps) http_mp4_defineProperties(Constructor, staticProps); return Constructor; }
+
+function http_mp4_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) http_mp4_setPrototypeOf(subClass, superClass); }
+
+function http_mp4_setPrototypeOf(o, p) { http_mp4_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return http_mp4_setPrototypeOf(o, p); }
+
+function http_mp4_createSuper(Derived) { var hasNativeReflectConstruct = http_mp4_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = http_mp4_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = http_mp4_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return http_mp4_possibleConstructorReturn(this, result); }; }
+
+function http_mp4_possibleConstructorReturn(self, call) { if (call && (http_mp4_typeof(call) === "object" || typeof call === "function")) { return call; } return http_mp4_assertThisInitialized(self); }
+
+function http_mp4_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
+
+function http_mp4_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
+
+function http_mp4_getPrototypeOf(o) { http_mp4_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return http_mp4_getPrototypeOf(o); }
+
+function http_mp4_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+
+
+
+
+var http_mp4_debug = browser_default()('msl:http-mp4');
+
+/**
+ * HttpMp4
+ *
+ * Stream MP4 data over HTTP/S, and use Axis-specific
+ * headers to determine MIME type and stream transformation.
+ */
+var HttpMp4Source = /*#__PURE__*/function (_Source) {
+  http_mp4_inherits(HttpMp4Source, _Source);
+
+  var _super = http_mp4_createSuper(HttpMp4Source);
+
+  /**
+   * Create an HTTP component.
+   *
+   * The constructor sets a single readable stream from a fetch.
+   */
+  function HttpMp4Source(config) {
+    var _this;
+
+    http_mp4_classCallCheck(this, HttpMp4Source);
+
+    var uri = config.uri,
+        options = config.options;
+    /**
+     * Set up an incoming stream and attach it to the socket.
+     */
+
+    var incoming = new stream_browserify.Readable({
+      objectMode: true,
+      read: function read() {//
+      }
+    }); // When an error is sent on the incoming stream, close the socket.
+
+    incoming.on('error', function (e) {
+      console.warn('closing socket due to incoming error', e);
+      _this._reader && _this._reader.cancel();
+    });
+    /**
+     * initialize the component.
+     */
+
+    _this = _super.call(this, incoming); // When a read is requested, continue to pull data
+
+    http_mp4_defineProperty(http_mp4_assertThisInitialized(_this), "uri", void 0);
+
+    http_mp4_defineProperty(http_mp4_assertThisInitialized(_this), "options", void 0);
+
+    http_mp4_defineProperty(http_mp4_assertThisInitialized(_this), "length", void 0);
+
+    http_mp4_defineProperty(http_mp4_assertThisInitialized(_this), "onHeaders", void 0);
+
+    http_mp4_defineProperty(http_mp4_assertThisInitialized(_this), "onServerClose", void 0);
+
+    http_mp4_defineProperty(http_mp4_assertThisInitialized(_this), "_reader", void 0);
+
+    http_mp4_defineProperty(http_mp4_assertThisInitialized(_this), "_abortController", void 0);
+
+    http_mp4_defineProperty(http_mp4_assertThisInitialized(_this), "_allDone", void 0);
+
+    incoming._read = function () {
+      _this._pull();
+    };
+
+    _this.uri = uri;
+    _this.options = options;
+    _this._allDone = false;
+    return _this;
+  }
+
+  http_mp4_createClass(HttpMp4Source, [{
+    key: "play",
+    value: function play() {
+      var _this2 = this;
+
+      if (this.uri === undefined) {
+        throw new Error('cannot start playing when there is no URI');
+      }
+
+      this._abortController = new AbortController();
+      this.length = 0;
+      fetch(this.uri, http_mp4_objectSpread({
+        credentials: 'include',
+        signal: this._abortController.signal
+      }, this.options)).then(function (rsp) {
+        if (rsp.body === null) {
+          throw new Error('empty response body');
+        }
+
+        var contentType = rsp.headers.get('Content-Type');
+
+        _this2.incoming.push({
+          data: http_mp4_Buffer.alloc(0),
+          type: MessageType.ISOM,
+          mime: contentType
+        });
+
+        _this2.onHeaders && _this2.onHeaders(rsp.headers);
+        _this2._reader = rsp.body.getReader();
+
+        _this2._pull();
+      }).catch(function (err) {
+        console.error('http-source: fetch failed: ', err);
+      });
+    }
+  }, {
+    key: "abort",
+    value: function abort() {
+      this._reader && this._reader.cancel().catch(function (err) {
+        console.log('http-source: cancel reader failed: ', err);
+      });
+      this._abortController && this._abortController.abort();
+    }
+  }, {
+    key: "_isClosed",
+    value: function _isClosed() {
+      return this._allDone;
+    }
+  }, {
+    key: "_close",
+    value: function _close() {
+      var _this$onServerClose;
+
+      this._reader = undefined;
+      this._allDone = true;
+      this.incoming.push(null);
+      (_this$onServerClose = this.onServerClose) === null || _this$onServerClose === void 0 ? void 0 : _this$onServerClose.call(this);
+    }
+  }, {
+    key: "_pull",
+    value: function _pull() {
+      var _this3 = this;
+
+      if (this._reader === undefined) {
+        return;
+      }
+
+      this._reader.read().then(function (_ref) {
+        var done = _ref.done,
+            value = _ref.value;
+
+        if (done) {
+          if (!_this3._isClosed()) {
+            http_mp4_debug('fetch completed, total downloaded: ', _this3.length, ' bytes');
+
+            _this3._close();
+          }
+
+          return;
+        }
+
+        if (value === undefined) {
+          throw new Error('expected value to be defined');
+        }
+
+        if (_this3.length === undefined) {
+          throw new Error('expected length to be defined');
+        }
+
+        _this3.length += value.length;
+        var buffer = http_mp4_Buffer.from(value);
+
+        if (!_this3.incoming.push({
+          data: buffer,
+          type: MessageType.ISOM
+        })) {
+          // Something happened down stream that it is no longer processing the
+          // incoming data, and the stream buffer got full.
+          // This could be because we are downloading too much data at once,
+          // or because the downstream is frozen. The latter is most likely
+          // when dealing with a live stream (as in that case we would expect
+          // downstream to be able to handle the data).
+          http_mp4_debug('downstream back pressure: pausing read');
+        } else {
+          // It's ok to read more data
+          _this3._pull();
+        }
+      }).catch(function (err) {
+        http_mp4_debug('http-source: read failed: ', err);
+
+        if (!_this3._isClosed()) {
+          _this3._close();
+        }
+      });
+    }
+  }]);
+
+  return HttpMp4Source;
+}(Source);
+;// CONCATENATED MODULE: ./lib/pipelines/http-mse-pipeline.ts
+function http_mse_pipeline_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { http_mse_pipeline_typeof = function _typeof(obj) { return typeof obj; }; } else { http_mse_pipeline_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return http_mse_pipeline_typeof(obj); }
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+function http_mse_pipeline_asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
+
+function http_mse_pipeline_asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { http_mse_pipeline_asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { http_mse_pipeline_asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
+
+function http_mse_pipeline_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
+
+function http_mse_pipeline_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
+
+function http_mse_pipeline_createClass(Constructor, protoProps, staticProps) { if (protoProps) http_mse_pipeline_defineProperties(Constructor.prototype, protoProps); if (staticProps) http_mse_pipeline_defineProperties(Constructor, staticProps); return Constructor; }
+
+function http_mse_pipeline_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) http_mse_pipeline_setPrototypeOf(subClass, superClass); }
+
+function http_mse_pipeline_setPrototypeOf(o, p) { http_mse_pipeline_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return http_mse_pipeline_setPrototypeOf(o, p); }
+
+function http_mse_pipeline_createSuper(Derived) { var hasNativeReflectConstruct = http_mse_pipeline_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = http_mse_pipeline_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = http_mse_pipeline_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return http_mse_pipeline_possibleConstructorReturn(this, result); }; }
+
+function http_mse_pipeline_possibleConstructorReturn(self, call) { if (call && (http_mse_pipeline_typeof(call) === "object" || typeof call === "function")) { return call; } return http_mse_pipeline_assertThisInitialized(self); }
+
+function http_mse_pipeline_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
+
+function http_mse_pipeline_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
+
+function http_mse_pipeline_getPrototypeOf(o) { http_mse_pipeline_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return http_mse_pipeline_getPrototypeOf(o); }
+
+function http_mse_pipeline_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+
+
+
+
+/*
+ * HttpMsePipeline
+ *
+ * A pipeline that connects to an HTTP server and can process an MP4 data stream
+ * that is then sent to a HTML video element
+ *
+ * Handlers that can be set on the pipeline:
+ * - `onServerClose`: called when the server closes the connection
+ */
+var HttpMsePipeline = /*#__PURE__*/function (_Pipeline) {
+  http_mse_pipeline_inherits(HttpMsePipeline, _Pipeline);
+
+  var _super = http_mse_pipeline_createSuper(HttpMsePipeline);
+
+  function HttpMsePipeline(config) {
+    var _this;
+
+    http_mse_pipeline_classCallCheck(this, HttpMsePipeline);
+
+    var httpConfig = config.http,
+        mediaElement = config.mediaElement;
+    var httpSource = new HttpMp4Source(httpConfig);
+    var mseSink = new MseSink(mediaElement);
+
+    httpSource.onHeaders = function (headers) {
+      _this.onHeaders && _this.onHeaders(headers);
+    };
+
+    httpSource.onServerClose = function () {
+      var _this$onServerClose, _this2;
+
+      return (_this$onServerClose = (_this2 = _this).onServerClose) === null || _this$onServerClose === void 0 ? void 0 : _this$onServerClose.call(_this2);
+    };
+
+    _this = _super.call(this, httpSource, mseSink);
+
+    http_mse_pipeline_defineProperty(http_mse_pipeline_assertThisInitialized(_this), "onHeaders", void 0);
+
+    http_mse_pipeline_defineProperty(http_mse_pipeline_assertThisInitialized(_this), "onServerClose", void 0);
+
+    http_mse_pipeline_defineProperty(http_mse_pipeline_assertThisInitialized(_this), "http", void 0);
+
+    http_mse_pipeline_defineProperty(http_mse_pipeline_assertThisInitialized(_this), "_src", void 0);
+
+    http_mse_pipeline_defineProperty(http_mse_pipeline_assertThisInitialized(_this), "_sink", void 0);
+
+    _this._src = httpSource;
+    _this._sink = mseSink; // Expose session for external use
+
+    _this.http = httpSource;
+    return _this;
+  }
+
+  http_mse_pipeline_createClass(HttpMsePipeline, [{
+    key: "close",
+    value: function close() {
+      this._src && this._src.abort();
+    }
+  }, {
+    key: "currentTime",
+    get: function get() {
+      return this._sink.currentTime;
+    }
+  }, {
+    key: "play",
+    value: function () {
+      var _play = http_mse_pipeline_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
+        return regeneratorRuntime.wrap(function _callee$(_context) {
+          while (1) {
+            switch (_context.prev = _context.next) {
+              case 0:
+                _context.next = 2;
+                return this._sink.play();
+
+              case 2:
+                return _context.abrupt("return", _context.sent);
+
+              case 3:
+              case "end":
+                return _context.stop();
+            }
+          }
+        }, _callee, this);
+      }));
+
+      function play() {
+        return _play.apply(this, arguments);
+      }
+
+      return play;
+    }()
+  }, {
+    key: "pause",
+    value: function pause() {
+      return this._sink.pause();
+    }
+  }]);
+
+  return HttpMsePipeline;
+}(Pipeline);
+;// CONCATENATED MODULE: ./lib/pipelines/index.browser.ts
+
+
+
+
+
+
+
+
+
+
+;// CONCATENATED MODULE: ./lib/utils/protocols/index.ts
+
+
+
+
+
+// EXTERNAL MODULE: ./.yarn/unplugged/core-js-npm-3.16.2-c7ce9e8d48/node_modules/core-js/modules/es.string.includes.js
+var es_string_includes = __webpack_require__(6837);
+;// CONCATENATED MODULE: ./lib/utils/retry.ts
+
+
+
+/**
+ * Retry failed commands.
+ *
+ * This retries RTSP commands that fails up to a certain
+ * limit of times.
+ */
+var addRTSPRetry = function addRTSPRetry(rtspSession) {
+  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
+    maxRetries: 20,
+    errors: [503]
+  },
+      maxRetries = _ref.maxRetries,
+      errors = _ref.errors;
+
+  var retries = 0;
+  var oldOnError = rtspSession.onError;
+
+  rtspSession.onError = function (err) {
+    oldOnError === null || oldOnError === void 0 ? void 0 : oldOnError(err);
+
+    if (!errors.includes(err.code)) {
+      return;
+    } // Stop retrying after 20 tries (~20 seconds)
+
+
+    if ((retries += 1) > maxRetries) {
+      console.log('retry, too many', retries, maxRetries);
+      return;
+    } // Retry
+
+
+    setTimeout(function () {
+      var _rtspSession$retry;
+
+      return (_rtspSession$retry = rtspSession.retry) === null || _rtspSession$retry === void 0 ? void 0 : _rtspSession$retry.call(rtspSession);
+    }, retries * 100);
+  };
+};
+;// CONCATENATED MODULE: ./lib/utils/index.browser.ts
+
+
+
+;// CONCATENATED MODULE: ./lib/index.browser.ts
+
+
+
+
+
+
+
+})();
+
+/******/ 	return __webpack_exports__;
+/******/ })()
+;
+});
\ No newline at end of file
diff --git a/dist/media-stream-library.min.js b/dist/media-stream-library.min.js
index 367847ce0ddbef78fdb0c6486f6f733d85284fc1..ff66e8d13881c6d8c6450da3cfb76018821bae51 100644
--- a/dist/media-stream-library.min.js
+++ b/dist/media-stream-library.min.js
@@ -1,2 +1,19444 @@
-/*! For license information please see media-stream-library.min.js.LICENSE.txt */
-!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.mediaStreamLibrary=t():e.mediaStreamLibrary=t()}(self,(function(){return(()=>{var e={7997:(e,t,r)=>{var n=r(2695);t.formatArgs=function(t){if(t[0]=(this.useColors?"%c":"")+this.namespace+(this.useColors?" %c":" ")+t[0]+(this.useColors?"%c ":" ")+"+"+e.exports.humanize(this.diff),!this.useColors)return;const r="color: "+this.color;t.splice(1,0,r,"color: inherit");let n=0,i=0;t[0].replace(/%[a-zA-Z%]/g,(e=>{"%%"!==e&&(n++,"%c"===e&&(i=n))})),t.splice(i,0,r)},t.save=function(e){try{e?t.storage.setItem("debug",e):t.storage.removeItem("debug")}catch(e){}},t.load=function(){let e;try{e=t.storage.getItem("debug")}catch(e){}return!e&&void 0!==n&&"env"in n&&(e=n.env.DEBUG),e},t.useColors=function(){return!("undefined"==typeof window||!window.process||"renderer"!==window.process.type&&!window.process.__nwjs)||("undefined"==typeof navigator||!navigator.userAgent||!navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))&&("undefined"!=typeof document&&document.documentElement&&document.documentElement.style&&document.documentElement.style.WebkitAppearance||"undefined"!=typeof window&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||"undefined"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)&&parseInt(RegExp.$1,10)>=31||"undefined"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/))},t.storage=function(){try{return localStorage}catch(e){}}(),t.destroy=(()=>{let e=!1;return()=>{e||(e=!0,console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."))}})(),t.colors=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"],t.log=console.debug||console.log||(()=>{}),e.exports=r(4069)(t);const{formatters:i}=e.exports;i.j=function(e){try{return JSON.stringify(e)}catch(e){return"[UnexpectedJSONParseError]: "+e.message}}},4069:(e,t,r)=>{e.exports=function(e){function t(e){let r,i,o,s=null;function a(...e){if(!a.enabled)return;const n=a,i=Number(new Date),o=i-(r||i);n.diff=o,n.prev=r,n.curr=i,r=i,e[0]=t.coerce(e[0]),"string"!=typeof e[0]&&e.unshift("%O");let s=0;e[0]=e[0].replace(/%([a-zA-Z%])/g,((r,i)=>{if("%%"===r)return"%";s++;const o=t.formatters[i];if("function"==typeof o){const t=e[s];r=o.call(n,t),e.splice(s,1),s--}return r})),t.formatArgs.call(n,e),(n.log||t.log).apply(n,e)}return a.namespace=e,a.useColors=t.useColors(),a.color=t.selectColor(e),a.extend=n,a.destroy=t.destroy,Object.defineProperty(a,"enabled",{enumerable:!0,configurable:!1,get:()=>null!==s?s:(i!==t.namespaces&&(i=t.namespaces,o=t.enabled(e)),o),set:e=>{s=e}}),"function"==typeof t.init&&t.init(a),a}function n(e,r){const n=t(this.namespace+(void 0===r?":":r)+e);return n.log=this.log,n}function i(e){return e.toString().substring(2,e.toString().length-2).replace(/\.\*\?$/,"*")}return t.debug=t,t.default=t,t.coerce=function(e){return e instanceof Error?e.stack||e.message:e},t.disable=function(){const e=[...t.names.map(i),...t.skips.map(i).map((e=>"-"+e))].join(",");return t.enable(""),e},t.enable=function(e){let r;t.save(e),t.namespaces=e,t.names=[],t.skips=[];const n=("string"==typeof e?e:"").split(/[\s,]+/),i=n.length;for(r=0;r<i;r++)n[r]&&("-"===(e=n[r].replace(/\*/g,".*?"))[0]?t.skips.push(new RegExp("^"+e.substr(1)+"$")):t.names.push(new RegExp("^"+e+"$")))},t.enabled=function(e){if("*"===e[e.length-1])return!0;let r,n;for(r=0,n=t.skips.length;r<n;r++)if(t.skips[r].test(e))return!1;for(r=0,n=t.names.length;r<n;r++)if(t.names[r].test(e))return!0;return!1},t.humanize=r(6117),t.destroy=function(){console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")},Object.keys(e).forEach((r=>{t[r]=e[r]})),t.names=[],t.skips=[],t.formatters={},t.selectColor=function(e){let r=0;for(let t=0;t<e.length;t++)r=(r<<5)-r+e.charCodeAt(t),r|=0;return t.colors[Math.abs(r)%t.colors.length]},t.enable(t.load()),t}},7378:(e,t)=>{"use strict";t.byteLength=function(e){var t=u(e),r=t[0],n=t[1];return 3*(r+n)/4-n},t.toByteArray=function(e){var t,r,o=u(e),s=o[0],a=o[1],c=new i(function(e,t,r){return 3*(t+r)/4-r}(0,s,a)),l=0,h=a>0?s-4:s;for(r=0;r<h;r+=4)t=n[e.charCodeAt(r)]<<18|n[e.charCodeAt(r+1)]<<12|n[e.charCodeAt(r+2)]<<6|n[e.charCodeAt(r+3)],c[l++]=t>>16&255,c[l++]=t>>8&255,c[l++]=255&t;return 2===a&&(t=n[e.charCodeAt(r)]<<2|n[e.charCodeAt(r+1)]>>4,c[l++]=255&t),1===a&&(t=n[e.charCodeAt(r)]<<10|n[e.charCodeAt(r+1)]<<4|n[e.charCodeAt(r+2)]>>2,c[l++]=t>>8&255,c[l++]=255&t),c},t.fromByteArray=function(e){for(var t,n=e.length,i=n%3,o=[],s=16383,a=0,u=n-i;a<u;a+=s)o.push(c(e,a,a+s>u?u:a+s));return 1===i?(t=e[n-1],o.push(r[t>>2]+r[t<<4&63]+"==")):2===i&&(t=(e[n-2]<<8)+e[n-1],o.push(r[t>>10]+r[t>>4&63]+r[t<<2&63]+"=")),o.join("")};for(var r=[],n=[],i="undefined"!=typeof Uint8Array?Uint8Array:Array,o="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",s=0,a=o.length;s<a;++s)r[s]=o[s],n[o.charCodeAt(s)]=s;function u(e){var t=e.length;if(t%4>0)throw new Error("Invalid string. Length must be a multiple of 4");var r=e.indexOf("=");return-1===r&&(r=t),[r,r===t?0:4-r%4]}function c(e,t,n){for(var i,o,s=[],a=t;a<n;a+=3)i=(e[a]<<16&16711680)+(e[a+1]<<8&65280)+(255&e[a+2]),s.push(r[(o=i)>>18&63]+r[o>>12&63]+r[o>>6&63]+r[63&o]);return s.join("")}n["-".charCodeAt(0)]=62,n["_".charCodeAt(0)]=63},7866:(e,t,r)=>{"use strict";const n=r(7378),i=r(9258),o="function"==typeof Symbol&&"function"==typeof Symbol.for?Symbol.for("nodejs.util.inspect.custom"):null;t.Buffer=u,t.SlowBuffer=function(e){return+e!=e&&(e=0),u.alloc(+e)},t.INSPECT_MAX_BYTES=50;const s=2147483647;function a(e){if(e>s)throw new RangeError('The value "'+e+'" is invalid for option "size"');const t=new Uint8Array(e);return Object.setPrototypeOf(t,u.prototype),t}function u(e,t,r){if("number"==typeof e){if("string"==typeof t)throw new TypeError('The "string" argument must be of type string. Received type number');return h(e)}return c(e,t,r)}function c(e,t,r){if("string"==typeof e)return function(e,t){if("string"==typeof t&&""!==t||(t="utf8"),!u.isEncoding(t))throw new TypeError("Unknown encoding: "+t);const r=0|m(e,t);let n=a(r);const i=n.write(e,t);return i!==r&&(n=n.slice(0,i)),n}(e,t);if(ArrayBuffer.isView(e))return function(e){if(J(e,Uint8Array)){const t=new Uint8Array(e);return d(t.buffer,t.byteOffset,t.byteLength)}return f(e)}(e);if(null==e)throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof e);if(J(e,ArrayBuffer)||e&&J(e.buffer,ArrayBuffer))return d(e,t,r);if("undefined"!=typeof SharedArrayBuffer&&(J(e,SharedArrayBuffer)||e&&J(e.buffer,SharedArrayBuffer)))return d(e,t,r);if("number"==typeof e)throw new TypeError('The "value" argument must not be of type number. Received type number');const n=e.valueOf&&e.valueOf();if(null!=n&&n!==e)return u.from(n,t,r);const i=function(e){if(u.isBuffer(e)){const t=0|p(e.length),r=a(t);return 0===r.length||e.copy(r,0,0,t),r}return void 0!==e.length?"number"!=typeof e.length||K(e.length)?a(0):f(e):"Buffer"===e.type&&Array.isArray(e.data)?f(e.data):void 0}(e);if(i)return i;if("undefined"!=typeof Symbol&&null!=Symbol.toPrimitive&&"function"==typeof e[Symbol.toPrimitive])return u.from(e[Symbol.toPrimitive]("string"),t,r);throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof e)}function l(e){if("number"!=typeof e)throw new TypeError('"size" argument must be of type number');if(e<0)throw new RangeError('The value "'+e+'" is invalid for option "size"')}function h(e){return l(e),a(e<0?0:0|p(e))}function f(e){const t=e.length<0?0:0|p(e.length),r=a(t);for(let n=0;n<t;n+=1)r[n]=255&e[n];return r}function d(e,t,r){if(t<0||e.byteLength<t)throw new RangeError('"offset" is outside of buffer bounds');if(e.byteLength<t+(r||0))throw new RangeError('"length" is outside of buffer bounds');let n;return n=void 0===t&&void 0===r?new Uint8Array(e):void 0===r?new Uint8Array(e,t):new Uint8Array(e,t,r),Object.setPrototypeOf(n,u.prototype),n}function p(e){if(e>=s)throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+s.toString(16)+" bytes");return 0|e}function m(e,t){if(u.isBuffer(e))return e.length;if(ArrayBuffer.isView(e)||J(e,ArrayBuffer))return e.byteLength;if("string"!=typeof e)throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type '+typeof e);const r=e.length,n=arguments.length>2&&!0===arguments[2];if(!n&&0===r)return 0;let i=!1;for(;;)switch(t){case"ascii":case"latin1":case"binary":return r;case"utf8":case"utf-8":return G(e).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return 2*r;case"hex":return r>>>1;case"base64":return V(e).length;default:if(i)return n?-1:G(e).length;t=(""+t).toLowerCase(),i=!0}}function g(e,t,r){let n=!1;if((void 0===t||t<0)&&(t=0),t>this.length)return"";if((void 0===r||r>this.length)&&(r=this.length),r<=0)return"";if((r>>>=0)<=(t>>>=0))return"";for(e||(e="utf8");;)switch(e){case"hex":return P(this,t,r);case"utf8":case"utf-8":return T(this,t,r);case"ascii":return k(this,t,r);case"latin1":case"binary":return O(this,t,r);case"base64":return R(this,t,r);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return I(this,t,r);default:if(n)throw new TypeError("Unknown encoding: "+e);e=(e+"").toLowerCase(),n=!0}}function y(e,t,r){const n=e[t];e[t]=e[r],e[r]=n}function b(e,t,r,n,i){if(0===e.length)return-1;if("string"==typeof r?(n=r,r=0):r>2147483647?r=2147483647:r<-2147483648&&(r=-2147483648),K(r=+r)&&(r=i?0:e.length-1),r<0&&(r=e.length+r),r>=e.length){if(i)return-1;r=e.length-1}else if(r<0){if(!i)return-1;r=0}if("string"==typeof t&&(t=u.from(t,n)),u.isBuffer(t))return 0===t.length?-1:v(e,t,r,n,i);if("number"==typeof t)return t&=255,"function"==typeof Uint8Array.prototype.indexOf?i?Uint8Array.prototype.indexOf.call(e,t,r):Uint8Array.prototype.lastIndexOf.call(e,t,r):v(e,[t],r,n,i);throw new TypeError("val must be string, number or Buffer")}function v(e,t,r,n,i){let o,s=1,a=e.length,u=t.length;if(void 0!==n&&("ucs2"===(n=String(n).toLowerCase())||"ucs-2"===n||"utf16le"===n||"utf-16le"===n)){if(e.length<2||t.length<2)return-1;s=2,a/=2,u/=2,r/=2}function c(e,t){return 1===s?e[t]:e.readUInt16BE(t*s)}if(i){let n=-1;for(o=r;o<a;o++)if(c(e,o)===c(t,-1===n?0:o-n)){if(-1===n&&(n=o),o-n+1===u)return n*s}else-1!==n&&(o-=o-n),n=-1}else for(r+u>a&&(r=a-u),o=r;o>=0;o--){let r=!0;for(let n=0;n<u;n++)if(c(e,o+n)!==c(t,n)){r=!1;break}if(r)return o}return-1}function w(e,t,r,n){r=Number(r)||0;const i=e.length-r;n?(n=Number(n))>i&&(n=i):n=i;const o=t.length;let s;for(n>o/2&&(n=o/2),s=0;s<n;++s){const n=parseInt(t.substr(2*s,2),16);if(K(n))return s;e[r+s]=n}return s}function _(e,t,r,n){return Y(G(t,e.length-r),e,r,n)}function S(e,t,r,n){return Y(function(e){const t=[];for(let r=0;r<e.length;++r)t.push(255&e.charCodeAt(r));return t}(t),e,r,n)}function E(e,t,r,n){return Y(V(t),e,r,n)}function x(e,t,r,n){return Y(function(e,t){let r,n,i;const o=[];for(let s=0;s<e.length&&!((t-=2)<0);++s)r=e.charCodeAt(s),n=r>>8,i=r%256,o.push(i),o.push(n);return o}(t,e.length-r),e,r,n)}function R(e,t,r){return 0===t&&r===e.length?n.fromByteArray(e):n.fromByteArray(e.slice(t,r))}function T(e,t,r){r=Math.min(e.length,r);const n=[];let i=t;for(;i<r;){const t=e[i];let o=null,s=t>239?4:t>223?3:t>191?2:1;if(i+s<=r){let r,n,a,u;switch(s){case 1:t<128&&(o=t);break;case 2:r=e[i+1],128==(192&r)&&(u=(31&t)<<6|63&r,u>127&&(o=u));break;case 3:r=e[i+1],n=e[i+2],128==(192&r)&&128==(192&n)&&(u=(15&t)<<12|(63&r)<<6|63&n,u>2047&&(u<55296||u>57343)&&(o=u));break;case 4:r=e[i+1],n=e[i+2],a=e[i+3],128==(192&r)&&128==(192&n)&&128==(192&a)&&(u=(15&t)<<18|(63&r)<<12|(63&n)<<6|63&a,u>65535&&u<1114112&&(o=u))}}null===o?(o=65533,s=1):o>65535&&(o-=65536,n.push(o>>>10&1023|55296),o=56320|1023&o),n.push(o),i+=s}return function(e){const t=e.length;if(t<=C)return String.fromCharCode.apply(String,e);let r="",n=0;for(;n<t;)r+=String.fromCharCode.apply(String,e.slice(n,n+=C));return r}(n)}t.kMaxLength=s,u.TYPED_ARRAY_SUPPORT=function(){try{const e=new Uint8Array(1),t={foo:function(){return 42}};return Object.setPrototypeOf(t,Uint8Array.prototype),Object.setPrototypeOf(e,t),42===e.foo()}catch(e){return!1}}(),u.TYPED_ARRAY_SUPPORT||"undefined"==typeof console||"function"!=typeof console.error||console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."),Object.defineProperty(u.prototype,"parent",{enumerable:!0,get:function(){if(u.isBuffer(this))return this.buffer}}),Object.defineProperty(u.prototype,"offset",{enumerable:!0,get:function(){if(u.isBuffer(this))return this.byteOffset}}),u.poolSize=8192,u.from=function(e,t,r){return c(e,t,r)},Object.setPrototypeOf(u.prototype,Uint8Array.prototype),Object.setPrototypeOf(u,Uint8Array),u.alloc=function(e,t,r){return function(e,t,r){return l(e),e<=0?a(e):void 0!==t?"string"==typeof r?a(e).fill(t,r):a(e).fill(t):a(e)}(e,t,r)},u.allocUnsafe=function(e){return h(e)},u.allocUnsafeSlow=function(e){return h(e)},u.isBuffer=function(e){return null!=e&&!0===e._isBuffer&&e!==u.prototype},u.compare=function(e,t){if(J(e,Uint8Array)&&(e=u.from(e,e.offset,e.byteLength)),J(t,Uint8Array)&&(t=u.from(t,t.offset,t.byteLength)),!u.isBuffer(e)||!u.isBuffer(t))throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');if(e===t)return 0;let r=e.length,n=t.length;for(let i=0,o=Math.min(r,n);i<o;++i)if(e[i]!==t[i]){r=e[i],n=t[i];break}return r<n?-1:n<r?1:0},u.isEncoding=function(e){switch(String(e).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},u.concat=function(e,t){if(!Array.isArray(e))throw new TypeError('"list" argument must be an Array of Buffers');if(0===e.length)return u.alloc(0);let r;if(void 0===t)for(t=0,r=0;r<e.length;++r)t+=e[r].length;const n=u.allocUnsafe(t);let i=0;for(r=0;r<e.length;++r){let t=e[r];if(J(t,Uint8Array))i+t.length>n.length?(u.isBuffer(t)||(t=u.from(t)),t.copy(n,i)):Uint8Array.prototype.set.call(n,t,i);else{if(!u.isBuffer(t))throw new TypeError('"list" argument must be an Array of Buffers');t.copy(n,i)}i+=t.length}return n},u.byteLength=m,u.prototype._isBuffer=!0,u.prototype.swap16=function(){const e=this.length;if(e%2!=0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(let t=0;t<e;t+=2)y(this,t,t+1);return this},u.prototype.swap32=function(){const e=this.length;if(e%4!=0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(let t=0;t<e;t+=4)y(this,t,t+3),y(this,t+1,t+2);return this},u.prototype.swap64=function(){const e=this.length;if(e%8!=0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(let t=0;t<e;t+=8)y(this,t,t+7),y(this,t+1,t+6),y(this,t+2,t+5),y(this,t+3,t+4);return this},u.prototype.toString=function(){const e=this.length;return 0===e?"":0===arguments.length?T(this,0,e):g.apply(this,arguments)},u.prototype.toLocaleString=u.prototype.toString,u.prototype.equals=function(e){if(!u.isBuffer(e))throw new TypeError("Argument must be a Buffer");return this===e||0===u.compare(this,e)},u.prototype.inspect=function(){let e="";const r=t.INSPECT_MAX_BYTES;return e=this.toString("hex",0,r).replace(/(.{2})/g,"$1 ").trim(),this.length>r&&(e+=" ... "),"<Buffer "+e+">"},o&&(u.prototype[o]=u.prototype.inspect),u.prototype.compare=function(e,t,r,n,i){if(J(e,Uint8Array)&&(e=u.from(e,e.offset,e.byteLength)),!u.isBuffer(e))throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type '+typeof e);if(void 0===t&&(t=0),void 0===r&&(r=e?e.length:0),void 0===n&&(n=0),void 0===i&&(i=this.length),t<0||r>e.length||n<0||i>this.length)throw new RangeError("out of range index");if(n>=i&&t>=r)return 0;if(n>=i)return-1;if(t>=r)return 1;if(this===e)return 0;let o=(i>>>=0)-(n>>>=0),s=(r>>>=0)-(t>>>=0);const a=Math.min(o,s),c=this.slice(n,i),l=e.slice(t,r);for(let e=0;e<a;++e)if(c[e]!==l[e]){o=c[e],s=l[e];break}return o<s?-1:s<o?1:0},u.prototype.includes=function(e,t,r){return-1!==this.indexOf(e,t,r)},u.prototype.indexOf=function(e,t,r){return b(this,e,t,r,!0)},u.prototype.lastIndexOf=function(e,t,r){return b(this,e,t,r,!1)},u.prototype.write=function(e,t,r,n){if(void 0===t)n="utf8",r=this.length,t=0;else if(void 0===r&&"string"==typeof t)n=t,r=this.length,t=0;else{if(!isFinite(t))throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");t>>>=0,isFinite(r)?(r>>>=0,void 0===n&&(n="utf8")):(n=r,r=void 0)}const i=this.length-t;if((void 0===r||r>i)&&(r=i),e.length>0&&(r<0||t<0)||t>this.length)throw new RangeError("Attempt to write outside buffer bounds");n||(n="utf8");let o=!1;for(;;)switch(n){case"hex":return w(this,e,t,r);case"utf8":case"utf-8":return _(this,e,t,r);case"ascii":case"latin1":case"binary":return S(this,e,t,r);case"base64":return E(this,e,t,r);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return x(this,e,t,r);default:if(o)throw new TypeError("Unknown encoding: "+n);n=(""+n).toLowerCase(),o=!0}},u.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};const C=4096;function k(e,t,r){let n="";r=Math.min(e.length,r);for(let i=t;i<r;++i)n+=String.fromCharCode(127&e[i]);return n}function O(e,t,r){let n="";r=Math.min(e.length,r);for(let i=t;i<r;++i)n+=String.fromCharCode(e[i]);return n}function P(e,t,r){const n=e.length;(!t||t<0)&&(t=0),(!r||r<0||r>n)&&(r=n);let i="";for(let n=t;n<r;++n)i+=X[e[n]];return i}function I(e,t,r){const n=e.slice(t,r);let i="";for(let e=0;e<n.length-1;e+=2)i+=String.fromCharCode(n[e]+256*n[e+1]);return i}function L(e,t,r){if(e%1!=0||e<0)throw new RangeError("offset is not uint");if(e+t>r)throw new RangeError("Trying to access beyond buffer length")}function B(e,t,r,n,i,o){if(!u.isBuffer(e))throw new TypeError('"buffer" argument must be a Buffer instance');if(t>i||t<o)throw new RangeError('"value" argument is out of bounds');if(r+n>e.length)throw new RangeError("Index out of range")}function A(e,t,r,n,i){H(t,n,i,e,r,7);let o=Number(t&BigInt(4294967295));e[r++]=o,o>>=8,e[r++]=o,o>>=8,e[r++]=o,o>>=8,e[r++]=o;let s=Number(t>>BigInt(32)&BigInt(4294967295));return e[r++]=s,s>>=8,e[r++]=s,s>>=8,e[r++]=s,s>>=8,e[r++]=s,r}function U(e,t,r,n,i){H(t,n,i,e,r,7);let o=Number(t&BigInt(4294967295));e[r+7]=o,o>>=8,e[r+6]=o,o>>=8,e[r+5]=o,o>>=8,e[r+4]=o;let s=Number(t>>BigInt(32)&BigInt(4294967295));return e[r+3]=s,s>>=8,e[r+2]=s,s>>=8,e[r+1]=s,s>>=8,e[r]=s,r+8}function j(e,t,r,n,i,o){if(r+n>e.length)throw new RangeError("Index out of range");if(r<0)throw new RangeError("Index out of range")}function M(e,t,r,n,o){return t=+t,r>>>=0,o||j(e,0,r,4),i.write(e,t,r,n,23,4),r+4}function D(e,t,r,n,o){return t=+t,r>>>=0,o||j(e,0,r,8),i.write(e,t,r,n,52,8),r+8}u.prototype.slice=function(e,t){const r=this.length;(e=~~e)<0?(e+=r)<0&&(e=0):e>r&&(e=r),(t=void 0===t?r:~~t)<0?(t+=r)<0&&(t=0):t>r&&(t=r),t<e&&(t=e);const n=this.subarray(e,t);return Object.setPrototypeOf(n,u.prototype),n},u.prototype.readUintLE=u.prototype.readUIntLE=function(e,t,r){e>>>=0,t>>>=0,r||L(e,t,this.length);let n=this[e],i=1,o=0;for(;++o<t&&(i*=256);)n+=this[e+o]*i;return n},u.prototype.readUintBE=u.prototype.readUIntBE=function(e,t,r){e>>>=0,t>>>=0,r||L(e,t,this.length);let n=this[e+--t],i=1;for(;t>0&&(i*=256);)n+=this[e+--t]*i;return n},u.prototype.readUint8=u.prototype.readUInt8=function(e,t){return e>>>=0,t||L(e,1,this.length),this[e]},u.prototype.readUint16LE=u.prototype.readUInt16LE=function(e,t){return e>>>=0,t||L(e,2,this.length),this[e]|this[e+1]<<8},u.prototype.readUint16BE=u.prototype.readUInt16BE=function(e,t){return e>>>=0,t||L(e,2,this.length),this[e]<<8|this[e+1]},u.prototype.readUint32LE=u.prototype.readUInt32LE=function(e,t){return e>>>=0,t||L(e,4,this.length),(this[e]|this[e+1]<<8|this[e+2]<<16)+16777216*this[e+3]},u.prototype.readUint32BE=u.prototype.readUInt32BE=function(e,t){return e>>>=0,t||L(e,4,this.length),16777216*this[e]+(this[e+1]<<16|this[e+2]<<8|this[e+3])},u.prototype.readBigUInt64LE=Z((function(e){$(e>>>=0,"offset");const t=this[e],r=this[e+7];void 0!==t&&void 0!==r||W(e,this.length-8);const n=t+256*this[++e]+65536*this[++e]+this[++e]*2**24,i=this[++e]+256*this[++e]+65536*this[++e]+r*2**24;return BigInt(n)+(BigInt(i)<<BigInt(32))})),u.prototype.readBigUInt64BE=Z((function(e){$(e>>>=0,"offset");const t=this[e],r=this[e+7];void 0!==t&&void 0!==r||W(e,this.length-8);const n=t*2**24+65536*this[++e]+256*this[++e]+this[++e],i=this[++e]*2**24+65536*this[++e]+256*this[++e]+r;return(BigInt(n)<<BigInt(32))+BigInt(i)})),u.prototype.readIntLE=function(e,t,r){e>>>=0,t>>>=0,r||L(e,t,this.length);let n=this[e],i=1,o=0;for(;++o<t&&(i*=256);)n+=this[e+o]*i;return i*=128,n>=i&&(n-=Math.pow(2,8*t)),n},u.prototype.readIntBE=function(e,t,r){e>>>=0,t>>>=0,r||L(e,t,this.length);let n=t,i=1,o=this[e+--n];for(;n>0&&(i*=256);)o+=this[e+--n]*i;return i*=128,o>=i&&(o-=Math.pow(2,8*t)),o},u.prototype.readInt8=function(e,t){return e>>>=0,t||L(e,1,this.length),128&this[e]?-1*(255-this[e]+1):this[e]},u.prototype.readInt16LE=function(e,t){e>>>=0,t||L(e,2,this.length);const r=this[e]|this[e+1]<<8;return 32768&r?4294901760|r:r},u.prototype.readInt16BE=function(e,t){e>>>=0,t||L(e,2,this.length);const r=this[e+1]|this[e]<<8;return 32768&r?4294901760|r:r},u.prototype.readInt32LE=function(e,t){return e>>>=0,t||L(e,4,this.length),this[e]|this[e+1]<<8|this[e+2]<<16|this[e+3]<<24},u.prototype.readInt32BE=function(e,t){return e>>>=0,t||L(e,4,this.length),this[e]<<24|this[e+1]<<16|this[e+2]<<8|this[e+3]},u.prototype.readBigInt64LE=Z((function(e){$(e>>>=0,"offset");const t=this[e],r=this[e+7];void 0!==t&&void 0!==r||W(e,this.length-8);const n=this[e+4]+256*this[e+5]+65536*this[e+6]+(r<<24);return(BigInt(n)<<BigInt(32))+BigInt(t+256*this[++e]+65536*this[++e]+this[++e]*2**24)})),u.prototype.readBigInt64BE=Z((function(e){$(e>>>=0,"offset");const t=this[e],r=this[e+7];void 0!==t&&void 0!==r||W(e,this.length-8);const n=(t<<24)+65536*this[++e]+256*this[++e]+this[++e];return(BigInt(n)<<BigInt(32))+BigInt(this[++e]*2**24+65536*this[++e]+256*this[++e]+r)})),u.prototype.readFloatLE=function(e,t){return e>>>=0,t||L(e,4,this.length),i.read(this,e,!0,23,4)},u.prototype.readFloatBE=function(e,t){return e>>>=0,t||L(e,4,this.length),i.read(this,e,!1,23,4)},u.prototype.readDoubleLE=function(e,t){return e>>>=0,t||L(e,8,this.length),i.read(this,e,!0,52,8)},u.prototype.readDoubleBE=function(e,t){return e>>>=0,t||L(e,8,this.length),i.read(this,e,!1,52,8)},u.prototype.writeUintLE=u.prototype.writeUIntLE=function(e,t,r,n){e=+e,t>>>=0,r>>>=0,n||B(this,e,t,r,Math.pow(2,8*r)-1,0);let i=1,o=0;for(this[t]=255&e;++o<r&&(i*=256);)this[t+o]=e/i&255;return t+r},u.prototype.writeUintBE=u.prototype.writeUIntBE=function(e,t,r,n){e=+e,t>>>=0,r>>>=0,n||B(this,e,t,r,Math.pow(2,8*r)-1,0);let i=r-1,o=1;for(this[t+i]=255&e;--i>=0&&(o*=256);)this[t+i]=e/o&255;return t+r},u.prototype.writeUint8=u.prototype.writeUInt8=function(e,t,r){return e=+e,t>>>=0,r||B(this,e,t,1,255,0),this[t]=255&e,t+1},u.prototype.writeUint16LE=u.prototype.writeUInt16LE=function(e,t,r){return e=+e,t>>>=0,r||B(this,e,t,2,65535,0),this[t]=255&e,this[t+1]=e>>>8,t+2},u.prototype.writeUint16BE=u.prototype.writeUInt16BE=function(e,t,r){return e=+e,t>>>=0,r||B(this,e,t,2,65535,0),this[t]=e>>>8,this[t+1]=255&e,t+2},u.prototype.writeUint32LE=u.prototype.writeUInt32LE=function(e,t,r){return e=+e,t>>>=0,r||B(this,e,t,4,4294967295,0),this[t+3]=e>>>24,this[t+2]=e>>>16,this[t+1]=e>>>8,this[t]=255&e,t+4},u.prototype.writeUint32BE=u.prototype.writeUInt32BE=function(e,t,r){return e=+e,t>>>=0,r||B(this,e,t,4,4294967295,0),this[t]=e>>>24,this[t+1]=e>>>16,this[t+2]=e>>>8,this[t+3]=255&e,t+4},u.prototype.writeBigUInt64LE=Z((function(e,t=0){return A(this,e,t,BigInt(0),BigInt("0xffffffffffffffff"))})),u.prototype.writeBigUInt64BE=Z((function(e,t=0){return U(this,e,t,BigInt(0),BigInt("0xffffffffffffffff"))})),u.prototype.writeIntLE=function(e,t,r,n){if(e=+e,t>>>=0,!n){const n=Math.pow(2,8*r-1);B(this,e,t,r,n-1,-n)}let i=0,o=1,s=0;for(this[t]=255&e;++i<r&&(o*=256);)e<0&&0===s&&0!==this[t+i-1]&&(s=1),this[t+i]=(e/o>>0)-s&255;return t+r},u.prototype.writeIntBE=function(e,t,r,n){if(e=+e,t>>>=0,!n){const n=Math.pow(2,8*r-1);B(this,e,t,r,n-1,-n)}let i=r-1,o=1,s=0;for(this[t+i]=255&e;--i>=0&&(o*=256);)e<0&&0===s&&0!==this[t+i+1]&&(s=1),this[t+i]=(e/o>>0)-s&255;return t+r},u.prototype.writeInt8=function(e,t,r){return e=+e,t>>>=0,r||B(this,e,t,1,127,-128),e<0&&(e=255+e+1),this[t]=255&e,t+1},u.prototype.writeInt16LE=function(e,t,r){return e=+e,t>>>=0,r||B(this,e,t,2,32767,-32768),this[t]=255&e,this[t+1]=e>>>8,t+2},u.prototype.writeInt16BE=function(e,t,r){return e=+e,t>>>=0,r||B(this,e,t,2,32767,-32768),this[t]=e>>>8,this[t+1]=255&e,t+2},u.prototype.writeInt32LE=function(e,t,r){return e=+e,t>>>=0,r||B(this,e,t,4,2147483647,-2147483648),this[t]=255&e,this[t+1]=e>>>8,this[t+2]=e>>>16,this[t+3]=e>>>24,t+4},u.prototype.writeInt32BE=function(e,t,r){return e=+e,t>>>=0,r||B(this,e,t,4,2147483647,-2147483648),e<0&&(e=4294967295+e+1),this[t]=e>>>24,this[t+1]=e>>>16,this[t+2]=e>>>8,this[t+3]=255&e,t+4},u.prototype.writeBigInt64LE=Z((function(e,t=0){return A(this,e,t,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))})),u.prototype.writeBigInt64BE=Z((function(e,t=0){return U(this,e,t,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))})),u.prototype.writeFloatLE=function(e,t,r){return M(this,e,t,!0,r)},u.prototype.writeFloatBE=function(e,t,r){return M(this,e,t,!1,r)},u.prototype.writeDoubleLE=function(e,t,r){return D(this,e,t,!0,r)},u.prototype.writeDoubleBE=function(e,t,r){return D(this,e,t,!1,r)},u.prototype.copy=function(e,t,r,n){if(!u.isBuffer(e))throw new TypeError("argument should be a Buffer");if(r||(r=0),n||0===n||(n=this.length),t>=e.length&&(t=e.length),t||(t=0),n>0&&n<r&&(n=r),n===r)return 0;if(0===e.length||0===this.length)return 0;if(t<0)throw new RangeError("targetStart out of bounds");if(r<0||r>=this.length)throw new RangeError("Index out of range");if(n<0)throw new RangeError("sourceEnd out of bounds");n>this.length&&(n=this.length),e.length-t<n-r&&(n=e.length-t+r);const i=n-r;return this===e&&"function"==typeof Uint8Array.prototype.copyWithin?this.copyWithin(t,r,n):Uint8Array.prototype.set.call(e,this.subarray(r,n),t),i},u.prototype.fill=function(e,t,r,n){if("string"==typeof e){if("string"==typeof t?(n=t,t=0,r=this.length):"string"==typeof r&&(n=r,r=this.length),void 0!==n&&"string"!=typeof n)throw new TypeError("encoding must be a string");if("string"==typeof n&&!u.isEncoding(n))throw new TypeError("Unknown encoding: "+n);if(1===e.length){const t=e.charCodeAt(0);("utf8"===n&&t<128||"latin1"===n)&&(e=t)}}else"number"==typeof e?e&=255:"boolean"==typeof e&&(e=Number(e));if(t<0||this.length<t||this.length<r)throw new RangeError("Out of range index");if(r<=t)return this;let i;if(t>>>=0,r=void 0===r?this.length:r>>>0,e||(e=0),"number"==typeof e)for(i=t;i<r;++i)this[i]=e;else{const o=u.isBuffer(e)?e:u.from(e,n),s=o.length;if(0===s)throw new TypeError('The value "'+e+'" is invalid for argument "value"');for(i=0;i<r-t;++i)this[i+t]=o[i%s]}return this};const N={};function F(e,t,r){N[e]=class extends r{constructor(){super(),Object.defineProperty(this,"message",{value:t.apply(this,arguments),writable:!0,configurable:!0}),this.name=`${this.name} [${e}]`,this.stack,delete this.name}get code(){return e}set code(e){Object.defineProperty(this,"code",{configurable:!0,enumerable:!0,value:e,writable:!0})}toString(){return`${this.name} [${e}]: ${this.message}`}}}function q(e){let t="",r=e.length;const n="-"===e[0]?1:0;for(;r>=n+4;r-=3)t=`_${e.slice(r-3,r)}${t}`;return`${e.slice(0,r)}${t}`}function H(e,t,r,n,i,o){if(e>r||e<t){const n="bigint"==typeof t?"n":"";let i;throw i=o>3?0===t||t===BigInt(0)?`>= 0${n} and < 2${n} ** ${8*(o+1)}${n}`:`>= -(2${n} ** ${8*(o+1)-1}${n}) and < 2 ** ${8*(o+1)-1}${n}`:`>= ${t}${n} and <= ${r}${n}`,new N.ERR_OUT_OF_RANGE("value",i,e)}!function(e,t,r){$(t,"offset"),void 0!==e[t]&&void 0!==e[t+r]||W(t,e.length-(r+1))}(n,i,o)}function $(e,t){if("number"!=typeof e)throw new N.ERR_INVALID_ARG_TYPE(t,"number",e)}function W(e,t,r){if(Math.floor(e)!==e)throw $(e,r),new N.ERR_OUT_OF_RANGE(r||"offset","an integer",e);if(t<0)throw new N.ERR_BUFFER_OUT_OF_BOUNDS;throw new N.ERR_OUT_OF_RANGE(r||"offset",`>= ${r?1:0} and <= ${t}`,e)}F("ERR_BUFFER_OUT_OF_BOUNDS",(function(e){return e?`${e} is outside of buffer bounds`:"Attempt to access memory outside buffer bounds"}),RangeError),F("ERR_INVALID_ARG_TYPE",(function(e,t){return`The "${e}" argument must be of type number. Received type ${typeof t}`}),TypeError),F("ERR_OUT_OF_RANGE",(function(e,t,r){let n=`The value of "${e}" is out of range.`,i=r;return Number.isInteger(r)&&Math.abs(r)>2**32?i=q(String(r)):"bigint"==typeof r&&(i=String(r),(r>BigInt(2)**BigInt(32)||r<-(BigInt(2)**BigInt(32)))&&(i=q(i)),i+="n"),n+=` It must be ${t}. Received ${i}`,n}),RangeError);const z=/[^+/0-9A-Za-z-_]/g;function G(e,t){let r;t=t||1/0;const n=e.length;let i=null;const o=[];for(let s=0;s<n;++s){if(r=e.charCodeAt(s),r>55295&&r<57344){if(!i){if(r>56319){(t-=3)>-1&&o.push(239,191,189);continue}if(s+1===n){(t-=3)>-1&&o.push(239,191,189);continue}i=r;continue}if(r<56320){(t-=3)>-1&&o.push(239,191,189),i=r;continue}r=65536+(i-55296<<10|r-56320)}else i&&(t-=3)>-1&&o.push(239,191,189);if(i=null,r<128){if((t-=1)<0)break;o.push(r)}else if(r<2048){if((t-=2)<0)break;o.push(r>>6|192,63&r|128)}else if(r<65536){if((t-=3)<0)break;o.push(r>>12|224,r>>6&63|128,63&r|128)}else{if(!(r<1114112))throw new Error("Invalid code point");if((t-=4)<0)break;o.push(r>>18|240,r>>12&63|128,r>>6&63|128,63&r|128)}}return o}function V(e){return n.toByteArray(function(e){if((e=(e=e.split("=")[0]).trim().replace(z,"")).length<2)return"";for(;e.length%4!=0;)e+="=";return e}(e))}function Y(e,t,r,n){let i;for(i=0;i<n&&!(i+r>=t.length||i>=e.length);++i)t[i+r]=e[i];return i}function J(e,t){return e instanceof t||null!=e&&null!=e.constructor&&null!=e.constructor.name&&e.constructor.name===t.name}function K(e){return e!=e}const X=function(){const e="0123456789abcdef",t=new Array(256);for(let r=0;r<16;++r){const n=16*r;for(let i=0;i<16;++i)t[n+i]=e[r]+e[i]}return t}();function Z(e){return"undefined"==typeof BigInt?Q:e}function Q(){throw new Error("BigInt not supported")}},488:e=>{"use strict";var t,r="object"==typeof Reflect?Reflect:null,n=r&&"function"==typeof r.apply?r.apply:function(e,t,r){return Function.prototype.apply.call(e,t,r)};t=r&&"function"==typeof r.ownKeys?r.ownKeys:Object.getOwnPropertySymbols?function(e){return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e))}:function(e){return Object.getOwnPropertyNames(e)};var i=Number.isNaN||function(e){return e!=e};function o(){o.init.call(this)}e.exports=o,e.exports.once=function(e,t){return new Promise((function(r,n){function i(){void 0!==o&&e.removeListener("error",o),r([].slice.call(arguments))}var o;"error"!==t&&(o=function(r){e.removeListener(t,i),n(r)},e.once("error",o)),e.once(t,i)}))},o.EventEmitter=o,o.prototype._events=void 0,o.prototype._eventsCount=0,o.prototype._maxListeners=void 0;var s=10;function a(e){if("function"!=typeof e)throw new TypeError('The "listener" argument must be of type Function. Received type '+typeof e)}function u(e){return void 0===e._maxListeners?o.defaultMaxListeners:e._maxListeners}function c(e,t,r,n){var i,o,s,c;if(a(r),void 0===(o=e._events)?(o=e._events=Object.create(null),e._eventsCount=0):(void 0!==o.newListener&&(e.emit("newListener",t,r.listener?r.listener:r),o=e._events),s=o[t]),void 0===s)s=o[t]=r,++e._eventsCount;else if("function"==typeof s?s=o[t]=n?[r,s]:[s,r]:n?s.unshift(r):s.push(r),(i=u(e))>0&&s.length>i&&!s.warned){s.warned=!0;var l=new Error("Possible EventEmitter memory leak detected. "+s.length+" "+String(t)+" listeners added. Use emitter.setMaxListeners() to increase limit");l.name="MaxListenersExceededWarning",l.emitter=e,l.type=t,l.count=s.length,c=l,console&&console.warn&&console.warn(c)}return e}function l(){if(!this.fired)return this.target.removeListener(this.type,this.wrapFn),this.fired=!0,0===arguments.length?this.listener.call(this.target):this.listener.apply(this.target,arguments)}function h(e,t,r){var n={fired:!1,wrapFn:void 0,target:e,type:t,listener:r},i=l.bind(n);return i.listener=r,n.wrapFn=i,i}function f(e,t,r){var n=e._events;if(void 0===n)return[];var i=n[t];return void 0===i?[]:"function"==typeof i?r?[i.listener||i]:[i]:r?function(e){for(var t=new Array(e.length),r=0;r<t.length;++r)t[r]=e[r].listener||e[r];return t}(i):p(i,i.length)}function d(e){var t=this._events;if(void 0!==t){var r=t[e];if("function"==typeof r)return 1;if(void 0!==r)return r.length}return 0}function p(e,t){for(var r=new Array(t),n=0;n<t;++n)r[n]=e[n];return r}Object.defineProperty(o,"defaultMaxListeners",{enumerable:!0,get:function(){return s},set:function(e){if("number"!=typeof e||e<0||i(e))throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received '+e+".");s=e}}),o.init=function(){void 0!==this._events&&this._events!==Object.getPrototypeOf(this)._events||(this._events=Object.create(null),this._eventsCount=0),this._maxListeners=this._maxListeners||void 0},o.prototype.setMaxListeners=function(e){if("number"!=typeof e||e<0||i(e))throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received '+e+".");return this._maxListeners=e,this},o.prototype.getMaxListeners=function(){return u(this)},o.prototype.emit=function(e){for(var t=[],r=1;r<arguments.length;r++)t.push(arguments[r]);var i="error"===e,o=this._events;if(void 0!==o)i=i&&void 0===o.error;else if(!i)return!1;if(i){var s;if(t.length>0&&(s=t[0]),s instanceof Error)throw s;var a=new Error("Unhandled error."+(s?" ("+s.message+")":""));throw a.context=s,a}var u=o[e];if(void 0===u)return!1;if("function"==typeof u)n(u,this,t);else{var c=u.length,l=p(u,c);for(r=0;r<c;++r)n(l[r],this,t)}return!0},o.prototype.addListener=function(e,t){return c(this,e,t,!1)},o.prototype.on=o.prototype.addListener,o.prototype.prependListener=function(e,t){return c(this,e,t,!0)},o.prototype.once=function(e,t){return a(t),this.on(e,h(this,e,t)),this},o.prototype.prependOnceListener=function(e,t){return a(t),this.prependListener(e,h(this,e,t)),this},o.prototype.removeListener=function(e,t){var r,n,i,o,s;if(a(t),void 0===(n=this._events))return this;if(void 0===(r=n[e]))return this;if(r===t||r.listener===t)0==--this._eventsCount?this._events=Object.create(null):(delete n[e],n.removeListener&&this.emit("removeListener",e,r.listener||t));else if("function"!=typeof r){for(i=-1,o=r.length-1;o>=0;o--)if(r[o]===t||r[o].listener===t){s=r[o].listener,i=o;break}if(i<0)return this;0===i?r.shift():function(e,t){for(;t+1<e.length;t++)e[t]=e[t+1];e.pop()}(r,i),1===r.length&&(n[e]=r[0]),void 0!==n.removeListener&&this.emit("removeListener",e,s||t)}return this},o.prototype.off=o.prototype.removeListener,o.prototype.removeAllListeners=function(e){var t,r,n;if(void 0===(r=this._events))return this;if(void 0===r.removeListener)return 0===arguments.length?(this._events=Object.create(null),this._eventsCount=0):void 0!==r[e]&&(0==--this._eventsCount?this._events=Object.create(null):delete r[e]),this;if(0===arguments.length){var i,o=Object.keys(r);for(n=0;n<o.length;++n)"removeListener"!==(i=o[n])&&this.removeAllListeners(i);return this.removeAllListeners("removeListener"),this._events=Object.create(null),this._eventsCount=0,this}if("function"==typeof(t=r[e]))this.removeListener(e,t);else if(void 0!==t)for(n=t.length-1;n>=0;n--)this.removeListener(e,t[n]);return this},o.prototype.listeners=function(e){return f(this,e,!0)},o.prototype.rawListeners=function(e){return f(this,e,!1)},o.listenerCount=function(e,t){return"function"==typeof e.listenerCount?e.listenerCount(t):d.call(e,t)},o.prototype.listenerCount=d,o.prototype.eventNames=function(){return this._eventsCount>0?t(this._events):[]}},9258:(e,t)=>{t.read=function(e,t,r,n,i){var o,s,a=8*i-n-1,u=(1<<a)-1,c=u>>1,l=-7,h=r?i-1:0,f=r?-1:1,d=e[t+h];for(h+=f,o=d&(1<<-l)-1,d>>=-l,l+=a;l>0;o=256*o+e[t+h],h+=f,l-=8);for(s=o&(1<<-l)-1,o>>=-l,l+=n;l>0;s=256*s+e[t+h],h+=f,l-=8);if(0===o)o=1-c;else{if(o===u)return s?NaN:1/0*(d?-1:1);s+=Math.pow(2,n),o-=c}return(d?-1:1)*s*Math.pow(2,o-n)},t.write=function(e,t,r,n,i,o){var s,a,u,c=8*o-i-1,l=(1<<c)-1,h=l>>1,f=23===i?Math.pow(2,-24)-Math.pow(2,-77):0,d=n?0:o-1,p=n?1:-1,m=t<0||0===t&&1/t<0?1:0;for(t=Math.abs(t),isNaN(t)||t===1/0?(a=isNaN(t)?1:0,s=l):(s=Math.floor(Math.log(t)/Math.LN2),t*(u=Math.pow(2,-s))<1&&(s--,u*=2),(t+=s+h>=1?f/u:f*Math.pow(2,1-h))*u>=2&&(s++,u/=2),s+h>=l?(a=0,s=l):s+h>=1?(a=(t*u-1)*Math.pow(2,i),s+=h):(a=t*Math.pow(2,h-1)*Math.pow(2,i),s=0));i>=8;e[r+d]=255&a,d+=p,a/=256,i-=8);for(s=s<<i|a,c+=i;c>0;e[r+d]=255&s,d+=p,s/=256,c-=8);e[r+d-p]|=128*m}},3730:e=>{"function"==typeof Object.create?e.exports=function(e,t){t&&(e.super_=t,e.prototype=Object.create(t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}))}:e.exports=function(e,t){if(t){e.super_=t;var r=function(){};r.prototype=t.prototype,e.prototype=new r,e.prototype.constructor=e}}},6117:e=>{var t=1e3,r=60*t,n=60*r,i=24*n;function o(e,t,r,n){var i=t>=1.5*r;return Math.round(e/r)+" "+n+(i?"s":"")}e.exports=function(e,s){s=s||{};var a,u,c=typeof e;if("string"===c&&e.length>0)return function(e){if(!((e=String(e)).length>100)){var o=/^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(e);if(o){var s=parseFloat(o[1]);switch((o[2]||"ms").toLowerCase()){case"years":case"year":case"yrs":case"yr":case"y":return 315576e5*s;case"weeks":case"week":case"w":return 6048e5*s;case"days":case"day":case"d":return s*i;case"hours":case"hour":case"hrs":case"hr":case"h":return s*n;case"minutes":case"minute":case"mins":case"min":case"m":return s*r;case"seconds":case"second":case"secs":case"sec":case"s":return s*t;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return s;default:return}}}}(e);if("number"===c&&isFinite(e))return s.long?(a=e,(u=Math.abs(a))>=i?o(a,u,i,"day"):u>=n?o(a,u,n,"hour"):u>=r?o(a,u,r,"minute"):u>=t?o(a,u,t,"second"):a+" ms"):function(e){var o=Math.abs(e);return o>=i?Math.round(e/i)+"d":o>=n?Math.round(e/n)+"h":o>=r?Math.round(e/r)+"m":o>=t?Math.round(e/t)+"s":e+"ms"}(e);throw new Error("val is not a non-empty string or a valid number. val="+JSON.stringify(e))}},2695:e=>{var t,r,n=e.exports={};function i(){throw new Error("setTimeout has not been defined")}function o(){throw new Error("clearTimeout has not been defined")}function s(e){if(t===setTimeout)return setTimeout(e,0);if((t===i||!t)&&setTimeout)return t=setTimeout,setTimeout(e,0);try{return t(e,0)}catch(r){try{return t.call(null,e,0)}catch(r){return t.call(this,e,0)}}}!function(){try{t="function"==typeof setTimeout?setTimeout:i}catch(e){t=i}try{r="function"==typeof clearTimeout?clearTimeout:o}catch(e){r=o}}();var a,u=[],c=!1,l=-1;function h(){c&&a&&(c=!1,a.length?u=a.concat(u):l=-1,u.length&&f())}function f(){if(!c){var e=s(h);c=!0;for(var t=u.length;t;){for(a=u,u=[];++l<t;)a&&a[l].run();l=-1,t=u.length}a=null,c=!1,function(e){if(r===clearTimeout)return clearTimeout(e);if((r===o||!r)&&clearTimeout)return r=clearTimeout,clearTimeout(e);try{r(e)}catch(t){try{return r.call(null,e)}catch(t){return r.call(this,e)}}}(e)}}function d(e,t){this.fun=e,this.array=t}function p(){}n.nextTick=function(e){var t=new Array(arguments.length-1);if(arguments.length>1)for(var r=1;r<arguments.length;r++)t[r-1]=arguments[r];u.push(new d(e,t)),1!==u.length||c||s(f)},d.prototype.run=function(){this.fun.apply(null,this.array)},n.title="browser",n.browser=!0,n.env={},n.argv=[],n.version="",n.versions={},n.on=p,n.addListener=p,n.once=p,n.off=p,n.removeListener=p,n.removeAllListeners=p,n.emit=p,n.prependListener=p,n.prependOnceListener=p,n.listeners=function(e){return[]},n.binding=function(e){throw new Error("process.binding is not supported")},n.cwd=function(){return"/"},n.chdir=function(e){throw new Error("process.chdir is not supported")},n.umask=function(){return 0}},553:e=>{"use strict";var t={};function r(e,r,n){n||(n=Error);var i=function(e){var t,n;function i(t,n,i){return e.call(this,function(e,t,n){return"string"==typeof r?r:r(e,t,n)}(t,n,i))||this}return n=e,(t=i).prototype=Object.create(n.prototype),t.prototype.constructor=t,t.__proto__=n,i}(n);i.prototype.name=n.name,i.prototype.code=e,t[e]=i}function n(e,t){if(Array.isArray(e)){var r=e.length;return e=e.map((function(e){return String(e)})),r>2?"one of ".concat(t," ").concat(e.slice(0,r-1).join(", "),", or ")+e[r-1]:2===r?"one of ".concat(t," ").concat(e[0]," or ").concat(e[1]):"of ".concat(t," ").concat(e[0])}return"of ".concat(t," ").concat(String(e))}r("ERR_INVALID_OPT_VALUE",(function(e,t){return'The value "'+t+'" is invalid for option "'+e+'"'}),TypeError),r("ERR_INVALID_ARG_TYPE",(function(e,t,r){var i,o,s,a,u;if("string"==typeof t&&(o="not ",t.substr(0,o.length)===o)?(i="must not be",t=t.replace(/^not /,"")):i="must be",function(e,t,r){return(void 0===r||r>e.length)&&(r=e.length),e.substring(r-t.length,r)===t}(e," argument"))s="The ".concat(e," ").concat(i," ").concat(n(t,"type"));else{var c=("number"!=typeof u&&(u=0),u+".".length>(a=e).length||-1===a.indexOf(".",u)?"argument":"property");s='The "'.concat(e,'" ').concat(c," ").concat(i," ").concat(n(t,"type"))}return s+". Received type ".concat(typeof r)}),TypeError),r("ERR_STREAM_PUSH_AFTER_EOF","stream.push() after EOF"),r("ERR_METHOD_NOT_IMPLEMENTED",(function(e){return"The "+e+" method is not implemented"})),r("ERR_STREAM_PREMATURE_CLOSE","Premature close"),r("ERR_STREAM_DESTROYED",(function(e){return"Cannot call "+e+" after a stream was destroyed"})),r("ERR_MULTIPLE_CALLBACK","Callback called multiple times"),r("ERR_STREAM_CANNOT_PIPE","Cannot pipe, not readable"),r("ERR_STREAM_WRITE_AFTER_END","write after end"),r("ERR_STREAM_NULL_VALUES","May not write null values to stream",TypeError),r("ERR_UNKNOWN_ENCODING",(function(e){return"Unknown encoding: "+e}),TypeError),r("ERR_STREAM_UNSHIFT_AFTER_END_EVENT","stream.unshift() after end event"),e.exports.q=t},673:(e,t,r)=>{"use strict";var n=r(2695),i=Object.keys||function(e){var t=[];for(var r in e)t.push(r);return t};e.exports=l;var o=r(5006),s=r(8719);r(3730)(l,o);for(var a=i(s.prototype),u=0;u<a.length;u++){var c=a[u];l.prototype[c]||(l.prototype[c]=s.prototype[c])}function l(e){if(!(this instanceof l))return new l(e);o.call(this,e),s.call(this,e),this.allowHalfOpen=!0,e&&(!1===e.readable&&(this.readable=!1),!1===e.writable&&(this.writable=!1),!1===e.allowHalfOpen&&(this.allowHalfOpen=!1,this.once("end",h)))}function h(){this._writableState.ended||n.nextTick(f,this)}function f(e){e.end()}Object.defineProperty(l.prototype,"writableHighWaterMark",{enumerable:!1,get:function(){return this._writableState.highWaterMark}}),Object.defineProperty(l.prototype,"writableBuffer",{enumerable:!1,get:function(){return this._writableState&&this._writableState.getBuffer()}}),Object.defineProperty(l.prototype,"writableLength",{enumerable:!1,get:function(){return this._writableState.length}}),Object.defineProperty(l.prototype,"destroyed",{enumerable:!1,get:function(){return void 0!==this._readableState&&void 0!==this._writableState&&this._readableState.destroyed&&this._writableState.destroyed},set:function(e){void 0!==this._readableState&&void 0!==this._writableState&&(this._readableState.destroyed=e,this._writableState.destroyed=e)}})},4343:(e,t,r)=>{"use strict";e.exports=i;var n=r(8597);function i(e){if(!(this instanceof i))return new i(e);n.call(this,e)}r(3730)(i,n),i.prototype._transform=function(e,t,r){r(null,e)}},5006:(e,t,r)=>{"use strict";var n,i=r(2695);e.exports=R,R.ReadableState=x,r(488).EventEmitter;var o,s=function(e,t){return e.listeners(t).length},a=r(8208),u=r(7866).Buffer,c=r.g.Uint8Array||function(){},l=r(6029);o=l&&l.debuglog?l.debuglog("stream"):function(){};var h,f,d,p=r(4506),m=r(3390),g=r(1111).getHighWaterMark,y=r(553).q,b=y.ERR_INVALID_ARG_TYPE,v=y.ERR_STREAM_PUSH_AFTER_EOF,w=y.ERR_METHOD_NOT_IMPLEMENTED,_=y.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;r(3730)(R,a);var S=m.errorOrDestroy,E=["error","close","destroy","pause","resume"];function x(e,t,i){n=n||r(673),e=e||{},"boolean"!=typeof i&&(i=t instanceof n),this.objectMode=!!e.objectMode,i&&(this.objectMode=this.objectMode||!!e.readableObjectMode),this.highWaterMark=g(this,e,"readableHighWaterMark",i),this.buffer=new p,this.length=0,this.pipes=null,this.pipesCount=0,this.flowing=null,this.ended=!1,this.endEmitted=!1,this.reading=!1,this.sync=!0,this.needReadable=!1,this.emittedReadable=!1,this.readableListening=!1,this.resumeScheduled=!1,this.paused=!0,this.emitClose=!1!==e.emitClose,this.autoDestroy=!!e.autoDestroy,this.destroyed=!1,this.defaultEncoding=e.defaultEncoding||"utf8",this.awaitDrain=0,this.readingMore=!1,this.decoder=null,this.encoding=null,e.encoding&&(h||(h=r(7361).s),this.decoder=new h(e.encoding),this.encoding=e.encoding)}function R(e){if(n=n||r(673),!(this instanceof R))return new R(e);var t=this instanceof n;this._readableState=new x(e,this,t),this.readable=!0,e&&("function"==typeof e.read&&(this._read=e.read),"function"==typeof e.destroy&&(this._destroy=e.destroy)),a.call(this)}function T(e,t,r,n,i){o("readableAddChunk",t);var s,a=e._readableState;if(null===t)a.reading=!1,function(e,t){if(o("onEofChunk"),!t.ended){if(t.decoder){var r=t.decoder.end();r&&r.length&&(t.buffer.push(r),t.length+=t.objectMode?1:r.length)}t.ended=!0,t.sync?P(e):(t.needReadable=!1,t.emittedReadable||(t.emittedReadable=!0,I(e)))}}(e,a);else if(i||(s=function(e,t){var r,n;return n=t,u.isBuffer(n)||n instanceof c||"string"==typeof t||void 0===t||e.objectMode||(r=new b("chunk",["string","Buffer","Uint8Array"],t)),r}(a,t)),s)S(e,s);else if(a.objectMode||t&&t.length>0)if("string"==typeof t||a.objectMode||Object.getPrototypeOf(t)===u.prototype||(t=function(e){return u.from(e)}(t)),n)a.endEmitted?S(e,new _):C(e,a,t,!0);else if(a.ended)S(e,new v);else{if(a.destroyed)return!1;a.reading=!1,a.decoder&&!r?(t=a.decoder.write(t),a.objectMode||0!==t.length?C(e,a,t,!1):L(e,a)):C(e,a,t,!1)}else n||(a.reading=!1,L(e,a));return!a.ended&&(a.length<a.highWaterMark||0===a.length)}function C(e,t,r,n){t.flowing&&0===t.length&&!t.sync?(t.awaitDrain=0,e.emit("data",r)):(t.length+=t.objectMode?1:r.length,n?t.buffer.unshift(r):t.buffer.push(r),t.needReadable&&P(e)),L(e,t)}Object.defineProperty(R.prototype,"destroyed",{enumerable:!1,get:function(){return void 0!==this._readableState&&this._readableState.destroyed},set:function(e){this._readableState&&(this._readableState.destroyed=e)}}),R.prototype.destroy=m.destroy,R.prototype._undestroy=m.undestroy,R.prototype._destroy=function(e,t){t(e)},R.prototype.push=function(e,t){var r,n=this._readableState;return n.objectMode?r=!0:"string"==typeof e&&((t=t||n.defaultEncoding)!==n.encoding&&(e=u.from(e,t),t=""),r=!0),T(this,e,t,!1,r)},R.prototype.unshift=function(e){return T(this,e,null,!0,!1)},R.prototype.isPaused=function(){return!1===this._readableState.flowing},R.prototype.setEncoding=function(e){h||(h=r(7361).s);var t=new h(e);this._readableState.decoder=t,this._readableState.encoding=this._readableState.decoder.encoding;for(var n=this._readableState.buffer.head,i="";null!==n;)i+=t.write(n.data),n=n.next;return this._readableState.buffer.clear(),""!==i&&this._readableState.buffer.push(i),this._readableState.length=i.length,this};var k=1073741824;function O(e,t){return e<=0||0===t.length&&t.ended?0:t.objectMode?1:e!=e?t.flowing&&t.length?t.buffer.head.data.length:t.length:(e>t.highWaterMark&&(t.highWaterMark=function(e){return e>=k?e=k:(e--,e|=e>>>1,e|=e>>>2,e|=e>>>4,e|=e>>>8,e|=e>>>16,e++),e}(e)),e<=t.length?e:t.ended?t.length:(t.needReadable=!0,0))}function P(e){var t=e._readableState;o("emitReadable",t.needReadable,t.emittedReadable),t.needReadable=!1,t.emittedReadable||(o("emitReadable",t.flowing),t.emittedReadable=!0,i.nextTick(I,e))}function I(e){var t=e._readableState;o("emitReadable_",t.destroyed,t.length,t.ended),t.destroyed||!t.length&&!t.ended||(e.emit("readable"),t.emittedReadable=!1),t.needReadable=!t.flowing&&!t.ended&&t.length<=t.highWaterMark,M(e)}function L(e,t){t.readingMore||(t.readingMore=!0,i.nextTick(B,e,t))}function B(e,t){for(;!t.reading&&!t.ended&&(t.length<t.highWaterMark||t.flowing&&0===t.length);){var r=t.length;if(o("maybeReadMore read 0"),e.read(0),r===t.length)break}t.readingMore=!1}function A(e){var t=e._readableState;t.readableListening=e.listenerCount("readable")>0,t.resumeScheduled&&!t.paused?t.flowing=!0:e.listenerCount("data")>0&&e.resume()}function U(e){o("readable nexttick read 0"),e.read(0)}function j(e,t){o("resume",t.reading),t.reading||e.read(0),t.resumeScheduled=!1,e.emit("resume"),M(e),t.flowing&&!t.reading&&e.read(0)}function M(e){var t=e._readableState;for(o("flow",t.flowing);t.flowing&&null!==e.read(););}function D(e,t){return 0===t.length?null:(t.objectMode?r=t.buffer.shift():!e||e>=t.length?(r=t.decoder?t.buffer.join(""):1===t.buffer.length?t.buffer.first():t.buffer.concat(t.length),t.buffer.clear()):r=t.buffer.consume(e,t.decoder),r);var r}function N(e){var t=e._readableState;o("endReadable",t.endEmitted),t.endEmitted||(t.ended=!0,i.nextTick(F,t,e))}function F(e,t){if(o("endReadableNT",e.endEmitted,e.length),!e.endEmitted&&0===e.length&&(e.endEmitted=!0,t.readable=!1,t.emit("end"),e.autoDestroy)){var r=t._writableState;(!r||r.autoDestroy&&r.finished)&&t.destroy()}}function q(e,t){for(var r=0,n=e.length;r<n;r++)if(e[r]===t)return r;return-1}R.prototype.read=function(e){o("read",e),e=parseInt(e,10);var t=this._readableState,r=e;if(0!==e&&(t.emittedReadable=!1),0===e&&t.needReadable&&((0!==t.highWaterMark?t.length>=t.highWaterMark:t.length>0)||t.ended))return o("read: emitReadable",t.length,t.ended),0===t.length&&t.ended?N(this):P(this),null;if(0===(e=O(e,t))&&t.ended)return 0===t.length&&N(this),null;var n,i=t.needReadable;return o("need readable",i),(0===t.length||t.length-e<t.highWaterMark)&&o("length less than watermark",i=!0),t.ended||t.reading?o("reading or ended",i=!1):i&&(o("do read"),t.reading=!0,t.sync=!0,0===t.length&&(t.needReadable=!0),this._read(t.highWaterMark),t.sync=!1,t.reading||(e=O(r,t))),null===(n=e>0?D(e,t):null)?(t.needReadable=t.length<=t.highWaterMark,e=0):(t.length-=e,t.awaitDrain=0),0===t.length&&(t.ended||(t.needReadable=!0),r!==e&&t.ended&&N(this)),null!==n&&this.emit("data",n),n},R.prototype._read=function(e){S(this,new w("_read()"))},R.prototype.pipe=function(e,t){var r=this,n=this._readableState;switch(n.pipesCount){case 0:n.pipes=e;break;case 1:n.pipes=[n.pipes,e];break;default:n.pipes.push(e)}n.pipesCount+=1,o("pipe count=%d opts=%j",n.pipesCount,t);var a=t&&!1===t.end||e===i.stdout||e===i.stderr?m:u;function u(){o("onend"),e.end()}n.endEmitted?i.nextTick(a):r.once("end",a),e.on("unpipe",(function t(i,s){o("onunpipe"),i===r&&s&&!1===s.hasUnpiped&&(s.hasUnpiped=!0,o("cleanup"),e.removeListener("close",d),e.removeListener("finish",p),e.removeListener("drain",c),e.removeListener("error",f),e.removeListener("unpipe",t),r.removeListener("end",u),r.removeListener("end",m),r.removeListener("data",h),l=!0,!n.awaitDrain||e._writableState&&!e._writableState.needDrain||c())}));var c=function(e){return function(){var t=e._readableState;o("pipeOnDrain",t.awaitDrain),t.awaitDrain&&t.awaitDrain--,0===t.awaitDrain&&s(e,"data")&&(t.flowing=!0,M(e))}}(r);e.on("drain",c);var l=!1;function h(t){o("ondata");var i=e.write(t);o("dest.write",i),!1===i&&((1===n.pipesCount&&n.pipes===e||n.pipesCount>1&&-1!==q(n.pipes,e))&&!l&&(o("false write response, pause",n.awaitDrain),n.awaitDrain++),r.pause())}function f(t){o("onerror",t),m(),e.removeListener("error",f),0===s(e,"error")&&S(e,t)}function d(){e.removeListener("finish",p),m()}function p(){o("onfinish"),e.removeListener("close",d),m()}function m(){o("unpipe"),r.unpipe(e)}return r.on("data",h),function(e,t,r){if("function"==typeof e.prependListener)return e.prependListener(t,r);e._events&&e._events.error?Array.isArray(e._events.error)?e._events.error.unshift(r):e._events.error=[r,e._events.error]:e.on(t,r)}(e,"error",f),e.once("close",d),e.once("finish",p),e.emit("pipe",r),n.flowing||(o("pipe resume"),r.resume()),e},R.prototype.unpipe=function(e){var t=this._readableState,r={hasUnpiped:!1};if(0===t.pipesCount)return this;if(1===t.pipesCount)return e&&e!==t.pipes||(e||(e=t.pipes),t.pipes=null,t.pipesCount=0,t.flowing=!1,e&&e.emit("unpipe",this,r)),this;if(!e){var n=t.pipes,i=t.pipesCount;t.pipes=null,t.pipesCount=0,t.flowing=!1;for(var o=0;o<i;o++)n[o].emit("unpipe",this,{hasUnpiped:!1});return this}var s=q(t.pipes,e);return-1===s||(t.pipes.splice(s,1),t.pipesCount-=1,1===t.pipesCount&&(t.pipes=t.pipes[0]),e.emit("unpipe",this,r)),this},R.prototype.on=function(e,t){var r=a.prototype.on.call(this,e,t),n=this._readableState;return"data"===e?(n.readableListening=this.listenerCount("readable")>0,!1!==n.flowing&&this.resume()):"readable"===e&&(n.endEmitted||n.readableListening||(n.readableListening=n.needReadable=!0,n.flowing=!1,n.emittedReadable=!1,o("on readable",n.length,n.reading),n.length?P(this):n.reading||i.nextTick(U,this))),r},R.prototype.addListener=R.prototype.on,R.prototype.removeListener=function(e,t){var r=a.prototype.removeListener.call(this,e,t);return"readable"===e&&i.nextTick(A,this),r},R.prototype.removeAllListeners=function(e){var t=a.prototype.removeAllListeners.apply(this,arguments);return"readable"!==e&&void 0!==e||i.nextTick(A,this),t},R.prototype.resume=function(){var e=this._readableState;return e.flowing||(o("resume"),e.flowing=!e.readableListening,function(e,t){t.resumeScheduled||(t.resumeScheduled=!0,i.nextTick(j,e,t))}(this,e)),e.paused=!1,this},R.prototype.pause=function(){return o("call pause flowing=%j",this._readableState.flowing),!1!==this._readableState.flowing&&(o("pause"),this._readableState.flowing=!1,this.emit("pause")),this._readableState.paused=!0,this},R.prototype.wrap=function(e){var t=this,r=this._readableState,n=!1;for(var i in e.on("end",(function(){if(o("wrapped end"),r.decoder&&!r.ended){var e=r.decoder.end();e&&e.length&&t.push(e)}t.push(null)})),e.on("data",(function(i){o("wrapped data"),r.decoder&&(i=r.decoder.write(i)),r.objectMode&&null==i||(r.objectMode||i&&i.length)&&(t.push(i)||(n=!0,e.pause()))})),e)void 0===this[i]&&"function"==typeof e[i]&&(this[i]=function(t){return function(){return e[t].apply(e,arguments)}}(i));for(var s=0;s<E.length;s++)e.on(E[s],this.emit.bind(this,E[s]));return this._read=function(t){o("wrapped _read",t),n&&(n=!1,e.resume())},this},"function"==typeof Symbol&&(R.prototype[Symbol.asyncIterator]=function(){return void 0===f&&(f=r(8187)),f(this)}),Object.defineProperty(R.prototype,"readableHighWaterMark",{enumerable:!1,get:function(){return this._readableState.highWaterMark}}),Object.defineProperty(R.prototype,"readableBuffer",{enumerable:!1,get:function(){return this._readableState&&this._readableState.buffer}}),Object.defineProperty(R.prototype,"readableFlowing",{enumerable:!1,get:function(){return this._readableState.flowing},set:function(e){this._readableState&&(this._readableState.flowing=e)}}),R._fromList=D,Object.defineProperty(R.prototype,"readableLength",{enumerable:!1,get:function(){return this._readableState.length}}),"function"==typeof Symbol&&(R.from=function(e,t){return void 0===d&&(d=r(3733)),d(R,e,t)})},8597:(e,t,r)=>{"use strict";e.exports=l;var n=r(553).q,i=n.ERR_METHOD_NOT_IMPLEMENTED,o=n.ERR_MULTIPLE_CALLBACK,s=n.ERR_TRANSFORM_ALREADY_TRANSFORMING,a=n.ERR_TRANSFORM_WITH_LENGTH_0,u=r(673);function c(e,t){var r=this._transformState;r.transforming=!1;var n=r.writecb;if(null===n)return this.emit("error",new o);r.writechunk=null,r.writecb=null,null!=t&&this.push(t),n(e);var i=this._readableState;i.reading=!1,(i.needReadable||i.length<i.highWaterMark)&&this._read(i.highWaterMark)}function l(e){if(!(this instanceof l))return new l(e);u.call(this,e),this._transformState={afterTransform:c.bind(this),needTransform:!1,transforming:!1,writecb:null,writechunk:null,writeencoding:null},this._readableState.needReadable=!0,this._readableState.sync=!1,e&&("function"==typeof e.transform&&(this._transform=e.transform),"function"==typeof e.flush&&(this._flush=e.flush)),this.on("prefinish",h)}function h(){var e=this;"function"!=typeof this._flush||this._readableState.destroyed?f(this,null,null):this._flush((function(t,r){f(e,t,r)}))}function f(e,t,r){if(t)return e.emit("error",t);if(null!=r&&e.push(r),e._writableState.length)throw new a;if(e._transformState.transforming)throw new s;return e.push(null)}r(3730)(l,u),l.prototype.push=function(e,t){return this._transformState.needTransform=!1,u.prototype.push.call(this,e,t)},l.prototype._transform=function(e,t,r){r(new i("_transform()"))},l.prototype._write=function(e,t,r){var n=this._transformState;if(n.writecb=r,n.writechunk=e,n.writeencoding=t,!n.transforming){var i=this._readableState;(n.needTransform||i.needReadable||i.length<i.highWaterMark)&&this._read(i.highWaterMark)}},l.prototype._read=function(e){var t=this._transformState;null===t.writechunk||t.transforming?t.needTransform=!0:(t.transforming=!0,this._transform(t.writechunk,t.writeencoding,t.afterTransform))},l.prototype._destroy=function(e,t){u.prototype._destroy.call(this,e,(function(e){t(e)}))}},8719:(e,t,r)=>{"use strict";var n,i=r(2695);function o(e){var t=this;this.next=null,this.entry=null,this.finish=function(){!function(e,t,r){var n=e.entry;for(e.entry=null;n;){var i=n.callback;t.pendingcb--,i(undefined),n=n.next}t.corkedRequestsFree.next=e}(t,e)}}e.exports=R,R.WritableState=x;var s,a={deprecate:r(72)},u=r(8208),c=r(7866).Buffer,l=r.g.Uint8Array||function(){},h=r(3390),f=r(1111).getHighWaterMark,d=r(553).q,p=d.ERR_INVALID_ARG_TYPE,m=d.ERR_METHOD_NOT_IMPLEMENTED,g=d.ERR_MULTIPLE_CALLBACK,y=d.ERR_STREAM_CANNOT_PIPE,b=d.ERR_STREAM_DESTROYED,v=d.ERR_STREAM_NULL_VALUES,w=d.ERR_STREAM_WRITE_AFTER_END,_=d.ERR_UNKNOWN_ENCODING,S=h.errorOrDestroy;function E(){}function x(e,t,s){n=n||r(673),e=e||{},"boolean"!=typeof s&&(s=t instanceof n),this.objectMode=!!e.objectMode,s&&(this.objectMode=this.objectMode||!!e.writableObjectMode),this.highWaterMark=f(this,e,"writableHighWaterMark",s),this.finalCalled=!1,this.needDrain=!1,this.ending=!1,this.ended=!1,this.finished=!1,this.destroyed=!1;var a=!1===e.decodeStrings;this.decodeStrings=!a,this.defaultEncoding=e.defaultEncoding||"utf8",this.length=0,this.writing=!1,this.corked=0,this.sync=!0,this.bufferProcessing=!1,this.onwrite=function(e){!function(e,t){var r=e._writableState,n=r.sync,o=r.writecb;if("function"!=typeof o)throw new g;if(function(e){e.writing=!1,e.writecb=null,e.length-=e.writelen,e.writelen=0}(r),t)!function(e,t,r,n,o){--t.pendingcb,r?(i.nextTick(o,n),i.nextTick(I,e,t),e._writableState.errorEmitted=!0,S(e,n)):(o(n),e._writableState.errorEmitted=!0,S(e,n),I(e,t))}(e,r,n,t,o);else{var s=O(r)||e.destroyed;s||r.corked||r.bufferProcessing||!r.bufferedRequest||k(e,r),n?i.nextTick(C,e,r,s,o):C(e,r,s,o)}}(t,e)},this.writecb=null,this.writelen=0,this.bufferedRequest=null,this.lastBufferedRequest=null,this.pendingcb=0,this.prefinished=!1,this.errorEmitted=!1,this.emitClose=!1!==e.emitClose,this.autoDestroy=!!e.autoDestroy,this.bufferedRequestCount=0,this.corkedRequestsFree=new o(this)}function R(e){var t=this instanceof(n=n||r(673));if(!t&&!s.call(R,this))return new R(e);this._writableState=new x(e,this,t),this.writable=!0,e&&("function"==typeof e.write&&(this._write=e.write),"function"==typeof e.writev&&(this._writev=e.writev),"function"==typeof e.destroy&&(this._destroy=e.destroy),"function"==typeof e.final&&(this._final=e.final)),u.call(this)}function T(e,t,r,n,i,o,s){t.writelen=n,t.writecb=s,t.writing=!0,t.sync=!0,t.destroyed?t.onwrite(new b("write")):r?e._writev(i,t.onwrite):e._write(i,o,t.onwrite),t.sync=!1}function C(e,t,r,n){r||function(e,t){0===t.length&&t.needDrain&&(t.needDrain=!1,e.emit("drain"))}(e,t),t.pendingcb--,n(),I(e,t)}function k(e,t){t.bufferProcessing=!0;var r=t.bufferedRequest;if(e._writev&&r&&r.next){var n=t.bufferedRequestCount,i=new Array(n),s=t.corkedRequestsFree;s.entry=r;for(var a=0,u=!0;r;)i[a]=r,r.isBuf||(u=!1),r=r.next,a+=1;i.allBuffers=u,T(e,t,!0,t.length,i,"",s.finish),t.pendingcb++,t.lastBufferedRequest=null,s.next?(t.corkedRequestsFree=s.next,s.next=null):t.corkedRequestsFree=new o(t),t.bufferedRequestCount=0}else{for(;r;){var c=r.chunk,l=r.encoding,h=r.callback;if(T(e,t,!1,t.objectMode?1:c.length,c,l,h),r=r.next,t.bufferedRequestCount--,t.writing)break}null===r&&(t.lastBufferedRequest=null)}t.bufferedRequest=r,t.bufferProcessing=!1}function O(e){return e.ending&&0===e.length&&null===e.bufferedRequest&&!e.finished&&!e.writing}function P(e,t){e._final((function(r){t.pendingcb--,r&&S(e,r),t.prefinished=!0,e.emit("prefinish"),I(e,t)}))}function I(e,t){var r=O(t);if(r&&(function(e,t){t.prefinished||t.finalCalled||("function"!=typeof e._final||t.destroyed?(t.prefinished=!0,e.emit("prefinish")):(t.pendingcb++,t.finalCalled=!0,i.nextTick(P,e,t)))}(e,t),0===t.pendingcb&&(t.finished=!0,e.emit("finish"),t.autoDestroy))){var n=e._readableState;(!n||n.autoDestroy&&n.endEmitted)&&e.destroy()}return r}r(3730)(R,u),x.prototype.getBuffer=function(){for(var e=this.bufferedRequest,t=[];e;)t.push(e),e=e.next;return t},function(){try{Object.defineProperty(x.prototype,"buffer",{get:a.deprecate((function(){return this.getBuffer()}),"_writableState.buffer is deprecated. Use _writableState.getBuffer instead.","DEP0003")})}catch(e){}}(),"function"==typeof Symbol&&Symbol.hasInstance&&"function"==typeof Function.prototype[Symbol.hasInstance]?(s=Function.prototype[Symbol.hasInstance],Object.defineProperty(R,Symbol.hasInstance,{value:function(e){return!!s.call(this,e)||this===R&&e&&e._writableState instanceof x}})):s=function(e){return e instanceof this},R.prototype.pipe=function(){S(this,new y)},R.prototype.write=function(e,t,r){var n,o=this._writableState,s=!1,a=!o.objectMode&&(n=e,c.isBuffer(n)||n instanceof l);return a&&!c.isBuffer(e)&&(e=function(e){return c.from(e)}(e)),"function"==typeof t&&(r=t,t=null),a?t="buffer":t||(t=o.defaultEncoding),"function"!=typeof r&&(r=E),o.ending?function(e,t){var r=new w;S(e,r),i.nextTick(t,r)}(this,r):(a||function(e,t,r,n){var o;return null===r?o=new v:"string"==typeof r||t.objectMode||(o=new p("chunk",["string","Buffer"],r)),!o||(S(e,o),i.nextTick(n,o),!1)}(this,o,e,r))&&(o.pendingcb++,s=function(e,t,r,n,i,o){if(!r){var s=function(e,t,r){return e.objectMode||!1===e.decodeStrings||"string"!=typeof t||(t=c.from(t,r)),t}(t,n,i);n!==s&&(r=!0,i="buffer",n=s)}var a=t.objectMode?1:n.length;t.length+=a;var u=t.length<t.highWaterMark;if(u||(t.needDrain=!0),t.writing||t.corked){var l=t.lastBufferedRequest;t.lastBufferedRequest={chunk:n,encoding:i,isBuf:r,callback:o,next:null},l?l.next=t.lastBufferedRequest:t.bufferedRequest=t.lastBufferedRequest,t.bufferedRequestCount+=1}else T(e,t,!1,a,n,i,o);return u}(this,o,a,e,t,r)),s},R.prototype.cork=function(){this._writableState.corked++},R.prototype.uncork=function(){var e=this._writableState;e.corked&&(e.corked--,e.writing||e.corked||e.bufferProcessing||!e.bufferedRequest||k(this,e))},R.prototype.setDefaultEncoding=function(e){if("string"==typeof e&&(e=e.toLowerCase()),!(["hex","utf8","utf-8","ascii","binary","base64","ucs2","ucs-2","utf16le","utf-16le","raw"].indexOf((e+"").toLowerCase())>-1))throw new _(e);return this._writableState.defaultEncoding=e,this},Object.defineProperty(R.prototype,"writableBuffer",{enumerable:!1,get:function(){return this._writableState&&this._writableState.getBuffer()}}),Object.defineProperty(R.prototype,"writableHighWaterMark",{enumerable:!1,get:function(){return this._writableState.highWaterMark}}),R.prototype._write=function(e,t,r){r(new m("_write()"))},R.prototype._writev=null,R.prototype.end=function(e,t,r){var n=this._writableState;return"function"==typeof e?(r=e,e=null,t=null):"function"==typeof t&&(r=t,t=null),null!=e&&this.write(e,t),n.corked&&(n.corked=1,this.uncork()),n.ending||function(e,t,r){t.ending=!0,I(e,t),r&&(t.finished?i.nextTick(r):e.once("finish",r)),t.ended=!0,e.writable=!1}(this,n,r),this},Object.defineProperty(R.prototype,"writableLength",{enumerable:!1,get:function(){return this._writableState.length}}),Object.defineProperty(R.prototype,"destroyed",{enumerable:!1,get:function(){return void 0!==this._writableState&&this._writableState.destroyed},set:function(e){this._writableState&&(this._writableState.destroyed=e)}}),R.prototype.destroy=h.destroy,R.prototype._undestroy=h.undestroy,R.prototype._destroy=function(e,t){t(e)}},8187:(e,t,r)=>{"use strict";var n,i=r(2695);function o(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}var s=r(2426),a=Symbol("lastResolve"),u=Symbol("lastReject"),c=Symbol("error"),l=Symbol("ended"),h=Symbol("lastPromise"),f=Symbol("handlePromise"),d=Symbol("stream");function p(e,t){return{value:e,done:t}}function m(e){var t=e[a];if(null!==t){var r=e[d].read();null!==r&&(e[h]=null,e[a]=null,e[u]=null,t(p(r,!1)))}}function g(e){i.nextTick(m,e)}var y=Object.getPrototypeOf((function(){})),b=Object.setPrototypeOf((o(n={get stream(){return this[d]},next:function(){var e=this,t=this[c];if(null!==t)return Promise.reject(t);if(this[l])return Promise.resolve(p(void 0,!0));if(this[d].destroyed)return new Promise((function(t,r){i.nextTick((function(){e[c]?r(e[c]):t(p(void 0,!0))}))}));var r,n=this[h];if(n)r=new Promise(function(e,t){return function(r,n){e.then((function(){t[l]?r(p(void 0,!0)):t[f](r,n)}),n)}}(n,this));else{var o=this[d].read();if(null!==o)return Promise.resolve(p(o,!1));r=new Promise(this[f])}return this[h]=r,r}},Symbol.asyncIterator,(function(){return this})),o(n,"return",(function(){var e=this;return new Promise((function(t,r){e[d].destroy(null,(function(e){e?r(e):t(p(void 0,!0))}))}))})),n),y);e.exports=function(e){var t,r=Object.create(b,(o(t={},d,{value:e,writable:!0}),o(t,a,{value:null,writable:!0}),o(t,u,{value:null,writable:!0}),o(t,c,{value:null,writable:!0}),o(t,l,{value:e._readableState.endEmitted,writable:!0}),o(t,f,{value:function(e,t){var n=r[d].read();n?(r[h]=null,r[a]=null,r[u]=null,e(p(n,!1))):(r[a]=e,r[u]=t)},writable:!0}),t));return r[h]=null,s(e,(function(e){if(e&&"ERR_STREAM_PREMATURE_CLOSE"!==e.code){var t=r[u];return null!==t&&(r[h]=null,r[a]=null,r[u]=null,t(e)),void(r[c]=e)}var n=r[a];null!==n&&(r[h]=null,r[a]=null,r[u]=null,n(p(void 0,!0))),r[l]=!0})),e.on("readable",g.bind(null,r)),r}},4506:(e,t,r)=>{"use strict";function n(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function i(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}var s=r(7866).Buffer,a=r(462).inspect,u=a&&a.custom||"inspect";e.exports=function(){function e(){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),this.head=null,this.tail=null,this.length=0}var t,r;return t=e,(r=[{key:"push",value:function(e){var t={data:e,next:null};this.length>0?this.tail.next=t:this.head=t,this.tail=t,++this.length}},{key:"unshift",value:function(e){var t={data:e,next:this.head};0===this.length&&(this.tail=t),this.head=t,++this.length}},{key:"shift",value:function(){if(0!==this.length){var e=this.head.data;return 1===this.length?this.head=this.tail=null:this.head=this.head.next,--this.length,e}}},{key:"clear",value:function(){this.head=this.tail=null,this.length=0}},{key:"join",value:function(e){if(0===this.length)return"";for(var t=this.head,r=""+t.data;t=t.next;)r+=e+t.data;return r}},{key:"concat",value:function(e){if(0===this.length)return s.alloc(0);for(var t,r,n,i=s.allocUnsafe(e>>>0),o=this.head,a=0;o;)t=o.data,r=i,n=a,s.prototype.copy.call(t,r,n),a+=o.data.length,o=o.next;return i}},{key:"consume",value:function(e,t){var r;return e<this.head.data.length?(r=this.head.data.slice(0,e),this.head.data=this.head.data.slice(e)):r=e===this.head.data.length?this.shift():t?this._getString(e):this._getBuffer(e),r}},{key:"first",value:function(){return this.head.data}},{key:"_getString",value:function(e){var t=this.head,r=1,n=t.data;for(e-=n.length;t=t.next;){var i=t.data,o=e>i.length?i.length:e;if(o===i.length?n+=i:n+=i.slice(0,e),0==(e-=o)){o===i.length?(++r,t.next?this.head=t.next:this.head=this.tail=null):(this.head=t,t.data=i.slice(o));break}++r}return this.length-=r,n}},{key:"_getBuffer",value:function(e){var t=s.allocUnsafe(e),r=this.head,n=1;for(r.data.copy(t),e-=r.data.length;r=r.next;){var i=r.data,o=e>i.length?i.length:e;if(i.copy(t,t.length-e,0,o),0==(e-=o)){o===i.length?(++n,r.next?this.head=r.next:this.head=this.tail=null):(this.head=r,r.data=i.slice(o));break}++n}return this.length-=n,t}},{key:u,value:function(e,t){return a(this,function(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?n(Object(r),!0).forEach((function(t){i(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):n(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}({},t,{depth:0,customInspect:!1}))}}])&&o(t.prototype,r),e}()},3390:(e,t,r)=>{"use strict";var n=r(2695);function i(e,t){s(e,t),o(e)}function o(e){e._writableState&&!e._writableState.emitClose||e._readableState&&!e._readableState.emitClose||e.emit("close")}function s(e,t){e.emit("error",t)}e.exports={destroy:function(e,t){var r=this,a=this._readableState&&this._readableState.destroyed,u=this._writableState&&this._writableState.destroyed;return a||u?(t?t(e):e&&(this._writableState?this._writableState.errorEmitted||(this._writableState.errorEmitted=!0,n.nextTick(s,this,e)):n.nextTick(s,this,e)),this):(this._readableState&&(this._readableState.destroyed=!0),this._writableState&&(this._writableState.destroyed=!0),this._destroy(e||null,(function(e){!t&&e?r._writableState?r._writableState.errorEmitted?n.nextTick(o,r):(r._writableState.errorEmitted=!0,n.nextTick(i,r,e)):n.nextTick(i,r,e):t?(n.nextTick(o,r),t(e)):n.nextTick(o,r)})),this)},undestroy:function(){this._readableState&&(this._readableState.destroyed=!1,this._readableState.reading=!1,this._readableState.ended=!1,this._readableState.endEmitted=!1),this._writableState&&(this._writableState.destroyed=!1,this._writableState.ended=!1,this._writableState.ending=!1,this._writableState.finalCalled=!1,this._writableState.prefinished=!1,this._writableState.finished=!1,this._writableState.errorEmitted=!1)},errorOrDestroy:function(e,t){var r=e._readableState,n=e._writableState;r&&r.autoDestroy||n&&n.autoDestroy?e.destroy(t):e.emit("error",t)}}},2426:(e,t,r)=>{"use strict";var n=r(553).q.ERR_STREAM_PREMATURE_CLOSE;function i(){}e.exports=function e(t,r,o){if("function"==typeof r)return e(t,null,r);r||(r={}),o=function(e){var t=!1;return function(){if(!t){t=!0;for(var r=arguments.length,n=new Array(r),i=0;i<r;i++)n[i]=arguments[i];e.apply(this,n)}}}(o||i);var s=r.readable||!1!==r.readable&&t.readable,a=r.writable||!1!==r.writable&&t.writable,u=function(){t.writable||l()},c=t._writableState&&t._writableState.finished,l=function(){a=!1,c=!0,s||o.call(t)},h=t._readableState&&t._readableState.endEmitted,f=function(){s=!1,h=!0,a||o.call(t)},d=function(e){o.call(t,e)},p=function(){var e;return s&&!h?(t._readableState&&t._readableState.ended||(e=new n),o.call(t,e)):a&&!c?(t._writableState&&t._writableState.ended||(e=new n),o.call(t,e)):void 0},m=function(){t.req.on("finish",l)};return function(e){return e.setHeader&&"function"==typeof e.abort}(t)?(t.on("complete",l),t.on("abort",p),t.req?m():t.on("request",m)):a&&!t._writableState&&(t.on("end",u),t.on("close",u)),t.on("end",f),t.on("finish",l),!1!==r.error&&t.on("error",d),t.on("close",p),function(){t.removeListener("complete",l),t.removeListener("abort",p),t.removeListener("request",m),t.req&&t.req.removeListener("finish",l),t.removeListener("end",u),t.removeListener("close",u),t.removeListener("finish",l),t.removeListener("end",f),t.removeListener("error",d),t.removeListener("close",p)}}},3733:e=>{e.exports=function(){throw new Error("Readable.from is not available in the browser")}},2970:(e,t,r)=>{"use strict";var n,i=r(553).q,o=i.ERR_MISSING_ARGS,s=i.ERR_STREAM_DESTROYED;function a(e){if(e)throw e}function u(e,t,i,o){o=function(e){var t=!1;return function(){t||(t=!0,e.apply(void 0,arguments))}}(o);var a=!1;e.on("close",(function(){a=!0})),void 0===n&&(n=r(2426)),n(e,{readable:t,writable:i},(function(e){if(e)return o(e);a=!0,o()}));var u=!1;return function(t){if(!a&&!u)return u=!0,function(e){return e.setHeader&&"function"==typeof e.abort}(e)?e.abort():"function"==typeof e.destroy?e.destroy():void o(t||new s("pipe"))}}function c(e){e()}function l(e,t){return e.pipe(t)}function h(e){return e.length?"function"!=typeof e[e.length-1]?a:e.pop():a}e.exports=function(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];var n,i=h(t);if(Array.isArray(t[0])&&(t=t[0]),t.length<2)throw new o("streams");var s=t.map((function(e,r){var o=r<t.length-1;return u(e,o,r>0,(function(e){n||(n=e),e&&s.forEach(c),o||(s.forEach(c),i(n))}))}));return t.reduce(l)}},1111:(e,t,r)=>{"use strict";var n=r(553).q.ERR_INVALID_OPT_VALUE;e.exports={getHighWaterMark:function(e,t,r,i){var o=function(e,t,r){return null!=e.highWaterMark?e.highWaterMark:t?e[r]:null}(t,i,r);if(null!=o){if(!isFinite(o)||Math.floor(o)!==o||o<0)throw new n(i?r:"highWaterMark",o);return Math.floor(o)}return e.objectMode?16:16384}}},8208:(e,t,r)=>{e.exports=r(488).EventEmitter},9685:(e,t,r)=>{var n=r(7866),i=n.Buffer;function o(e,t){for(var r in e)t[r]=e[r]}function s(e,t,r){return i(e,t,r)}i.from&&i.alloc&&i.allocUnsafe&&i.allocUnsafeSlow?e.exports=n:(o(n,t),t.Buffer=s),s.prototype=Object.create(i.prototype),o(i,s),s.from=function(e,t,r){if("number"==typeof e)throw new TypeError("Argument must not be a number");return i(e,t,r)},s.alloc=function(e,t,r){if("number"!=typeof e)throw new TypeError("Argument must be a number");var n=i(e);return void 0!==t?"string"==typeof r?n.fill(t,r):n.fill(t):n.fill(0),n},s.allocUnsafe=function(e){if("number"!=typeof e)throw new TypeError("Argument must be a number");return i(e)},s.allocUnsafeSlow=function(e){if("number"!=typeof e)throw new TypeError("Argument must be a number");return n.SlowBuffer(e)}},8981:(e,t,r)=>{e.exports=i;var n=r(488).EventEmitter;function i(){n.call(this)}r(3730)(i,n),i.Readable=r(5006),i.Writable=r(8719),i.Duplex=r(673),i.Transform=r(8597),i.PassThrough=r(4343),i.finished=r(2426),i.pipeline=r(2970),i.Stream=i,i.prototype.pipe=function(e,t){var r=this;function i(t){e.writable&&!1===e.write(t)&&r.pause&&r.pause()}function o(){r.readable&&r.resume&&r.resume()}r.on("data",i),e.on("drain",o),e._isStdio||t&&!1===t.end||(r.on("end",a),r.on("close",u));var s=!1;function a(){s||(s=!0,e.end())}function u(){s||(s=!0,"function"==typeof e.destroy&&e.destroy())}function c(e){if(l(),0===n.listenerCount(this,"error"))throw e}function l(){r.removeListener("data",i),e.removeListener("drain",o),r.removeListener("end",a),r.removeListener("close",u),r.removeListener("error",c),e.removeListener("error",c),r.removeListener("end",l),r.removeListener("close",l),e.removeListener("close",l)}return r.on("error",c),e.on("error",c),r.on("end",l),r.on("close",l),e.on("close",l),e.emit("pipe",r),e}},7361:(e,t,r)=>{"use strict";var n=r(9685).Buffer,i=n.isEncoding||function(e){switch((e=""+e)&&e.toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":case"raw":return!0;default:return!1}};function o(e){var t;switch(this.encoding=function(e){var t=function(e){if(!e)return"utf8";for(var t;;)switch(e){case"utf8":case"utf-8":return"utf8";case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return"utf16le";case"latin1":case"binary":return"latin1";case"base64":case"ascii":case"hex":return e;default:if(t)return;e=(""+e).toLowerCase(),t=!0}}(e);if("string"!=typeof t&&(n.isEncoding===i||!i(e)))throw new Error("Unknown encoding: "+e);return t||e}(e),this.encoding){case"utf16le":this.text=u,this.end=c,t=4;break;case"utf8":this.fillLast=a,t=4;break;case"base64":this.text=l,this.end=h,t=3;break;default:return this.write=f,void(this.end=d)}this.lastNeed=0,this.lastTotal=0,this.lastChar=n.allocUnsafe(t)}function s(e){return e<=127?0:e>>5==6?2:e>>4==14?3:e>>3==30?4:e>>6==2?-1:-2}function a(e){var t=this.lastTotal-this.lastNeed,r=function(e,t,r){if(128!=(192&t[0]))return e.lastNeed=0,"";if(e.lastNeed>1&&t.length>1){if(128!=(192&t[1]))return e.lastNeed=1,"";if(e.lastNeed>2&&t.length>2&&128!=(192&t[2]))return e.lastNeed=2,""}}(this,e);return void 0!==r?r:this.lastNeed<=e.length?(e.copy(this.lastChar,t,0,this.lastNeed),this.lastChar.toString(this.encoding,0,this.lastTotal)):(e.copy(this.lastChar,t,0,e.length),void(this.lastNeed-=e.length))}function u(e,t){if((e.length-t)%2==0){var r=e.toString("utf16le",t);if(r){var n=r.charCodeAt(r.length-1);if(n>=55296&&n<=56319)return this.lastNeed=2,this.lastTotal=4,this.lastChar[0]=e[e.length-2],this.lastChar[1]=e[e.length-1],r.slice(0,-1)}return r}return this.lastNeed=1,this.lastTotal=2,this.lastChar[0]=e[e.length-1],e.toString("utf16le",t,e.length-1)}function c(e){var t=e&&e.length?this.write(e):"";if(this.lastNeed){var r=this.lastTotal-this.lastNeed;return t+this.lastChar.toString("utf16le",0,r)}return t}function l(e,t){var r=(e.length-t)%3;return 0===r?e.toString("base64",t):(this.lastNeed=3-r,this.lastTotal=3,1===r?this.lastChar[0]=e[e.length-1]:(this.lastChar[0]=e[e.length-2],this.lastChar[1]=e[e.length-1]),e.toString("base64",t,e.length-r))}function h(e){var t=e&&e.length?this.write(e):"";return this.lastNeed?t+this.lastChar.toString("base64",0,3-this.lastNeed):t}function f(e){return e.toString(this.encoding)}function d(e){return e&&e.length?this.write(e):""}t.s=o,o.prototype.write=function(e){if(0===e.length)return"";var t,r;if(this.lastNeed){if(void 0===(t=this.fillLast(e)))return"";r=this.lastNeed,this.lastNeed=0}else r=0;return r<e.length?t?t+this.text(e,r):this.text(e,r):t||""},o.prototype.end=function(e){var t=e&&e.length?this.write(e):"";return this.lastNeed?t+"":t},o.prototype.text=function(e,t){var r=function(e,t,r){var n=t.length-1;if(n<r)return 0;var i=s(t[n]);return i>=0?(i>0&&(e.lastNeed=i-1),i):--n<r||-2===i?0:(i=s(t[n]))>=0?(i>0&&(e.lastNeed=i-2),i):--n<r||-2===i?0:(i=s(t[n]))>=0?(i>0&&(2===i?i=0:e.lastNeed=i-3),i):0}(this,e,t);if(!this.lastNeed)return e.toString("utf8",t);this.lastTotal=r;var n=e.length-(r-this.lastNeed);return e.copy(this.lastChar,0,n),e.toString("utf8",t,n)},o.prototype.fillLast=function(e){if(this.lastNeed<=e.length)return e.copy(this.lastChar,this.lastTotal-this.lastNeed,0,this.lastNeed),this.lastChar.toString(this.encoding,0,this.lastTotal);e.copy(this.lastChar,this.lastTotal-this.lastNeed,0,e.length),this.lastNeed-=e.length}},2993:(e,t)=>{"use strict";var r=function(){function e(){this._state=new Int32Array(4),this._buffer=new ArrayBuffer(68),this._buffer8=new Uint8Array(this._buffer,0,68),this._buffer32=new Uint32Array(this._buffer,0,17),this.start()}return e.hashStr=function(e,t){return void 0===t&&(t=!1),this.onePassHasher.start().appendStr(e).end(t)},e.hashAsciiStr=function(e,t){return void 0===t&&(t=!1),this.onePassHasher.start().appendAsciiStr(e).end(t)},e._hex=function(t){var r,n,i,o,s=e.hexChars,a=e.hexOut;for(o=0;o<4;o+=1)for(n=8*o,r=t[o],i=0;i<8;i+=2)a[n+1+i]=s.charAt(15&r),r>>>=4,a[n+0+i]=s.charAt(15&r),r>>>=4;return a.join("")},e._md5cycle=function(e,t){var r=e[0],n=e[1],i=e[2],o=e[3];n=((n+=((i=((i+=((o=((o+=((r=((r+=(n&i|~n&o)+t[0]-680876936|0)<<7|r>>>25)+n|0)&n|~r&i)+t[1]-389564586|0)<<12|o>>>20)+r|0)&r|~o&n)+t[2]+606105819|0)<<17|i>>>15)+o|0)&o|~i&r)+t[3]-1044525330|0)<<22|n>>>10)+i|0,n=((n+=((i=((i+=((o=((o+=((r=((r+=(n&i|~n&o)+t[4]-176418897|0)<<7|r>>>25)+n|0)&n|~r&i)+t[5]+1200080426|0)<<12|o>>>20)+r|0)&r|~o&n)+t[6]-1473231341|0)<<17|i>>>15)+o|0)&o|~i&r)+t[7]-45705983|0)<<22|n>>>10)+i|0,n=((n+=((i=((i+=((o=((o+=((r=((r+=(n&i|~n&o)+t[8]+1770035416|0)<<7|r>>>25)+n|0)&n|~r&i)+t[9]-1958414417|0)<<12|o>>>20)+r|0)&r|~o&n)+t[10]-42063|0)<<17|i>>>15)+o|0)&o|~i&r)+t[11]-1990404162|0)<<22|n>>>10)+i|0,n=((n+=((i=((i+=((o=((o+=((r=((r+=(n&i|~n&o)+t[12]+1804603682|0)<<7|r>>>25)+n|0)&n|~r&i)+t[13]-40341101|0)<<12|o>>>20)+r|0)&r|~o&n)+t[14]-1502002290|0)<<17|i>>>15)+o|0)&o|~i&r)+t[15]+1236535329|0)<<22|n>>>10)+i|0,n=((n+=((i=((i+=((o=((o+=((r=((r+=(n&o|i&~o)+t[1]-165796510|0)<<5|r>>>27)+n|0)&i|n&~i)+t[6]-1069501632|0)<<9|o>>>23)+r|0)&n|r&~n)+t[11]+643717713|0)<<14|i>>>18)+o|0)&r|o&~r)+t[0]-373897302|0)<<20|n>>>12)+i|0,n=((n+=((i=((i+=((o=((o+=((r=((r+=(n&o|i&~o)+t[5]-701558691|0)<<5|r>>>27)+n|0)&i|n&~i)+t[10]+38016083|0)<<9|o>>>23)+r|0)&n|r&~n)+t[15]-660478335|0)<<14|i>>>18)+o|0)&r|o&~r)+t[4]-405537848|0)<<20|n>>>12)+i|0,n=((n+=((i=((i+=((o=((o+=((r=((r+=(n&o|i&~o)+t[9]+568446438|0)<<5|r>>>27)+n|0)&i|n&~i)+t[14]-1019803690|0)<<9|o>>>23)+r|0)&n|r&~n)+t[3]-187363961|0)<<14|i>>>18)+o|0)&r|o&~r)+t[8]+1163531501|0)<<20|n>>>12)+i|0,n=((n+=((i=((i+=((o=((o+=((r=((r+=(n&o|i&~o)+t[13]-1444681467|0)<<5|r>>>27)+n|0)&i|n&~i)+t[2]-51403784|0)<<9|o>>>23)+r|0)&n|r&~n)+t[7]+1735328473|0)<<14|i>>>18)+o|0)&r|o&~r)+t[12]-1926607734|0)<<20|n>>>12)+i|0,n=((n+=((i=((i+=((o=((o+=((r=((r+=(n^i^o)+t[5]-378558|0)<<4|r>>>28)+n|0)^n^i)+t[8]-2022574463|0)<<11|o>>>21)+r|0)^r^n)+t[11]+1839030562|0)<<16|i>>>16)+o|0)^o^r)+t[14]-35309556|0)<<23|n>>>9)+i|0,n=((n+=((i=((i+=((o=((o+=((r=((r+=(n^i^o)+t[1]-1530992060|0)<<4|r>>>28)+n|0)^n^i)+t[4]+1272893353|0)<<11|o>>>21)+r|0)^r^n)+t[7]-155497632|0)<<16|i>>>16)+o|0)^o^r)+t[10]-1094730640|0)<<23|n>>>9)+i|0,n=((n+=((i=((i+=((o=((o+=((r=((r+=(n^i^o)+t[13]+681279174|0)<<4|r>>>28)+n|0)^n^i)+t[0]-358537222|0)<<11|o>>>21)+r|0)^r^n)+t[3]-722521979|0)<<16|i>>>16)+o|0)^o^r)+t[6]+76029189|0)<<23|n>>>9)+i|0,n=((n+=((i=((i+=((o=((o+=((r=((r+=(n^i^o)+t[9]-640364487|0)<<4|r>>>28)+n|0)^n^i)+t[12]-421815835|0)<<11|o>>>21)+r|0)^r^n)+t[15]+530742520|0)<<16|i>>>16)+o|0)^o^r)+t[2]-995338651|0)<<23|n>>>9)+i|0,n=((n+=((o=((o+=(n^((r=((r+=(i^(n|~o))+t[0]-198630844|0)<<6|r>>>26)+n|0)|~i))+t[7]+1126891415|0)<<10|o>>>22)+r|0)^((i=((i+=(r^(o|~n))+t[14]-1416354905|0)<<15|i>>>17)+o|0)|~r))+t[5]-57434055|0)<<21|n>>>11)+i|0,n=((n+=((o=((o+=(n^((r=((r+=(i^(n|~o))+t[12]+1700485571|0)<<6|r>>>26)+n|0)|~i))+t[3]-1894986606|0)<<10|o>>>22)+r|0)^((i=((i+=(r^(o|~n))+t[10]-1051523|0)<<15|i>>>17)+o|0)|~r))+t[1]-2054922799|0)<<21|n>>>11)+i|0,n=((n+=((o=((o+=(n^((r=((r+=(i^(n|~o))+t[8]+1873313359|0)<<6|r>>>26)+n|0)|~i))+t[15]-30611744|0)<<10|o>>>22)+r|0)^((i=((i+=(r^(o|~n))+t[6]-1560198380|0)<<15|i>>>17)+o|0)|~r))+t[13]+1309151649|0)<<21|n>>>11)+i|0,n=((n+=((o=((o+=(n^((r=((r+=(i^(n|~o))+t[4]-145523070|0)<<6|r>>>26)+n|0)|~i))+t[11]-1120210379|0)<<10|o>>>22)+r|0)^((i=((i+=(r^(o|~n))+t[2]+718787259|0)<<15|i>>>17)+o|0)|~r))+t[9]-343485551|0)<<21|n>>>11)+i|0,e[0]=r+e[0]|0,e[1]=n+e[1]|0,e[2]=i+e[2]|0,e[3]=o+e[3]|0},e.prototype.start=function(){return this._dataLength=0,this._bufferLength=0,this._state.set(e.stateIdentity),this},e.prototype.appendStr=function(t){var r,n,i=this._buffer8,o=this._buffer32,s=this._bufferLength;for(n=0;n<t.length;n+=1){if((r=t.charCodeAt(n))<128)i[s++]=r;else if(r<2048)i[s++]=192+(r>>>6),i[s++]=63&r|128;else if(r<55296||r>56319)i[s++]=224+(r>>>12),i[s++]=r>>>6&63|128,i[s++]=63&r|128;else{if((r=1024*(r-55296)+(t.charCodeAt(++n)-56320)+65536)>1114111)throw new Error("Unicode standard supports code points up to U+10FFFF");i[s++]=240+(r>>>18),i[s++]=r>>>12&63|128,i[s++]=r>>>6&63|128,i[s++]=63&r|128}s>=64&&(this._dataLength+=64,e._md5cycle(this._state,o),s-=64,o[0]=o[16])}return this._bufferLength=s,this},e.prototype.appendAsciiStr=function(t){for(var r,n=this._buffer8,i=this._buffer32,o=this._bufferLength,s=0;;){for(r=Math.min(t.length-s,64-o);r--;)n[o++]=t.charCodeAt(s++);if(o<64)break;this._dataLength+=64,e._md5cycle(this._state,i),o=0}return this._bufferLength=o,this},e.prototype.appendByteArray=function(t){for(var r,n=this._buffer8,i=this._buffer32,o=this._bufferLength,s=0;;){for(r=Math.min(t.length-s,64-o);r--;)n[o++]=t[s++];if(o<64)break;this._dataLength+=64,e._md5cycle(this._state,i),o=0}return this._bufferLength=o,this},e.prototype.getState=function(){var e=this,t=e._state;return{buffer:String.fromCharCode.apply(null,e._buffer8),buflen:e._bufferLength,length:e._dataLength,state:[t[0],t[1],t[2],t[3]]}},e.prototype.setState=function(e){var t,r=e.buffer,n=e.state,i=this._state;for(this._dataLength=e.length,this._bufferLength=e.buflen,i[0]=n[0],i[1]=n[1],i[2]=n[2],i[3]=n[3],t=0;t<r.length;t+=1)this._buffer8[t]=r.charCodeAt(t)},e.prototype.end=function(t){void 0===t&&(t=!1);var r,n=this._bufferLength,i=this._buffer8,o=this._buffer32,s=1+(n>>2);if(this._dataLength+=n,i[n]=128,i[n+1]=i[n+2]=i[n+3]=0,o.set(e.buffer32Identity.subarray(s),s),n>55&&(e._md5cycle(this._state,o),o.set(e.buffer32Identity)),(r=8*this._dataLength)<=4294967295)o[14]=r;else{var a=r.toString(16).match(/(.*?)(.{0,8})$/);if(null===a)return;var u=parseInt(a[2],16),c=parseInt(a[1],16)||0;o[14]=u,o[15]=c}return e._md5cycle(this._state,o),t?this._state:e._hex(this._state)},e.stateIdentity=new Int32Array([1732584193,-271733879,-1732584194,271733878]),e.buffer32Identity=new Int32Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]),e.hexChars="0123456789abcdef",e.hexOut=[],e.onePassHasher=new e,e}();t.V=r,"5d41402abc4b2a76b9719d911017c592"!==r.hashStr("hello")&&console.error("Md5 self test failed.")},72:(e,t,r)=>{function n(e){try{if(!r.g.localStorage)return!1}catch(e){return!1}var t=r.g.localStorage[e];return null!=t&&"true"===String(t).toLowerCase()}e.exports=function(e,t){if(n("noDeprecation"))return e;var r=!1;return function(){if(!r){if(n("throwDeprecation"))throw new Error(t);n("traceDeprecation")?console.trace(t):console.warn(t),r=!0}return e.apply(this,arguments)}}},769:e=>{e.exports=function(e){if("function"!=typeof e)throw TypeError(String(e)+" is not a function");return e}},8143:(e,t,r)=>{var n=r(6944);e.exports=function(e){if(!n(e)&&null!==e)throw TypeError("Can't set "+String(e)+" as a prototype");return e}},9611:(e,t,r)=>{var n=r(3706),i=r(2361),o=r(3376),s=n("unscopables"),a=Array.prototype;null==a[s]&&o.f(a,s,{configurable:!0,value:i(null)}),e.exports=function(e){a[s][e]=!0}},2482:e=>{e.exports=function(e,t,r){if(!(e instanceof t))throw TypeError("Incorrect "+(r?r+" ":"")+"invocation");return e}},47:(e,t,r)=>{var n=r(6944);e.exports=function(e){if(!n(e))throw TypeError(String(e)+" is not an object");return e}},1774:(e,t,r)=>{"use strict";var n=r(4833),i=r(4680),o=r(3960),s=r(1008),a=r(4954),u=r(2076),c=r(3126);e.exports=function(e){var t,r,l,h,f,d,p=i(e),m="function"==typeof this?this:Array,g=arguments.length,y=g>1?arguments[1]:void 0,b=void 0!==y,v=c(p),w=0;if(b&&(y=n(y,g>2?arguments[2]:void 0,2)),null==v||m==Array&&s(v))for(r=new m(t=a(p.length));t>w;w++)d=b?y(p[w],w):p[w],u(r,w,d);else for(f=(h=v.call(p)).next,r=new m;!(l=f.call(h)).done;w++)d=b?o(h,y,[l.value,w],!0):l.value,u(r,w,d);return r.length=w,r}},1270:(e,t,r)=>{var n=r(8852),i=r(4954),o=r(2145),s=function(e){return function(t,r,s){var a,u=n(t),c=i(u.length),l=o(s,c);if(e&&r!=r){for(;c>l;)if((a=u[l++])!=a)return!0}else for(;c>l;l++)if((e||l in u)&&u[l]===r)return e||l||0;return!e&&-1}};e.exports={includes:s(!0),indexOf:s(!1)}},3960:(e,t,r)=>{var n=r(47),i=r(2608);e.exports=function(e,t,r,o){try{return o?t(n(r)[0],r[1]):t(r)}catch(t){throw i(e),t}}},3565:e=>{var t={}.toString;e.exports=function(e){return t.call(e).slice(8,-1)}},8753:(e,t,r)=>{var n=r(939),i=r(3565),o=r(3706)("toStringTag"),s="Arguments"==i(function(){return arguments}());e.exports=n?i:function(e){var t,r,n;return void 0===e?"Undefined":null===e?"Null":"string"==typeof(r=function(e,t){try{return e[t]}catch(e){}}(t=Object(e),o))?r:s?i(t):"Object"==(n=i(t))&&"function"==typeof t.callee?"Arguments":n}},7918:(e,t,r)=>{var n=r(5884),i=r(8204),o=r(7825),s=r(3376);e.exports=function(e,t){for(var r=i(t),a=s.f,u=o.f,c=0;c<r.length;c++){var l=r[c];n(e,l)||a(e,l,u(t,l))}}},9241:(e,t,r)=>{var n=r(7841);e.exports=!n((function(){function e(){}return e.prototype.constructor=null,Object.getPrototypeOf(new e)!==e.prototype}))},9670:(e,t,r)=>{"use strict";var n=r(888).IteratorPrototype,i=r(2361),o=r(976),s=r(9400),a=r(873),u=function(){return this};e.exports=function(e,t,r){var c=t+" Iterator";return e.prototype=i(n,{next:o(1,r)}),s(e,c,!1,!0),a[c]=u,e}},4791:(e,t,r)=>{var n=r(5542),i=r(3376),o=r(976);e.exports=n?function(e,t,r){return i.f(e,t,o(1,r))}:function(e,t,r){return e[t]=r,e}},976:e=>{e.exports=function(e,t){return{enumerable:!(1&e),configurable:!(2&e),writable:!(4&e),value:t}}},2076:(e,t,r)=>{"use strict";var n=r(2694),i=r(3376),o=r(976);e.exports=function(e,t,r){var s=n(t);s in e?i.f(e,s,o(0,r)):e[s]=r}},3131:(e,t,r)=>{"use strict";var n=r(1082),i=r(9670),o=r(8186),s=r(2686),a=r(9400),u=r(4791),c=r(1249),l=r(3706),h=r(6852),f=r(873),d=r(888),p=d.IteratorPrototype,m=d.BUGGY_SAFARI_ITERATORS,g=l("iterator"),y="keys",b="values",v="entries",w=function(){return this};e.exports=function(e,t,r,l,d,_,S){i(r,t,l);var E,x,R,T=function(e){if(e===d&&I)return I;if(!m&&e in O)return O[e];switch(e){case y:case b:case v:return function(){return new r(this,e)}}return function(){return new r(this)}},C=t+" Iterator",k=!1,O=e.prototype,P=O[g]||O["@@iterator"]||d&&O[d],I=!m&&P||T(d),L="Array"==t&&O.entries||P;if(L&&(E=o(L.call(new e)),p!==Object.prototype&&E.next&&(h||o(E)===p||(s?s(E,p):"function"!=typeof E[g]&&u(E,g,w)),a(E,C,!0,!0),h&&(f[C]=w))),d==b&&P&&P.name!==b&&(k=!0,I=function(){return P.call(this)}),h&&!S||O[g]===I||u(O,g,I),f[t]=I,d)if(x={values:T(b),keys:_?I:T(y),entries:T(v)},S)for(R in x)(m||k||!(R in O))&&c(O,R,x[R]);else n({target:t,proto:!0,forced:m||k},x);return x}},5542:(e,t,r)=>{var n=r(7841);e.exports=!n((function(){return 7!=Object.defineProperty({},1,{get:function(){return 7}})[1]}))},3879:(e,t,r)=>{var n=r(6874),i=r(6944),o=n.document,s=i(o)&&i(o.createElement);e.exports=function(e){return s?o.createElement(e):{}}},4229:(e,t,r)=>{var n=r(4578);e.exports=n("navigator","userAgent")||""},579:(e,t,r)=>{var n,i,o=r(6874),s=r(4229),a=o.process,u=o.Deno,c=a&&a.versions||u&&u.version,l=c&&c.v8;l?i=(n=l.split("."))[0]<4?1:n[0]+n[1]:s&&(!(n=s.match(/Edge\/(\d+)/))||n[1]>=74)&&(n=s.match(/Chrome\/(\d+)/))&&(i=n[1]),e.exports=i&&+i},9752:e=>{e.exports=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"]},1082:(e,t,r)=>{var n=r(6874),i=r(7825).f,o=r(4791),s=r(1249),a=r(1278),u=r(7918),c=r(2350);e.exports=function(e,t){var r,l,h,f,d,p=e.target,m=e.global,g=e.stat;if(r=m?n:g?n[p]||a(p,{}):(n[p]||{}).prototype)for(l in t){if(f=t[l],h=e.noTargetGet?(d=i(r,l))&&d.value:r[l],!c(m?l:p+(g?".":"#")+l,e.forced)&&void 0!==h){if(typeof f==typeof h)continue;u(f,h)}(e.sham||h&&h.sham)&&o(f,"sham",!0),s(r,l,f,e)}}},7841:e=>{e.exports=function(e){try{return!!e()}catch(e){return!0}}},4833:(e,t,r)=>{var n=r(769);e.exports=function(e,t,r){if(n(e),void 0===t)return e;switch(r){case 0:return function(){return e.call(t)};case 1:return function(r){return e.call(t,r)};case 2:return function(r,n){return e.call(t,r,n)};case 3:return function(r,n,i){return e.call(t,r,n,i)}}return function(){return e.apply(t,arguments)}}},4578:(e,t,r)=>{var n=r(6874),i=function(e){return"function"==typeof e?e:void 0};e.exports=function(e,t){return arguments.length<2?i(n[e]):n[e]&&n[e][t]}},3126:(e,t,r)=>{var n=r(8753),i=r(873),o=r(3706)("iterator");e.exports=function(e){if(null!=e)return e[o]||e["@@iterator"]||i[n(e)]}},7053:(e,t,r)=>{var n=r(47),i=r(3126);e.exports=function(e){var t=i(e);if("function"!=typeof t)throw TypeError(String(e)+" is not iterable");return n(t.call(e))}},6874:(e,t,r)=>{var n=function(e){return e&&e.Math==Math&&e};e.exports=n("object"==typeof globalThis&&globalThis)||n("object"==typeof window&&window)||n("object"==typeof self&&self)||n("object"==typeof r.g&&r.g)||function(){return this}()||Function("return this")()},5884:(e,t,r)=>{var n=r(4680),i={}.hasOwnProperty;e.exports=Object.hasOwn||function(e,t){return i.call(n(e),t)}},5644:e=>{e.exports={}},7666:(e,t,r)=>{var n=r(4578);e.exports=n("document","documentElement")},6056:(e,t,r)=>{var n=r(5542),i=r(7841),o=r(3879);e.exports=!n&&!i((function(){return 7!=Object.defineProperty(o("div"),"a",{get:function(){return 7}}).a}))},8517:(e,t,r)=>{var n=r(7841),i=r(3565),o="".split;e.exports=n((function(){return!Object("z").propertyIsEnumerable(0)}))?function(e){return"String"==i(e)?o.call(e,""):Object(e)}:Object},6090:(e,t,r)=>{var n=r(4925),i=Function.toString;"function"!=typeof n.inspectSource&&(n.inspectSource=function(e){return i.call(e)}),e.exports=n.inspectSource},6619:(e,t,r)=>{var n,i,o,s=r(9957),a=r(6874),u=r(6944),c=r(4791),l=r(5884),h=r(4925),f=r(8698),d=r(5644),p="Object already initialized",m=a.WeakMap;if(s||h.state){var g=h.state||(h.state=new m),y=g.get,b=g.has,v=g.set;n=function(e,t){if(b.call(g,e))throw new TypeError(p);return t.facade=e,v.call(g,e,t),t},i=function(e){return y.call(g,e)||{}},o=function(e){return b.call(g,e)}}else{var w=f("state");d[w]=!0,n=function(e,t){if(l(e,w))throw new TypeError(p);return t.facade=e,c(e,w,t),t},i=function(e){return l(e,w)?e[w]:{}},o=function(e){return l(e,w)}}e.exports={set:n,get:i,has:o,enforce:function(e){return o(e)?i(e):n(e,{})},getterFor:function(e){return function(t){var r;if(!u(t)||(r=i(t)).type!==e)throw TypeError("Incompatible receiver, "+e+" required");return r}}}},1008:(e,t,r)=>{var n=r(3706),i=r(873),o=n("iterator"),s=Array.prototype;e.exports=function(e){return void 0!==e&&(i.Array===e||s[o]===e)}},2350:(e,t,r)=>{var n=r(7841),i=/#|\.prototype\./,o=function(e,t){var r=a[s(e)];return r==c||r!=u&&("function"==typeof t?n(t):!!t)},s=o.normalize=function(e){return String(e).replace(i,".").toLowerCase()},a=o.data={},u=o.NATIVE="N",c=o.POLYFILL="P";e.exports=o},6944:e=>{e.exports=function(e){return"object"==typeof e?null!==e:"function"==typeof e}},6852:e=>{e.exports=!1},8377:(e,t,r)=>{var n=r(4578),i=r(4587);e.exports=i?function(e){return"symbol"==typeof e}:function(e){var t=n("Symbol");return"function"==typeof t&&Object(e)instanceof t}},2608:(e,t,r)=>{var n=r(47);e.exports=function(e){var t=e.return;if(void 0!==t)return n(t.call(e)).value}},888:(e,t,r)=>{"use strict";var n,i,o,s=r(7841),a=r(8186),u=r(4791),c=r(5884),l=r(3706),h=r(6852),f=l("iterator"),d=!1;[].keys&&("next"in(o=[].keys())?(i=a(a(o)))!==Object.prototype&&(n=i):d=!0);var p=null==n||s((function(){var e={};return n[f].call(e)!==e}));p&&(n={}),h&&!p||c(n,f)||u(n,f,(function(){return this})),e.exports={IteratorPrototype:n,BUGGY_SAFARI_ITERATORS:d}},873:e=>{e.exports={}},1453:(e,t,r)=>{var n=r(579),i=r(7841);e.exports=!!Object.getOwnPropertySymbols&&!i((function(){var e=Symbol();return!String(e)||!(Object(e)instanceof Symbol)||!Symbol.sham&&n&&n<41}))},1781:(e,t,r)=>{var n=r(7841),i=r(3706),o=r(6852),s=i("iterator");e.exports=!n((function(){var e=new URL("b?a=1&b=2&c=3","http://a"),t=e.searchParams,r="";return e.pathname="c%20d",t.forEach((function(e,n){t.delete("b"),r+=n+e})),o&&!e.toJSON||!t.sort||"http://a/c%20d?a=1&c=3"!==e.href||"3"!==t.get("c")||"a=1"!==String(new URLSearchParams("?a=1"))||!t[s]||"a"!==new URL("https://a@b").username||"b"!==new URLSearchParams(new URLSearchParams("a=b")).get("a")||"xn--e1aybc"!==new URL("http://").host||"#%D0%B1"!==new URL("http://a#").hash||"a1c3"!==r||"x"!==new URL("http://x",void 0).host}))},9957:(e,t,r)=>{var n=r(6874),i=r(6090),o=n.WeakMap;e.exports="function"==typeof o&&/native code/.test(i(o))},5277:(e,t,r)=>{"use strict";var n=r(5542),i=r(7841),o=r(965),s=r(1913),a=r(3626),u=r(4680),c=r(8517),l=Object.assign,h=Object.defineProperty;e.exports=!l||i((function(){if(n&&1!==l({b:1},l(h({},"a",{enumerable:!0,get:function(){h(this,"b",{value:3,enumerable:!1})}}),{b:2})).b)return!0;var e={},t={},r=Symbol(),i="abcdefghijklmnopqrst";return e[r]=7,i.split("").forEach((function(e){t[e]=e})),7!=l({},e)[r]||o(l({},t)).join("")!=i}))?function(e,t){for(var r=u(e),i=arguments.length,l=1,h=s.f,f=a.f;i>l;)for(var d,p=c(arguments[l++]),m=h?o(p).concat(h(p)):o(p),g=m.length,y=0;g>y;)d=m[y++],n&&!f.call(p,d)||(r[d]=p[d]);return r}:l},2361:(e,t,r)=>{var n,i=r(47),o=r(7852),s=r(9752),a=r(5644),u=r(7666),c=r(3879),l=r(8698)("IE_PROTO"),h=function(){},f=function(e){return"<script>"+e+"<\/script>"},d=function(e){e.write(f("")),e.close();var t=e.parentWindow.Object;return e=null,t},p=function(){try{n=new ActiveXObject("htmlfile")}catch(e){}var e,t;p="undefined"!=typeof document?document.domain&&n?d(n):((t=c("iframe")).style.display="none",u.appendChild(t),t.src=String("javascript:"),(e=t.contentWindow.document).open(),e.write(f("document.F=Object")),e.close(),e.F):d(n);for(var r=s.length;r--;)delete p.prototype[s[r]];return p()};a[l]=!0,e.exports=Object.create||function(e,t){var r;return null!==e?(h.prototype=i(e),r=new h,h.prototype=null,r[l]=e):r=p(),void 0===t?r:o(r,t)}},7852:(e,t,r)=>{var n=r(5542),i=r(3376),o=r(47),s=r(965);e.exports=n?Object.defineProperties:function(e,t){o(e);for(var r,n=s(t),a=n.length,u=0;a>u;)i.f(e,r=n[u++],t[r]);return e}},3376:(e,t,r)=>{var n=r(5542),i=r(6056),o=r(47),s=r(2694),a=Object.defineProperty;t.f=n?a:function(e,t,r){if(o(e),t=s(t),o(r),i)try{return a(e,t,r)}catch(e){}if("get"in r||"set"in r)throw TypeError("Accessors not supported");return"value"in r&&(e[t]=r.value),e}},7825:(e,t,r)=>{var n=r(5542),i=r(3626),o=r(976),s=r(8852),a=r(2694),u=r(5884),c=r(6056),l=Object.getOwnPropertyDescriptor;t.f=n?l:function(e,t){if(e=s(e),t=a(t),c)try{return l(e,t)}catch(e){}if(u(e,t))return o(!i.f.call(e,t),e[t])}},8401:(e,t,r)=>{var n=r(8104),i=r(9752).concat("length","prototype");t.f=Object.getOwnPropertyNames||function(e){return n(e,i)}},1913:(e,t)=>{t.f=Object.getOwnPropertySymbols},8186:(e,t,r)=>{var n=r(5884),i=r(4680),o=r(8698),s=r(9241),a=o("IE_PROTO"),u=Object.prototype;e.exports=s?Object.getPrototypeOf:function(e){return e=i(e),n(e,a)?e[a]:"function"==typeof e.constructor&&e instanceof e.constructor?e.constructor.prototype:e instanceof Object?u:null}},8104:(e,t,r)=>{var n=r(5884),i=r(8852),o=r(1270).indexOf,s=r(5644);e.exports=function(e,t){var r,a=i(e),u=0,c=[];for(r in a)!n(s,r)&&n(a,r)&&c.push(r);for(;t.length>u;)n(a,r=t[u++])&&(~o(c,r)||c.push(r));return c}},965:(e,t,r)=>{var n=r(8104),i=r(9752);e.exports=Object.keys||function(e){return n(e,i)}},3626:(e,t)=>{"use strict";var r={}.propertyIsEnumerable,n=Object.getOwnPropertyDescriptor,i=n&&!r.call({1:2},1);t.f=i?function(e){var t=n(this,e);return!!t&&t.enumerable}:r},2686:(e,t,r)=>{var n=r(47),i=r(8143);e.exports=Object.setPrototypeOf||("__proto__"in{}?function(){var e,t=!1,r={};try{(e=Object.getOwnPropertyDescriptor(Object.prototype,"__proto__").set).call(r,[]),t=r instanceof Array}catch(e){}return function(r,o){return n(r),i(o),t?e.call(r,o):r.__proto__=o,r}}():void 0)},2392:(e,t,r)=>{var n=r(6944);e.exports=function(e,t){var r,i;if("string"===t&&"function"==typeof(r=e.toString)&&!n(i=r.call(e)))return i;if("function"==typeof(r=e.valueOf)&&!n(i=r.call(e)))return i;if("string"!==t&&"function"==typeof(r=e.toString)&&!n(i=r.call(e)))return i;throw TypeError("Can't convert object to primitive value")}},8204:(e,t,r)=>{var n=r(4578),i=r(8401),o=r(1913),s=r(47);e.exports=n("Reflect","ownKeys")||function(e){var t=i.f(s(e)),r=o.f;return r?t.concat(r(e)):t}},7490:(e,t,r)=>{var n=r(1249);e.exports=function(e,t,r){for(var i in t)n(e,i,t[i],r);return e}},1249:(e,t,r)=>{var n=r(6874),i=r(4791),o=r(5884),s=r(1278),a=r(6090),u=r(6619),c=u.get,l=u.enforce,h=String(String).split("String");(e.exports=function(e,t,r,a){var u,c=!!a&&!!a.unsafe,f=!!a&&!!a.enumerable,d=!!a&&!!a.noTargetGet;"function"==typeof r&&("string"!=typeof t||o(r,"name")||i(r,"name",t),(u=l(r)).source||(u.source=h.join("string"==typeof t?t:""))),e!==n?(c?!d&&e[t]&&(f=!0):delete e[t],f?e[t]=r:i(e,t,r)):f?e[t]=r:s(t,r)})(Function.prototype,"toString",(function(){return"function"==typeof this&&c(this).source||a(this)}))},164:e=>{e.exports=function(e){if(null==e)throw TypeError("Can't call method on "+e);return e}},1278:(e,t,r)=>{var n=r(6874);e.exports=function(e,t){try{Object.defineProperty(n,e,{value:t,configurable:!0,writable:!0})}catch(r){n[e]=t}return t}},9400:(e,t,r)=>{var n=r(3376).f,i=r(5884),o=r(3706)("toStringTag");e.exports=function(e,t,r){e&&!i(e=r?e:e.prototype,o)&&n(e,o,{configurable:!0,value:t})}},8698:(e,t,r)=>{var n=r(3215),i=r(8435),o=n("keys");e.exports=function(e){return o[e]||(o[e]=i(e))}},4925:(e,t,r)=>{var n=r(6874),i=r(1278),o="__core-js_shared__",s=n[o]||i(o,{});e.exports=s},3215:(e,t,r)=>{var n=r(6852),i=r(4925);(e.exports=function(e,t){return i[e]||(i[e]=void 0!==t?t:{})})("versions",[]).push({version:"3.16.2",mode:n?"pure":"global",copyright:" 2021 Denis Pushkarev (zloirock.ru)"})},6174:(e,t,r)=>{var n=r(7896),i=r(401),o=r(164),s=function(e){return function(t,r){var s,a,u=i(o(t)),c=n(r),l=u.length;return c<0||c>=l?e?"":void 0:(s=u.charCodeAt(c))<55296||s>56319||c+1===l||(a=u.charCodeAt(c+1))<56320||a>57343?e?u.charAt(c):s:e?u.slice(c,c+2):a-56320+(s-55296<<10)+65536}};e.exports={codeAt:s(!1),charAt:s(!0)}},8:e=>{"use strict";var t=2147483647,r=/[^\0-\u007E]/,n=/[.\u3002\uFF0E\uFF61]/g,i="Overflow: input needs wider integers to process",o=Math.floor,s=String.fromCharCode,a=function(e){return e+22+75*(e<26)},u=function(e,t,r){var n=0;for(e=r?o(e/700):e>>1,e+=o(e/t);e>455;n+=36)e=o(e/35);return o(n+36*e/(e+38))},c=function(e){var r,n,c=[],l=(e=function(e){for(var t=[],r=0,n=e.length;r<n;){var i=e.charCodeAt(r++);if(i>=55296&&i<=56319&&r<n){var o=e.charCodeAt(r++);56320==(64512&o)?t.push(((1023&i)<<10)+(1023&o)+65536):(t.push(i),r--)}else t.push(i)}return t}(e)).length,h=128,f=0,d=72;for(r=0;r<e.length;r++)(n=e[r])<128&&c.push(s(n));var p=c.length,m=p;for(p&&c.push("-");m<l;){var g=t;for(r=0;r<e.length;r++)(n=e[r])>=h&&n<g&&(g=n);var y=m+1;if(g-h>o((t-f)/y))throw RangeError(i);for(f+=(g-h)*y,h=g,r=0;r<e.length;r++){if((n=e[r])<h&&++f>t)throw RangeError(i);if(n==h){for(var b=f,v=36;;v+=36){var w=v<=d?1:v>=d+26?26:v-d;if(b<w)break;var _=b-w,S=36-w;c.push(s(a(w+_%S))),b=o(_/S)}c.push(s(a(b))),d=u(f,y,m==p),f=0,++m}}++f,++h}return c.join("")};e.exports=function(e){var t,i,o=[],s=e.toLowerCase().replace(n,".").split(".");for(t=0;t<s.length;t++)i=s[t],o.push(r.test(i)?"xn--"+c(i):i);return o.join(".")}},2145:(e,t,r)=>{var n=r(7896),i=Math.max,o=Math.min;e.exports=function(e,t){var r=n(e);return r<0?i(r+t,0):o(r,t)}},8852:(e,t,r)=>{var n=r(8517),i=r(164);e.exports=function(e){return n(i(e))}},7896:e=>{var t=Math.ceil,r=Math.floor;e.exports=function(e){return isNaN(e=+e)?0:(e>0?r:t)(e)}},4954:(e,t,r)=>{var n=r(7896),i=Math.min;e.exports=function(e){return e>0?i(n(e),9007199254740991):0}},4680:(e,t,r)=>{var n=r(164);e.exports=function(e){return Object(n(e))}},2034:(e,t,r)=>{var n=r(6944),i=r(8377),o=r(2392),s=r(3706)("toPrimitive");e.exports=function(e,t){if(!n(e)||i(e))return e;var r,a=e[s];if(void 0!==a){if(void 0===t&&(t="default"),r=a.call(e,t),!n(r)||i(r))return r;throw TypeError("Can't convert object to primitive value")}return void 0===t&&(t="number"),o(e,t)}},2694:(e,t,r)=>{var n=r(2034),i=r(8377);e.exports=function(e){var t=n(e,"string");return i(t)?t:String(t)}},939:(e,t,r)=>{var n={};n[r(3706)("toStringTag")]="z",e.exports="[object z]"===String(n)},401:(e,t,r)=>{var n=r(8377);e.exports=function(e){if(n(e))throw TypeError("Cannot convert a Symbol value to a string");return String(e)}},8435:e=>{var t=0,r=Math.random();e.exports=function(e){return"Symbol("+String(void 0===e?"":e)+")_"+(++t+r).toString(36)}},4587:(e,t,r)=>{var n=r(1453);e.exports=n&&!Symbol.sham&&"symbol"==typeof Symbol.iterator},3706:(e,t,r)=>{var n=r(6874),i=r(3215),o=r(5884),s=r(8435),a=r(1453),u=r(4587),c=i("wks"),l=n.Symbol,h=u?l:l&&l.withoutSetter||s;e.exports=function(e){return o(c,e)&&(a||"string"==typeof c[e])||(a&&o(l,e)?c[e]=l[e]:c[e]=h("Symbol."+e)),c[e]}},2837:(e,t,r)=>{"use strict";var n=r(8852),i=r(9611),o=r(873),s=r(6619),a=r(3131),u="Array Iterator",c=s.set,l=s.getterFor(u);e.exports=a(Array,"Array",(function(e,t){c(this,{type:u,target:n(e),index:0,kind:t})}),(function(){var e=l(this),t=e.target,r=e.kind,n=e.index++;return!t||n>=t.length?(e.target=void 0,{value:void 0,done:!0}):"keys"==r?{value:n,done:!1}:"values"==r?{value:t[n],done:!1}:{value:[n,t[n]],done:!1}}),"values"),o.Arguments=o.Array,i("keys"),i("values"),i("entries")},6949:(e,t,r)=>{"use strict";var n=r(6174).charAt,i=r(401),o=r(6619),s=r(3131),a="String Iterator",u=o.set,c=o.getterFor(a);s(String,"String",(function(e){u(this,{type:a,string:i(e),index:0})}),(function(){var e,t=c(this),r=t.string,i=t.index;return i>=r.length?{value:void 0,done:!0}:(e=n(r,i),t.index+=e.length,{value:e,done:!1})}))},2303:(e,t,r)=>{"use strict";r(2837);var n=r(1082),i=r(4578),o=r(1781),s=r(1249),a=r(7490),u=r(9400),c=r(9670),l=r(6619),h=r(2482),f=r(5884),d=r(4833),p=r(8753),m=r(47),g=r(6944),y=r(401),b=r(2361),v=r(976),w=r(7053),_=r(3126),S=r(3706),E=i("fetch"),x=i("Request"),R=x&&x.prototype,T=i("Headers"),C=S("iterator"),k="URLSearchParams",O="URLSearchParamsIterator",P=l.set,I=l.getterFor(k),L=l.getterFor(O),B=/\+/g,A=Array(4),U=function(e){return A[e-1]||(A[e-1]=RegExp("((?:%[\\da-f]{2}){"+e+"})","gi"))},j=function(e){try{return decodeURIComponent(e)}catch(t){return e}},M=function(e){var t=e.replace(B," "),r=4;try{return decodeURIComponent(t)}catch(e){for(;r;)t=t.replace(U(r--),j);return t}},D=/[!'()~]|%20/g,N={"!":"%21","'":"%27","(":"%28",")":"%29","~":"%7E","%20":"+"},F=function(e){return N[e]},q=function(e){return encodeURIComponent(e).replace(D,F)},H=function(e,t){if(t)for(var r,n,i=t.split("&"),o=0;o<i.length;)(r=i[o++]).length&&(n=r.split("="),e.push({key:M(n.shift()),value:M(n.join("="))}))},$=function(e){this.entries.length=0,H(this.entries,e)},W=function(e,t){if(e<t)throw TypeError("Not enough arguments")},z=c((function(e,t){P(this,{type:O,iterator:w(I(e).entries),kind:t})}),"Iterator",(function(){var e=L(this),t=e.kind,r=e.iterator.next(),n=r.value;return r.done||(r.value="keys"===t?n.key:"values"===t?n.value:[n.key,n.value]),r})),G=function(){h(this,G,k);var e,t,r,n,i,o,s,a,u,c=arguments.length>0?arguments[0]:void 0,l=this,d=[];if(P(l,{type:k,entries:d,updateURL:function(){},updateSearchParams:$}),void 0!==c)if(g(c))if("function"==typeof(e=_(c)))for(r=(t=e.call(c)).next;!(n=r.call(t)).done;){if((s=(o=(i=w(m(n.value))).next).call(i)).done||(a=o.call(i)).done||!o.call(i).done)throw TypeError("Expected sequence with length 2");d.push({key:y(s.value),value:y(a.value)})}else for(u in c)f(c,u)&&d.push({key:u,value:y(c[u])});else H(d,"string"==typeof c?"?"===c.charAt(0)?c.slice(1):c:y(c))},V=G.prototype;if(a(V,{append:function(e,t){W(arguments.length,2);var r=I(this);r.entries.push({key:y(e),value:y(t)}),r.updateURL()},delete:function(e){W(arguments.length,1);for(var t=I(this),r=t.entries,n=y(e),i=0;i<r.length;)r[i].key===n?r.splice(i,1):i++;t.updateURL()},get:function(e){W(arguments.length,1);for(var t=I(this).entries,r=y(e),n=0;n<t.length;n++)if(t[n].key===r)return t[n].value;return null},getAll:function(e){W(arguments.length,1);for(var t=I(this).entries,r=y(e),n=[],i=0;i<t.length;i++)t[i].key===r&&n.push(t[i].value);return n},has:function(e){W(arguments.length,1);for(var t=I(this).entries,r=y(e),n=0;n<t.length;)if(t[n++].key===r)return!0;return!1},set:function(e,t){W(arguments.length,1);for(var r,n=I(this),i=n.entries,o=!1,s=y(e),a=y(t),u=0;u<i.length;u++)(r=i[u]).key===s&&(o?i.splice(u--,1):(o=!0,r.value=a));o||i.push({key:s,value:a}),n.updateURL()},sort:function(){var e,t,r,n=I(this),i=n.entries,o=i.slice();for(i.length=0,r=0;r<o.length;r++){for(e=o[r],t=0;t<r;t++)if(i[t].key>e.key){i.splice(t,0,e);break}t===r&&i.push(e)}n.updateURL()},forEach:function(e){for(var t,r=I(this).entries,n=d(e,arguments.length>1?arguments[1]:void 0,3),i=0;i<r.length;)n((t=r[i++]).value,t.key,this)},keys:function(){return new z(this,"keys")},values:function(){return new z(this,"values")},entries:function(){return new z(this,"entries")}},{enumerable:!0}),s(V,C,V.entries),s(V,"toString",(function(){for(var e,t=I(this).entries,r=[],n=0;n<t.length;)e=t[n++],r.push(q(e.key)+"="+q(e.value));return r.join("&")}),{enumerable:!0}),u(G,k),n({global:!0,forced:!o},{URLSearchParams:G}),!o&&"function"==typeof T){var Y=function(e){if(g(e)){var t,r=e.body;if(p(r)===k)return(t=e.headers?new T(e.headers):new T).has("content-type")||t.set("content-type","application/x-www-form-urlencoded;charset=UTF-8"),b(e,{body:v(0,String(r)),headers:v(0,t)})}return e};if("function"==typeof E&&n({global:!0,enumerable:!0,forced:!0},{fetch:function(e){return E(e,arguments.length>1?Y(arguments[1]):{})}}),"function"==typeof x){var J=function(e){return h(this,J,"Request"),new x(e,arguments.length>1?Y(arguments[1]):{})};R.constructor=J,J.prototype=R,n({global:!0,forced:!0},{Request:J})}}e.exports={URLSearchParams:G,getState:I}},2743:(e,t,r)=>{"use strict";r(6949);var n,i=r(1082),o=r(5542),s=r(1781),a=r(6874),u=r(7852),c=r(1249),l=r(2482),h=r(5884),f=r(5277),d=r(1774),p=r(6174).codeAt,m=r(8),g=r(401),y=r(9400),b=r(2303),v=r(6619),w=a.URL,_=b.URLSearchParams,S=b.getState,E=v.set,x=v.getterFor("URL"),R=Math.floor,T=Math.pow,C="Invalid scheme",k="Invalid host",O="Invalid port",P=/[A-Za-z]/,I=/[\d+-.A-Za-z]/,L=/\d/,B=/^0x/i,A=/^[0-7]+$/,U=/^\d+$/,j=/^[\dA-Fa-f]+$/,M=/[\0\t\n\r #%/:<>?@[\\\]^|]/,D=/[\0\t\n\r #/:<>?@[\\\]^|]/,N=/^[\u0000-\u0020]+|[\u0000-\u0020]+$/g,F=/[\t\n\r]/g,q=function(e,t){var r,n,i;if("["==t.charAt(0)){if("]"!=t.charAt(t.length-1))return k;if(!(r=$(t.slice(1,-1))))return k;e.host=r}else if(X(e)){if(t=m(t),M.test(t))return k;if(null===(r=H(t)))return k;e.host=r}else{if(D.test(t))return k;for(r="",n=d(t),i=0;i<n.length;i++)r+=J(n[i],z);e.host=r}},H=function(e){var t,r,n,i,o,s,a,u=e.split(".");if(u.length&&""==u[u.length-1]&&u.pop(),(t=u.length)>4)return e;for(r=[],n=0;n<t;n++){if(""==(i=u[n]))return e;if(o=10,i.length>1&&"0"==i.charAt(0)&&(o=B.test(i)?16:8,i=i.slice(8==o?1:2)),""===i)s=0;else{if(!(10==o?U:8==o?A:j).test(i))return e;s=parseInt(i,o)}r.push(s)}for(n=0;n<t;n++)if(s=r[n],n==t-1){if(s>=T(256,5-t))return null}else if(s>255)return null;for(a=r.pop(),n=0;n<r.length;n++)a+=r[n]*T(256,3-n);return a},$=function(e){var t,r,n,i,o,s,a,u=[0,0,0,0,0,0,0,0],c=0,l=null,h=0,f=function(){return e.charAt(h)};if(":"==f()){if(":"!=e.charAt(1))return;h+=2,l=++c}for(;f();){if(8==c)return;if(":"!=f()){for(t=r=0;r<4&&j.test(f());)t=16*t+parseInt(f(),16),h++,r++;if("."==f()){if(0==r)return;if(h-=r,c>6)return;for(n=0;f();){if(i=null,n>0){if(!("."==f()&&n<4))return;h++}if(!L.test(f()))return;for(;L.test(f());){if(o=parseInt(f(),10),null===i)i=o;else{if(0==i)return;i=10*i+o}if(i>255)return;h++}u[c]=256*u[c]+i,2!=++n&&4!=n||c++}if(4!=n)return;break}if(":"==f()){if(h++,!f())return}else if(f())return;u[c++]=t}else{if(null!==l)return;h++,l=++c}}if(null!==l)for(s=c-l,c=7;0!=c&&s>0;)a=u[c],u[c--]=u[l+s-1],u[l+--s]=a;else if(8!=c)return;return u},W=function(e){var t,r,n,i;if("number"==typeof e){for(t=[],r=0;r<4;r++)t.unshift(e%256),e=R(e/256);return t.join(".")}if("object"==typeof e){for(t="",n=function(e){for(var t=null,r=1,n=null,i=0,o=0;o<8;o++)0!==e[o]?(i>r&&(t=n,r=i),n=null,i=0):(null===n&&(n=o),++i);return i>r&&(t=n,r=i),t}(e),r=0;r<8;r++)i&&0===e[r]||(i&&(i=!1),n===r?(t+=r?":":"::",i=!0):(t+=e[r].toString(16),r<7&&(t+=":")));return"["+t+"]"}return e},z={},G=f({},z,{" ":1,'"':1,"<":1,">":1,"`":1}),V=f({},G,{"#":1,"?":1,"{":1,"}":1}),Y=f({},V,{"/":1,":":1,";":1,"=":1,"@":1,"[":1,"\\":1,"]":1,"^":1,"|":1}),J=function(e,t){var r=p(e,0);return r>32&&r<127&&!h(t,e)?e:encodeURIComponent(e)},K={ftp:21,file:null,http:80,https:443,ws:80,wss:443},X=function(e){return h(K,e.scheme)},Z=function(e){return""!=e.username||""!=e.password},Q=function(e){return!e.host||e.cannotBeABaseURL||"file"==e.scheme},ee=function(e,t){var r;return 2==e.length&&P.test(e.charAt(0))&&(":"==(r=e.charAt(1))||!t&&"|"==r)},te=function(e){var t;return e.length>1&&ee(e.slice(0,2))&&(2==e.length||"/"===(t=e.charAt(2))||"\\"===t||"?"===t||"#"===t)},re=function(e){var t=e.path,r=t.length;!r||"file"==e.scheme&&1==r&&ee(t[0],!0)||t.pop()},ne=function(e){return"."===e||"%2e"===e.toLowerCase()},ie={},oe={},se={},ae={},ue={},ce={},le={},he={},fe={},de={},pe={},me={},ge={},ye={},be={},ve={},we={},_e={},Se={},Ee={},xe={},Re=function(e,t,r,i){var o,s,a,u,c,l=r||ie,f=0,p="",m=!1,g=!1,y=!1;for(r||(e.scheme="",e.username="",e.password="",e.host=null,e.port=null,e.path=[],e.query=null,e.fragment=null,e.cannotBeABaseURL=!1,t=t.replace(N,"")),t=t.replace(F,""),o=d(t);f<=o.length;){switch(s=o[f],l){case ie:if(!s||!P.test(s)){if(r)return C;l=se;continue}p+=s.toLowerCase(),l=oe;break;case oe:if(s&&(I.test(s)||"+"==s||"-"==s||"."==s))p+=s.toLowerCase();else{if(":"!=s){if(r)return C;p="",l=se,f=0;continue}if(r&&(X(e)!=h(K,p)||"file"==p&&(Z(e)||null!==e.port)||"file"==e.scheme&&!e.host))return;if(e.scheme=p,r)return void(X(e)&&K[e.scheme]==e.port&&(e.port=null));p="","file"==e.scheme?l=ye:X(e)&&i&&i.scheme==e.scheme?l=ae:X(e)?l=he:"/"==o[f+1]?(l=ue,f++):(e.cannotBeABaseURL=!0,e.path.push(""),l=Se)}break;case se:if(!i||i.cannotBeABaseURL&&"#"!=s)return C;if(i.cannotBeABaseURL&&"#"==s){e.scheme=i.scheme,e.path=i.path.slice(),e.query=i.query,e.fragment="",e.cannotBeABaseURL=!0,l=xe;break}l="file"==i.scheme?ye:ce;continue;case ae:if("/"!=s||"/"!=o[f+1]){l=ce;continue}l=fe,f++;break;case ue:if("/"==s){l=de;break}l=_e;continue;case ce:if(e.scheme=i.scheme,s==n)e.username=i.username,e.password=i.password,e.host=i.host,e.port=i.port,e.path=i.path.slice(),e.query=i.query;else if("/"==s||"\\"==s&&X(e))l=le;else if("?"==s)e.username=i.username,e.password=i.password,e.host=i.host,e.port=i.port,e.path=i.path.slice(),e.query="",l=Ee;else{if("#"!=s){e.username=i.username,e.password=i.password,e.host=i.host,e.port=i.port,e.path=i.path.slice(),e.path.pop(),l=_e;continue}e.username=i.username,e.password=i.password,e.host=i.host,e.port=i.port,e.path=i.path.slice(),e.query=i.query,e.fragment="",l=xe}break;case le:if(!X(e)||"/"!=s&&"\\"!=s){if("/"!=s){e.username=i.username,e.password=i.password,e.host=i.host,e.port=i.port,l=_e;continue}l=de}else l=fe;break;case he:if(l=fe,"/"!=s||"/"!=p.charAt(f+1))continue;f++;break;case fe:if("/"!=s&&"\\"!=s){l=de;continue}break;case de:if("@"==s){m&&(p="%40"+p),m=!0,a=d(p);for(var b=0;b<a.length;b++){var v=a[b];if(":"!=v||y){var w=J(v,Y);y?e.password+=w:e.username+=w}else y=!0}p=""}else if(s==n||"/"==s||"?"==s||"#"==s||"\\"==s&&X(e)){if(m&&""==p)return"Invalid authority";f-=d(p).length+1,p="",l=pe}else p+=s;break;case pe:case me:if(r&&"file"==e.scheme){l=ve;continue}if(":"!=s||g){if(s==n||"/"==s||"?"==s||"#"==s||"\\"==s&&X(e)){if(X(e)&&""==p)return k;if(r&&""==p&&(Z(e)||null!==e.port))return;if(u=q(e,p))return u;if(p="",l=we,r)return;continue}"["==s?g=!0:"]"==s&&(g=!1),p+=s}else{if(""==p)return k;if(u=q(e,p))return u;if(p="",l=ge,r==me)return}break;case ge:if(!L.test(s)){if(s==n||"/"==s||"?"==s||"#"==s||"\\"==s&&X(e)||r){if(""!=p){var _=parseInt(p,10);if(_>65535)return O;e.port=X(e)&&_===K[e.scheme]?null:_,p=""}if(r)return;l=we;continue}return O}p+=s;break;case ye:if(e.scheme="file","/"==s||"\\"==s)l=be;else{if(!i||"file"!=i.scheme){l=_e;continue}if(s==n)e.host=i.host,e.path=i.path.slice(),e.query=i.query;else if("?"==s)e.host=i.host,e.path=i.path.slice(),e.query="",l=Ee;else{if("#"!=s){te(o.slice(f).join(""))||(e.host=i.host,e.path=i.path.slice(),re(e)),l=_e;continue}e.host=i.host,e.path=i.path.slice(),e.query=i.query,e.fragment="",l=xe}}break;case be:if("/"==s||"\\"==s){l=ve;break}i&&"file"==i.scheme&&!te(o.slice(f).join(""))&&(ee(i.path[0],!0)?e.path.push(i.path[0]):e.host=i.host),l=_e;continue;case ve:if(s==n||"/"==s||"\\"==s||"?"==s||"#"==s){if(!r&&ee(p))l=_e;else if(""==p){if(e.host="",r)return;l=we}else{if(u=q(e,p))return u;if("localhost"==e.host&&(e.host=""),r)return;p="",l=we}continue}p+=s;break;case we:if(X(e)){if(l=_e,"/"!=s&&"\\"!=s)continue}else if(r||"?"!=s)if(r||"#"!=s){if(s!=n&&(l=_e,"/"!=s))continue}else e.fragment="",l=xe;else e.query="",l=Ee;break;case _e:if(s==n||"/"==s||"\\"==s&&X(e)||!r&&("?"==s||"#"==s)){if(".."===(c=(c=p).toLowerCase())||"%2e."===c||".%2e"===c||"%2e%2e"===c?(re(e),"/"==s||"\\"==s&&X(e)||e.path.push("")):ne(p)?"/"==s||"\\"==s&&X(e)||e.path.push(""):("file"==e.scheme&&!e.path.length&&ee(p)&&(e.host&&(e.host=""),p=p.charAt(0)+":"),e.path.push(p)),p="","file"==e.scheme&&(s==n||"?"==s||"#"==s))for(;e.path.length>1&&""===e.path[0];)e.path.shift();"?"==s?(e.query="",l=Ee):"#"==s&&(e.fragment="",l=xe)}else p+=J(s,V);break;case Se:"?"==s?(e.query="",l=Ee):"#"==s?(e.fragment="",l=xe):s!=n&&(e.path[0]+=J(s,z));break;case Ee:r||"#"!=s?s!=n&&("'"==s&&X(e)?e.query+="%27":e.query+="#"==s?"%23":J(s,z)):(e.fragment="",l=xe);break;case xe:s!=n&&(e.fragment+=J(s,G))}f++}},Te=function(e){var t,r,n=l(this,Te,"URL"),i=arguments.length>1?arguments[1]:void 0,s=g(e),a=E(n,{type:"URL"});if(void 0!==i)if(i instanceof Te)t=x(i);else if(r=Re(t={},g(i)))throw TypeError(r);if(r=Re(a,s,null,t))throw TypeError(r);var u=a.searchParams=new _,c=S(u);c.updateSearchParams(a.query),c.updateURL=function(){a.query=String(u)||null},o||(n.href=ke.call(n),n.origin=Oe.call(n),n.protocol=Pe.call(n),n.username=Ie.call(n),n.password=Le.call(n),n.host=Be.call(n),n.hostname=Ae.call(n),n.port=Ue.call(n),n.pathname=je.call(n),n.search=Me.call(n),n.searchParams=De.call(n),n.hash=Ne.call(n))},Ce=Te.prototype,ke=function(){var e=x(this),t=e.scheme,r=e.username,n=e.password,i=e.host,o=e.port,s=e.path,a=e.query,u=e.fragment,c=t+":";return null!==i?(c+="//",Z(e)&&(c+=r+(n?":"+n:"")+"@"),c+=W(i),null!==o&&(c+=":"+o)):"file"==t&&(c+="//"),c+=e.cannotBeABaseURL?s[0]:s.length?"/"+s.join("/"):"",null!==a&&(c+="?"+a),null!==u&&(c+="#"+u),c},Oe=function(){var e=x(this),t=e.scheme,r=e.port;if("blob"==t)try{return new Te(t.path[0]).origin}catch(e){return"null"}return"file"!=t&&X(e)?t+"://"+W(e.host)+(null!==r?":"+r:""):"null"},Pe=function(){return x(this).scheme+":"},Ie=function(){return x(this).username},Le=function(){return x(this).password},Be=function(){var e=x(this),t=e.host,r=e.port;return null===t?"":null===r?W(t):W(t)+":"+r},Ae=function(){var e=x(this).host;return null===e?"":W(e)},Ue=function(){var e=x(this).port;return null===e?"":String(e)},je=function(){var e=x(this),t=e.path;return e.cannotBeABaseURL?t[0]:t.length?"/"+t.join("/"):""},Me=function(){var e=x(this).query;return e?"?"+e:""},De=function(){return x(this).searchParams},Ne=function(){var e=x(this).fragment;return e?"#"+e:""},Fe=function(e,t){return{get:e,set:t,configurable:!0,enumerable:!0}};if(o&&u(Ce,{href:Fe(ke,(function(e){var t=x(this),r=g(e),n=Re(t,r);if(n)throw TypeError(n);S(t.searchParams).updateSearchParams(t.query)})),origin:Fe(Oe),protocol:Fe(Pe,(function(e){var t=x(this);Re(t,g(e)+":",ie)})),username:Fe(Ie,(function(e){var t=x(this),r=d(g(e));if(!Q(t)){t.username="";for(var n=0;n<r.length;n++)t.username+=J(r[n],Y)}})),password:Fe(Le,(function(e){var t=x(this),r=d(g(e));if(!Q(t)){t.password="";for(var n=0;n<r.length;n++)t.password+=J(r[n],Y)}})),host:Fe(Be,(function(e){var t=x(this);t.cannotBeABaseURL||Re(t,g(e),pe)})),hostname:Fe(Ae,(function(e){var t=x(this);t.cannotBeABaseURL||Re(t,g(e),me)})),port:Fe(Ue,(function(e){var t=x(this);Q(t)||(""==(e=g(e))?t.port=null:Re(t,e,ge))})),pathname:Fe(je,(function(e){var t=x(this);t.cannotBeABaseURL||(t.path=[],Re(t,g(e),we))})),search:Fe(Me,(function(e){var t=x(this);""==(e=g(e))?t.query=null:("?"==e.charAt(0)&&(e=e.slice(1)),t.query="",Re(t,e,Ee)),S(t.searchParams).updateSearchParams(t.query)})),searchParams:Fe(De),hash:Fe(Ne,(function(e){var t=x(this);""!=(e=g(e))?("#"==e.charAt(0)&&(e=e.slice(1)),t.fragment="",Re(t,e,xe)):t.fragment=null}))}),c(Ce,"toJSON",(function(){return ke.call(this)}),{enumerable:!0}),c(Ce,"toString",(function(){return ke.call(this)}),{enumerable:!0}),w){var qe=w.createObjectURL,He=w.revokeObjectURL;qe&&c(Te,"createObjectURL",(function(e){return qe.apply(w,arguments)})),He&&c(Te,"revokeObjectURL",(function(e){return He.apply(w,arguments)}))}y(Te,"URL"),i({global:!0,forced:!s,sham:!o},{URL:Te})},462:()=>{},6029:()=>{}},t={};function r(n){var i=t[n];if(void 0!==i)return i.exports;var o=t[n]={exports:{}};return e[n](o,o.exports,r),o.exports}r.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return r.d(t,{a:t}),t},r.d=(e,t)=>{for(var n in t)r.o(t,n)&&!r.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},r.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),r.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var n={};return(()=>{"use strict";r.r(n),r.d(n,{AACDepay:()=>P,BasicDepay:()=>L,CanvasSink:()=>D,H264Depay:()=>J,Html5CanvasPipeline:()=>wr,Html5VideoMetadataPipeline:()=>Er,Html5VideoPipeline:()=>Sr,HttpMsePipeline:()=>Ur,HttpSource:()=>ee,Inspector:()=>re,JPEGDepay:()=>ve,MessageType:()=>k,MetadataPipeline:()=>Tr,Mp4Capture:()=>Se,Mp4Muxer:()=>et,MseSink:()=>St,ONVIFDepay:()=>xt,Pipeline:()=>ar,RTCPPacketType:()=>it,RTSPResponseError:()=>tr,RTSP_METHOD:()=>er,RtspMjpegPipeline:()=>fr,RtspMp4Pipeline:()=>hr,RtspParser:()=>Vt,RtspPipeline:()=>cr,RtspSession:()=>rr,SDESItem:()=>dt,SR:()=>at,Scheduler:()=>j,Sink:()=>f,Source:()=>l,Tube:()=>h,WSSource:()=>or,WsSdpPipeline:()=>kr,addRTSPRetry:()=>jr,bodyOffset:()=>Ht,cSrc:()=>x,cSrcCount:()=>b,components:()=>e,connectionEnded:()=>Ft,contentBase:()=>Dt,contentLocation:()=>Nt,createTransform:()=>O,extHeader:()=>T,extHeaderLength:()=>R,extension:()=>y,extractHeaderValue:()=>Bt,extractURIs:()=>Pt,getTime:()=>Kt,isRtcpApp:()=>vt,isRtcpBye:()=>yt,isRtcpRR:()=>ft,isRtcpSDES:()=>mt,isRtcpSR:()=>lt,marker:()=>v,messageFromBuffer:()=>Lt,padding:()=>g,parse:()=>It,parseRtcp:()=>ot,payload:()=>C,payloadType:()=>w,pipelines:()=>t,range:()=>qt,rtcpMessageFromBuffer:()=>st,sSrc:()=>E,sequence:()=>At,sequenceNumber:()=>_,sessionId:()=>Ut,sessionTimeout:()=>jt,statusCode:()=>Mt,timestamp:()=>S,utils:()=>i,version:()=>m});var e={};r.r(e),r.d(e,{AACDepay:()=>P,BasicDepay:()=>L,CanvasSink:()=>D,H264Depay:()=>J,HttpSource:()=>ee,Inspector:()=>re,JPEGDepay:()=>ve,MessageType:()=>k,Mp4Capture:()=>Se,Mp4Muxer:()=>et,MseSink:()=>St,ONVIFDepay:()=>xt,RTSPResponseError:()=>tr,RTSP_METHOD:()=>er,RtspParser:()=>Vt,RtspSession:()=>rr,Sink:()=>f,Source:()=>l,Tube:()=>h,WSSource:()=>or,createTransform:()=>O});var t={};r.r(t),r.d(t,{Html5CanvasPipeline:()=>wr,Html5VideoMetadataPipeline:()=>Er,Html5VideoPipeline:()=>Sr,HttpMsePipeline:()=>Ur,MetadataPipeline:()=>Tr,Pipeline:()=>ar,RtspMjpegPipeline:()=>fr,RtspMp4Pipeline:()=>hr,RtspPipeline:()=>cr,WsSdpPipeline:()=>kr});var i={};r.r(i),r.d(i,{RTCPPacketType:()=>it,SDESItem:()=>dt,SR:()=>at,Scheduler:()=>j,addRTSPRetry:()=>jr,bodyOffset:()=>Ht,cSrc:()=>x,cSrcCount:()=>b,connectionEnded:()=>Ft,contentBase:()=>Dt,contentLocation:()=>Nt,extHeader:()=>T,extHeaderLength:()=>R,extension:()=>y,extractHeaderValue:()=>Bt,extractURIs:()=>Pt,getTime:()=>Kt,isRtcpApp:()=>vt,isRtcpBye:()=>yt,isRtcpRR:()=>ft,isRtcpSDES:()=>mt,isRtcpSR:()=>lt,marker:()=>v,messageFromBuffer:()=>Lt,padding:()=>g,parse:()=>It,parseRtcp:()=>ot,payload:()=>C,payloadType:()=>w,range:()=>qt,rtcpMessageFromBuffer:()=>st,sSrc:()=>E,sequence:()=>At,sequenceNumber:()=>_,sessionId:()=>Ut,sessionTimeout:()=>jt,statusCode:()=>Mt,timestamp:()=>S,version:()=>m});var o=r(8981),s=r(7866).Buffer;class a{static consumer(e=(()=>{})){return new o.Writable({objectMode:!0,write(t,r,n){e(t),n()}})}static peeker(e){if("function"!=typeof e)throw new Error("you must supply a function");return new o.Transform({objectMode:!0,transform(t,r,n){e(t),n(void 0,t)}})}static producer(e){let t=0;return new o.Readable({objectMode:!0,read(){void 0!==e&&(t<e.length?this.push(e[t++]):this.push(null))}})}static recorder(e,t){return new o.Transform({objectMode:!0,transform(r,n,i){const o=Date.now(),s=Object.assign({},r,{data:r.data.toString("base64")});t.write(JSON.stringify({type:e,timestamp:o,message:s},null,2)),t.write(",\n"),i(void 0,r)}})}static replayer(e){let t=0,r=e[0].timestamp;return new o.Readable({objectMode:!0,read(){const n=e[t++];if(n){const{type:e,timestamp:t,message:i}=n,o=t-r;if(r=t,i){const t=i.data?s.from(i.data,"base64"):s.alloc(0),r=Object.assign({},i,{data:t});this.push({type:e,delay:o,msg:r})}else this.push({type:e,delay:o,msg:null})}else this.push(null)}})}}function u(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}class c{constructor(){u(this,"incoming",void 0),u(this,"outgoing",void 0),u(this,"next",void 0),u(this,"prev",void 0),u(this,"_incomingErrorHandler",void 0),u(this,"_outgoingErrorHandler",void 0)}}class l extends c{static fromMessages(e){return new l(a.producer(e),a.consumer())}constructor(e=new o.Readable({objectMode:!0}),t=new o.Writable({objectMode:!0})){super(),u(this,"incoming",void 0),u(this,"outgoing",void 0),u(this,"next",void 0),u(this,"prev",void 0),this.incoming=e,this.outgoing=t,this.next=null,this.prev=null}connect(e){if(null===e)return this;if(null!==this.next||null!==e.prev)throw new Error("connection failed: component(s) already connected");if(!this.incoming.readable||!this.outgoing.writable)throw new Error("connection failed: this component not compatible");if(!e.incoming.writable||!e.outgoing.readable)throw new Error("connection failed: next component not compatible");try{this.incoming.pipe(e.incoming),e.outgoing.pipe(this.outgoing)}catch(e){throw new Error(`connection failed: ${e.message}`)}const t=e=>{this.incoming.emit("error",e)};e.incoming.on("error",t);const r=t=>{e.outgoing.emit("error",t)};return this.outgoing.on("error",r),this.next=e,e.prev=this,this._incomingErrorHandler=t,this._outgoingErrorHandler=r,e}disconnect(){const e=this.next;return null!==e&&(this.incoming.unpipe(e.incoming),e.outgoing.unpipe(this.outgoing),void 0!==this._incomingErrorHandler&&e.incoming.removeListener("error",this._incomingErrorHandler),void 0!==this._outgoingErrorHandler&&this.outgoing.removeListener("error",this._outgoingErrorHandler),this.next=null,e.prev=null,delete this._incomingErrorHandler,delete this._outgoingErrorHandler),this}}class h extends l{static fromHandlers(e,t){const r=e?a.peeker(e):void 0,n=t?a.peeker(t):void 0;return new h(r,n)}constructor(e=new o.PassThrough({objectMode:!0}),t=new o.PassThrough({objectMode:!0})){super(e,t),u(this,"incoming",void 0),u(this,"outgoing",void 0),this.incoming=e,this.outgoing=t}}class f extends c{static fromHandler(e){const t=new f(a.consumer(e),a.producer(void 0));return t.incoming.on("finish",(()=>{t.outgoing.push(null)})),t}constructor(e=new o.Writable({objectMode:!0}),t=new o.Readable({objectMode:!0})){super(),u(this,"incoming",void 0),u(this,"outgoing",void 0),u(this,"next",void 0),u(this,"prev",void 0),this.incoming=e,this.outgoing=t,this.next=null,this.prev=null}connect(){throw new Error("connection failed: attempting to connect after a sink")}disconnect(){return this}}const d=[128,64,32,16,8,4,2,1];var p=r(7866).Buffer;const m=e=>e[0]>>>6,g=e=>!!(e[0]&d[2]),y=e=>!!(e[0]&d[3]),b=e=>15&e[0],v=e=>!!(e[1]&d[0]),w=e=>127&e[1],_=e=>e.readUInt16BE(2),S=e=>e.readUInt32BE(4),E=e=>e.readUInt32BE(8),x=(e,t=0)=>b(e)>t?e.readUInt32BE(12+4*t):0,R=e=>y(e)?e.readUInt16BE(12+4*b(e)+2):0,T=e=>0===R(e)?p.from([]):e.slice(12+4*b(e),12+4*b(e)+4+4*R(e)),C=e=>y(e)?e.slice(12+4*b(e)+4+4*R(e)):e.slice(12+4*b(e));let k;!function(e){e[e.UNKNOWN=0]="UNKNOWN",e[e.RAW=1]="RAW",e[e.RTP=2]="RTP",e[e.RTCP=3]="RTCP",e[e.RTSP=4]="RTSP",e[e.SDP=5]="SDP",e[e.ELEMENTARY=6]="ELEMENTARY",e[e.H264=7]="H264",e[e.ISOM=8]="ISOM",e[e.XML=9]="XML",e[e.JPEG=10]="JPEG"}(k||(k={}));const O=e=>new o.Transform({objectMode:!0,transform:e});class P extends h{constructor(){let e,t;super(O((function(r,n,i){if(r.type===k.SDP){let n;for(const e of r.sdp.media)"audio"===e.type&&e.fmtp&&e.fmtp.parameters&&"AAC-hbr"===e.fmtp.parameters.mode&&(n=e);if(n&&void 0!==n.rtpmap){e=Number(n.rtpmap.payloadType);const r=n.fmtp.parameters,i=Number(r.sizelength)||0,o=Number(r.indexlength)||0,s=Number(r.indexdeltalength)||0,a=Number(r.ctsdeltalength)||0,u=Number(r.dtsdeltalength)||0,c=Number(r.randomaccessindication)||0,l=Number(r.streamstateindication)||0,h=Number(r.auxiliarydatasizelength)||0;t=i+Math.max(o,s)+a+u+c+l+h>0}i(void 0,r)}else r.type===k.RTP&&w(r.data)===e?(function(e,t,r){const n=C(e.data);let i=0;if(t){const e=n.readUInt16BE(0);i=2+(e+e%8)/8}r({type:k.ELEMENTARY,data:n.slice(i),payloadType:w(e.data),timestamp:S(e.data),ntpTimestamp:e.ntpTimestamp})}(r,t,this.push.bind(this)),i()):i(void 0,r)})))}}var I=r(7866).Buffer;class L extends h{constructor(e){if(void 0===e)throw new Error("you must supply a payload type to BasicDepayComponent");let t=I.alloc(0);super(O((function(r,n,i){if(r.type===k.RTP&&w(r.data)===e){const e=C(r.data);t=I.concat([t,e]),v(r.data)&&(t.length>0&&this.push({data:t,timestamp:S(r.data),ntpTimestamp:r.ntpTimestamp,payloadType:w(r.data),type:k.ELEMENTARY}),t=I.alloc(0)),i()}else i(void 0,r)})))}}function B(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}r(2743);class A{constructor(){B(this,"started",void 0),B(this,"stopped",void 0),B(this,"elapsed",void 0),this.elapsed=0,this.started=0,this.stopped=!0}start(){this.stopped&&(this.started=window.performance.now(),this.stopped=!1)}stop(){this.stopped||(this.elapsed=this.now(),this.stopped=!0)}reset(){this.elapsed=0,this.started=0,this.stopped=!0}now(){return this.stopped?this.elapsed:this.elapsed+(window.performance.now()-this.started)}play(){this.start()}pause(){this.stop()}get currentTime(){return this.now()/1e3}}function U(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}class j{constructor(e,t,r=10){U(this,"_clock",void 0),U(this,"_handler",void 0),U(this,"_tolerance",void 0),U(this,"_nextRun",void 0),U(this,"_nextPlay",void 0),U(this,"_fifo",void 0),U(this,"_ntpPresentationTime",void 0),U(this,"_suspended",void 0),this._clock=e,this._handler=t,this._tolerance=r,this._nextRun=0,this._nextPlay=0,this._fifo=[],this._ntpPresentationTime=0,this._suspended=!1}reset(){clearTimeout(this._nextRun),clearTimeout(this._nextPlay),this._fifo=[],this._ntpPresentationTime=0,this._suspended=!1}init(e){this._ntpPresentationTime=e}suspend(){clearTimeout(this._nextPlay),this._suspended=!0}resume(){this._suspended=!1,this.run(void 0)}run(e){if(clearTimeout(this._nextRun),void 0===this._ntpPresentationTime)return;if(void 0!==e&&this._fifo.push(e),this._suspended)return;if(0===this._fifo.length)return;let t,r=0;do{const e=this._fifo.shift();if(void 0===e)throw new Error("internal error: message should never be undefined");t=e;const n=t.ntpTimestamp;void 0!==n&&(r=n-this._ntpPresentationTime-1e3*this._clock.currentTime,Math.abs(r)<this._tolerance&&this._handler&&this._handler(t))}while(r<this._tolerance&&this._fifo.length>0);r<-this._tolerance?(clearTimeout(this._nextPlay),this._clock.pause(),this._nextPlay=window.setTimeout((()=>this._clock.play()),-r)):r>this._tolerance&&(this._fifo.unshift(t),this._nextRun=window.setTimeout((()=>this.run(void 0)),r))}}function M(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}class D extends f{constructor(e){if(void 0===e)throw new Error("canvas element argument missing");let t=0,r=0,n=0;const i={bitrate:0,framerate:0,renderedFrames:0};let s,a,u=null;if(void 0!==window.createImageBitmap&&(u=e.getContext("bitmaprenderer")),null===u&&(u=e.getContext("2d")),null===u)a=()=>{};else if("transferFromImageBitmap"in u){const e=u;a=({blob:t})=>{i.renderedFrames++,window.createImageBitmap(t).then((t=>{e.transferFromImageBitmap(t)})).catch((()=>{}))}}else{const e=u,t=new Image;t.onload=()=>{e.drawImage(t,0,0)},a=({blob:e})=>{i.renderedFrames++;const r=window.URL.createObjectURL(e);t.src=r}}const c=new A,l=new j(c,a);let h=0;const f=()=>{this.onCanplay&&this.onCanplay()},d=e=>{this.onSync&&this.onSync(e)},p=new o.Writable({objectMode:!0,write:(o,a,u)=>{if(o.type===k.SDP){c.reset(),l.reset(),t=0;const e=o.sdp.media.find((e=>"video"===e.type&&void 0!==e.rtpmap&&"JPEG"===e.rtpmap.encodingName));void 0!==e&&void 0!==e.rtpmap&&(n=e.rtpmap.clockrate,(e=>{e.bitrate=0,e.framerate=0,e.renderedFrames=0})(i),s=(e=>{let t=0,r=0,n=0;return(i,{byteLength:o,duration:s})=>{if(t+=o,r+=s,n++,r>=e){const o=8*t,s=n,a=r/e;i.bitrate=o/a,i.framerate=s/a,t=0,r=0,n=0}}})(n)),u()}else if(o.type===k.JPEG){const{timestamp:a,ntpTimestamp:c}=o;if(!t){t=a,r=a;const{width:n,height:i}=o.framesize;e.width=n,e.height=i,l.init(0)}const p=1e3*(a-t)/n,m=new window.Blob([o.data],{type:"image/jpeg"});!h&&c&&(h=c-p,d(h)),l.run({ntpTimestamp:p,blob:m}),a===t&&f(),s(i,{byteLength:o.data.length,duration:a-r}),r=a,u()}else u()}}),m=new o.Readable({objectMode:!0,read:function(){}});m.on("error",(()=>{console.warn("outgoing stream broke somewhere")})),super(p,m),M(this,"onCanplay",void 0),M(this,"onSync",void 0),M(this,"_clock",void 0),M(this,"_scheduler",void 0),M(this,"_info",void 0),this._clock=c,this._scheduler=l,this._info=i,this.onCanplay=void 0,this.onSync=void 0}get currentTime(){return this._clock.currentTime}pause(){this._scheduler.suspend(),this._clock.pause()}play(){this._clock.play(),this._scheduler.resume()}get bitrate(){return this._info.bitrate}get framerate(){return this._info.framerate}}var N=r(7997),F=r.n(N),q=r(7866).Buffer;let H;!function(e){e[e.UNSPECIFIED=0]="UNSPECIFIED",e[e.NON_IDR_PICTURE=1]="NON_IDR_PICTURE",e[e.IDR_PICTURE=5]="IDR_PICTURE",e[e.SPS=7]="SPS",e[e.PPS=8]="PPS"}(H||(H={}));const $=F()("msl:h264depay");class W{constructor(){var e,t;t=void 0,(e="_buffer")in this?Object.defineProperty(this,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):this[e]=t,this._buffer=q.alloc(0)}parse(e){const t=C(e.data),r=31&t[0];if(28===r){const r=t[0],n=t[1],i=31&n,o=224&r|i,s=64&n;if(n>>7)return this._buffer=q.concat([q.from([0,0,0,0,o]),t.slice(2)]),null;if(s){const r=q.concat([this._buffer,t.slice(2)]);r.writeUInt32BE(r.length-4,0);const n={data:r,type:k.H264,timestamp:S(e.data),ntpTimestamp:e.ntpTimestamp,payloadType:w(e.data),nalType:i};return this._buffer=q.alloc(0),n}return this._buffer=q.concat([this._buffer,t.slice(2)]),null}if(r!==H.NON_IDR_PICTURE&&r!==H.IDR_PICTURE||0!==this._buffer.length)return $(`H264depayComponent can only extract types 1,5 and 28, got ${r}`),this._buffer=q.alloc(0),null;{const n=q.concat([q.from([0,0,0,0]),t]);n.writeUInt32BE(n.length-4,0);const i={data:n,type:k.H264,timestamp:S(e.data),ntpTimestamp:e.ntpTimestamp,payloadType:w(e.data),nalType:r};return this._buffer=q.alloc(0),i}}}var z=r(7866).Buffer;function G(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function V(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?G(Object(r),!0).forEach((function(t){Y(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):G(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function Y(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}class J extends h{constructor(){let e,t=!1,r=[];const n=new W;super(new o.Transform({objectMode:!0,transform:function(i,o,s){if(i.type===k.SDP){const t=i.sdp.media.find((e=>"video"===e.type&&void 0!==e.rtpmap&&"H264"===e.rtpmap.encodingName));void 0!==t&&void 0!==t.rtpmap&&(e=t.rtpmap.payloadType),s(void 0,i)}else if(i.type===k.RTP&&w(i.data)===e){const e=v(i.data),o=n.parse(i);if(null===o||!t&&o.nalType!==H.IDR_PICTURE)return void s();t=!0,r.push(o.data),e&&(this.push(V(V({},o),{},{data:1===r.length?r[0]:z.concat(r)})),r=[]),s()}else s(void 0,i)}}))}}var K=r(7866).Buffer;function X(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function Z(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}const Q=F()("msl:http-source");class ee extends l{constructor(e){const{uri:t,options:r}=e,n=new o.Readable({objectMode:!0,read:function(){}});n.on("error",(e=>{console.warn("closing socket due to incoming error",e),this._reader&&this._reader.cancel()})),super(n),Z(this,"uri",void 0),Z(this,"options",void 0),Z(this,"length",void 0),Z(this,"onHeaders",void 0),Z(this,"onServerClose",void 0),Z(this,"_reader",void 0),Z(this,"_abortController",void 0),Z(this,"_allDone",void 0),n._read=()=>{this._pull()},this.uri=t,this.options=r,this._allDone=!1}play(){if(void 0===this.uri)throw new Error("cannot start playing when there is no URI");this._abortController=new AbortController,this.length=0,fetch(this.uri,function(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?X(Object(r),!0).forEach((function(t){Z(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):X(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}({credentials:"include",signal:this._abortController.signal},this.options)).then((e=>{if(null===e.body)throw new Error("empty response body");this.onHeaders&&this.onHeaders(e.headers),this._reader=e.body.getReader(),this._pull()})).catch((e=>{console.error("http-source: fetch failed: ",e)}))}abort(){this._reader&&this._reader.cancel().catch((e=>{console.log("http-source: cancel reader failed: ",e)})),this._abortController&&this._abortController.abort()}_isClosed(){return this._allDone}_close(){var e;this._reader=void 0,this._allDone=!0,this.incoming.push(null),null===(e=this.onServerClose)||void 0===e||e.call(this)}_pull(){void 0!==this._reader&&this._reader.read().then((({done:e,value:t})=>{if(e)return void(this._isClosed()||(Q("fetch completed, total downloaded: ",this.length," bytes"),this._close()));if(void 0===t)throw new Error("expected value to be defined");if(void 0===this.length)throw new Error("expected length to be defined");this.length+=t.length;const r=K.from(t);this.incoming.push({data:r,type:k.RAW})?this._pull():Q("downstream back pressure: pausing read")})).catch((e=>{Q("http-source: read failed: ",e),this._isClosed()||this._close()}))}}const te=(e,t)=>{let r=Date.now();const n=t=>{const n=Date.now();console.log(`${e}: +${n-r}ms`,t),r=n};return void 0===t?n:e=>e.type===t&&n(e)};class re extends h{constructor(e){const t=te("incoming",e),r=new o.Transform({objectMode:!0,transform:function(e,r,n){t(e),n(void 0,e)}}),n=te("outgoing",e);super(r,new o.Transform({objectMode:!0,transform:function(e,t,r){n(e),r(void 0,e)}}))}}var ne=r(7866).Buffer;const ie=[0,1,5,1,1,1,1,1,1,0,0,0,0,0,0,0],oe=[0,1,2,3,4,5,6,7,8,9,10,11],se=[0,2,1,3,3,2,4,3,5,5,4,4,0,0,1,125],ae=[1,2,3,0,4,17,5,18,33,49,65,6,19,81,97,7,34,113,20,50,129,145,161,8,35,66,177,193,21,82,209,240,36,51,98,114,130,9,10,22,23,24,25,26,37,38,39,40,41,42,52,53,54,55,56,57,58,67,68,69,70,71,72,73,74,83,84,85,86,87,88,89,90,99,100,101,102,103,104,105,106,115,116,117,118,119,120,121,122,131,132,133,134,135,136,137,138,146,147,148,149,150,151,152,153,154,162,163,164,165,166,167,168,169,170,178,179,180,181,182,183,184,185,186,194,195,196,197,198,199,200,201,202,210,211,212,213,214,215,216,217,218,225,226,227,228,229,230,231,232,233,234,241,242,243,244,245,246,247,248,249,250],ue=[0,3,1,1,1,1,1,1,1,1,1,0,0,0,0,0],ce=[0,1,2,3,4,5,6,7,8,9,10,11],le=[0,2,1,2,4,4,3,4,7,5,4,4,0,1,2,119],he=[0,1,2,3,17,4,5,33,49,6,18,65,81,7,97,113,19,34,50,129,8,20,66,145,161,177,193,9,35,51,82,240,21,98,114,209,10,22,36,52,225,37,241,23,24,25,26,38,39,40,41,42,53,54,55,56,57,58,67,68,69,70,71,72,73,74,83,84,85,86,87,88,89,90,99,100,101,102,103,104,105,106,115,116,117,118,119,120,121,122,130,131,132,133,134,135,136,137,138,146,147,148,149,150,151,152,153,154,162,163,164,165,166,167,168,169,170,178,179,180,181,182,183,184,185,186,194,195,196,197,198,199,200,201,202,210,211,212,213,214,215,216,217,218,226,227,228,229,230,231,232,233,234,242,243,244,245,246,247,248,249,250];function fe(e,t,r){return e>r?r:e<t?t:e}var de=r(7866).Buffer;const pe=[16,11,12,14,12,10,16,14,13,14,18,17,16,19,24,40,26,24,22,22,24,49,35,37,29,40,58,51,61,60,57,51,56,55,64,72,92,78,64,68,87,69,55,56,80,109,81,87,95,98,103,104,103,62,77,113,121,112,100,120,92,101,103,99],me=[17,18,18,24,21,24,47,26,26,47,99,66,56,66,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99];function ge(e){const t=fe(e,1,99),r=de.alloc(128),n=e<50?Math.floor(5e3/t):200-2*t;for(let e=0;e<64;e++){const t=Math.floor((pe[e]*n+50)/100),i=Math.floor((me[e]*n+50)/100);r.writeUInt8(fe(t,1,255),e),r.writeUInt8(fe(i,1,255),e+64)}return r}var ye=r(7866).Buffer;function be(e=0,t=0){const r=ne.from([255,216]),n=function(){const e=[[255,196,0,3+ie.length+oe.length,0],ie,oe],t=[[255,196,0,3+se.length+ae.length,16],se,ae],r=[[255,196,0,3+ue.length+ce.length,1],ue,ce],n=[[255,196,0,3+le.length+he.length,17],le,he];return ne.concat([...e.map(ne.from),...t.map(ne.from),...r.map(ne.from),...n.map(ne.from)])}(),i=ne.from([255,218,0,12,3,0,0,1,17,2,17,0,63,0]);return function(o){let s;const a=[];for(const r of o){let n=C(r);const i=n.readUInt8(0),o=n.readUInt8(1)<<16|n.readUInt8(2)<<8|n.readUInt8(3),u=n.readUInt8(4),c=n.readUInt8(5),l=8*n.readUInt8(6)||e,h=8*n.readUInt8(7)||t;n=n.slice(8);let f=0;if(u>=64&&u<=127&&(f=n.readUInt16BE(0),n=n.slice(4)),c>=128&&0===o){const e=n.readUInt8(1),t=n.readUInt16BE(2);s={typeSpecific:i,type:u,width:l,height:h,DRI:f,precision:e,qTable:n.slice(4,4+t)},n=n.slice(4+t)}else c<128&&0===o&&(s={typeSpecific:i,type:u,width:l,height:h,DRI:f,precision:0,qTable:ge(c)});a.push(n)}if(void 0===s)throw new Error("no quantization header present");const{precision:u,qTable:c,type:l,width:h,height:f}=s,d=function(e,t){const r=1&e?128:64,n=2&e?128:64;if(t.length!==r+n)throw new Error("invalid quantization table");const i=ne.from([255,219,0,r+3,0]),o=ne.from([255,219,0,n+3,1]);return ne.concat([i,t.slice(0,r),o,t.slice(r)])}(u,c),p=0===s.DRI?ye.alloc(0):(m=s.DRI,ne.from([255,221,0,4,m>>8,255&m]));var m;const g=function(e,t,r){return ne.from([255,192,0,17,8,t>>8,t,e>>8,e,3,0,0===r?33:34,0,1,17,1,2,17,1])}(h,f,l);return{size:{width:h,height:f},data:ye.concat([r,d,p,g,n,i,...a])}}}class ve extends h{constructor(){let e,t,r=[];super(new o.Transform({objectMode:!0,transform:function(n,i,o){if(n.type===k.SDP){const r=n.sdp.media.find((e=>"video"===e.type&&void 0!==e.rtpmap&&"JPEG"===e.rtpmap.encodingName));if(void 0!==r&&void 0!==r.rtpmap){e=Number(r.rtpmap.payloadType);const n=r.framesize;if(void 0!==n){const[e,r]=n;t=be(e,r)}else t=be()}o(void 0,n)}else if(n.type===k.RTP&&w(n.data)===e){if(r.push(n.data),v(n.data)&&r.length>0){const e=t(r);this.push({timestamp:S(n.data),ntpTimestamp:n.ntpTimestamp,payloadType:w(n.data),data:e.data,framesize:e.size,type:k.JPEG}),r=[]}o()}else o(void 0,n)}}))}}var we=r(7866).Buffer;function _e(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}class Se extends h{constructor(e=225e6){const t=new o.Transform({objectMode:!0,transform:(e,t,r)=>{this._active&&e.type===k.ISOM&&void 0!==e.tracks&&(this._capture=!0),this._capture&&e.type===k.ISOM&&(this._bufferOffset<this._buffer.byteLength-e.data.byteLength?(e.data.copy(this._buffer,this._bufferOffset),this._bufferOffset+=e.data.byteLength):this.stop()),r(void 0,e)}});t.on("finish",(()=>{this.stop()})),super(t),_e(this,"_active",void 0),_e(this,"_capture",void 0),_e(this,"_captureCallback",void 0),_e(this,"_bufferOffset",void 0),_e(this,"_bufferSize",void 0),_e(this,"_buffer",void 0),this._buffer=we.allocUnsafe(0),this._bufferSize=e,this._bufferOffset=0,this._active=!1,this._capture=!1,this._captureCallback=()=>{}}start(e){this._active||(F()("msl:capture:start")(e),this._captureCallback=e,this._buffer=we.allocUnsafe(this._bufferSize),this._bufferOffset=0,this._active=!0)}stop(){if(this._active){F()("msl:capture:stop")(`captured bytes: ${this._bufferOffset}`);try{this._captureCallback(this._buffer.slice(0,this._bufferOffset))}catch(e){console.error(e)}this._buffer=we.allocUnsafe(0),this._bufferOffset=0,this._active=!1,this._capture=!1}}}var Ee=r(7866).Buffer;function xe(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}const Re=Math.pow(2,32);class Te{constructor(e){xe(this,"byteLength",void 0),xe(this,"value",void 0),this.byteLength=e}}class Ce extends Te{constructor(e=0){super(e),xe(this,"copy",((e,t)=>{e.fill(0,t,t+this.byteLength)}))}load(){}}class ke extends Te{constructor(e){super(e.length),xe(this,"value",void 0),xe(this,"copy",((e,t)=>{for(let r=0;r<this.byteLength;r+=1)e[t+r]=this.value.charCodeAt(r)})),xe(this,"load",((e,t)=>{this.value=e.slice(t,t+this.byteLength).toString("ascii")})),this.value=e}}class Oe extends Te{constructor(e=0){super(1),xe(this,"value",void 0),xe(this,"copy",((e,t)=>{e.writeUInt8(this.value,t)})),xe(this,"load",((e,t)=>{this.value=e.readUInt8(t)})),this.value=e}}class Pe extends Te{constructor(e){super(e.length),xe(this,"value",void 0),xe(this,"copy",((e,t)=>{for(let r=0;r<this.value.length;++r)e.writeUInt8(this.value[r],t+r)})),xe(this,"load",((e,t)=>{for(let r=0;r<this.value.length;++r)this.value[r]=e.readUInt8(t+r)})),this.value=e}}class Ie extends Te{constructor(e=0){super(2),xe(this,"value",void 0),xe(this,"copy",((e,t)=>{e.writeUInt16BE(this.value,t)})),xe(this,"load",((e,t)=>{this.value=e.readUInt16BE(t)})),this.value=e}}class Le extends Te{constructor(e=0){super(3),xe(this,"value",void 0),xe(this,"copy",((e,t)=>{e.writeUInt8(this.value>>16&255,t),e.writeUInt8(this.value>>8&255,t+1),e.writeUInt8(255&this.value,t+2)})),xe(this,"load",((e,t)=>{this.value=e.readUInt8(t)<<16+e.readUInt8(t+1)<<8+e.readUInt8(t+2)})),this.value=e}}class Be extends Te{constructor(e=0){super(4),xe(this,"value",void 0),xe(this,"copy",((e,t)=>{e.writeUInt32BE(this.value,t)})),xe(this,"load",((e,t)=>{this.value=e.readUInt32BE(t)})),this.value=e}}class Ae extends Te{constructor(e){super(4*e.length),xe(this,"value",void 0),xe(this,"copy",((e,t)=>{for(let r=0;r<this.value.length;++r)e.writeUInt32BE(this.value[r],t+4*r)})),xe(this,"load",((e,t)=>{for(let r=0;r<this.value.length;++r)this.value[r]=e.readUInt32BE(t+4*r)})),this.value=e}}const Ue=function(e=0){return class extends Te{constructor(t){super(0),xe(this,"value",void 0),xe(this,"copy",((e,t)=>{let r=0;for(const n of this.value)n.copy(e,t+r),r+=n.byteLength})),xe(this,"load",(()=>{})),this.value=t.reduce(((e,t)=>e.concat(new Ie(t.length),new Pe(t))),[new Oe(e|t.length)]),this.byteLength=this.value.reduce(((e,t)=>e+t.byteLength),0)}}},je={ftyp:{container:"file",mandatory:!0,quantity:"one",box:"Box",is_container:!0,body:[["major_brand",ke,"isom"],["minor_version",Be,0],["compatible_brands",ke,"mp41"]]},moov:{container:"file",mandatory:!0,quantity:"one",box:"Box",is_container:!0},mdat:{container:"file",mandatory:!1,quantity:"any",box:"Box",is_container:!1,body:[]},mvhd:{container:"moov",mandatory:!0,quantity:"one",box:"FullBox",is_container:!1,body:[["creation_time",Be,0],["modification_time",Be,0],["timescale",Be,1e3],["duration",Be,4294967295],["rate",Be,65536],["volume",Ie,256],["reserved",Ce,10],["matrix",Ae,[65536,0,0,0,65536,0,0,0,1073741824]],["pre_defined",Ce,24],["next_track_ID",Be,4294967295]]},trak:{container:"moov",mandatory:!0,quantity:"one+",box:"Box",is_container:!0},tkhd:{container:"trak",mandatory:!0,quantity:"one",box:"FullBox",is_container:!1,config:{flags:3},body:[["creation_time",Be,0],["modification_time",Be,0],["track_ID",Be,1],["reserved",Ce,4],["duration",Be,0],["reserved2",Ce,8],["layer",Ie,0],["alternate_group",Ie,0],["volume",Ie,256],["reserved3",Ce,2],["matrix",Ae,[65536,0,0,0,65536,0,0,0,1073741824]],["width",Be,0],["height",Be,0]]},tref:{container:"trak",mandatory:!1,quantity:"one-",box:"Box",is_container:!1},mdia:{container:"trak",mandatory:!1,quantity:"one",box:"Box",is_container:!0},mdhd:{container:"mdia",mandatory:!1,quantity:"one",box:"FullBox",is_container:!1,body:[["creation_time",Be,0],["modification_time",Be,0],["timescale",Be,1e3],["duration",Be,4294967295],["language",Ie,0],["pre_defined",Ie,0]]},hdlr:{container:"mdia",mandatory:!0,quantity:"one",box:"FullBox",is_container:!1,body:[["predefined",Be,0],["handler_type",ke,"vide"],["reserved",Ce,12],["name",ke,"VideoHandler\0"]]},minf:{container:"mdia",mandatory:!0,quantity:"one",box:"Box",is_container:!0},vmhd:{container:"minf",mandatory:!0,quantity:"one",box:"FullBox",is_container:!1,config:{flags:1},body:[["graphicsmode",Ie,0],["opcolor",class extends Te{constructor(e){super(2*e.length),xe(this,"value",void 0),xe(this,"copy",((e,t)=>{for(let r=0;r<this.value.length;++r)e.writeUInt16BE(this.value[r],t+2*r)})),xe(this,"load",((e,t)=>{for(let r=0;r<this.value.length;++r)this.value[r]=e.readUInt16BE(t+2*r)})),this.value=e}},[0,0,0]]]},smhd:{container:"minf",mandatory:!0,quantity:"one",box:"FullBox",is_container:!1,body:[["balance",Ie,0],["reserved",Ie]]},dinf:{container:"minf",mandatory:!0,quantity:"one",box:"Box",is_container:!0},dref:{container:"dinf",mandatory:!0,quantity:"one",box:"FullBox",is_container:!0,body:[["entry_count",Be,0]]},"url ":{container:"dref",mandatory:!0,quantity:"one+",box:"FullBox",is_container:!1,config:{flags:1},body:[]},stbl:{container:"minf",mandatory:!0,quantity:"one",box:"Box",is_container:!0},stts:{container:"stbl",mandatory:!0,quantity:"one",box:"FullBox",is_container:!1,body:[["entry_count",Be,0]]},stsd:{container:"stbl",mandatory:!0,quantity:"one",box:"FullBox",is_container:!0,body:[["entry_count",Be,1]]},avc1:{container:"stsd",mandatory:!1,quantity:"one",box:"Box",is_container:!0,body:[["reserved",Ce,6],["data_reference_index",Ie,1],["pre_defined",Ie,0],["reserved2",Ce,2],["pre_defined2",Ae,[0,0,0]],["width",Ie,1920],["height",Ie,1080],["horizresolution",Be,4718592],["vertresolution",Be,4718592],["reserved3",Be,0],["frame_count",Ie,1],["compressorname",Pe,Ee.alloc(32)],["depth",Ie,24],["pre_defined3",Ie,65535]]},avcC:{container:"avc1",mandatory:!1,quantity:"one",box:"Box",is_container:!1,body:[["configurationVersion",Oe,1],["AVCProfileIndication",Oe,77],["profile_compatibility",Oe,0],["AVCLevelIndication",Oe,41],["lengthSizeMinusOne",Oe,255],["sequenceParameterSets",Ue(224),[]],["pictureParameterSets",Ue(),[]]]},mp4a:{container:"stsd",mandatory:!1,quantity:"one",box:"Box",is_container:!0,body:[["reserved",Ce,6],["data_reference_index",Ie,1],["reserved2",Ae,[0,0]],["channelcount",Ie,2],["samplesize",Ie,16],["pre_defined",Ie,0],["reserved3",Ie,0],["samplerate",Be,0]]},esds:{container:"mp4a",mandatory:!1,quantity:"one",box:"FullBox",is_container:!1,body:[["ES_DescrTag",Oe,3],["ES_DescrLength",Oe,25],["ES_ID",Ie,1],["flagsAndStreamPriority",Oe,0],["DecoderConfigDescrTag",Oe,4],["DecoderConfigDescrLength",Oe,17],["objectProfileIndication",Oe,64],["streamTypeUpstreamReserved",Oe,21],["bufferSizeDB",Pe,[0,0,0]],["maxBitRate",Be,0],["avgBitRate",Be,0],["DecSpecificInfoShortTag",Oe,5],["DecSpecificInfoShortLength",Oe,2],["audioConfigBytes",Ie,0],["SLConfigDescrTag",Oe,6],["SLConfigDescrLength",Oe,1],["SLConfigDescrPredefined",Oe,2]]},stsz:{container:"stbl",mandatory:!0,quantity:"one",box:"FullBox",is_container:!1,body:[["sample_size",Be,0],["sample_count",Be,0]]},stsc:{container:"stbl",mandatory:!0,quantity:"one",box:"FullBox",is_container:!1,body:[["entry_count",Be,0]]},stco:{container:"stbl",mandatory:!0,quantity:"one",box:"FullBox",is_container:!1,body:[["entry_count",Be,0]]},stss:{container:"stbl",mandatory:!1,quantity:"one-",box:"FullBox",is_container:!1,body:[["entry_count",Be,0]]},edts:{container:"trak",mandatory:!1,quantity:"one-",box:"Box",is_container:!0},elst:{container:"edts",mandatory:!1,quantity:"one-",box:"FullBox",is_container:!1,body:[["entry_count",Be,1],["segment_duration",Be,0],["media_time",Be,4294967295],["media_rate_integer",Ie,1],["media_rate_fraction",Ie,0]]},mvex:{container:"moov",mandatory:!1,quantity:"one-",box:"Box",is_container:!0},mehd:{container:"mvex",mandatory:!1,quantity:"one-",box:"FullBox",is_container:!1,body:[["fragment_duration",Be,0]]},trex:{container:"mvex",mandatory:!0,quantity:"one+",box:"FullBox",is_container:!1,body:[["track_ID",Be,1],["default_sample_description_index",Be,1],["default_sample_duration",Be,0],["default_sample_size",Be,0],["default_sample_flags",Be,0]]},moof:{container:"file",mandatory:!1,quantity:"zero+",box:"Box",is_container:!1},mfhd:{container:"moof",mandatory:!0,quantity:"one",box:"FullBox",is_container:!1,body:[["sequence_number",Be,0]]},traf:{container:"moof",mandatory:!1,quantity:"zero+",box:"Box",is_container:!0},tfhd:{container:"traf",mandatory:!0,quantity:"one",box:"FullBox",is_container:!1,config:{flags:32},body:[["track_ID",Be,1],["default_sample_flags",Be,0]]},tfdt:{container:"traf",mandatory:!1,quantity:"one-",box:"FullBox",is_container:!1,config:{version:1},body:[["baseMediaDecodeTime",class extends Te{constructor(e=0){super(8),xe(this,"value",void 0),xe(this,"copy",((e,t)=>{const r=this.value/Re|0,n=this.value-r*Re;e.writeUInt32BE(r,t),e.writeUInt32BE(n,t+4)})),xe(this,"load",((e,t)=>{const r=e.readUInt32BE(t),n=e.readUInt32BE(t+4);this.value=r*Re+n})),this.value=e}},0]]},trun:{container:"traf",mandatory:!1,quantity:"zero+",box:"FullBox",is_container:!1,config:{flags:773},body:[["sample_count",Be,1],["data_offset",Be,0],["first_sample_flags",Be,0],["sample_duration",Be,0],["sample_size",Be,0]]},"....":{box:"Box",is_container:!1,body:[]},file:{box:"None",is_container:!0,mandatory:!0,quantity:"one"}};class Me extends Te{constructor(e,t){super(0),xe(this,"type",void 0),xe(this,"config",void 0),xe(this,"struct",void 0),this.type=e;const r=je[this.type];if(void 0===r)throw new Error(`unknown box type: ${e}`);this.config=Object.assign({},r.config,t);const n=class{static None(){return[]}static Box(e){return[["size",Be,0],["type",ke,e]]}static FullBox(e){return[].concat(this.Box(e),[["version",Oe,0],["flags",Le,0]])}}[r.box](this.type),i=r.body||[];this.struct=new Map;let o=0;for(const[e,t,r]of[].concat(n,i)){if(this.has(e))throw new Error("Trying to add existing key");let n=r;this.config[e]&&(n=this.config[e]);const i=new t(n);this.struct.set(e,{offset:o,element:i}),o+=i.byteLength}this.byteLength=o}element(e){const t=this.struct.get(e);if(void 0===t)throw new Error("invalid key");return t.element}set(e,t){this.element(e).value=t}get(e){return this.element(e).value}offset(e){const t=this.struct.get(e);if(void 0===t)throw new Error("invalid key");return t.offset}has(e){return this.struct.has(e)}add(e,t){if(this.has(e))throw new Error("Trying to add existing key");return this.struct.set(e,{offset:this.byteLength,element:t}),this.byteLength+=t.byteLength,this}buffer(){const e=Ee.allocUnsafe(this.byteLength);return this.copy(e),e}copy(e,t=0){this.set("size",this.byteLength);for(const r of this.struct.values())r.element.copy(e,t+r.offset)}load(e,t=0){for(const r of this.struct.values())void 0!==r.element.load&&r.element.load(e,t+r.offset)}format(e=0){const t=[" ".repeat(e)+`[${this.type}] (${this.byteLength})`];for(const[r,n]of this.struct){const i=n.element;void 0!==i.format?t.push(i.format(e+2)):t.push(" ".repeat(e+2)+`${r} = ${i.value} (${i.byteLength})`)}return t.join("\n")}print(e){console.warn(this.format(e))}}class De extends Me{constructor(e,t,...r){super(e,t),xe(this,"boxSize",void 0),this.boxSize=0,this.append(...r)}append(...e){for(const t of e)this.add("box_"+this.boxSize++,t);return this}parse(e){const t=[];for(;e.byteLength>0;){const r=new ke("....");r.load(e,4);const n=r.value,i=je[n];let o;if(void 0!==i){if(i.is_container){o=new De(n),o.load(e);const r=o.parse(e.slice(o.byteLength,o.get("size")));t.push(...r)}else if(o=new Me(n),o.load(e),"avcC"===n){const e=o.element("AVCProfileIndication").value.toString(16).padStart(2,0),r=o.element("profile_compatibility").value.toString(16).padStart(2,0),n=o.element("AVCLevelIndication").value.toString(16).padStart(2,0);t.push({type:"video",mime:`avc1.${e}${r}${n}`})}else if("esds"===n){const e=o.element("audioConfigBytes").value>>>11&31;t.push({type:"audio",mime:`mp4a.40.${e}`})}}else o=new Me("...."),o.load(e),o.type=o.get("type");this.append(o),e=e.slice(o.get("size"))}return t}}const Ne={1:"AAC Main",2:"AAC LC"},Fe={0:"96 kHz",1:"88.2 kHz",2:"64 kHz",3:"48 kHz",4:"44.1 kHz",5:"32 kHz",6:"24 kHz",7:"22.05 kHz",8:"16 kHz",9:"12 kHz",10:"11.025 kHz",11:"8 kHz",12:"7.35 kHz"},qe={1:"Mono",2:"Stereo"},He=e=>{const t=e>>>11&31,r=e>>>3&15;return{coding:Ne[t]||`AAC (${t})`,samplingRate:Fe[e>>>7&15]||"unknown",channels:qe[r]||r.toString()}};function $e(e,t){const r=e.replace(/[^A-Za-z0-9+/]/g,""),n=r.length,i=t?Math.ceil((3*n+1>>2)/t)*t:3*n+1>>2,o=new Uint8Array(i);let s,a,u=0,c=0;for(let e=0;e<n;e++)if(a=3&e,u|=((l=r.charCodeAt(e))>64&&l<91?l-65:l>96&&l<123?l-71:l>47&&l<58?l+4:43===l?62:47===l?63:0)<<18-6*a,3===a||n-e==1){for(s=0;s<3&&c<i;s++,c++)o[c]=u>>>(16>>>s&24)&255;u=0}var l;return o}function We(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}class ze{constructor(e){We(this,"_buffer",void 0),We(this,"_dataView",void 0),We(this,"_offset",void 0),We(this,"_bitpos",void 0),We(this,"_byte",void 0),this._buffer=e,this._dataView=new DataView(this._buffer),this._offset=0,this._bitpos=0,this._byte=0}readUint8(e){return this._dataView.getUint8(e)}readUint16(e){return this._dataView.getUint16(e)}readUint32(e){return this._dataView.getUint32(e)}readNext(){const e=this.readUint8(this._offset);return this._offset+=1,e}readBits(e){if(e>32||0===e)throw new Error("length has to be between 0 - 31 bits");let t=0;for(let r=1;r<=e;++r)0===this._bitpos&&(this._byte=this.readNext()),t=t<<1|this._byte>>8-++this._bitpos&1,this._bitpos%=8;return t}readUnsignedExpGolomb(){let e=0;for(;1!==this.readBits(1);)e++;if(0===e)return 0;if(e>=31)throw new Error("read unsigned exponential Golomb: internal error");let t=this.readBits(e);return t|=1<<e,t-1}readSignedExpGolomb(){let e=this.readUnsignedExpGolomb();return e=1&e?e+1>>1:-(e>>1),e}size(){return this._buffer.byteLength}getUint8Array(){return new Uint8Array(this._buffer)}getArrayBuffer(){return this._buffer}}class Ge{constructor(e){var t,r;r=void 0,(t="reader")in this?Object.defineProperty(this,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):this[t]=r,this.reader=new ze(e)}parse(){this.reader.readNext();const e=this.reader.readNext();this.reader.readNext();const t=this.reader.readNext();if(this.reader.readUnsignedExpGolomb(),[100,110,122,244,44,83,86,118].includes(e)){const e=this.reader.readUnsignedExpGolomb();if(3===e&&this.reader.readBits(1),this.reader.readUnsignedExpGolomb(),this.reader.readUnsignedExpGolomb(),this.reader.readBits(1),this.reader.readBits(1))for(let t=0;t<(3!==e?8:12);t++)this.reader.readBits(1)}this.reader.readUnsignedExpGolomb();const r=this.reader.readUnsignedExpGolomb();if(0===r)this.reader.readUnsignedExpGolomb();else if(1===r){let e=0;this.reader.readBits(1),this.reader.readSignedExpGolomb(),this.reader.readSignedExpGolomb(),e=this.reader.readUnsignedExpGolomb();for(let t=0;t<e;t++)this.reader.readSignedExpGolomb()}this.reader.readUnsignedExpGolomb(),this.reader.readBits(1);const n=this.reader.readUnsignedExpGolomb(),i=this.reader.readUnsignedExpGolomb(),o=this.reader.readBits(1);this.reader.readBits(1);const s=this.reader.readBits(1);return{profile:e,level:t/10,width:16*(n+1)-2*(s?this.reader.readUnsignedExpGolomb():0)-2*(s?this.reader.readUnsignedExpGolomb():0),height:(2-o)*(i+1)*16-2*(s?this.reader.readUnsignedExpGolomb():0)-2*(s?this.reader.readUnsignedExpGolomb():0)}}}const Ve={66:"Baseline",77:"Main",100:"High"},Ye=e=>{const t=parseInt(e.substr(0,2),16),r=parseInt(e.substr(4,2),16);return{coding:"H.264",profile:Ve[t]||t.toString(),level:(r/10).toFixed(1)}};function Je(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}const Ke={"MPEG4-GENERIC":(e,t,r)=>{const n=Number(e.fmtp.parameters.bitrate)||32e4,i=parseInt(e.fmtp.parameters.config,16),o=i>>>11&31;return{tkhd:{track_ID:r,creation_time:t,modification_time:t,width:0,height:0,volume:1},mdhd:{timescale:Number(e.rtpmap.clockrate),creation_time:t,modification_time:t,duration:0},hdlr:{handler_type:"soun",name:"SoundHandler\0"},mediaHeaderBox:new Me("smhd"),sampleEntryBox:new De("mp4a",{samplerate:e.rtpmap.clockrate<<16>>>0},new Me("esds",{audioConfigBytes:i,maxBitRate:n,avgBitRate:n})),defaultFrameDuration:1024,mime:`mp4a.40.${o}`,codec:He(i)}},H264:(e,t,r)=>{const n=e.fmtp.parameters["profile-level-id"],i=e.fmtp.parameters["sprop-parameter-sets"].split(",").map($e),o=i.slice(0,1),s=i.slice(1),a=new Ge(o[0].buffer).parse();return{mediaHeaderBox:new Me("vmhd"),sampleEntryBox:new De("avc1",{width:a.width,height:a.height},new Me("avcC",{AVCProfileIndication:o[0][1],profile_compatibility:o[0][2],AVCLevelIndication:o[0][3],sequenceParameterSets:o,pictureParameterSets:s})),tkhd:{track_ID:r,creation_time:t,modification_time:t,width:a.width<<16,height:a.height<<16,volume:0},hdlr:{},mdhd:{timescale:e.rtpmap.clockrate,creation_time:t,modification_time:t,duration:0},defaultFrameDuration:void 0!==e.framerate&&e.framerate>0&&Number(e.rtpmap.clockrate)/Number(e.framerate)||3600,mime:`avc1.${n}`,codec:Ye(n)}}};class Xe{constructor(){Je(this,"trackIdMap",void 0),Je(this,"sequenceNumber",void 0),Je(this,"ntpPresentationTime",void 0),Je(this,"trackData",void 0),Je(this,"videoTrackId",void 0),this.trackIdMap={},this.sequenceNumber=0,this.ntpPresentationTime=0,this.trackData=[]}trak(e){const t=new De("trak"),r=new De("mdia"),n=new De("minf"),i=new De("dinf"),o=new De("dref"),s=new De("stbl");return o.set("entry_count",1),t.append(new Me("tkhd",e.tkhd),r.append(new Me("mdhd",e.mdhd),new Me("hdlr",e.hdlr),n.append(e.mediaHeaderBox,i.append(o.append(new Me("url "))),s.append(new De("stsd",void 0,e.sampleEntryBox),new Me("stts"),new Me("stsc"),new Me("stco"),new Me("stsz"),new Me("stss"))))),t}moov(e,t){const r=new De("moov");r.append(new Me("mvhd",{creation_time:t,modification_time:t,duration:0}));const n=new De("mvex");this.trackIdMap={},this.sequenceNumber=0,this.ntpPresentationTime=0;let i=0;return this.trackData=[],e.media.forEach((e=>{if(void 0===e.rtpmap)return;const o=e.rtpmap.payloadType,s=e.rtpmap.encodingName;if(void 0!==Ke[s]){this.trackIdMap[o]=++i,"video"===e.type.toLowerCase()&&(this.videoTrackId=i);const a=Ke[s](e,t,i);e.mime=a.mime,e.codec=a.codec;const u={lastTimestamp:0,baseMediaDecodeTime:0,defaultFrameDuration:0,clockrate:0,bitrate:0,framerate:0,cumulativeByteLength:0,cumulativeDuration:0,cumulativeFrames:0};u.clockrate=e.rtpmap.clockrate,u.defaultFrameDuration=a.defaultFrameDuration,this.trackData.push(u);const c=this.trak(a);r.append(c),n.append(new Me("trex",{track_ID:i}))}})),r.append(n),r}moof(e){const{trackId:t,timestamp:r,byteLength:n}=e,i=t-1,o=this.trackData[i],s=0!==o.lastTimestamp?r-o.lastTimestamp|0:o.defaultFrameDuration;o.lastTimestamp=r;const a=new De("moof"),u=new De("traf"),c=new Me("trun",{sample_duration:s,sample_size:n,first_sample_flags:64});return a.append(new Me("mfhd",{sequence_number:this.sequenceNumber++}),u.append(new Me("tfhd",{track_ID:t}),new Me("tfdt",{baseMediaDecodeTime:o.baseMediaDecodeTime}),c)),o.baseMediaDecodeTime+=s,c.set("data_offset",a.byteLength+8),((e,{byteLength:t,duration:r})=>{if(e.cumulativeByteLength+=t,e.cumulativeDuration+=r,e.cumulativeFrames++,e.cumulativeDuration>=e.clockrate){const t=8*e.cumulativeByteLength,r=e.cumulativeFrames,n=e.cumulativeDuration/e.clockrate;e.bitrate=t/n,e.framerate=r/n,e.cumulativeByteLength=0,e.cumulativeDuration=0,e.cumulativeFrames=0}})(o,{byteLength:n,duration:s}),a}mdat(e){const t=new Me("mdat");return t.add("data",e),t}setPresentationTime(e,t){if(!this.ntpPresentationTime&&t&&e===this.videoTrackId){const r=e-1,n=this.trackData[r];this.ntpPresentationTime=t-n.baseMediaDecodeTime/n.clockrate*1e3}}}var Ze=r(7866).Buffer;function Qe(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}class et extends h{constructor(){const e=new Xe,t=e=>{this.onSync&&this.onSync(e)};super(new o.Transform({objectMode:!0,transform:function(r,n,i){if(r.type===k.SDP){const t=Math.floor((new Date).getTime()/1e3+2082852e3),n=new Me("ftyp"),i=e.moov(r.sdp,t),o=Ze.allocUnsafe(n.byteLength+i.byteLength);n.copy(o,0),i.copy(o,n.byteLength),F()("msl:mp4:isom")(`ftyp: ${n.format()}`),F()("msl:mp4:isom")(`moov: ${i.format()}`);const s=r.sdp.media.map((e=>({type:e.type,encoding:e.rtpmap&&e.rtpmap.encodingName,mime:e.mime,codec:e.codec})));this.push({type:k.ISOM,data:o,tracks:s,ftyp:n,moov:i})}else if(r.type===k.ELEMENTARY||r.type===k.H264){const{payloadType:n,timestamp:i,ntpTimestamp:o}=r,s=e.trackIdMap[n];if(s){let n;e.ntpPresentationTime||(e.setPresentationTime(s,o),e.ntpPresentationTime&&t(e.ntpPresentationTime));const a=r.type===k.H264?r.nalType===H.IDR_PICTURE:void 0;e.ntpPresentationTime&&a&&void 0!==r.ntpTimestamp&&(n=(r.ntpTimestamp-e.ntpPresentationTime)/1e3);const u=r.data.byteLength,c=e.moof({trackId:s,timestamp:i,byteLength:u}),l=e.mdat(r.data),h=Ze.allocUnsafe(c.byteLength+l.byteLength);c.copy(h,0),l.copy(h,c.byteLength),this.push({type:k.ISOM,data:h,moof:c,mdat:l,ntpTimestamp:o,checkpointTime:n})}}else this.push(r);i()}})),Qe(this,"boxBuilder",void 0),Qe(this,"onSync",void 0),this.boxBuilder=e}get bitrate(){return this.boxBuilder.trackData&&this.boxBuilder.trackData.map((e=>e.bitrate))}get framerate(){return this.boxBuilder.trackData&&this.boxBuilder.trackData.map((e=>e.framerate))}get ntpPresentationTime(){return this.boxBuilder.ntpPresentationTime}}function tt(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function rt(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?tt(Object(r),!0).forEach((function(t){nt(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):tt(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function nt(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}let it;!function(e){e[e.SR=200]="SR",e[e.RR=201]="RR",e[e.SDES=202]="SDES",e[e.BYE=203]="BYE",e[e.APP=204]="APP"}(it||(it={}));const ot=e=>{const t=(e=>({version:e[0]>>>6,padding:!!(e[0]&d[2]),count:31&e[0],packetType:e.readUInt8(1),length:e.readUInt16BE(2)}))(e);switch(t.packetType){case it.SR:return ct(e,t);case it.RR:return ht(e,t);case it.SDES:return pt(e,t);case it.BYE:return gt(e,t);case it.APP:return bt(e,t);default:return t}},st=(e,t)=>({type:k.RTCP,data:t,channel:e,rtcp:ot(t)}),at={packetType:200},ut=(e,t,r)=>{const n=[];for(let i=0;i<e;i++){const e=r+24*i;n.push({syncSource:t.readUInt32BE(e+0),fractionLost:t.readUInt8(e+4),cumulativeNumberOfPacketsLost:t.readUIntBE(e+5,3),extendedHighestSequenceNumberReceived:t.readUInt32BE(e+8),interarrivalJitter:t.readUInt32BE(e+12),lastSRTimestamp:t.readUInt32BE(e+16),delaySinceLastSR:t.readUInt32BE(e+20)})}return n},ct=(e,t)=>rt(rt({},t),{},{syncSource:e.readUInt32BE(4),ntpMost:e.readUInt32BE(8),ntpLeast:e.readUInt32BE(12),rtpTimestamp:e.readUInt32BE(16),sendersPacketCount:e.readUInt32BE(20),sendersOctetCount:e.readUInt32BE(24),reports:ut(t.count,e,28)}),lt=e=>e.packetType===it.SR,ht=(e,t)=>rt(rt({},t),{},{syncSource:e.readUInt32BE(4),reports:ut(t.count,e,8)}),ft=e=>e.packetType===it.RR;let dt;!function(e){e[e.CNAME=1]="CNAME",e[e.NAME=2]="NAME",e[e.EMAIL=3]="EMAIL",e[e.PHONE=4]="PHONE",e[e.LOC=5]="LOC",e[e.TOOL=6]="TOOL",e[e.NOTE=7]="NOTE",e[e.PRIV=8]="PRIV"}(dt||(dt={}));const pt=(e,t)=>{const r=[];let n=4;for(let i=0;i<t.count;i++){const t={source:e.readUInt32BE(n),items:[]};for(n+=4;;){const r=e.readUInt8(n++);if(0===r){n%4!=0&&(n+=4-n%4);break}const i=e.readUInt8(n++);if(r===dt.PRIV){const r=e.readUInt8(n),o=e.toString("utf8",n+1,n+1+r),s=e.toString("utf8",n+1+r,n+i);t.items.push([dt.PRIV,o,s])}else{const o=e.toString("utf8",n,n+i);t.items.push([r,o])}n+=i}r.push(t)}return rt(rt({},t),{},{syncSource:e.readUInt32BE(4),sourceDescriptions:r})},mt=e=>e.packetType===it.SDES,gt=(e,t)=>{const r=[];for(let n=0;n<t.count;n++)r.push(e.readUInt32BE(4+4*n));let n;if(t.length>t.count){const r=4+4*t.count,i=e.readUInt8(r);n=e.toString("utf-8",r+1,r+1+i)}return rt(rt({},t),{},{sources:r,reason:n})},yt=e=>e.packetType===it.BYE,bt=(e,t)=>rt(rt({},t),{},{subtype:t.count,source:e.readUInt32BE(4),name:e.toString("ascii",8,12),data:e.slice(12)}),vt=e=>e.packetType===it.APP;function wt(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}const _t=F()("msl:mse");class St extends f{constructor(e){if(void 0===e)throw new Error("video element argument missing");let t,r;const n=new o.Writable({objectMode:!0,write:(i,o,s)=>{if(i.type===k.ISOM)if(this._done=s,void 0!==i.tracks||void 0!==i.mime){const o=i.tracks??[],s=o.map((e=>e.mime)).filter((e=>e)),a=0!==s.length?s.join(", "):"avc1.640029, mp4a.40.2",u=i.mime??`video/mp4; codecs="${a}"`;if(!MediaSource.isTypeSupported(u))return void n.emit("error",`unsupported media type: ${u}`);this._lastCheckpointTime=0,t=new MediaSource,e.src=window.URL.createObjectURL(t);const c=()=>{if(void 0!==t){window.URL.revokeObjectURL(e.src),t.removeEventListener("sourceopen",c),this.onSourceOpen&&this.onSourceOpen(t,o),r=this.addSourceBuffer(e,t,u),r.onerror=e=>{console.error("error on SourceBuffer: ",e),n.emit("error")};try{r.appendBuffer(i.data)}catch(e){_t("failed to append to SourceBuffer: ",e,i)}}else n.emit("error","no MediaSource instance")};t.addEventListener("sourceopen",c)}else{this._lastCheckpointTime=void 0!==i.checkpointTime?i.checkpointTime:this._lastCheckpointTime;try{var a;null===(a=r)||void 0===a||a.appendBuffer(i.data)}catch(e){_t("failed to append to SourceBuffer: ",e,i)}}else if(i.type===k.RTCP){var u;yt(i.rtcp)&&"open"===(null===(u=t)||void 0===u?void 0:u.readyState)&&t.endOfStream(),s()}else s()}});n.on("finish",(()=>{console.warn("incoming stream finished: end stream"),t&&"open"===t.readyState&&t.endOfStream()})),n.on("error",(e=>{var n;console.error("error on incoming stream: ",e),r&&r.updating?r.addEventListener("updateend",(()=>{var e;"open"===(null===(e=t)||void 0===e?void 0:e.readyState)&&t.endOfStream()})):"open"===(null===(n=t)||void 0===n?void 0:n.readyState)&&t.endOfStream()}));const i=new o.Readable({objectMode:!0,read:function(){}});i.on("error",(()=>{console.warn("outgoing stream broke somewhere")})),super(n,i),wt(this,"_videoEl",void 0),wt(this,"_done",void 0),wt(this,"_lastCheckpointTime",void 0),wt(this,"onSourceOpen",void 0),this._videoEl=e,this._lastCheckpointTime=0}addSourceBuffer(e,t,r){const n=t.addSourceBuffer(r);let i=0;return n.addEventListener("updateend",(()=>{if(++i,i>100&&n.buffered.length){i=0;const t=n.buffered.length-1,r=n.buffered.start(t),o=Math.min(e.currentTime,this._lastCheckpointTime)-10;try{if(o>r)return void n.remove(r,o)}catch(e){console.warn(e)}}this._done&&this._done()})),n}get currentTime(){return this._videoEl.currentTime}async play(){return await this._videoEl.play()}pause(){return this._videoEl.pause()}}var Et=r(7866).Buffer;class xt extends h{constructor(){let e,t=[];super(new o.Transform({objectMode:!0,transform:function(r,n,i){if(r.type===k.SDP){let t;for(const e of r.sdp.media)"application"===e.type&&e.rtpmap&&"VND.ONVIF.METADATA"===e.rtpmap.encodingName&&(t=e);t&&t.rtpmap&&(e=Number(t.rtpmap.payloadType)),i(void 0,r)}else if(r.type===k.RTP&&w(r.data)===e){if(t.push(C(r.data)),v(r.data)&&t.length>0)return i(void 0,{timestamp:S(r.data),ntpTimestamp:r.ntpTimestamp,payloadType:w(r.data),data:Et.concat(t),type:k.XML}),void(t=[]);i()}else i(void 0,r)}}))}}var Rt=r(7866).Buffer;const Tt=e=>e.match(/^m=/),Ct=(e,t)=>{const r=t.indexOf(e);return r<0?[t.slice(0)]:[t.slice(0,r),t.slice(r+1)]},kt={fmtp:e=>{const[t,r]=Ct(" ",e);{const e=r.trim().split(";"),n={};return e.forEach((e=>{const[t,r]=Ct("=",e),i=t.trim().toLowerCase();""!==i&&(n[i]=r.trim())})),{format:t,parameters:n}}},framerate:Number,rtpmap:e=>{const[t,r]=Ct(" ",e),[n,i,o]=r.toUpperCase().split("/");return void 0===o?{payloadType:Number(t),encodingName:n,clockrate:Number(i)}:{payloadType:Number(t),encodingName:n,clockrate:Number(i),encodingParameters:o}},transform:e=>e.split(";").map((e=>e.split(",").map(Number))),"x-sensor-transform":e=>e.split(";").map((e=>e.split(",").map(Number))),framesize:e=>e.split(" ")[1].split("-").map(Number)},Ot=e=>{const t=e.slice(0,1),r=e.slice(2);switch(t){case"v":return{version:r};case"o":const[e,t,n,i,o,s]=r.split(" ");return{origin:{addrType:o,netType:i,sessionId:t,sessionVersion:n,unicastAddress:s,username:e}};case"s":return{sessionName:r};case"i":return{sessionInformation:r};case"u":return{uri:r};case"e":return{email:r};case"p":return{phone:r};case"c":const[a,u,c]=r.split(" ");return{connectionData:{addrType:u,connectionAddress:c,netType:a}};case"b":const[l,h]=r.split(":");return{bwtype:l,bandwidth:h};case"t":const[f,d]=r.split(" ").map(Number);return{time:{startTime:f,stopTime:d}};case"r":const[p,m,...g]=r.split(" ").map(Number);return{repeatTimes:{repeatInterval:p,activeDuration:m,offsets:g}};case"z":case"k":return;case"a":return(e=>{const[t,r]=Ct(":",e);return void 0===r?{[t]:!0}:void 0!==kt[t]?{[t]:kt[t](r)}:{[t]:r}})(r);case"m":const[y,b,v,w]=r.split(" ");return{type:y,port:Number(b),protocol:v,fmt:Number(w)}}},Pt=e=>{const t=e.indexOf("\nm=");return((e,t,r=0)=>{const n=`\n${"a=control:"}`;r=e.indexOf(n,r);let i=0;const o=[];for(;r>=0;)i=e.indexOf("\n",r+n.length),o.push(e.toString("ascii",r+n.length,i).trim()),r=e.indexOf(n,i);return o})(e,0,t)},It=e=>{const t=e.toString("ascii").split("\n").map((e=>e.trim())),r={session:{},media:[]};let n=0,i=r.session;for(const e of t)Tt(e)&&(r.media[n]={},i=r.media[n],++n),i=Object.assign(i,Ot(e));return r},Lt=e=>({type:k.SDP,data:e,sdp:It(e)}),Bt=(e,t)=>{const r=`\n${t.toLowerCase()}: `,n=e.toString().toLowerCase().indexOf(r);if(n>=0){const t=e.indexOf("\n",n+r.length);return e.toString("ascii",n+r.length,t).trim()}return null},At=e=>{const t=Bt(e,"CSeq");return null!==t?Number(t):null},Ut=e=>{const t=Bt(e,"Session");return t?t.split(";")[0]:null},jt=e=>{const t=Bt(e,"Session");if(null===t)return null;const r="timeout=",n=t.toLowerCase().indexOf(r);if(-1!==n){let e=t.substring(n+r.length);e=e.split(";")[0];const i=parseInt(e);return isNaN(i)?60:i}return 60},Mt=e=>Number(e.toString("ascii",9,12)),Dt=e=>Bt(e,"Content-Base"),Nt=e=>Bt(e,"Content-Location"),Ft=e=>{const t=Bt(e,"Connection");return null!==t&&"close"===t.toLowerCase()},qt=e=>{const t=Bt(e,"Range");if(null!==t)return t.split("=")[1].split("-")},Ht=e=>{const t=["\n\n","\r\r","\r\n\r\n"].map((t=>{const r=e.indexOf(t);return-1!==r?r+t.length:r})).filter((e=>-1!==e));return t.length>0?t.reduce(((e,t)=>Math.min(e,t))):-1};var $t,Wt=r(7866).Buffer;function zt(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}!function(e){e[e.IDLE=0]="IDLE",e[e.INTERLEAVED=1]="INTERLEAVED",e[e.RTSP=2]="RTSP"}($t||($t={}));class Gt{constructor(){zt(this,"_chunks",[]),zt(this,"_length",0),zt(this,"_state",$t.IDLE),zt(this,"_packet",void 0),this._init()}_init(){this._chunks=[],this._length=0,this._state=$t.IDLE}_push(e){this._chunks.push(e),this._length+=e.length}_parseRtsp(){const e=[],t=Wt.concat(this._chunks),r=Ht(t);if(-1===r)return e;const n=r,i=Bt(t,"Content-Length");if(i&&parseInt(i)>t.length-n)return e;if(this._init(),n===t.length||36===t[n]){const r=t.slice(0,n);e.push({type:k.RTSP,data:r});const i=t.slice(n);this._push(i)}else{const r=t,i=t.slice(n);e.push({type:k.RTSP,data:r}),e.push(Lt(i))}return e}_parseInterleaved(){const e=[];if(this._length<4)return e;if(this._packet||(this._packet=(e=>{const t=Wt.alloc(4);let r=0,n=0;for(;n<t.length;){const i=e[r++],o=Math.min(i.length,t.length-n);i.copy(t,n,0,o),n+=o}const i=t[1],o=t.length;return{channel:i,begin:o,end:o+t.readUInt16BE(2)}})(this._chunks)),this._length<this._packet.end)return e;const t=Wt.concat(this._chunks),r=t.slice(this._packet.begin,this._packet.end),n=t.slice(this._packet.end),i=this._packet.channel;if(delete this._packet,this._init(),this._push(n),i%2==0)e.push({type:k.RTP,data:r,channel:i});else{let t=r;do{const r=4*t.readUInt16BE(2)+4;e.push(st(i,t.slice(0,r))),t=t.slice(r)}while(t.length>0)}return e}_setState(){for(;this._chunks.length>0&&0===this._chunks[0].length;)this._chunks.shift();const e=this._chunks[0];if(0===this._chunks.length)this._state=$t.IDLE;else if(36===e[0])this._state=$t.INTERLEAVED;else{if("RTSP"!==e.toString("ascii",0,4))throw new Error(`Unknown chunk of length ${e.length}`);this._state=$t.RTSP}}parse(e){this._push(e),this._state===$t.IDLE&&this._setState();let t=[],r=!1;for(;!r;){let e=[];switch(this._state){case $t.IDLE:break;case $t.INTERLEAVED:e=this._parseInterleaved();break;case $t.RTSP:e=this._parseRtsp();break;default:throw new Error("internal error: unknown state")}e.length>0?t=t.concat(e):r=!0,this._setState()}return t}}class Vt extends h{constructor(){const e=new Gt,t=new o.Transform({objectMode:!0,transform:function(r,n,i){if(r.type===k.RAW)try{e.parse(r.data).forEach((e=>t.push(e))),i()}catch(e){i(e)}else i(void 0,r)}}),r=new o.Transform({objectMode:!0,transform:function(e,t,r){if(e.type===k.RTSP){const t=(e=>{if(!e.method||!e.uri)throw new Error("message needs to contain a method and a uri");const t=e.protocol||"RTSP/1.0",r=e.headers||{},n=[`${e.method} ${e.uri} ${t}`,Object.entries(r).map((([e,t])=>e+": "+t)).join("\r\n"),"\r\n"].join("\r\n");return F()("msl:rtsp:outgoing")(n),Rt.from(n)})(e);r(void 0,{type:k.RAW,data:t})}else r(void 0,e)}});super(t,r)}}const Yt=(e,t)=>{let r;if(void 0!==t){if("object"!=typeof t)throw new Error("merge expects override to be an object!");r=Object.keys(t).reduce(((e,r)=>(void 0!==t[r]&&(e[r]=t[r]),e)),{})}return Object.assign({},e,r)},Jt=Date.UTC(1900,0,1);function Kt(e,t){return Jt+1e3*(e+t/4294967296)}var Xt,Zt=r(7866).Buffer;function Qt(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}let er;!function(e){e.IDLE="idle",e.PLAYING="playing",e.PAUSED="paused"}(Xt||(Xt={})),function(e){e.OPTIONS="OPTIONS",e.DESCRIBE="DESCRIBE",e.SETUP="SETUP",e.PLAY="PLAY",e.PAUSE="PAUSE",e.TEARDOWN="TEARDOWN"}(er||(er={}));class tr extends Error{constructor(e,t){super(e),Qt(this,"code",void 0),this.name="RTSPResponseError",this.code=t}}class rr extends h{constructor(e={}){const{uri:t,headers:r,defaultHeaders:n}=Yt(((e=("undefined"==typeof window?"":window.location.hostname),t=[])=>({uri:t.length>0?`rtsp://${e}/axis-media/media.amp?${t.join("&")}`:`rtsp://${e}/axis-media/media.amp`}))(e.hostname,e.parameters),e),i=new o.Transform({objectMode:!0,transform:(e,t,r)=>{e.type===k.RTSP?(this._onRtsp(e),r()):e.type===k.RTCP?(this._onRtcp(e),this.onRtcp&&this.onRtcp(e.rtcp),r(void 0,e)):e.type===k.RTP?(this._onRtp(e),r(void 0,e)):e.type===k.SDP?(this._onSdp(e),this.onSdp&&this.onSdp(e.sdp),r(void 0,e)):r(void 0,e)}});i.on("end",(()=>{this._outgoingClosed=!0})),super(i),Qt(this,"uri",void 0),Qt(this,"headers",void 0),Qt(this,"defaultHeaders",void 0),Qt(this,"t0",void 0),Qt(this,"n0",void 0),Qt(this,"clockrates",void 0),Qt(this,"startTime",void 0),Qt(this,"onRtcp",void 0),Qt(this,"onSdp",void 0),Qt(this,"onError",void 0),Qt(this,"onPlay",void 0),Qt(this,"retry",void 0),Qt(this,"_outgoingClosed",void 0),Qt(this,"_sequence",void 0),Qt(this,"_callStack",void 0),Qt(this,"_callHistory",void 0),Qt(this,"_state",void 0),Qt(this,"_waiting",void 0),Qt(this,"_contentBase",void 0),Qt(this,"_contentLocation",void 0),Qt(this,"_sessionId",void 0),Qt(this,"_sessionControlURL",void 0),Qt(this,"_renewSessionInterval",void 0),this._outgoingClosed=!1,this._reset(),this.update(t,r,n),this._sessionControlURL=this._controlURL()}update(e,t={},r={}){if(void 0===e)throw new Error("You must supply an uri when creating a RtspSessionComponent");this.uri=e,this.defaultHeaders=r,this.headers=Object.assign({[er.OPTIONS]:{},[er.PLAY]:{},[er.SETUP]:{Blocksize:"64000"},[er.DESCRIBE]:{Accept:"application/sdp"},[er.PAUSE]:{}},t)}_reset(){this._sequence=1,this.retry=()=>console.error("No request sent, can't retry"),this._callStack=[],this._callHistory=[],this._state=Xt.IDLE,this._waiting=!1,this._contentBase=null,this._sessionId=null,null!==this._renewSessionInterval&&clearInterval(this._renewSessionInterval),this._renewSessionInterval=null,this.t0=void 0,this.n0=void 0,this.clockrates=void 0}_controlURL(e){if(void 0!==e&&/^[^:]+:\/\//.test(e))return e;const t=this._contentBase??this._contentLocation??this.uri;if(null==t)throw new Error("relative or missing control attribute but no base URL available");return void 0===e||"*"===e?t:new URL(e,t).href}_onRtsp(e){this._waiting=!1;const t=Mt(e.data),r=Ft(e.data),n=At(e.data);if(null===n)throw new Error("rtsp: expected sequence number");if(void 0===this._callHistory)throw new Error("rtsp: internal error");const i=this._callHistory[n-1];if(F()("msl:rtsp:incoming")(`${e.data}`),!this._sessionId&&!r){this._sessionId=Ut(e.data);const t=jt(e.data);null!==t&&(null!==this._renewSessionInterval&&clearInterval(this._renewSessionInterval),this._renewSessionInterval=setInterval((()=>{this._enqueue({method:er.OPTIONS}),this._dequeue()}),1e3*Math.max(5,t-5)))}this._contentBase||(this._contentBase=Dt(e.data)),this._contentLocation||(this._contentLocation=Nt(e.data)),t>=400&&this.onError&&this.onError(new tr(e.data.toString("ascii"),t)),i===er.PLAY&&this.onPlay&&this.onPlay(qt(e.data)),r&&(F()("msl:rtsp:incoming")(`RTSP Session ${this._sessionId} ended with statusCode: ${t}`),this._sessionId=null),this._dequeue()}_onRtcp(e){if(void 0===this.t0||void 0===this.n0)throw new Error("rtsp: internal error");if(lt(e.rtcp)){const t=e.channel-1;this.t0[t]=e.rtcp.rtpTimestamp,this.n0[t]=Kt(e.rtcp.ntpMost,e.rtcp.ntpLeast)}}_onRtp(e){if(void 0===this.t0||void 0===this.n0||void 0===this.clockrates)throw new Error("rtsp: internal error");const t=e.channel,r=this.t0[t],n=this.n0[t];if(void 0!==r&&void 0!==n){const i=this.clockrates[t],o=S(e.data)-r|0;e.ntpTimestamp=o/i*1e3+n}}_onSdp(e){this.n0={},this.t0={},this.clockrates={},this._sessionControlURL=this._controlURL(e.sdp.session.control),e.sdp.media.forEach(((e,t)=>{if(void 0===e.rtpmap)return;const{clockrate:r}=e.rtpmap,n=2*t,i=n+1,o=void 0===e.control?this._sessionControlURL:this._controlURL(e.control);this._enqueue({method:er.SETUP,headers:{Transport:"RTP/AVP/TCP;unicast;interleaved="+n+"-"+i},uri:o}),void 0!==this.clockrates&&(this.clockrates[n]=r)})),this._state===Xt.PLAYING&&this._enqueue({method:er.PLAY,headers:{Range:`npt=${this.startTime||0}-`},uri:this._sessionControlURL}),this._dequeue()}play(e=0){if(this._state===Xt.IDLE)this.startTime=Number(e)||0,this._enqueue({method:er.OPTIONS}),this._enqueue({method:er.DESCRIBE});else if(this._state===Xt.PAUSED){if(null===this._sessionId||void 0===this._sessionId)throw new Error("rtsp: internal error");this._enqueue({method:er.PLAY,headers:{Session:this._sessionId},uri:this._sessionControlURL})}this._state=Xt.PLAYING,this._dequeue()}pause(){this._enqueue({method:er.PAUSE}),this._state=Xt.PAUSED,this._dequeue()}stop(){this._sessionId?this._enqueue({method:er.TEARDOWN}):this._callStack=[],this._state=Xt.IDLE,null!==this._renewSessionInterval&&(clearInterval(this._renewSessionInterval),this._renewSessionInterval=null),this._dequeue()}send(e){const{method:t,headers:r,uri:n}=e;if(void 0===t)throw new Error("missing method when send request");if(this._waiting=!0,this.retry=this.send.bind(this,e),void 0===this._sequence||void 0===this.headers||void 0===this._callHistory)throw new Error("rtsp: internal error");const i=Object.assign({type:k.RTSP,uri:n||this._sessionControlURL,data:Zt.alloc(0)},{method:t,headers:r},{headers:Object.assign({CSeq:this._sequence++},this.defaultHeaders,this.headers[t],r)});this._sessionId&&(i.headers.Session=this._sessionId),this._callHistory.push(t),this._outgoingClosed?F()("msl:rtsp:outgoing")(`Unable to send ${t}, connection closed`):this.outgoing.push(i)}_enqueue(e){if(void 0===this._callStack)throw new Error("rtsp: internal error");this._callStack.push(e)}_dequeue(){if(void 0===this._callStack)throw new Error("rtsp: internal error");if(!this._waiting&&this._callStack.length>0){const e=this._callStack.shift();void 0!==e&&this.send(e)}}}const nr=async(e={})=>{const{uri:t,tokenUri:r,protocol:n,timeout:i}=Yt(((e=window.location.host,t=window.location.protocol)=>({uri:`${"https:"===t?"wss:":"ws:"}//${e}/rtsp-over-websocket`,tokenUri:`${t}//${e}/axis-cgi/rtspwssession.cgi`,protocol:"binary",timeout:10007}))(e.host,e.scheme),e);if(void 0===t)throw new Error("ws: internal error");return await new Promise(((e,o)=>{try{const s=new WebSocket(t,n),a=setTimeout((()=>{clearTimeout(a),s.readyState===WebSocket.CONNECTING&&(s.onerror=null,o(new Error("websocket connection timed out")))}),i);s.binaryType="arraybuffer",s.onerror=i=>{clearTimeout(a);const s=new XMLHttpRequest;s.addEventListener("load",(function(){if(this.status>=400)return console.warn("failed to load token",this.status,this.responseText),void o(i);const r=this.responseText.trim(),s=new WebSocket(`${t}?rtspwssession=${r}`,n);s.binaryType="arraybuffer",s.onerror=e=>{o(e)},s.onopen=()=>e(s)})),s.addEventListener("error",(e=>{console.warn("failed to get token"),o(e)})),s.addEventListener("abort",(()=>o(i))),s.open("GET",`${r}?${Date.now()}`);try{s.send()}catch(e){o(i)}},s.onopen=()=>{clearTimeout(a),e(s)}}catch(e){o(e)}}))};var ir=r(7866).Buffer;class or extends l{constructor(e){if(void 0===e)throw new Error("socket argument missing");const t=new o.Readable({objectMode:!0,read:function(){}});e.onmessage=r=>{const n=ir.from(r.data);t.push({data:n,type:k.RAW})||e.readyState===WebSocket.OPEN&&(F()("msl:websocket:incoming")("downstream frozen"),e.close())},t.on("error",(t=>{console.warn("closing socket due to incoming error",t),e.close()}));const r=new o.Writable({objectMode:!0,write:function(t,r,n){try{e.send(t.data)}catch(e){console.warn("message lost during send:",t)}n()}});var n,i;r.on("error",(e=>{console.warn("error during websocket send, ignoring:",e)})),r.on("finish",(()=>{F()("msl:websocket:outgoing")("finish"),e.readyState!==WebSocket.CLOSED&&e.close()})),e.onclose=e=>{F()("msl:websocket:close")(`${e.code}`),1001===e.code&&this.onServerClose&&this.onServerClose(),t.push(null),r.end()},super(t,r),i=void 0,(n="onServerClose")in this?Object.defineProperty(this,n,{value:i,enumerable:!0,configurable:!0,writable:!0}):this[n]=i}static async open(e){return await nr(e).then((e=>new or(e)))}}function sr(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}class ar{constructor(...e){sr(this,"firstComponent",void 0),sr(this,"lastComponent",void 0),sr(this,"_set",void 0);const[t,...r]=e;this._set=new Set(e),this.firstComponent=t,this.lastComponent=r.reduce(((e,t)=>e.connect(t)),t)}init(...e){const[t,...r]=e;this._set=new Set(e),this.firstComponent=t,this.lastComponent=r.reduce(((e,t)=>e.connect(t)),t)}insertAfter(e,t){if(!this._set.has(e))throw new Error("insertion point not part of pipeline");if(this._set.has(t))throw new Error("new component already in the pipeline");const r=e.next;return null===r?(e.connect(t),this.lastComponent=t):(e.disconnect(),e.connect(t).connect(r)),this._set.add(t),this}insertBefore(e,t){if(!this._set.has(e))throw new Error("insertion point not part of pipeline");if(this._set.has(t))throw new Error("new component already in the pipeline");const r=e.prev;return null===r?(t.connect(e),this.firstComponent=t):(r.disconnect(),r.connect(t).connect(e)),this._set.add(t),this}remove(e){if(!this._set.has(e))throw new Error("component not part of pipeline");const t=e.prev,r=e.next;if(null===t&&null===r)throw new Error("cannot remove last component");return null===t&&null!==r?(e.disconnect(),this.firstComponent=r):null!==t&&null===r?(t.disconnect(),this.lastComponent=t):null!==t&&null!==r&&(t.disconnect(),e.disconnect(),t.connect(r)),this._set.delete(e),this}append(...e){return e.forEach((e=>{this.insertAfter(this.lastComponent,e)})),this}prepend(...e){return e.forEach((e=>{this.insertBefore(this.firstComponent,e)})),this}}function ur(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}class cr extends ar{constructor(e){const t=new Vt,r=new rr(e);r.onSdp=e=>{this.onSdp&&this.onSdp(e)},r.onPlay=e=>{this.onPlay&&this.onPlay(e)},super(t,r),ur(this,"onSdp",void 0),ur(this,"onPlay",void 0),ur(this,"rtsp",void 0),this.rtsp=r}}function lr(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}class hr extends cr{constructor(e){super(e),lr(this,"onSync",void 0),lr(this,"_mp4Muxer",void 0);const t=new J,r=new P,n=new et;n.onSync=e=>{this.onSync&&this.onSync(e)},this.append(t,r,n),this._mp4Muxer=n}get bitrate(){return this._mp4Muxer.bitrate}get framerate(){return this._mp4Muxer.framerate}}class fr extends cr{constructor(e){super(e);const t=new ve;this.append(t)}}var dr=r(2993);function pr(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}class mr{constructor(e,t,r){pr(this,"realm",void 0),pr(this,"nonce",void 0),pr(this,"opaque",void 0),pr(this,"algorithm",void 0),pr(this,"qop",void 0),pr(this,"username",void 0),pr(this,"ha1Base",void 0),pr(this,"count",void 0),pr(this,"nc",(()=>(++this.count,this.count.toString(16).padStart(8,"0")))),pr(this,"cnonce",(()=>new Array(4).fill(0).map((()=>Math.floor(256*Math.random()))).map((e=>e.toString(16))).join(""))),pr(this,"ha1",(e=>{let t=this.ha1Base;return"md5-sess"===this.algorithm&&(t=(new dr.V).appendStr(`${t}:${this.nonce}:${e}`).end().toString()),t})),pr(this,"ha2",((e,t,r="")=>{let n=(new dr.V).appendStr(`${e}:${t}`).end().toString();if("md5-sess"===this.algorithm){const i=(new dr.V).appendStr(r).end().toString();n=(new dr.V).appendStr(`${e}:${t}:${i}`).end().toString()}return n})),pr(this,"authorization",((e="GET",t="",r)=>{const n=this.nc(),i=this.cnonce(),o=this.ha1(i),s=this.ha2(e,t,r),a=void 0===this.qop?(new dr.V).appendStr(`${o}:${this.nonce}:${s}`).end().toString():(new dr.V).appendStr(`${o}:${this.nonce}:${n}:${i}:${this.qop}:${s}`).end().toString(),u=[];return u.push(`username="${this.username}"`),u.push(`realm="${this.realm}"`),u.push(`nonce="${this.nonce}"`),u.push(`uri="${t}"`),void 0!==this.qop&&(u.push(`qop=${this.qop}`),u.push(`nc=${n}`),u.push(`cnonce="${i}"`)),u.push(`response="${a}"`),void 0!==this.opaque&&u.push(`opaque="${this.opaque}"`),`Digest ${u.join(", ")}`}));const n=e.get("realm");if(void 0===n)throw new Error("no realm in digest challenge");this.realm=n,this.ha1Base=(new dr.V).appendStr(`${t}:${n}:${r}`).end().toString();const i=e.get("nonce");if(void 0===i)throw new Error("no nonce in digest challenge");this.nonce=i,this.opaque=e.get("opaque");const o=e.get("algorithm");void 0!==o?"md5"===o?this.algorithm="md5":"md5-sess"===o&&(this.algorithm="md5-sess"):this.algorithm="md5";const s=e.get("qop");if(void 0!==s){const e=s.split(",").map((e=>e.trim()));e.some((e=>"auth"===e))?this.qop="auth":e.some((e=>"auth-int"===e))&&(this.qop="auth-int")}this.count=0,this.username=t}}var gr=r(7866).Buffer;const yr={username:"root",password:"pass"};class br extends h{constructor(e={}){const{username:t,password:r}=Yt(yr,e);if(void 0===t||void 0===r)throw new Error("need username and password");let n,i;const o=O((function(e,t,r){e.type===k.RTSP&&(n=e,i&&e.headers&&(e.headers.Authorization=i)),r(void 0,e)}));super(O((function(e,s,a){if(e.type===k.RTSP&&401===Mt(e.data)){const s=e.data.toString().split("\n").find((e=>/WWW-Auth/i.test(e)));if(void 0===s)throw new Error("cannot find WWW-Authenticate header");const u=(e=>{const[,t,...r]=e.split(" "),n=[],i=/\s*([^=]+)="([^"]*)",?/gm;let o;do{if(o=i.exec(r.join(" ")),null!==o){const[,e,t]=o;n.push([e,t])}}while(null!==o);const s=new Map(n);return{type:t.toLowerCase(),params:s}})(s);if("basic"===u.type)i="Basic "+gr.from(t+":"+r).toString("base64");else{if("digest"!==u.type)return;{const e=new mr(u.params,t,r);i=e.authorization(n.method,n.uri)}}o.write(n,(()=>a()))}else a(void 0,e)})),o)}}function vr(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}class wr extends fr{constructor(e){const{ws:t,rtsp:r,mediaElement:n,auth:i}=e;if(super(r),vr(this,"onCanplay",void 0),vr(this,"onSync",void 0),vr(this,"onServerClose",void 0),vr(this,"ready",void 0),vr(this,"_src",void 0),vr(this,"_sink",void 0),i){const e=new br(i);this.insertBefore(this.rtsp,e)}const o=new D(n);o.onCanplay=()=>{o.play(),this.onCanplay&&this.onCanplay()},o.onSync=e=>{this.onSync&&this.onSync(e)},this.append(o),this._sink=o;const s=or.open(t);this.ready=s.then((e=>{e.onServerClose=()=>{this.onServerClose&&this.onServerClose()},this.prepend(e),this._src=e}))}close(){this._src&&this._src.outgoing.end()}get currentTime(){return this._sink.currentTime}play(){return this._sink.play()}pause(){return this._sink.pause()}get bitrate(){return this._sink.bitrate}get framerate(){return this._sink.framerate}}function _r(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}class Sr extends hr{constructor(e){const{ws:t,rtsp:r,mediaElement:n,auth:i}=e;if(super(r),_r(this,"onSourceOpen",void 0),_r(this,"onServerClose",void 0),_r(this,"ready",void 0),_r(this,"tracks",void 0),_r(this,"_src",void 0),_r(this,"_sink",void 0),i){const e=new br(i);this.insertBefore(this.rtsp,e)}const o=new St(n);o.onSourceOpen=(e,t)=>{this.tracks=t,this.onSourceOpen&&this.onSourceOpen(e,t)},this.append(o),this._sink=o;const s=or.open(t);this.ready=s.then((e=>{e.onServerClose=()=>{this.onServerClose&&this.onServerClose()},this.prepend(e),this._src=e}))}close(){this._src&&this._src.outgoing.end()}get currentTime(){return this._sink.currentTime}async play(){return await this._sink.play()}pause(){return this._sink.pause()}}class Er extends Sr{constructor(e){const{metadataHandler:t}=e;super(e);const r=new xt;this.insertAfter(this.rtsp,r);const n=h.fromHandlers((e=>{e.type===k.XML&&t(e)}),void 0);this.insertAfter(r,n)}}function xr(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}const Rr={parameters:["audio=0","video=0","event=on","ptz=all"]};class Tr extends cr{constructor(e){const{ws:t,rtsp:r,metadataHandler:n}=e;super(Object.assign({},Rr,r)),xr(this,"onServerClose",void 0),xr(this,"ready",void 0),xr(this,"_src",void 0);const i=new xt;this.append(i);const o=f.fromHandler((e=>{e.type===k.XML&&n(e)}));this.append(o);const s=or.open(t);this.ready=s.then((e=>{e.onServerClose=()=>{this.onServerClose&&this.onServerClose()},this.prepend(e),this._src=e}))}close(){this._src&&this._src.outgoing.end()}}function Cr(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}class kr extends cr{constructor(e){const{ws:t,rtsp:r,auth:n}=e;if(super(r),Cr(this,"onServerClose",void 0),Cr(this,"ready",void 0),Cr(this,"_src",void 0),n){const e=new br(n);this.insertBefore(this.rtsp,e)}const i=or.open(t);this.ready=i.then((e=>{e.onServerClose=()=>{this.onServerClose&&this.onServerClose()},this.prepend(e),this._src=e}))}close(){this._src&&this._src.outgoing.end()}get sdp(){return this.ready.then((async()=>{const e=new Promise((e=>{this.rtsp.onSdp=e}));return this.rtsp.send({method:er.DESCRIBE}),this.rtsp.send({method:er.TEARDOWN}),e}))}}var Or=r(7866).Buffer;function Pr(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function Ir(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}const Lr=F()("msl:http-mp4");class Br extends l{constructor(e){const{uri:t,options:r}=e,n=new o.Readable({objectMode:!0,read:function(){}});n.on("error",(e=>{console.warn("closing socket due to incoming error",e),this._reader&&this._reader.cancel()})),super(n),Ir(this,"uri",void 0),Ir(this,"options",void 0),Ir(this,"length",void 0),Ir(this,"onHeaders",void 0),Ir(this,"onServerClose",void 0),Ir(this,"_reader",void 0),Ir(this,"_abortController",void 0),Ir(this,"_allDone",void 0),n._read=()=>{this._pull()},this.uri=t,this.options=r,this._allDone=!1}play(){if(void 0===this.uri)throw new Error("cannot start playing when there is no URI");this._abortController=new AbortController,this.length=0,fetch(this.uri,function(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?Pr(Object(r),!0).forEach((function(t){Ir(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):Pr(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}({credentials:"include",signal:this._abortController.signal},this.options)).then((e=>{if(null===e.body)throw new Error("empty response body");const t=e.headers.get("Content-Type");this.incoming.push({data:Or.alloc(0),type:k.ISOM,mime:t}),this.onHeaders&&this.onHeaders(e.headers),this._reader=e.body.getReader(),this._pull()})).catch((e=>{console.error("http-source: fetch failed: ",e)}))}abort(){this._reader&&this._reader.cancel().catch((e=>{console.log("http-source: cancel reader failed: ",e)})),this._abortController&&this._abortController.abort()}_isClosed(){return this._allDone}_close(){var e;this._reader=void 0,this._allDone=!0,this.incoming.push(null),null===(e=this.onServerClose)||void 0===e||e.call(this)}_pull(){void 0!==this._reader&&this._reader.read().then((({done:e,value:t})=>{if(e)return void(this._isClosed()||(Lr("fetch completed, total downloaded: ",this.length," bytes"),this._close()));if(void 0===t)throw new Error("expected value to be defined");if(void 0===this.length)throw new Error("expected length to be defined");this.length+=t.length;const r=Or.from(t);this.incoming.push({data:r,type:k.ISOM})?this._pull():Lr("downstream back pressure: pausing read")})).catch((e=>{Lr("http-source: read failed: ",e),this._isClosed()||this._close()}))}}function Ar(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}class Ur extends ar{constructor(e){const{http:t,mediaElement:r}=e,n=new Br(t),i=new St(r);n.onHeaders=e=>{this.onHeaders&&this.onHeaders(e)},n.onServerClose=()=>{var e;return null===(e=this.onServerClose)||void 0===e?void 0:e.call(this)},super(n,i),Ar(this,"onHeaders",void 0),Ar(this,"onServerClose",void 0),Ar(this,"http",void 0),Ar(this,"_src",void 0),Ar(this,"_sink",void 0),this._src=n,this._sink=i,this.http=n}close(){this._src&&this._src.abort()}get currentTime(){return this._sink.currentTime}async play(){return await this._sink.play()}pause(){return this._sink.pause()}}const jr=(e,{maxRetries:t,errors:r}={maxRetries:20,errors:[503]})=>{let n=0;const i=e.onError;e.onError=o=>{null==i||i(o),r.includes(o.code)&&((n+=1)>t?console.log("retry, too many",n,t):setTimeout((()=>{var t;return null===(t=e.retry)||void 0===t?void 0:t.call(e)}),100*n))}}})(),n})()}));
\ No newline at end of file
+(function webpackUniversalModuleDefinition(root, factory) {
+	if(typeof exports === 'object' && typeof module === 'object')
+		module.exports = factory();
+	else if(typeof define === 'function' && define.amd)
+		define([], factory);
+	else if(typeof exports === 'object')
+		exports["mediaStreamLibrary"] = factory();
+	else
+		root["mediaStreamLibrary"] = factory();
+})(self, function() {
+return /******/ (() => { // webpackBootstrap
+/******/ 	var __webpack_modules__ = ({
+
+/***/ 7997:
+/***/ ((module, exports, __webpack_require__) => {
+
+/* provided dependency */ var process = __webpack_require__(2695);
+/* eslint-env browser */
+
+/**
+ * This is the web browser implementation of `debug()`.
+ */
+
+exports.formatArgs = formatArgs;
+exports.save = save;
+exports.load = load;
+exports.useColors = useColors;
+exports.storage = localstorage();
+exports.destroy = (() => {
+	let warned = false;
+
+	return () => {
+		if (!warned) {
+			warned = true;
+			console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
+		}
+	};
+})();
+
+/**
+ * Colors.
+ */
+
+exports.colors = [
+	'#0000CC',
+	'#0000FF',
+	'#0033CC',
+	'#0033FF',
+	'#0066CC',
+	'#0066FF',
+	'#0099CC',
+	'#0099FF',
+	'#00CC00',
+	'#00CC33',
+	'#00CC66',
+	'#00CC99',
+	'#00CCCC',
+	'#00CCFF',
+	'#3300CC',
+	'#3300FF',
+	'#3333CC',
+	'#3333FF',
+	'#3366CC',
+	'#3366FF',
+	'#3399CC',
+	'#3399FF',
+	'#33CC00',
+	'#33CC33',
+	'#33CC66',
+	'#33CC99',
+	'#33CCCC',
+	'#33CCFF',
+	'#6600CC',
+	'#6600FF',
+	'#6633CC',
+	'#6633FF',
+	'#66CC00',
+	'#66CC33',
+	'#9900CC',
+	'#9900FF',
+	'#9933CC',
+	'#9933FF',
+	'#99CC00',
+	'#99CC33',
+	'#CC0000',
+	'#CC0033',
+	'#CC0066',
+	'#CC0099',
+	'#CC00CC',
+	'#CC00FF',
+	'#CC3300',
+	'#CC3333',
+	'#CC3366',
+	'#CC3399',
+	'#CC33CC',
+	'#CC33FF',
+	'#CC6600',
+	'#CC6633',
+	'#CC9900',
+	'#CC9933',
+	'#CCCC00',
+	'#CCCC33',
+	'#FF0000',
+	'#FF0033',
+	'#FF0066',
+	'#FF0099',
+	'#FF00CC',
+	'#FF00FF',
+	'#FF3300',
+	'#FF3333',
+	'#FF3366',
+	'#FF3399',
+	'#FF33CC',
+	'#FF33FF',
+	'#FF6600',
+	'#FF6633',
+	'#FF9900',
+	'#FF9933',
+	'#FFCC00',
+	'#FFCC33'
+];
+
+/**
+ * Currently only WebKit-based Web Inspectors, Firefox >= v31,
+ * and the Firebug extension (any Firefox version) are known
+ * to support "%c" CSS customizations.
+ *
+ * TODO: add a `localStorage` variable to explicitly enable/disable colors
+ */
+
+// eslint-disable-next-line complexity
+function useColors() {
+	// NB: In an Electron preload script, document will be defined but not fully
+	// initialized. Since we know we're in Chrome, we'll just detect this case
+	// explicitly
+	if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
+		return true;
+	}
+
+	// Internet Explorer and Edge do not support colors.
+	if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
+		return false;
+	}
+
+	// Is webkit? http://stackoverflow.com/a/16459606/376773
+	// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
+	return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
+		// Is firebug? http://stackoverflow.com/a/398120/376773
+		(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
+		// Is firefox >= v31?
+		// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
+		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
+		// Double check webkit in userAgent just in case we are in a worker
+		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
+}
+
+/**
+ * Colorize log arguments if enabled.
+ *
+ * @api public
+ */
+
+function formatArgs(args) {
+	args[0] = (this.useColors ? '%c' : '') +
+		this.namespace +
+		(this.useColors ? ' %c' : ' ') +
+		args[0] +
+		(this.useColors ? '%c ' : ' ') +
+		'+' + module.exports.humanize(this.diff);
+
+	if (!this.useColors) {
+		return;
+	}
+
+	const c = 'color: ' + this.color;
+	args.splice(1, 0, c, 'color: inherit');
+
+	// The final "%c" is somewhat tricky, because there could be other
+	// arguments passed either before or after the %c, so we need to
+	// figure out the correct index to insert the CSS into
+	let index = 0;
+	let lastC = 0;
+	args[0].replace(/%[a-zA-Z%]/g, match => {
+		if (match === '%%') {
+			return;
+		}
+		index++;
+		if (match === '%c') {
+			// We only are interested in the *last* %c
+			// (the user may have provided their own)
+			lastC = index;
+		}
+	});
+
+	args.splice(lastC, 0, c);
+}
+
+/**
+ * Invokes `console.debug()` when available.
+ * No-op when `console.debug` is not a "function".
+ * If `console.debug` is not available, falls back
+ * to `console.log`.
+ *
+ * @api public
+ */
+exports.log = console.debug || console.log || (() => {});
+
+/**
+ * Save `namespaces`.
+ *
+ * @param {String} namespaces
+ * @api private
+ */
+function save(namespaces) {
+	try {
+		if (namespaces) {
+			exports.storage.setItem('debug', namespaces);
+		} else {
+			exports.storage.removeItem('debug');
+		}
+	} catch (error) {
+		// Swallow
+		// XXX (@Qix-) should we be logging these?
+	}
+}
+
+/**
+ * Load `namespaces`.
+ *
+ * @return {String} returns the previously persisted debug modes
+ * @api private
+ */
+function load() {
+	let r;
+	try {
+		r = exports.storage.getItem('debug');
+	} catch (error) {
+		// Swallow
+		// XXX (@Qix-) should we be logging these?
+	}
+
+	// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
+	if (!r && typeof process !== 'undefined' && 'env' in process) {
+		r = process.env.DEBUG;
+	}
+
+	return r;
+}
+
+/**
+ * Localstorage attempts to return the localstorage.
+ *
+ * This is necessary because safari throws
+ * when a user disables cookies/localstorage
+ * and you attempt to access it.
+ *
+ * @return {LocalStorage}
+ * @api private
+ */
+
+function localstorage() {
+	try {
+		// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
+		// The Browser also has localStorage in the global context.
+		return localStorage;
+	} catch (error) {
+		// Swallow
+		// XXX (@Qix-) should we be logging these?
+	}
+}
+
+module.exports = __webpack_require__(4069)(exports);
+
+const {formatters} = module.exports;
+
+/**
+ * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
+ */
+
+formatters.j = function (v) {
+	try {
+		return JSON.stringify(v);
+	} catch (error) {
+		return '[UnexpectedJSONParseError]: ' + error.message;
+	}
+};
+
+
+/***/ }),
+
+/***/ 4069:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+
+/**
+ * This is the common logic for both the Node.js and web browser
+ * implementations of `debug()`.
+ */
+
+function setup(env) {
+	createDebug.debug = createDebug;
+	createDebug.default = createDebug;
+	createDebug.coerce = coerce;
+	createDebug.disable = disable;
+	createDebug.enable = enable;
+	createDebug.enabled = enabled;
+	createDebug.humanize = __webpack_require__(6117);
+	createDebug.destroy = destroy;
+
+	Object.keys(env).forEach(key => {
+		createDebug[key] = env[key];
+	});
+
+	/**
+	* The currently active debug mode names, and names to skip.
+	*/
+
+	createDebug.names = [];
+	createDebug.skips = [];
+
+	/**
+	* Map of special "%n" handling functions, for the debug "format" argument.
+	*
+	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
+	*/
+	createDebug.formatters = {};
+
+	/**
+	* Selects a color for a debug namespace
+	* @param {String} namespace The namespace string for the for the debug instance to be colored
+	* @return {Number|String} An ANSI color code for the given namespace
+	* @api private
+	*/
+	function selectColor(namespace) {
+		let hash = 0;
+
+		for (let i = 0; i < namespace.length; i++) {
+			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
+			hash |= 0; // Convert to 32bit integer
+		}
+
+		return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
+	}
+	createDebug.selectColor = selectColor;
+
+	/**
+	* Create a debugger with the given `namespace`.
+	*
+	* @param {String} namespace
+	* @return {Function}
+	* @api public
+	*/
+	function createDebug(namespace) {
+		let prevTime;
+		let enableOverride = null;
+		let namespacesCache;
+		let enabledCache;
+
+		function debug(...args) {
+			// Disabled?
+			if (!debug.enabled) {
+				return;
+			}
+
+			const self = debug;
+
+			// Set `diff` timestamp
+			const curr = Number(new Date());
+			const ms = curr - (prevTime || curr);
+			self.diff = ms;
+			self.prev = prevTime;
+			self.curr = curr;
+			prevTime = curr;
+
+			args[0] = createDebug.coerce(args[0]);
+
+			if (typeof args[0] !== 'string') {
+				// Anything else let's inspect with %O
+				args.unshift('%O');
+			}
+
+			// Apply any `formatters` transformations
+			let index = 0;
+			args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
+				// If we encounter an escaped % then don't increase the array index
+				if (match === '%%') {
+					return '%';
+				}
+				index++;
+				const formatter = createDebug.formatters[format];
+				if (typeof formatter === 'function') {
+					const val = args[index];
+					match = formatter.call(self, val);
+
+					// Now we need to remove `args[index]` since it's inlined in the `format`
+					args.splice(index, 1);
+					index--;
+				}
+				return match;
+			});
+
+			// Apply env-specific formatting (colors, etc.)
+			createDebug.formatArgs.call(self, args);
+
+			const logFn = self.log || createDebug.log;
+			logFn.apply(self, args);
+		}
+
+		debug.namespace = namespace;
+		debug.useColors = createDebug.useColors();
+		debug.color = createDebug.selectColor(namespace);
+		debug.extend = extend;
+		debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.
+
+		Object.defineProperty(debug, 'enabled', {
+			enumerable: true,
+			configurable: false,
+			get: () => {
+				if (enableOverride !== null) {
+					return enableOverride;
+				}
+				if (namespacesCache !== createDebug.namespaces) {
+					namespacesCache = createDebug.namespaces;
+					enabledCache = createDebug.enabled(namespace);
+				}
+
+				return enabledCache;
+			},
+			set: v => {
+				enableOverride = v;
+			}
+		});
+
+		// Env-specific initialization logic for debug instances
+		if (typeof createDebug.init === 'function') {
+			createDebug.init(debug);
+		}
+
+		return debug;
+	}
+
+	function extend(namespace, delimiter) {
+		const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
+		newDebug.log = this.log;
+		return newDebug;
+	}
+
+	/**
+	* Enables a debug mode by namespaces. This can include modes
+	* separated by a colon and wildcards.
+	*
+	* @param {String} namespaces
+	* @api public
+	*/
+	function enable(namespaces) {
+		createDebug.save(namespaces);
+		createDebug.namespaces = namespaces;
+
+		createDebug.names = [];
+		createDebug.skips = [];
+
+		let i;
+		const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
+		const len = split.length;
+
+		for (i = 0; i < len; i++) {
+			if (!split[i]) {
+				// ignore empty strings
+				continue;
+			}
+
+			namespaces = split[i].replace(/\*/g, '.*?');
+
+			if (namespaces[0] === '-') {
+				createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
+			} else {
+				createDebug.names.push(new RegExp('^' + namespaces + '$'));
+			}
+		}
+	}
+
+	/**
+	* Disable debug output.
+	*
+	* @return {String} namespaces
+	* @api public
+	*/
+	function disable() {
+		const namespaces = [
+			...createDebug.names.map(toNamespace),
+			...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)
+		].join(',');
+		createDebug.enable('');
+		return namespaces;
+	}
+
+	/**
+	* Returns true if the given mode name is enabled, false otherwise.
+	*
+	* @param {String} name
+	* @return {Boolean}
+	* @api public
+	*/
+	function enabled(name) {
+		if (name[name.length - 1] === '*') {
+			return true;
+		}
+
+		let i;
+		let len;
+
+		for (i = 0, len = createDebug.skips.length; i < len; i++) {
+			if (createDebug.skips[i].test(name)) {
+				return false;
+			}
+		}
+
+		for (i = 0, len = createDebug.names.length; i < len; i++) {
+			if (createDebug.names[i].test(name)) {
+				return true;
+			}
+		}
+
+		return false;
+	}
+
+	/**
+	* Convert regexp to namespace
+	*
+	* @param {RegExp} regxep
+	* @return {String} namespace
+	* @api private
+	*/
+	function toNamespace(regexp) {
+		return regexp.toString()
+			.substring(2, regexp.toString().length - 2)
+			.replace(/\.\*\?$/, '*');
+	}
+
+	/**
+	* Coerce `val`.
+	*
+	* @param {Mixed} val
+	* @return {Mixed}
+	* @api private
+	*/
+	function coerce(val) {
+		if (val instanceof Error) {
+			return val.stack || val.message;
+		}
+		return val;
+	}
+
+	/**
+	* XXX DO NOT USE. This is a temporary stub function.
+	* XXX It WILL be removed in the next major release.
+	*/
+	function destroy() {
+		console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
+	}
+
+	createDebug.enable(createDebug.load());
+
+	return createDebug;
+}
+
+module.exports = setup;
+
+
+/***/ }),
+
+/***/ 7378:
+/***/ ((__unused_webpack_module, exports) => {
+
+"use strict";
+
+
+exports.byteLength = byteLength
+exports.toByteArray = toByteArray
+exports.fromByteArray = fromByteArray
+
+var lookup = []
+var revLookup = []
+var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array
+
+var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
+for (var i = 0, len = code.length; i < len; ++i) {
+  lookup[i] = code[i]
+  revLookup[code.charCodeAt(i)] = i
+}
+
+// Support decoding URL-safe base64 strings, as Node.js does.
+// See: https://en.wikipedia.org/wiki/Base64#URL_applications
+revLookup['-'.charCodeAt(0)] = 62
+revLookup['_'.charCodeAt(0)] = 63
+
+function getLens (b64) {
+  var len = b64.length
+
+  if (len % 4 > 0) {
+    throw new Error('Invalid string. Length must be a multiple of 4')
+  }
+
+  // Trim off extra bytes after placeholder bytes are found
+  // See: https://github.com/beatgammit/base64-js/issues/42
+  var validLen = b64.indexOf('=')
+  if (validLen === -1) validLen = len
+
+  var placeHoldersLen = validLen === len
+    ? 0
+    : 4 - (validLen % 4)
+
+  return [validLen, placeHoldersLen]
+}
+
+// base64 is 4/3 + up to two characters of the original data
+function byteLength (b64) {
+  var lens = getLens(b64)
+  var validLen = lens[0]
+  var placeHoldersLen = lens[1]
+  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
+}
+
+function _byteLength (b64, validLen, placeHoldersLen) {
+  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
+}
+
+function toByteArray (b64) {
+  var tmp
+  var lens = getLens(b64)
+  var validLen = lens[0]
+  var placeHoldersLen = lens[1]
+
+  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))
+
+  var curByte = 0
+
+  // if there are placeholders, only get up to the last complete 4 chars
+  var len = placeHoldersLen > 0
+    ? validLen - 4
+    : validLen
+
+  var i
+  for (i = 0; i < len; i += 4) {
+    tmp =
+      (revLookup[b64.charCodeAt(i)] << 18) |
+      (revLookup[b64.charCodeAt(i + 1)] << 12) |
+      (revLookup[b64.charCodeAt(i + 2)] << 6) |
+      revLookup[b64.charCodeAt(i + 3)]
+    arr[curByte++] = (tmp >> 16) & 0xFF
+    arr[curByte++] = (tmp >> 8) & 0xFF
+    arr[curByte++] = tmp & 0xFF
+  }
+
+  if (placeHoldersLen === 2) {
+    tmp =
+      (revLookup[b64.charCodeAt(i)] << 2) |
+      (revLookup[b64.charCodeAt(i + 1)] >> 4)
+    arr[curByte++] = tmp & 0xFF
+  }
+
+  if (placeHoldersLen === 1) {
+    tmp =
+      (revLookup[b64.charCodeAt(i)] << 10) |
+      (revLookup[b64.charCodeAt(i + 1)] << 4) |
+      (revLookup[b64.charCodeAt(i + 2)] >> 2)
+    arr[curByte++] = (tmp >> 8) & 0xFF
+    arr[curByte++] = tmp & 0xFF
+  }
+
+  return arr
+}
+
+function tripletToBase64 (num) {
+  return lookup[num >> 18 & 0x3F] +
+    lookup[num >> 12 & 0x3F] +
+    lookup[num >> 6 & 0x3F] +
+    lookup[num & 0x3F]
+}
+
+function encodeChunk (uint8, start, end) {
+  var tmp
+  var output = []
+  for (var i = start; i < end; i += 3) {
+    tmp =
+      ((uint8[i] << 16) & 0xFF0000) +
+      ((uint8[i + 1] << 8) & 0xFF00) +
+      (uint8[i + 2] & 0xFF)
+    output.push(tripletToBase64(tmp))
+  }
+  return output.join('')
+}
+
+function fromByteArray (uint8) {
+  var tmp
+  var len = uint8.length
+  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
+  var parts = []
+  var maxChunkLength = 16383 // must be multiple of 3
+
+  // go through the array every three bytes, we'll deal with trailing stuff later
+  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
+    parts.push(encodeChunk(
+      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
+    ))
+  }
+
+  // pad the end with zeros, but make sure to not forget the extra bytes
+  if (extraBytes === 1) {
+    tmp = uint8[len - 1]
+    parts.push(
+      lookup[tmp >> 2] +
+      lookup[(tmp << 4) & 0x3F] +
+      '=='
+    )
+  } else if (extraBytes === 2) {
+    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
+    parts.push(
+      lookup[tmp >> 10] +
+      lookup[(tmp >> 4) & 0x3F] +
+      lookup[(tmp << 2) & 0x3F] +
+      '='
+    )
+  }
+
+  return parts.join('')
+}
+
+
+/***/ }),
+
+/***/ 7866:
+/***/ ((__unused_webpack_module, exports, __webpack_require__) => {
+
+"use strict";
+/*!
+ * The buffer module from node.js, for the browser.
+ *
+ * @author   Feross Aboukhadijeh <https://feross.org>
+ * @license  MIT
+ */
+/* eslint-disable no-proto */
+
+
+
+const base64 = __webpack_require__(7378)
+const ieee754 = __webpack_require__(9258)
+const customInspectSymbol =
+  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation
+    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation
+    : null
+
+exports.Buffer = Buffer
+exports.SlowBuffer = SlowBuffer
+exports.INSPECT_MAX_BYTES = 50
+
+const K_MAX_LENGTH = 0x7fffffff
+exports.kMaxLength = K_MAX_LENGTH
+
+/**
+ * If `Buffer.TYPED_ARRAY_SUPPORT`:
+ *   === true    Use Uint8Array implementation (fastest)
+ *   === false   Print warning and recommend using `buffer` v4.x which has an Object
+ *               implementation (most compatible, even IE6)
+ *
+ * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
+ * Opera 11.6+, iOS 4.2+.
+ *
+ * We report that the browser does not support typed arrays if the are not subclassable
+ * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
+ * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
+ * for __proto__ and has a buggy typed array implementation.
+ */
+Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()
+
+if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
+    typeof console.error === 'function') {
+  console.error(
+    'This browser lacks typed array (Uint8Array) support which is required by ' +
+    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
+  )
+}
+
+function typedArraySupport () {
+  // Can typed array instances can be augmented?
+  try {
+    const arr = new Uint8Array(1)
+    const proto = { foo: function () { return 42 } }
+    Object.setPrototypeOf(proto, Uint8Array.prototype)
+    Object.setPrototypeOf(arr, proto)
+    return arr.foo() === 42
+  } catch (e) {
+    return false
+  }
+}
+
+Object.defineProperty(Buffer.prototype, 'parent', {
+  enumerable: true,
+  get: function () {
+    if (!Buffer.isBuffer(this)) return undefined
+    return this.buffer
+  }
+})
+
+Object.defineProperty(Buffer.prototype, 'offset', {
+  enumerable: true,
+  get: function () {
+    if (!Buffer.isBuffer(this)) return undefined
+    return this.byteOffset
+  }
+})
+
+function createBuffer (length) {
+  if (length > K_MAX_LENGTH) {
+    throw new RangeError('The value "' + length + '" is invalid for option "size"')
+  }
+  // Return an augmented `Uint8Array` instance
+  const buf = new Uint8Array(length)
+  Object.setPrototypeOf(buf, Buffer.prototype)
+  return buf
+}
+
+/**
+ * The Buffer constructor returns instances of `Uint8Array` that have their
+ * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
+ * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
+ * and the `Uint8Array` methods. Square bracket notation works as expected -- it
+ * returns a single octet.
+ *
+ * The `Uint8Array` prototype remains unmodified.
+ */
+
+function Buffer (arg, encodingOrOffset, length) {
+  // Common case.
+  if (typeof arg === 'number') {
+    if (typeof encodingOrOffset === 'string') {
+      throw new TypeError(
+        'The "string" argument must be of type string. Received type number'
+      )
+    }
+    return allocUnsafe(arg)
+  }
+  return from(arg, encodingOrOffset, length)
+}
+
+Buffer.poolSize = 8192 // not used by this implementation
+
+function from (value, encodingOrOffset, length) {
+  if (typeof value === 'string') {
+    return fromString(value, encodingOrOffset)
+  }
+
+  if (ArrayBuffer.isView(value)) {
+    return fromArrayView(value)
+  }
+
+  if (value == null) {
+    throw new TypeError(
+      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
+      'or Array-like Object. Received type ' + (typeof value)
+    )
+  }
+
+  if (isInstance(value, ArrayBuffer) ||
+      (value && isInstance(value.buffer, ArrayBuffer))) {
+    return fromArrayBuffer(value, encodingOrOffset, length)
+  }
+
+  if (typeof SharedArrayBuffer !== 'undefined' &&
+      (isInstance(value, SharedArrayBuffer) ||
+      (value && isInstance(value.buffer, SharedArrayBuffer)))) {
+    return fromArrayBuffer(value, encodingOrOffset, length)
+  }
+
+  if (typeof value === 'number') {
+    throw new TypeError(
+      'The "value" argument must not be of type number. Received type number'
+    )
+  }
+
+  const valueOf = value.valueOf && value.valueOf()
+  if (valueOf != null && valueOf !== value) {
+    return Buffer.from(valueOf, encodingOrOffset, length)
+  }
+
+  const b = fromObject(value)
+  if (b) return b
+
+  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
+      typeof value[Symbol.toPrimitive] === 'function') {
+    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)
+  }
+
+  throw new TypeError(
+    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
+    'or Array-like Object. Received type ' + (typeof value)
+  )
+}
+
+/**
+ * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
+ * if value is a number.
+ * Buffer.from(str[, encoding])
+ * Buffer.from(array)
+ * Buffer.from(buffer)
+ * Buffer.from(arrayBuffer[, byteOffset[, length]])
+ **/
+Buffer.from = function (value, encodingOrOffset, length) {
+  return from(value, encodingOrOffset, length)
+}
+
+// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
+// https://github.com/feross/buffer/pull/148
+Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)
+Object.setPrototypeOf(Buffer, Uint8Array)
+
+function assertSize (size) {
+  if (typeof size !== 'number') {
+    throw new TypeError('"size" argument must be of type number')
+  } else if (size < 0) {
+    throw new RangeError('The value "' + size + '" is invalid for option "size"')
+  }
+}
+
+function alloc (size, fill, encoding) {
+  assertSize(size)
+  if (size <= 0) {
+    return createBuffer(size)
+  }
+  if (fill !== undefined) {
+    // Only pay attention to encoding if it's a string. This
+    // prevents accidentally sending in a number that would
+    // be interpreted as a start offset.
+    return typeof encoding === 'string'
+      ? createBuffer(size).fill(fill, encoding)
+      : createBuffer(size).fill(fill)
+  }
+  return createBuffer(size)
+}
+
+/**
+ * Creates a new filled Buffer instance.
+ * alloc(size[, fill[, encoding]])
+ **/
+Buffer.alloc = function (size, fill, encoding) {
+  return alloc(size, fill, encoding)
+}
+
+function allocUnsafe (size) {
+  assertSize(size)
+  return createBuffer(size < 0 ? 0 : checked(size) | 0)
+}
+
+/**
+ * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
+ * */
+Buffer.allocUnsafe = function (size) {
+  return allocUnsafe(size)
+}
+/**
+ * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
+ */
+Buffer.allocUnsafeSlow = function (size) {
+  return allocUnsafe(size)
+}
+
+function fromString (string, encoding) {
+  if (typeof encoding !== 'string' || encoding === '') {
+    encoding = 'utf8'
+  }
+
+  if (!Buffer.isEncoding(encoding)) {
+    throw new TypeError('Unknown encoding: ' + encoding)
+  }
+
+  const length = byteLength(string, encoding) | 0
+  let buf = createBuffer(length)
+
+  const actual = buf.write(string, encoding)
+
+  if (actual !== length) {
+    // Writing a hex string, for example, that contains invalid characters will
+    // cause everything after the first invalid character to be ignored. (e.g.
+    // 'abxxcd' will be treated as 'ab')
+    buf = buf.slice(0, actual)
+  }
+
+  return buf
+}
+
+function fromArrayLike (array) {
+  const length = array.length < 0 ? 0 : checked(array.length) | 0
+  const buf = createBuffer(length)
+  for (let i = 0; i < length; i += 1) {
+    buf[i] = array[i] & 255
+  }
+  return buf
+}
+
+function fromArrayView (arrayView) {
+  if (isInstance(arrayView, Uint8Array)) {
+    const copy = new Uint8Array(arrayView)
+    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)
+  }
+  return fromArrayLike(arrayView)
+}
+
+function fromArrayBuffer (array, byteOffset, length) {
+  if (byteOffset < 0 || array.byteLength < byteOffset) {
+    throw new RangeError('"offset" is outside of buffer bounds')
+  }
+
+  if (array.byteLength < byteOffset + (length || 0)) {
+    throw new RangeError('"length" is outside of buffer bounds')
+  }
+
+  let buf
+  if (byteOffset === undefined && length === undefined) {
+    buf = new Uint8Array(array)
+  } else if (length === undefined) {
+    buf = new Uint8Array(array, byteOffset)
+  } else {
+    buf = new Uint8Array(array, byteOffset, length)
+  }
+
+  // Return an augmented `Uint8Array` instance
+  Object.setPrototypeOf(buf, Buffer.prototype)
+
+  return buf
+}
+
+function fromObject (obj) {
+  if (Buffer.isBuffer(obj)) {
+    const len = checked(obj.length) | 0
+    const buf = createBuffer(len)
+
+    if (buf.length === 0) {
+      return buf
+    }
+
+    obj.copy(buf, 0, 0, len)
+    return buf
+  }
+
+  if (obj.length !== undefined) {
+    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
+      return createBuffer(0)
+    }
+    return fromArrayLike(obj)
+  }
+
+  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
+    return fromArrayLike(obj.data)
+  }
+}
+
+function checked (length) {
+  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
+  // length is NaN (which is otherwise coerced to zero.)
+  if (length >= K_MAX_LENGTH) {
+    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
+                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
+  }
+  return length | 0
+}
+
+function SlowBuffer (length) {
+  if (+length != length) { // eslint-disable-line eqeqeq
+    length = 0
+  }
+  return Buffer.alloc(+length)
+}
+
+Buffer.isBuffer = function isBuffer (b) {
+  return b != null && b._isBuffer === true &&
+    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
+}
+
+Buffer.compare = function compare (a, b) {
+  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
+  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
+  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
+    throw new TypeError(
+      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
+    )
+  }
+
+  if (a === b) return 0
+
+  let x = a.length
+  let y = b.length
+
+  for (let i = 0, len = Math.min(x, y); i < len; ++i) {
+    if (a[i] !== b[i]) {
+      x = a[i]
+      y = b[i]
+      break
+    }
+  }
+
+  if (x < y) return -1
+  if (y < x) return 1
+  return 0
+}
+
+Buffer.isEncoding = function isEncoding (encoding) {
+  switch (String(encoding).toLowerCase()) {
+    case 'hex':
+    case 'utf8':
+    case 'utf-8':
+    case 'ascii':
+    case 'latin1':
+    case 'binary':
+    case 'base64':
+    case 'ucs2':
+    case 'ucs-2':
+    case 'utf16le':
+    case 'utf-16le':
+      return true
+    default:
+      return false
+  }
+}
+
+Buffer.concat = function concat (list, length) {
+  if (!Array.isArray(list)) {
+    throw new TypeError('"list" argument must be an Array of Buffers')
+  }
+
+  if (list.length === 0) {
+    return Buffer.alloc(0)
+  }
+
+  let i
+  if (length === undefined) {
+    length = 0
+    for (i = 0; i < list.length; ++i) {
+      length += list[i].length
+    }
+  }
+
+  const buffer = Buffer.allocUnsafe(length)
+  let pos = 0
+  for (i = 0; i < list.length; ++i) {
+    let buf = list[i]
+    if (isInstance(buf, Uint8Array)) {
+      if (pos + buf.length > buffer.length) {
+        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)
+        buf.copy(buffer, pos)
+      } else {
+        Uint8Array.prototype.set.call(
+          buffer,
+          buf,
+          pos
+        )
+      }
+    } else if (!Buffer.isBuffer(buf)) {
+      throw new TypeError('"list" argument must be an Array of Buffers')
+    } else {
+      buf.copy(buffer, pos)
+    }
+    pos += buf.length
+  }
+  return buffer
+}
+
+function byteLength (string, encoding) {
+  if (Buffer.isBuffer(string)) {
+    return string.length
+  }
+  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
+    return string.byteLength
+  }
+  if (typeof string !== 'string') {
+    throw new TypeError(
+      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
+      'Received type ' + typeof string
+    )
+  }
+
+  const len = string.length
+  const mustMatch = (arguments.length > 2 && arguments[2] === true)
+  if (!mustMatch && len === 0) return 0
+
+  // Use a for loop to avoid recursion
+  let loweredCase = false
+  for (;;) {
+    switch (encoding) {
+      case 'ascii':
+      case 'latin1':
+      case 'binary':
+        return len
+      case 'utf8':
+      case 'utf-8':
+        return utf8ToBytes(string).length
+      case 'ucs2':
+      case 'ucs-2':
+      case 'utf16le':
+      case 'utf-16le':
+        return len * 2
+      case 'hex':
+        return len >>> 1
+      case 'base64':
+        return base64ToBytes(string).length
+      default:
+        if (loweredCase) {
+          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
+        }
+        encoding = ('' + encoding).toLowerCase()
+        loweredCase = true
+    }
+  }
+}
+Buffer.byteLength = byteLength
+
+function slowToString (encoding, start, end) {
+  let loweredCase = false
+
+  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
+  // property of a typed array.
+
+  // This behaves neither like String nor Uint8Array in that we set start/end
+  // to their upper/lower bounds if the value passed is out of range.
+  // undefined is handled specially as per ECMA-262 6th Edition,
+  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
+  if (start === undefined || start < 0) {
+    start = 0
+  }
+  // Return early if start > this.length. Done here to prevent potential uint32
+  // coercion fail below.
+  if (start > this.length) {
+    return ''
+  }
+
+  if (end === undefined || end > this.length) {
+    end = this.length
+  }
+
+  if (end <= 0) {
+    return ''
+  }
+
+  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
+  end >>>= 0
+  start >>>= 0
+
+  if (end <= start) {
+    return ''
+  }
+
+  if (!encoding) encoding = 'utf8'
+
+  while (true) {
+    switch (encoding) {
+      case 'hex':
+        return hexSlice(this, start, end)
+
+      case 'utf8':
+      case 'utf-8':
+        return utf8Slice(this, start, end)
+
+      case 'ascii':
+        return asciiSlice(this, start, end)
+
+      case 'latin1':
+      case 'binary':
+        return latin1Slice(this, start, end)
+
+      case 'base64':
+        return base64Slice(this, start, end)
+
+      case 'ucs2':
+      case 'ucs-2':
+      case 'utf16le':
+      case 'utf-16le':
+        return utf16leSlice(this, start, end)
+
+      default:
+        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
+        encoding = (encoding + '').toLowerCase()
+        loweredCase = true
+    }
+  }
+}
+
+// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
+// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
+// reliably in a browserify context because there could be multiple different
+// copies of the 'buffer' package in use. This method works even for Buffer
+// instances that were created from another copy of the `buffer` package.
+// See: https://github.com/feross/buffer/issues/154
+Buffer.prototype._isBuffer = true
+
+function swap (b, n, m) {
+  const i = b[n]
+  b[n] = b[m]
+  b[m] = i
+}
+
+Buffer.prototype.swap16 = function swap16 () {
+  const len = this.length
+  if (len % 2 !== 0) {
+    throw new RangeError('Buffer size must be a multiple of 16-bits')
+  }
+  for (let i = 0; i < len; i += 2) {
+    swap(this, i, i + 1)
+  }
+  return this
+}
+
+Buffer.prototype.swap32 = function swap32 () {
+  const len = this.length
+  if (len % 4 !== 0) {
+    throw new RangeError('Buffer size must be a multiple of 32-bits')
+  }
+  for (let i = 0; i < len; i += 4) {
+    swap(this, i, i + 3)
+    swap(this, i + 1, i + 2)
+  }
+  return this
+}
+
+Buffer.prototype.swap64 = function swap64 () {
+  const len = this.length
+  if (len % 8 !== 0) {
+    throw new RangeError('Buffer size must be a multiple of 64-bits')
+  }
+  for (let i = 0; i < len; i += 8) {
+    swap(this, i, i + 7)
+    swap(this, i + 1, i + 6)
+    swap(this, i + 2, i + 5)
+    swap(this, i + 3, i + 4)
+  }
+  return this
+}
+
+Buffer.prototype.toString = function toString () {
+  const length = this.length
+  if (length === 0) return ''
+  if (arguments.length === 0) return utf8Slice(this, 0, length)
+  return slowToString.apply(this, arguments)
+}
+
+Buffer.prototype.toLocaleString = Buffer.prototype.toString
+
+Buffer.prototype.equals = function equals (b) {
+  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
+  if (this === b) return true
+  return Buffer.compare(this, b) === 0
+}
+
+Buffer.prototype.inspect = function inspect () {
+  let str = ''
+  const max = exports.INSPECT_MAX_BYTES
+  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
+  if (this.length > max) str += ' ... '
+  return '<Buffer ' + str + '>'
+}
+if (customInspectSymbol) {
+  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect
+}
+
+Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
+  if (isInstance(target, Uint8Array)) {
+    target = Buffer.from(target, target.offset, target.byteLength)
+  }
+  if (!Buffer.isBuffer(target)) {
+    throw new TypeError(
+      'The "target" argument must be one of type Buffer or Uint8Array. ' +
+      'Received type ' + (typeof target)
+    )
+  }
+
+  if (start === undefined) {
+    start = 0
+  }
+  if (end === undefined) {
+    end = target ? target.length : 0
+  }
+  if (thisStart === undefined) {
+    thisStart = 0
+  }
+  if (thisEnd === undefined) {
+    thisEnd = this.length
+  }
+
+  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
+    throw new RangeError('out of range index')
+  }
+
+  if (thisStart >= thisEnd && start >= end) {
+    return 0
+  }
+  if (thisStart >= thisEnd) {
+    return -1
+  }
+  if (start >= end) {
+    return 1
+  }
+
+  start >>>= 0
+  end >>>= 0
+  thisStart >>>= 0
+  thisEnd >>>= 0
+
+  if (this === target) return 0
+
+  let x = thisEnd - thisStart
+  let y = end - start
+  const len = Math.min(x, y)
+
+  const thisCopy = this.slice(thisStart, thisEnd)
+  const targetCopy = target.slice(start, end)
+
+  for (let i = 0; i < len; ++i) {
+    if (thisCopy[i] !== targetCopy[i]) {
+      x = thisCopy[i]
+      y = targetCopy[i]
+      break
+    }
+  }
+
+  if (x < y) return -1
+  if (y < x) return 1
+  return 0
+}
+
+// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
+// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
+//
+// Arguments:
+// - buffer - a Buffer to search
+// - val - a string, Buffer, or number
+// - byteOffset - an index into `buffer`; will be clamped to an int32
+// - encoding - an optional encoding, relevant is val is a string
+// - dir - true for indexOf, false for lastIndexOf
+function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
+  // Empty buffer means no match
+  if (buffer.length === 0) return -1
+
+  // Normalize byteOffset
+  if (typeof byteOffset === 'string') {
+    encoding = byteOffset
+    byteOffset = 0
+  } else if (byteOffset > 0x7fffffff) {
+    byteOffset = 0x7fffffff
+  } else if (byteOffset < -0x80000000) {
+    byteOffset = -0x80000000
+  }
+  byteOffset = +byteOffset // Coerce to Number.
+  if (numberIsNaN(byteOffset)) {
+    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
+    byteOffset = dir ? 0 : (buffer.length - 1)
+  }
+
+  // Normalize byteOffset: negative offsets start from the end of the buffer
+  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
+  if (byteOffset >= buffer.length) {
+    if (dir) return -1
+    else byteOffset = buffer.length - 1
+  } else if (byteOffset < 0) {
+    if (dir) byteOffset = 0
+    else return -1
+  }
+
+  // Normalize val
+  if (typeof val === 'string') {
+    val = Buffer.from(val, encoding)
+  }
+
+  // Finally, search either indexOf (if dir is true) or lastIndexOf
+  if (Buffer.isBuffer(val)) {
+    // Special case: looking for empty string/buffer always fails
+    if (val.length === 0) {
+      return -1
+    }
+    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
+  } else if (typeof val === 'number') {
+    val = val & 0xFF // Search for a byte value [0-255]
+    if (typeof Uint8Array.prototype.indexOf === 'function') {
+      if (dir) {
+        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
+      } else {
+        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
+      }
+    }
+    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
+  }
+
+  throw new TypeError('val must be string, number or Buffer')
+}
+
+function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
+  let indexSize = 1
+  let arrLength = arr.length
+  let valLength = val.length
+
+  if (encoding !== undefined) {
+    encoding = String(encoding).toLowerCase()
+    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
+        encoding === 'utf16le' || encoding === 'utf-16le') {
+      if (arr.length < 2 || val.length < 2) {
+        return -1
+      }
+      indexSize = 2
+      arrLength /= 2
+      valLength /= 2
+      byteOffset /= 2
+    }
+  }
+
+  function read (buf, i) {
+    if (indexSize === 1) {
+      return buf[i]
+    } else {
+      return buf.readUInt16BE(i * indexSize)
+    }
+  }
+
+  let i
+  if (dir) {
+    let foundIndex = -1
+    for (i = byteOffset; i < arrLength; i++) {
+      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
+        if (foundIndex === -1) foundIndex = i
+        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
+      } else {
+        if (foundIndex !== -1) i -= i - foundIndex
+        foundIndex = -1
+      }
+    }
+  } else {
+    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
+    for (i = byteOffset; i >= 0; i--) {
+      let found = true
+      for (let j = 0; j < valLength; j++) {
+        if (read(arr, i + j) !== read(val, j)) {
+          found = false
+          break
+        }
+      }
+      if (found) return i
+    }
+  }
+
+  return -1
+}
+
+Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
+  return this.indexOf(val, byteOffset, encoding) !== -1
+}
+
+Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
+  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
+}
+
+Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
+  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
+}
+
+function hexWrite (buf, string, offset, length) {
+  offset = Number(offset) || 0
+  const remaining = buf.length - offset
+  if (!length) {
+    length = remaining
+  } else {
+    length = Number(length)
+    if (length > remaining) {
+      length = remaining
+    }
+  }
+
+  const strLen = string.length
+
+  if (length > strLen / 2) {
+    length = strLen / 2
+  }
+  let i
+  for (i = 0; i < length; ++i) {
+    const parsed = parseInt(string.substr(i * 2, 2), 16)
+    if (numberIsNaN(parsed)) return i
+    buf[offset + i] = parsed
+  }
+  return i
+}
+
+function utf8Write (buf, string, offset, length) {
+  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
+}
+
+function asciiWrite (buf, string, offset, length) {
+  return blitBuffer(asciiToBytes(string), buf, offset, length)
+}
+
+function base64Write (buf, string, offset, length) {
+  return blitBuffer(base64ToBytes(string), buf, offset, length)
+}
+
+function ucs2Write (buf, string, offset, length) {
+  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
+}
+
+Buffer.prototype.write = function write (string, offset, length, encoding) {
+  // Buffer#write(string)
+  if (offset === undefined) {
+    encoding = 'utf8'
+    length = this.length
+    offset = 0
+  // Buffer#write(string, encoding)
+  } else if (length === undefined && typeof offset === 'string') {
+    encoding = offset
+    length = this.length
+    offset = 0
+  // Buffer#write(string, offset[, length][, encoding])
+  } else if (isFinite(offset)) {
+    offset = offset >>> 0
+    if (isFinite(length)) {
+      length = length >>> 0
+      if (encoding === undefined) encoding = 'utf8'
+    } else {
+      encoding = length
+      length = undefined
+    }
+  } else {
+    throw new Error(
+      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
+    )
+  }
+
+  const remaining = this.length - offset
+  if (length === undefined || length > remaining) length = remaining
+
+  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
+    throw new RangeError('Attempt to write outside buffer bounds')
+  }
+
+  if (!encoding) encoding = 'utf8'
+
+  let loweredCase = false
+  for (;;) {
+    switch (encoding) {
+      case 'hex':
+        return hexWrite(this, string, offset, length)
+
+      case 'utf8':
+      case 'utf-8':
+        return utf8Write(this, string, offset, length)
+
+      case 'ascii':
+      case 'latin1':
+      case 'binary':
+        return asciiWrite(this, string, offset, length)
+
+      case 'base64':
+        // Warning: maxLength not taken into account in base64Write
+        return base64Write(this, string, offset, length)
+
+      case 'ucs2':
+      case 'ucs-2':
+      case 'utf16le':
+      case 'utf-16le':
+        return ucs2Write(this, string, offset, length)
+
+      default:
+        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
+        encoding = ('' + encoding).toLowerCase()
+        loweredCase = true
+    }
+  }
+}
+
+Buffer.prototype.toJSON = function toJSON () {
+  return {
+    type: 'Buffer',
+    data: Array.prototype.slice.call(this._arr || this, 0)
+  }
+}
+
+function base64Slice (buf, start, end) {
+  if (start === 0 && end === buf.length) {
+    return base64.fromByteArray(buf)
+  } else {
+    return base64.fromByteArray(buf.slice(start, end))
+  }
+}
+
+function utf8Slice (buf, start, end) {
+  end = Math.min(buf.length, end)
+  const res = []
+
+  let i = start
+  while (i < end) {
+    const firstByte = buf[i]
+    let codePoint = null
+    let bytesPerSequence = (firstByte > 0xEF)
+      ? 4
+      : (firstByte > 0xDF)
+          ? 3
+          : (firstByte > 0xBF)
+              ? 2
+              : 1
+
+    if (i + bytesPerSequence <= end) {
+      let secondByte, thirdByte, fourthByte, tempCodePoint
+
+      switch (bytesPerSequence) {
+        case 1:
+          if (firstByte < 0x80) {
+            codePoint = firstByte
+          }
+          break
+        case 2:
+          secondByte = buf[i + 1]
+          if ((secondByte & 0xC0) === 0x80) {
+            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
+            if (tempCodePoint > 0x7F) {
+              codePoint = tempCodePoint
+            }
+          }
+          break
+        case 3:
+          secondByte = buf[i + 1]
+          thirdByte = buf[i + 2]
+          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
+            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
+            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
+              codePoint = tempCodePoint
+            }
+          }
+          break
+        case 4:
+          secondByte = buf[i + 1]
+          thirdByte = buf[i + 2]
+          fourthByte = buf[i + 3]
+          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
+            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
+            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
+              codePoint = tempCodePoint
+            }
+          }
+      }
+    }
+
+    if (codePoint === null) {
+      // we did not generate a valid codePoint so insert a
+      // replacement char (U+FFFD) and advance only 1 byte
+      codePoint = 0xFFFD
+      bytesPerSequence = 1
+    } else if (codePoint > 0xFFFF) {
+      // encode to utf16 (surrogate pair dance)
+      codePoint -= 0x10000
+      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
+      codePoint = 0xDC00 | codePoint & 0x3FF
+    }
+
+    res.push(codePoint)
+    i += bytesPerSequence
+  }
+
+  return decodeCodePointsArray(res)
+}
+
+// Based on http://stackoverflow.com/a/22747272/680742, the browser with
+// the lowest limit is Chrome, with 0x10000 args.
+// We go 1 magnitude less, for safety
+const MAX_ARGUMENTS_LENGTH = 0x1000
+
+function decodeCodePointsArray (codePoints) {
+  const len = codePoints.length
+  if (len <= MAX_ARGUMENTS_LENGTH) {
+    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
+  }
+
+  // Decode in chunks to avoid "call stack size exceeded".
+  let res = ''
+  let i = 0
+  while (i < len) {
+    res += String.fromCharCode.apply(
+      String,
+      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
+    )
+  }
+  return res
+}
+
+function asciiSlice (buf, start, end) {
+  let ret = ''
+  end = Math.min(buf.length, end)
+
+  for (let i = start; i < end; ++i) {
+    ret += String.fromCharCode(buf[i] & 0x7F)
+  }
+  return ret
+}
+
+function latin1Slice (buf, start, end) {
+  let ret = ''
+  end = Math.min(buf.length, end)
+
+  for (let i = start; i < end; ++i) {
+    ret += String.fromCharCode(buf[i])
+  }
+  return ret
+}
+
+function hexSlice (buf, start, end) {
+  const len = buf.length
+
+  if (!start || start < 0) start = 0
+  if (!end || end < 0 || end > len) end = len
+
+  let out = ''
+  for (let i = start; i < end; ++i) {
+    out += hexSliceLookupTable[buf[i]]
+  }
+  return out
+}
+
+function utf16leSlice (buf, start, end) {
+  const bytes = buf.slice(start, end)
+  let res = ''
+  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
+  for (let i = 0; i < bytes.length - 1; i += 2) {
+    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
+  }
+  return res
+}
+
+Buffer.prototype.slice = function slice (start, end) {
+  const len = this.length
+  start = ~~start
+  end = end === undefined ? len : ~~end
+
+  if (start < 0) {
+    start += len
+    if (start < 0) start = 0
+  } else if (start > len) {
+    start = len
+  }
+
+  if (end < 0) {
+    end += len
+    if (end < 0) end = 0
+  } else if (end > len) {
+    end = len
+  }
+
+  if (end < start) end = start
+
+  const newBuf = this.subarray(start, end)
+  // Return an augmented `Uint8Array` instance
+  Object.setPrototypeOf(newBuf, Buffer.prototype)
+
+  return newBuf
+}
+
+/*
+ * Need to make sure that buffer isn't trying to write out of bounds.
+ */
+function checkOffset (offset, ext, length) {
+  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
+  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
+}
+
+Buffer.prototype.readUintLE =
+Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
+  offset = offset >>> 0
+  byteLength = byteLength >>> 0
+  if (!noAssert) checkOffset(offset, byteLength, this.length)
+
+  let val = this[offset]
+  let mul = 1
+  let i = 0
+  while (++i < byteLength && (mul *= 0x100)) {
+    val += this[offset + i] * mul
+  }
+
+  return val
+}
+
+Buffer.prototype.readUintBE =
+Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
+  offset = offset >>> 0
+  byteLength = byteLength >>> 0
+  if (!noAssert) {
+    checkOffset(offset, byteLength, this.length)
+  }
+
+  let val = this[offset + --byteLength]
+  let mul = 1
+  while (byteLength > 0 && (mul *= 0x100)) {
+    val += this[offset + --byteLength] * mul
+  }
+
+  return val
+}
+
+Buffer.prototype.readUint8 =
+Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
+  offset = offset >>> 0
+  if (!noAssert) checkOffset(offset, 1, this.length)
+  return this[offset]
+}
+
+Buffer.prototype.readUint16LE =
+Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
+  offset = offset >>> 0
+  if (!noAssert) checkOffset(offset, 2, this.length)
+  return this[offset] | (this[offset + 1] << 8)
+}
+
+Buffer.prototype.readUint16BE =
+Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
+  offset = offset >>> 0
+  if (!noAssert) checkOffset(offset, 2, this.length)
+  return (this[offset] << 8) | this[offset + 1]
+}
+
+Buffer.prototype.readUint32LE =
+Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
+  offset = offset >>> 0
+  if (!noAssert) checkOffset(offset, 4, this.length)
+
+  return ((this[offset]) |
+      (this[offset + 1] << 8) |
+      (this[offset + 2] << 16)) +
+      (this[offset + 3] * 0x1000000)
+}
+
+Buffer.prototype.readUint32BE =
+Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
+  offset = offset >>> 0
+  if (!noAssert) checkOffset(offset, 4, this.length)
+
+  return (this[offset] * 0x1000000) +
+    ((this[offset + 1] << 16) |
+    (this[offset + 2] << 8) |
+    this[offset + 3])
+}
+
+Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {
+  offset = offset >>> 0
+  validateNumber(offset, 'offset')
+  const first = this[offset]
+  const last = this[offset + 7]
+  if (first === undefined || last === undefined) {
+    boundsError(offset, this.length - 8)
+  }
+
+  const lo = first +
+    this[++offset] * 2 ** 8 +
+    this[++offset] * 2 ** 16 +
+    this[++offset] * 2 ** 24
+
+  const hi = this[++offset] +
+    this[++offset] * 2 ** 8 +
+    this[++offset] * 2 ** 16 +
+    last * 2 ** 24
+
+  return BigInt(lo) + (BigInt(hi) << BigInt(32))
+})
+
+Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {
+  offset = offset >>> 0
+  validateNumber(offset, 'offset')
+  const first = this[offset]
+  const last = this[offset + 7]
+  if (first === undefined || last === undefined) {
+    boundsError(offset, this.length - 8)
+  }
+
+  const hi = first * 2 ** 24 +
+    this[++offset] * 2 ** 16 +
+    this[++offset] * 2 ** 8 +
+    this[++offset]
+
+  const lo = this[++offset] * 2 ** 24 +
+    this[++offset] * 2 ** 16 +
+    this[++offset] * 2 ** 8 +
+    last
+
+  return (BigInt(hi) << BigInt(32)) + BigInt(lo)
+})
+
+Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
+  offset = offset >>> 0
+  byteLength = byteLength >>> 0
+  if (!noAssert) checkOffset(offset, byteLength, this.length)
+
+  let val = this[offset]
+  let mul = 1
+  let i = 0
+  while (++i < byteLength && (mul *= 0x100)) {
+    val += this[offset + i] * mul
+  }
+  mul *= 0x80
+
+  if (val >= mul) val -= Math.pow(2, 8 * byteLength)
+
+  return val
+}
+
+Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
+  offset = offset >>> 0
+  byteLength = byteLength >>> 0
+  if (!noAssert) checkOffset(offset, byteLength, this.length)
+
+  let i = byteLength
+  let mul = 1
+  let val = this[offset + --i]
+  while (i > 0 && (mul *= 0x100)) {
+    val += this[offset + --i] * mul
+  }
+  mul *= 0x80
+
+  if (val >= mul) val -= Math.pow(2, 8 * byteLength)
+
+  return val
+}
+
+Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
+  offset = offset >>> 0
+  if (!noAssert) checkOffset(offset, 1, this.length)
+  if (!(this[offset] & 0x80)) return (this[offset])
+  return ((0xff - this[offset] + 1) * -1)
+}
+
+Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
+  offset = offset >>> 0
+  if (!noAssert) checkOffset(offset, 2, this.length)
+  const val = this[offset] | (this[offset + 1] << 8)
+  return (val & 0x8000) ? val | 0xFFFF0000 : val
+}
+
+Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
+  offset = offset >>> 0
+  if (!noAssert) checkOffset(offset, 2, this.length)
+  const val = this[offset + 1] | (this[offset] << 8)
+  return (val & 0x8000) ? val | 0xFFFF0000 : val
+}
+
+Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
+  offset = offset >>> 0
+  if (!noAssert) checkOffset(offset, 4, this.length)
+
+  return (this[offset]) |
+    (this[offset + 1] << 8) |
+    (this[offset + 2] << 16) |
+    (this[offset + 3] << 24)
+}
+
+Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
+  offset = offset >>> 0
+  if (!noAssert) checkOffset(offset, 4, this.length)
+
+  return (this[offset] << 24) |
+    (this[offset + 1] << 16) |
+    (this[offset + 2] << 8) |
+    (this[offset + 3])
+}
+
+Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {
+  offset = offset >>> 0
+  validateNumber(offset, 'offset')
+  const first = this[offset]
+  const last = this[offset + 7]
+  if (first === undefined || last === undefined) {
+    boundsError(offset, this.length - 8)
+  }
+
+  const val = this[offset + 4] +
+    this[offset + 5] * 2 ** 8 +
+    this[offset + 6] * 2 ** 16 +
+    (last << 24) // Overflow
+
+  return (BigInt(val) << BigInt(32)) +
+    BigInt(first +
+    this[++offset] * 2 ** 8 +
+    this[++offset] * 2 ** 16 +
+    this[++offset] * 2 ** 24)
+})
+
+Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {
+  offset = offset >>> 0
+  validateNumber(offset, 'offset')
+  const first = this[offset]
+  const last = this[offset + 7]
+  if (first === undefined || last === undefined) {
+    boundsError(offset, this.length - 8)
+  }
+
+  const val = (first << 24) + // Overflow
+    this[++offset] * 2 ** 16 +
+    this[++offset] * 2 ** 8 +
+    this[++offset]
+
+  return (BigInt(val) << BigInt(32)) +
+    BigInt(this[++offset] * 2 ** 24 +
+    this[++offset] * 2 ** 16 +
+    this[++offset] * 2 ** 8 +
+    last)
+})
+
+Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
+  offset = offset >>> 0
+  if (!noAssert) checkOffset(offset, 4, this.length)
+  return ieee754.read(this, offset, true, 23, 4)
+}
+
+Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
+  offset = offset >>> 0
+  if (!noAssert) checkOffset(offset, 4, this.length)
+  return ieee754.read(this, offset, false, 23, 4)
+}
+
+Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
+  offset = offset >>> 0
+  if (!noAssert) checkOffset(offset, 8, this.length)
+  return ieee754.read(this, offset, true, 52, 8)
+}
+
+Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
+  offset = offset >>> 0
+  if (!noAssert) checkOffset(offset, 8, this.length)
+  return ieee754.read(this, offset, false, 52, 8)
+}
+
+function checkInt (buf, value, offset, ext, max, min) {
+  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
+  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
+  if (offset + ext > buf.length) throw new RangeError('Index out of range')
+}
+
+Buffer.prototype.writeUintLE =
+Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
+  value = +value
+  offset = offset >>> 0
+  byteLength = byteLength >>> 0
+  if (!noAssert) {
+    const maxBytes = Math.pow(2, 8 * byteLength) - 1
+    checkInt(this, value, offset, byteLength, maxBytes, 0)
+  }
+
+  let mul = 1
+  let i = 0
+  this[offset] = value & 0xFF
+  while (++i < byteLength && (mul *= 0x100)) {
+    this[offset + i] = (value / mul) & 0xFF
+  }
+
+  return offset + byteLength
+}
+
+Buffer.prototype.writeUintBE =
+Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
+  value = +value
+  offset = offset >>> 0
+  byteLength = byteLength >>> 0
+  if (!noAssert) {
+    const maxBytes = Math.pow(2, 8 * byteLength) - 1
+    checkInt(this, value, offset, byteLength, maxBytes, 0)
+  }
+
+  let i = byteLength - 1
+  let mul = 1
+  this[offset + i] = value & 0xFF
+  while (--i >= 0 && (mul *= 0x100)) {
+    this[offset + i] = (value / mul) & 0xFF
+  }
+
+  return offset + byteLength
+}
+
+Buffer.prototype.writeUint8 =
+Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
+  value = +value
+  offset = offset >>> 0
+  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
+  this[offset] = (value & 0xff)
+  return offset + 1
+}
+
+Buffer.prototype.writeUint16LE =
+Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
+  value = +value
+  offset = offset >>> 0
+  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
+  this[offset] = (value & 0xff)
+  this[offset + 1] = (value >>> 8)
+  return offset + 2
+}
+
+Buffer.prototype.writeUint16BE =
+Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
+  value = +value
+  offset = offset >>> 0
+  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
+  this[offset] = (value >>> 8)
+  this[offset + 1] = (value & 0xff)
+  return offset + 2
+}
+
+Buffer.prototype.writeUint32LE =
+Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
+  value = +value
+  offset = offset >>> 0
+  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
+  this[offset + 3] = (value >>> 24)
+  this[offset + 2] = (value >>> 16)
+  this[offset + 1] = (value >>> 8)
+  this[offset] = (value & 0xff)
+  return offset + 4
+}
+
+Buffer.prototype.writeUint32BE =
+Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
+  value = +value
+  offset = offset >>> 0
+  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
+  this[offset] = (value >>> 24)
+  this[offset + 1] = (value >>> 16)
+  this[offset + 2] = (value >>> 8)
+  this[offset + 3] = (value & 0xff)
+  return offset + 4
+}
+
+function wrtBigUInt64LE (buf, value, offset, min, max) {
+  checkIntBI(value, min, max, buf, offset, 7)
+
+  let lo = Number(value & BigInt(0xffffffff))
+  buf[offset++] = lo
+  lo = lo >> 8
+  buf[offset++] = lo
+  lo = lo >> 8
+  buf[offset++] = lo
+  lo = lo >> 8
+  buf[offset++] = lo
+  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))
+  buf[offset++] = hi
+  hi = hi >> 8
+  buf[offset++] = hi
+  hi = hi >> 8
+  buf[offset++] = hi
+  hi = hi >> 8
+  buf[offset++] = hi
+  return offset
+}
+
+function wrtBigUInt64BE (buf, value, offset, min, max) {
+  checkIntBI(value, min, max, buf, offset, 7)
+
+  let lo = Number(value & BigInt(0xffffffff))
+  buf[offset + 7] = lo
+  lo = lo >> 8
+  buf[offset + 6] = lo
+  lo = lo >> 8
+  buf[offset + 5] = lo
+  lo = lo >> 8
+  buf[offset + 4] = lo
+  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))
+  buf[offset + 3] = hi
+  hi = hi >> 8
+  buf[offset + 2] = hi
+  hi = hi >> 8
+  buf[offset + 1] = hi
+  hi = hi >> 8
+  buf[offset] = hi
+  return offset + 8
+}
+
+Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {
+  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))
+})
+
+Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {
+  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))
+})
+
+Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
+  value = +value
+  offset = offset >>> 0
+  if (!noAssert) {
+    const limit = Math.pow(2, (8 * byteLength) - 1)
+
+    checkInt(this, value, offset, byteLength, limit - 1, -limit)
+  }
+
+  let i = 0
+  let mul = 1
+  let sub = 0
+  this[offset] = value & 0xFF
+  while (++i < byteLength && (mul *= 0x100)) {
+    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
+      sub = 1
+    }
+    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
+  }
+
+  return offset + byteLength
+}
+
+Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
+  value = +value
+  offset = offset >>> 0
+  if (!noAssert) {
+    const limit = Math.pow(2, (8 * byteLength) - 1)
+
+    checkInt(this, value, offset, byteLength, limit - 1, -limit)
+  }
+
+  let i = byteLength - 1
+  let mul = 1
+  let sub = 0
+  this[offset + i] = value & 0xFF
+  while (--i >= 0 && (mul *= 0x100)) {
+    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
+      sub = 1
+    }
+    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
+  }
+
+  return offset + byteLength
+}
+
+Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
+  value = +value
+  offset = offset >>> 0
+  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
+  if (value < 0) value = 0xff + value + 1
+  this[offset] = (value & 0xff)
+  return offset + 1
+}
+
+Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
+  value = +value
+  offset = offset >>> 0
+  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
+  this[offset] = (value & 0xff)
+  this[offset + 1] = (value >>> 8)
+  return offset + 2
+}
+
+Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
+  value = +value
+  offset = offset >>> 0
+  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
+  this[offset] = (value >>> 8)
+  this[offset + 1] = (value & 0xff)
+  return offset + 2
+}
+
+Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
+  value = +value
+  offset = offset >>> 0
+  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
+  this[offset] = (value & 0xff)
+  this[offset + 1] = (value >>> 8)
+  this[offset + 2] = (value >>> 16)
+  this[offset + 3] = (value >>> 24)
+  return offset + 4
+}
+
+Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
+  value = +value
+  offset = offset >>> 0
+  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
+  if (value < 0) value = 0xffffffff + value + 1
+  this[offset] = (value >>> 24)
+  this[offset + 1] = (value >>> 16)
+  this[offset + 2] = (value >>> 8)
+  this[offset + 3] = (value & 0xff)
+  return offset + 4
+}
+
+Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {
+  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
+})
+
+Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {
+  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
+})
+
+function checkIEEE754 (buf, value, offset, ext, max, min) {
+  if (offset + ext > buf.length) throw new RangeError('Index out of range')
+  if (offset < 0) throw new RangeError('Index out of range')
+}
+
+function writeFloat (buf, value, offset, littleEndian, noAssert) {
+  value = +value
+  offset = offset >>> 0
+  if (!noAssert) {
+    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
+  }
+  ieee754.write(buf, value, offset, littleEndian, 23, 4)
+  return offset + 4
+}
+
+Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
+  return writeFloat(this, value, offset, true, noAssert)
+}
+
+Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
+  return writeFloat(this, value, offset, false, noAssert)
+}
+
+function writeDouble (buf, value, offset, littleEndian, noAssert) {
+  value = +value
+  offset = offset >>> 0
+  if (!noAssert) {
+    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
+  }
+  ieee754.write(buf, value, offset, littleEndian, 52, 8)
+  return offset + 8
+}
+
+Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
+  return writeDouble(this, value, offset, true, noAssert)
+}
+
+Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
+  return writeDouble(this, value, offset, false, noAssert)
+}
+
+// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
+Buffer.prototype.copy = function copy (target, targetStart, start, end) {
+  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
+  if (!start) start = 0
+  if (!end && end !== 0) end = this.length
+  if (targetStart >= target.length) targetStart = target.length
+  if (!targetStart) targetStart = 0
+  if (end > 0 && end < start) end = start
+
+  // Copy 0 bytes; we're done
+  if (end === start) return 0
+  if (target.length === 0 || this.length === 0) return 0
+
+  // Fatal error conditions
+  if (targetStart < 0) {
+    throw new RangeError('targetStart out of bounds')
+  }
+  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
+  if (end < 0) throw new RangeError('sourceEnd out of bounds')
+
+  // Are we oob?
+  if (end > this.length) end = this.length
+  if (target.length - targetStart < end - start) {
+    end = target.length - targetStart + start
+  }
+
+  const len = end - start
+
+  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
+    // Use built-in when available, missing from IE11
+    this.copyWithin(targetStart, start, end)
+  } else {
+    Uint8Array.prototype.set.call(
+      target,
+      this.subarray(start, end),
+      targetStart
+    )
+  }
+
+  return len
+}
+
+// Usage:
+//    buffer.fill(number[, offset[, end]])
+//    buffer.fill(buffer[, offset[, end]])
+//    buffer.fill(string[, offset[, end]][, encoding])
+Buffer.prototype.fill = function fill (val, start, end, encoding) {
+  // Handle string cases:
+  if (typeof val === 'string') {
+    if (typeof start === 'string') {
+      encoding = start
+      start = 0
+      end = this.length
+    } else if (typeof end === 'string') {
+      encoding = end
+      end = this.length
+    }
+    if (encoding !== undefined && typeof encoding !== 'string') {
+      throw new TypeError('encoding must be a string')
+    }
+    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
+      throw new TypeError('Unknown encoding: ' + encoding)
+    }
+    if (val.length === 1) {
+      const code = val.charCodeAt(0)
+      if ((encoding === 'utf8' && code < 128) ||
+          encoding === 'latin1') {
+        // Fast path: If `val` fits into a single byte, use that numeric value.
+        val = code
+      }
+    }
+  } else if (typeof val === 'number') {
+    val = val & 255
+  } else if (typeof val === 'boolean') {
+    val = Number(val)
+  }
+
+  // Invalid ranges are not set to a default, so can range check early.
+  if (start < 0 || this.length < start || this.length < end) {
+    throw new RangeError('Out of range index')
+  }
+
+  if (end <= start) {
+    return this
+  }
+
+  start = start >>> 0
+  end = end === undefined ? this.length : end >>> 0
+
+  if (!val) val = 0
+
+  let i
+  if (typeof val === 'number') {
+    for (i = start; i < end; ++i) {
+      this[i] = val
+    }
+  } else {
+    const bytes = Buffer.isBuffer(val)
+      ? val
+      : Buffer.from(val, encoding)
+    const len = bytes.length
+    if (len === 0) {
+      throw new TypeError('The value "' + val +
+        '" is invalid for argument "value"')
+    }
+    for (i = 0; i < end - start; ++i) {
+      this[i + start] = bytes[i % len]
+    }
+  }
+
+  return this
+}
+
+// CUSTOM ERRORS
+// =============
+
+// Simplified versions from Node, changed for Buffer-only usage
+const errors = {}
+function E (sym, getMessage, Base) {
+  errors[sym] = class NodeError extends Base {
+    constructor () {
+      super()
+
+      Object.defineProperty(this, 'message', {
+        value: getMessage.apply(this, arguments),
+        writable: true,
+        configurable: true
+      })
+
+      // Add the error code to the name to include it in the stack trace.
+      this.name = `${this.name} [${sym}]`
+      // Access the stack to generate the error message including the error code
+      // from the name.
+      this.stack // eslint-disable-line no-unused-expressions
+      // Reset the name to the actual name.
+      delete this.name
+    }
+
+    get code () {
+      return sym
+    }
+
+    set code (value) {
+      Object.defineProperty(this, 'code', {
+        configurable: true,
+        enumerable: true,
+        value,
+        writable: true
+      })
+    }
+
+    toString () {
+      return `${this.name} [${sym}]: ${this.message}`
+    }
+  }
+}
+
+E('ERR_BUFFER_OUT_OF_BOUNDS',
+  function (name) {
+    if (name) {
+      return `${name} is outside of buffer bounds`
+    }
+
+    return 'Attempt to access memory outside buffer bounds'
+  }, RangeError)
+E('ERR_INVALID_ARG_TYPE',
+  function (name, actual) {
+    return `The "${name}" argument must be of type number. Received type ${typeof actual}`
+  }, TypeError)
+E('ERR_OUT_OF_RANGE',
+  function (str, range, input) {
+    let msg = `The value of "${str}" is out of range.`
+    let received = input
+    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
+      received = addNumericalSeparator(String(input))
+    } else if (typeof input === 'bigint') {
+      received = String(input)
+      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
+        received = addNumericalSeparator(received)
+      }
+      received += 'n'
+    }
+    msg += ` It must be ${range}. Received ${received}`
+    return msg
+  }, RangeError)
+
+function addNumericalSeparator (val) {
+  let res = ''
+  let i = val.length
+  const start = val[0] === '-' ? 1 : 0
+  for (; i >= start + 4; i -= 3) {
+    res = `_${val.slice(i - 3, i)}${res}`
+  }
+  return `${val.slice(0, i)}${res}`
+}
+
+// CHECK FUNCTIONS
+// ===============
+
+function checkBounds (buf, offset, byteLength) {
+  validateNumber(offset, 'offset')
+  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {
+    boundsError(offset, buf.length - (byteLength + 1))
+  }
+}
+
+function checkIntBI (value, min, max, buf, offset, byteLength) {
+  if (value > max || value < min) {
+    const n = typeof min === 'bigint' ? 'n' : ''
+    let range
+    if (byteLength > 3) {
+      if (min === 0 || min === BigInt(0)) {
+        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`
+      } else {
+        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +
+                `${(byteLength + 1) * 8 - 1}${n}`
+      }
+    } else {
+      range = `>= ${min}${n} and <= ${max}${n}`
+    }
+    throw new errors.ERR_OUT_OF_RANGE('value', range, value)
+  }
+  checkBounds(buf, offset, byteLength)
+}
+
+function validateNumber (value, name) {
+  if (typeof value !== 'number') {
+    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)
+  }
+}
+
+function boundsError (value, length, type) {
+  if (Math.floor(value) !== value) {
+    validateNumber(value, type)
+    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)
+  }
+
+  if (length < 0) {
+    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()
+  }
+
+  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',
+                                    `>= ${type ? 1 : 0} and <= ${length}`,
+                                    value)
+}
+
+// HELPER FUNCTIONS
+// ================
+
+const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g
+
+function base64clean (str) {
+  // Node takes equal signs as end of the Base64 encoding
+  str = str.split('=')[0]
+  // Node strips out invalid characters like \n and \t from the string, base64-js does not
+  str = str.trim().replace(INVALID_BASE64_RE, '')
+  // Node converts strings with length < 2 to ''
+  if (str.length < 2) return ''
+  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
+  while (str.length % 4 !== 0) {
+    str = str + '='
+  }
+  return str
+}
+
+function utf8ToBytes (string, units) {
+  units = units || Infinity
+  let codePoint
+  const length = string.length
+  let leadSurrogate = null
+  const bytes = []
+
+  for (let i = 0; i < length; ++i) {
+    codePoint = string.charCodeAt(i)
+
+    // is surrogate component
+    if (codePoint > 0xD7FF && codePoint < 0xE000) {
+      // last char was a lead
+      if (!leadSurrogate) {
+        // no lead yet
+        if (codePoint > 0xDBFF) {
+          // unexpected trail
+          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
+          continue
+        } else if (i + 1 === length) {
+          // unpaired lead
+          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
+          continue
+        }
+
+        // valid lead
+        leadSurrogate = codePoint
+
+        continue
+      }
+
+      // 2 leads in a row
+      if (codePoint < 0xDC00) {
+        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
+        leadSurrogate = codePoint
+        continue
+      }
+
+      // valid surrogate pair
+      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
+    } else if (leadSurrogate) {
+      // valid bmp char, but last char was a lead
+      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
+    }
+
+    leadSurrogate = null
+
+    // encode utf8
+    if (codePoint < 0x80) {
+      if ((units -= 1) < 0) break
+      bytes.push(codePoint)
+    } else if (codePoint < 0x800) {
+      if ((units -= 2) < 0) break
+      bytes.push(
+        codePoint >> 0x6 | 0xC0,
+        codePoint & 0x3F | 0x80
+      )
+    } else if (codePoint < 0x10000) {
+      if ((units -= 3) < 0) break
+      bytes.push(
+        codePoint >> 0xC | 0xE0,
+        codePoint >> 0x6 & 0x3F | 0x80,
+        codePoint & 0x3F | 0x80
+      )
+    } else if (codePoint < 0x110000) {
+      if ((units -= 4) < 0) break
+      bytes.push(
+        codePoint >> 0x12 | 0xF0,
+        codePoint >> 0xC & 0x3F | 0x80,
+        codePoint >> 0x6 & 0x3F | 0x80,
+        codePoint & 0x3F | 0x80
+      )
+    } else {
+      throw new Error('Invalid code point')
+    }
+  }
+
+  return bytes
+}
+
+function asciiToBytes (str) {
+  const byteArray = []
+  for (let i = 0; i < str.length; ++i) {
+    // Node's code seems to be doing this and not & 0x7F..
+    byteArray.push(str.charCodeAt(i) & 0xFF)
+  }
+  return byteArray
+}
+
+function utf16leToBytes (str, units) {
+  let c, hi, lo
+  const byteArray = []
+  for (let i = 0; i < str.length; ++i) {
+    if ((units -= 2) < 0) break
+
+    c = str.charCodeAt(i)
+    hi = c >> 8
+    lo = c % 256
+    byteArray.push(lo)
+    byteArray.push(hi)
+  }
+
+  return byteArray
+}
+
+function base64ToBytes (str) {
+  return base64.toByteArray(base64clean(str))
+}
+
+function blitBuffer (src, dst, offset, length) {
+  let i
+  for (i = 0; i < length; ++i) {
+    if ((i + offset >= dst.length) || (i >= src.length)) break
+    dst[i + offset] = src[i]
+  }
+  return i
+}
+
+// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
+// the `instanceof` check but they should be treated as of that type.
+// See: https://github.com/feross/buffer/issues/166
+function isInstance (obj, type) {
+  return obj instanceof type ||
+    (obj != null && obj.constructor != null && obj.constructor.name != null &&
+      obj.constructor.name === type.name)
+}
+function numberIsNaN (obj) {
+  // For IE11 support
+  return obj !== obj // eslint-disable-line no-self-compare
+}
+
+// Create lookup table for `toString('hex')`
+// See: https://github.com/feross/buffer/issues/219
+const hexSliceLookupTable = (function () {
+  const alphabet = '0123456789abcdef'
+  const table = new Array(256)
+  for (let i = 0; i < 16; ++i) {
+    const i16 = i * 16
+    for (let j = 0; j < 16; ++j) {
+      table[i16 + j] = alphabet[i] + alphabet[j]
+    }
+  }
+  return table
+})()
+
+// Return not function with Error if BigInt not supported
+function defineBigIntMethod (fn) {
+  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn
+}
+
+function BufferBigIntNotDefined () {
+  throw new Error('BigInt not supported')
+}
+
+
+/***/ }),
+
+/***/ 488:
+/***/ ((module) => {
+
+"use strict";
+// Copyright Joyent, Inc. and other Node contributors.
+//
+// Permission is hereby granted, free of charge, to any person obtaining a
+// copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to permit
+// persons to whom the Software is furnished to do so, subject to the
+// following conditions:
+//
+// The above copyright notice and this permission notice shall be included
+// in all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
+// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
+// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
+// USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+
+
+var R = typeof Reflect === 'object' ? Reflect : null
+var ReflectApply = R && typeof R.apply === 'function'
+  ? R.apply
+  : function ReflectApply(target, receiver, args) {
+    return Function.prototype.apply.call(target, receiver, args);
+  }
+
+var ReflectOwnKeys
+if (R && typeof R.ownKeys === 'function') {
+  ReflectOwnKeys = R.ownKeys
+} else if (Object.getOwnPropertySymbols) {
+  ReflectOwnKeys = function ReflectOwnKeys(target) {
+    return Object.getOwnPropertyNames(target)
+      .concat(Object.getOwnPropertySymbols(target));
+  };
+} else {
+  ReflectOwnKeys = function ReflectOwnKeys(target) {
+    return Object.getOwnPropertyNames(target);
+  };
+}
+
+function ProcessEmitWarning(warning) {
+  if (console && console.warn) console.warn(warning);
+}
+
+var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
+  return value !== value;
+}
+
+function EventEmitter() {
+  EventEmitter.init.call(this);
+}
+module.exports = EventEmitter;
+module.exports.once = once;
+
+// Backwards-compat with node 0.10.x
+EventEmitter.EventEmitter = EventEmitter;
+
+EventEmitter.prototype._events = undefined;
+EventEmitter.prototype._eventsCount = 0;
+EventEmitter.prototype._maxListeners = undefined;
+
+// By default EventEmitters will print a warning if more than 10 listeners are
+// added to it. This is a useful default which helps finding memory leaks.
+var defaultMaxListeners = 10;
+
+function checkListener(listener) {
+  if (typeof listener !== 'function') {
+    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
+  }
+}
+
+Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
+  enumerable: true,
+  get: function() {
+    return defaultMaxListeners;
+  },
+  set: function(arg) {
+    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
+      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
+    }
+    defaultMaxListeners = arg;
+  }
+});
+
+EventEmitter.init = function() {
+
+  if (this._events === undefined ||
+      this._events === Object.getPrototypeOf(this)._events) {
+    this._events = Object.create(null);
+    this._eventsCount = 0;
+  }
+
+  this._maxListeners = this._maxListeners || undefined;
+};
+
+// Obviously not all Emitters should be limited to 10. This function allows
+// that to be increased. Set to zero for unlimited.
+EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
+  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
+    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
+  }
+  this._maxListeners = n;
+  return this;
+};
+
+function _getMaxListeners(that) {
+  if (that._maxListeners === undefined)
+    return EventEmitter.defaultMaxListeners;
+  return that._maxListeners;
+}
+
+EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
+  return _getMaxListeners(this);
+};
+
+EventEmitter.prototype.emit = function emit(type) {
+  var args = [];
+  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
+  var doError = (type === 'error');
+
+  var events = this._events;
+  if (events !== undefined)
+    doError = (doError && events.error === undefined);
+  else if (!doError)
+    return false;
+
+  // If there is no 'error' event listener then throw.
+  if (doError) {
+    var er;
+    if (args.length > 0)
+      er = args[0];
+    if (er instanceof Error) {
+      // Note: The comments on the `throw` lines are intentional, they show
+      // up in Node's output if this results in an unhandled exception.
+      throw er; // Unhandled 'error' event
+    }
+    // At least give some kind of context to the user
+    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
+    err.context = er;
+    throw err; // Unhandled 'error' event
+  }
+
+  var handler = events[type];
+
+  if (handler === undefined)
+    return false;
+
+  if (typeof handler === 'function') {
+    ReflectApply(handler, this, args);
+  } else {
+    var len = handler.length;
+    var listeners = arrayClone(handler, len);
+    for (var i = 0; i < len; ++i)
+      ReflectApply(listeners[i], this, args);
+  }
+
+  return true;
+};
+
+function _addListener(target, type, listener, prepend) {
+  var m;
+  var events;
+  var existing;
+
+  checkListener(listener);
+
+  events = target._events;
+  if (events === undefined) {
+    events = target._events = Object.create(null);
+    target._eventsCount = 0;
+  } else {
+    // To avoid recursion in the case that type === "newListener"! Before
+    // adding it to the listeners, first emit "newListener".
+    if (events.newListener !== undefined) {
+      target.emit('newListener', type,
+                  listener.listener ? listener.listener : listener);
+
+      // Re-assign `events` because a newListener handler could have caused the
+      // this._events to be assigned to a new object
+      events = target._events;
+    }
+    existing = events[type];
+  }
+
+  if (existing === undefined) {
+    // Optimize the case of one listener. Don't need the extra array object.
+    existing = events[type] = listener;
+    ++target._eventsCount;
+  } else {
+    if (typeof existing === 'function') {
+      // Adding the second element, need to change to array.
+      existing = events[type] =
+        prepend ? [listener, existing] : [existing, listener];
+      // If we've already got an array, just append.
+    } else if (prepend) {
+      existing.unshift(listener);
+    } else {
+      existing.push(listener);
+    }
+
+    // Check for listener leak
+    m = _getMaxListeners(target);
+    if (m > 0 && existing.length > m && !existing.warned) {
+      existing.warned = true;
+      // No error code for this since it is a Warning
+      // eslint-disable-next-line no-restricted-syntax
+      var w = new Error('Possible EventEmitter memory leak detected. ' +
+                          existing.length + ' ' + String(type) + ' listeners ' +
+                          'added. Use emitter.setMaxListeners() to ' +
+                          'increase limit');
+      w.name = 'MaxListenersExceededWarning';
+      w.emitter = target;
+      w.type = type;
+      w.count = existing.length;
+      ProcessEmitWarning(w);
+    }
+  }
+
+  return target;
+}
+
+EventEmitter.prototype.addListener = function addListener(type, listener) {
+  return _addListener(this, type, listener, false);
+};
+
+EventEmitter.prototype.on = EventEmitter.prototype.addListener;
+
+EventEmitter.prototype.prependListener =
+    function prependListener(type, listener) {
+      return _addListener(this, type, listener, true);
+    };
+
+function onceWrapper() {
+  if (!this.fired) {
+    this.target.removeListener(this.type, this.wrapFn);
+    this.fired = true;
+    if (arguments.length === 0)
+      return this.listener.call(this.target);
+    return this.listener.apply(this.target, arguments);
+  }
+}
+
+function _onceWrap(target, type, listener) {
+  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
+  var wrapped = onceWrapper.bind(state);
+  wrapped.listener = listener;
+  state.wrapFn = wrapped;
+  return wrapped;
+}
+
+EventEmitter.prototype.once = function once(type, listener) {
+  checkListener(listener);
+  this.on(type, _onceWrap(this, type, listener));
+  return this;
+};
+
+EventEmitter.prototype.prependOnceListener =
+    function prependOnceListener(type, listener) {
+      checkListener(listener);
+      this.prependListener(type, _onceWrap(this, type, listener));
+      return this;
+    };
+
+// Emits a 'removeListener' event if and only if the listener was removed.
+EventEmitter.prototype.removeListener =
+    function removeListener(type, listener) {
+      var list, events, position, i, originalListener;
+
+      checkListener(listener);
+
+      events = this._events;
+      if (events === undefined)
+        return this;
+
+      list = events[type];
+      if (list === undefined)
+        return this;
+
+      if (list === listener || list.listener === listener) {
+        if (--this._eventsCount === 0)
+          this._events = Object.create(null);
+        else {
+          delete events[type];
+          if (events.removeListener)
+            this.emit('removeListener', type, list.listener || listener);
+        }
+      } else if (typeof list !== 'function') {
+        position = -1;
+
+        for (i = list.length - 1; i >= 0; i--) {
+          if (list[i] === listener || list[i].listener === listener) {
+            originalListener = list[i].listener;
+            position = i;
+            break;
+          }
+        }
+
+        if (position < 0)
+          return this;
+
+        if (position === 0)
+          list.shift();
+        else {
+          spliceOne(list, position);
+        }
+
+        if (list.length === 1)
+          events[type] = list[0];
+
+        if (events.removeListener !== undefined)
+          this.emit('removeListener', type, originalListener || listener);
+      }
+
+      return this;
+    };
+
+EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
+
+EventEmitter.prototype.removeAllListeners =
+    function removeAllListeners(type) {
+      var listeners, events, i;
+
+      events = this._events;
+      if (events === undefined)
+        return this;
+
+      // not listening for removeListener, no need to emit
+      if (events.removeListener === undefined) {
+        if (arguments.length === 0) {
+          this._events = Object.create(null);
+          this._eventsCount = 0;
+        } else if (events[type] !== undefined) {
+          if (--this._eventsCount === 0)
+            this._events = Object.create(null);
+          else
+            delete events[type];
+        }
+        return this;
+      }
+
+      // emit removeListener for all listeners on all events
+      if (arguments.length === 0) {
+        var keys = Object.keys(events);
+        var key;
+        for (i = 0; i < keys.length; ++i) {
+          key = keys[i];
+          if (key === 'removeListener') continue;
+          this.removeAllListeners(key);
+        }
+        this.removeAllListeners('removeListener');
+        this._events = Object.create(null);
+        this._eventsCount = 0;
+        return this;
+      }
+
+      listeners = events[type];
+
+      if (typeof listeners === 'function') {
+        this.removeListener(type, listeners);
+      } else if (listeners !== undefined) {
+        // LIFO order
+        for (i = listeners.length - 1; i >= 0; i--) {
+          this.removeListener(type, listeners[i]);
+        }
+      }
+
+      return this;
+    };
+
+function _listeners(target, type, unwrap) {
+  var events = target._events;
+
+  if (events === undefined)
+    return [];
+
+  var evlistener = events[type];
+  if (evlistener === undefined)
+    return [];
+
+  if (typeof evlistener === 'function')
+    return unwrap ? [evlistener.listener || evlistener] : [evlistener];
+
+  return unwrap ?
+    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
+}
+
+EventEmitter.prototype.listeners = function listeners(type) {
+  return _listeners(this, type, true);
+};
+
+EventEmitter.prototype.rawListeners = function rawListeners(type) {
+  return _listeners(this, type, false);
+};
+
+EventEmitter.listenerCount = function(emitter, type) {
+  if (typeof emitter.listenerCount === 'function') {
+    return emitter.listenerCount(type);
+  } else {
+    return listenerCount.call(emitter, type);
+  }
+};
+
+EventEmitter.prototype.listenerCount = listenerCount;
+function listenerCount(type) {
+  var events = this._events;
+
+  if (events !== undefined) {
+    var evlistener = events[type];
+
+    if (typeof evlistener === 'function') {
+      return 1;
+    } else if (evlistener !== undefined) {
+      return evlistener.length;
+    }
+  }
+
+  return 0;
+}
+
+EventEmitter.prototype.eventNames = function eventNames() {
+  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
+};
+
+function arrayClone(arr, n) {
+  var copy = new Array(n);
+  for (var i = 0; i < n; ++i)
+    copy[i] = arr[i];
+  return copy;
+}
+
+function spliceOne(list, index) {
+  for (; index + 1 < list.length; index++)
+    list[index] = list[index + 1];
+  list.pop();
+}
+
+function unwrapListeners(arr) {
+  var ret = new Array(arr.length);
+  for (var i = 0; i < ret.length; ++i) {
+    ret[i] = arr[i].listener || arr[i];
+  }
+  return ret;
+}
+
+function once(emitter, name) {
+  return new Promise(function (resolve, reject) {
+    function eventListener() {
+      if (errorListener !== undefined) {
+        emitter.removeListener('error', errorListener);
+      }
+      resolve([].slice.call(arguments));
+    };
+    var errorListener;
+
+    // Adding an error listener is not optional because
+    // if an error is thrown on an event emitter we cannot
+    // guarantee that the actual event we are waiting will
+    // be fired. The result could be a silent way to create
+    // memory or file descriptor leaks, which is something
+    // we should avoid.
+    if (name !== 'error') {
+      errorListener = function errorListener(err) {
+        emitter.removeListener(name, eventListener);
+        reject(err);
+      };
+
+      emitter.once('error', errorListener);
+    }
+
+    emitter.once(name, eventListener);
+  });
+}
+
+
+/***/ }),
+
+/***/ 9258:
+/***/ ((__unused_webpack_module, exports) => {
+
+/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
+exports.read = function (buffer, offset, isLE, mLen, nBytes) {
+  var e, m
+  var eLen = (nBytes * 8) - mLen - 1
+  var eMax = (1 << eLen) - 1
+  var eBias = eMax >> 1
+  var nBits = -7
+  var i = isLE ? (nBytes - 1) : 0
+  var d = isLE ? -1 : 1
+  var s = buffer[offset + i]
+
+  i += d
+
+  e = s & ((1 << (-nBits)) - 1)
+  s >>= (-nBits)
+  nBits += eLen
+  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}
+
+  m = e & ((1 << (-nBits)) - 1)
+  e >>= (-nBits)
+  nBits += mLen
+  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}
+
+  if (e === 0) {
+    e = 1 - eBias
+  } else if (e === eMax) {
+    return m ? NaN : ((s ? -1 : 1) * Infinity)
+  } else {
+    m = m + Math.pow(2, mLen)
+    e = e - eBias
+  }
+  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
+}
+
+exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
+  var e, m, c
+  var eLen = (nBytes * 8) - mLen - 1
+  var eMax = (1 << eLen) - 1
+  var eBias = eMax >> 1
+  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
+  var i = isLE ? 0 : (nBytes - 1)
+  var d = isLE ? 1 : -1
+  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0
+
+  value = Math.abs(value)
+
+  if (isNaN(value) || value === Infinity) {
+    m = isNaN(value) ? 1 : 0
+    e = eMax
+  } else {
+    e = Math.floor(Math.log(value) / Math.LN2)
+    if (value * (c = Math.pow(2, -e)) < 1) {
+      e--
+      c *= 2
+    }
+    if (e + eBias >= 1) {
+      value += rt / c
+    } else {
+      value += rt * Math.pow(2, 1 - eBias)
+    }
+    if (value * c >= 2) {
+      e++
+      c /= 2
+    }
+
+    if (e + eBias >= eMax) {
+      m = 0
+      e = eMax
+    } else if (e + eBias >= 1) {
+      m = ((value * c) - 1) * Math.pow(2, mLen)
+      e = e + eBias
+    } else {
+      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
+      e = 0
+    }
+  }
+
+  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}
+
+  e = (e << mLen) | m
+  eLen += mLen
+  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}
+
+  buffer[offset + i - d] |= s * 128
+}
+
+
+/***/ }),
+
+/***/ 3730:
+/***/ ((module) => {
+
+if (typeof Object.create === 'function') {
+  // implementation from standard node.js 'util' module
+  module.exports = function inherits(ctor, superCtor) {
+    if (superCtor) {
+      ctor.super_ = superCtor
+      ctor.prototype = Object.create(superCtor.prototype, {
+        constructor: {
+          value: ctor,
+          enumerable: false,
+          writable: true,
+          configurable: true
+        }
+      })
+    }
+  };
+} else {
+  // old school shim for old browsers
+  module.exports = function inherits(ctor, superCtor) {
+    if (superCtor) {
+      ctor.super_ = superCtor
+      var TempCtor = function () {}
+      TempCtor.prototype = superCtor.prototype
+      ctor.prototype = new TempCtor()
+      ctor.prototype.constructor = ctor
+    }
+  }
+}
+
+
+/***/ }),
+
+/***/ 6117:
+/***/ ((module) => {
+
+/**
+ * Helpers.
+ */
+
+var s = 1000;
+var m = s * 60;
+var h = m * 60;
+var d = h * 24;
+var w = d * 7;
+var y = d * 365.25;
+
+/**
+ * Parse or format the given `val`.
+ *
+ * Options:
+ *
+ *  - `long` verbose formatting [false]
+ *
+ * @param {String|Number} val
+ * @param {Object} [options]
+ * @throws {Error} throw an error if val is not a non-empty string or a number
+ * @return {String|Number}
+ * @api public
+ */
+
+module.exports = function(val, options) {
+  options = options || {};
+  var type = typeof val;
+  if (type === 'string' && val.length > 0) {
+    return parse(val);
+  } else if (type === 'number' && isFinite(val)) {
+    return options.long ? fmtLong(val) : fmtShort(val);
+  }
+  throw new Error(
+    'val is not a non-empty string or a valid number. val=' +
+      JSON.stringify(val)
+  );
+};
+
+/**
+ * Parse the given `str` and return milliseconds.
+ *
+ * @param {String} str
+ * @return {Number}
+ * @api private
+ */
+
+function parse(str) {
+  str = String(str);
+  if (str.length > 100) {
+    return;
+  }
+  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
+    str
+  );
+  if (!match) {
+    return;
+  }
+  var n = parseFloat(match[1]);
+  var type = (match[2] || 'ms').toLowerCase();
+  switch (type) {
+    case 'years':
+    case 'year':
+    case 'yrs':
+    case 'yr':
+    case 'y':
+      return n * y;
+    case 'weeks':
+    case 'week':
+    case 'w':
+      return n * w;
+    case 'days':
+    case 'day':
+    case 'd':
+      return n * d;
+    case 'hours':
+    case 'hour':
+    case 'hrs':
+    case 'hr':
+    case 'h':
+      return n * h;
+    case 'minutes':
+    case 'minute':
+    case 'mins':
+    case 'min':
+    case 'm':
+      return n * m;
+    case 'seconds':
+    case 'second':
+    case 'secs':
+    case 'sec':
+    case 's':
+      return n * s;
+    case 'milliseconds':
+    case 'millisecond':
+    case 'msecs':
+    case 'msec':
+    case 'ms':
+      return n;
+    default:
+      return undefined;
+  }
+}
+
+/**
+ * Short format for `ms`.
+ *
+ * @param {Number} ms
+ * @return {String}
+ * @api private
+ */
+
+function fmtShort(ms) {
+  var msAbs = Math.abs(ms);
+  if (msAbs >= d) {
+    return Math.round(ms / d) + 'd';
+  }
+  if (msAbs >= h) {
+    return Math.round(ms / h) + 'h';
+  }
+  if (msAbs >= m) {
+    return Math.round(ms / m) + 'm';
+  }
+  if (msAbs >= s) {
+    return Math.round(ms / s) + 's';
+  }
+  return ms + 'ms';
+}
+
+/**
+ * Long format for `ms`.
+ *
+ * @param {Number} ms
+ * @return {String}
+ * @api private
+ */
+
+function fmtLong(ms) {
+  var msAbs = Math.abs(ms);
+  if (msAbs >= d) {
+    return plural(ms, msAbs, d, 'day');
+  }
+  if (msAbs >= h) {
+    return plural(ms, msAbs, h, 'hour');
+  }
+  if (msAbs >= m) {
+    return plural(ms, msAbs, m, 'minute');
+  }
+  if (msAbs >= s) {
+    return plural(ms, msAbs, s, 'second');
+  }
+  return ms + ' ms';
+}
+
+/**
+ * Pluralization helper.
+ */
+
+function plural(ms, msAbs, n, name) {
+  var isPlural = msAbs >= n * 1.5;
+  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
+}
+
+
+/***/ }),
+
+/***/ 2695:
+/***/ ((module) => {
+
+// shim for using process in browser
+var process = module.exports = {};
+
+// cached from whatever global is present so that test runners that stub it
+// don't break things.  But we need to wrap it in a try catch in case it is
+// wrapped in strict mode code which doesn't define any globals.  It's inside a
+// function because try/catches deoptimize in certain engines.
+
+var cachedSetTimeout;
+var cachedClearTimeout;
+
+function defaultSetTimout() {
+    throw new Error('setTimeout has not been defined');
+}
+function defaultClearTimeout () {
+    throw new Error('clearTimeout has not been defined');
+}
+(function () {
+    try {
+        if (typeof setTimeout === 'function') {
+            cachedSetTimeout = setTimeout;
+        } else {
+            cachedSetTimeout = defaultSetTimout;
+        }
+    } catch (e) {
+        cachedSetTimeout = defaultSetTimout;
+    }
+    try {
+        if (typeof clearTimeout === 'function') {
+            cachedClearTimeout = clearTimeout;
+        } else {
+            cachedClearTimeout = defaultClearTimeout;
+        }
+    } catch (e) {
+        cachedClearTimeout = defaultClearTimeout;
+    }
+} ())
+function runTimeout(fun) {
+    if (cachedSetTimeout === setTimeout) {
+        //normal enviroments in sane situations
+        return setTimeout(fun, 0);
+    }
+    // if setTimeout wasn't available but was latter defined
+    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
+        cachedSetTimeout = setTimeout;
+        return setTimeout(fun, 0);
+    }
+    try {
+        // when when somebody has screwed with setTimeout but no I.E. maddness
+        return cachedSetTimeout(fun, 0);
+    } catch(e){
+        try {
+            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
+            return cachedSetTimeout.call(null, fun, 0);
+        } catch(e){
+            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
+            return cachedSetTimeout.call(this, fun, 0);
+        }
+    }
+
+
+}
+function runClearTimeout(marker) {
+    if (cachedClearTimeout === clearTimeout) {
+        //normal enviroments in sane situations
+        return clearTimeout(marker);
+    }
+    // if clearTimeout wasn't available but was latter defined
+    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
+        cachedClearTimeout = clearTimeout;
+        return clearTimeout(marker);
+    }
+    try {
+        // when when somebody has screwed with setTimeout but no I.E. maddness
+        return cachedClearTimeout(marker);
+    } catch (e){
+        try {
+            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
+            return cachedClearTimeout.call(null, marker);
+        } catch (e){
+            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
+            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
+            return cachedClearTimeout.call(this, marker);
+        }
+    }
+
+
+
+}
+var queue = [];
+var draining = false;
+var currentQueue;
+var queueIndex = -1;
+
+function cleanUpNextTick() {
+    if (!draining || !currentQueue) {
+        return;
+    }
+    draining = false;
+    if (currentQueue.length) {
+        queue = currentQueue.concat(queue);
+    } else {
+        queueIndex = -1;
+    }
+    if (queue.length) {
+        drainQueue();
+    }
+}
+
+function drainQueue() {
+    if (draining) {
+        return;
+    }
+    var timeout = runTimeout(cleanUpNextTick);
+    draining = true;
+
+    var len = queue.length;
+    while(len) {
+        currentQueue = queue;
+        queue = [];
+        while (++queueIndex < len) {
+            if (currentQueue) {
+                currentQueue[queueIndex].run();
+            }
+        }
+        queueIndex = -1;
+        len = queue.length;
+    }
+    currentQueue = null;
+    draining = false;
+    runClearTimeout(timeout);
+}
+
+process.nextTick = function (fun) {
+    var args = new Array(arguments.length - 1);
+    if (arguments.length > 1) {
+        for (var i = 1; i < arguments.length; i++) {
+            args[i - 1] = arguments[i];
+        }
+    }
+    queue.push(new Item(fun, args));
+    if (queue.length === 1 && !draining) {
+        runTimeout(drainQueue);
+    }
+};
+
+// v8 likes predictible objects
+function Item(fun, array) {
+    this.fun = fun;
+    this.array = array;
+}
+Item.prototype.run = function () {
+    this.fun.apply(null, this.array);
+};
+process.title = 'browser';
+process.browser = true;
+process.env = {};
+process.argv = [];
+process.version = ''; // empty string to avoid regexp issues
+process.versions = {};
+
+function noop() {}
+
+process.on = noop;
+process.addListener = noop;
+process.once = noop;
+process.off = noop;
+process.removeListener = noop;
+process.removeAllListeners = noop;
+process.emit = noop;
+process.prependListener = noop;
+process.prependOnceListener = noop;
+
+process.listeners = function (name) { return [] }
+
+process.binding = function (name) {
+    throw new Error('process.binding is not supported');
+};
+
+process.cwd = function () { return '/' };
+process.chdir = function (dir) {
+    throw new Error('process.chdir is not supported');
+};
+process.umask = function() { return 0; };
+
+
+/***/ }),
+
+/***/ 553:
+/***/ ((module) => {
+
+"use strict";
+
+
+function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }
+
+var codes = {};
+
+function createErrorType(code, message, Base) {
+  if (!Base) {
+    Base = Error;
+  }
+
+  function getMessage(arg1, arg2, arg3) {
+    if (typeof message === 'string') {
+      return message;
+    } else {
+      return message(arg1, arg2, arg3);
+    }
+  }
+
+  var NodeError =
+  /*#__PURE__*/
+  function (_Base) {
+    _inheritsLoose(NodeError, _Base);
+
+    function NodeError(arg1, arg2, arg3) {
+      return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
+    }
+
+    return NodeError;
+  }(Base);
+
+  NodeError.prototype.name = Base.name;
+  NodeError.prototype.code = code;
+  codes[code] = NodeError;
+} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js
+
+
+function oneOf(expected, thing) {
+  if (Array.isArray(expected)) {
+    var len = expected.length;
+    expected = expected.map(function (i) {
+      return String(i);
+    });
+
+    if (len > 2) {
+      return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
+    } else if (len === 2) {
+      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
+    } else {
+      return "of ".concat(thing, " ").concat(expected[0]);
+    }
+  } else {
+    return "of ".concat(thing, " ").concat(String(expected));
+  }
+} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith
+
+
+function startsWith(str, search, pos) {
+  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
+} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith
+
+
+function endsWith(str, search, this_len) {
+  if (this_len === undefined || this_len > str.length) {
+    this_len = str.length;
+  }
+
+  return str.substring(this_len - search.length, this_len) === search;
+} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes
+
+
+function includes(str, search, start) {
+  if (typeof start !== 'number') {
+    start = 0;
+  }
+
+  if (start + search.length > str.length) {
+    return false;
+  } else {
+    return str.indexOf(search, start) !== -1;
+  }
+}
+
+createErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {
+  return 'The value "' + value + '" is invalid for option "' + name + '"';
+}, TypeError);
+createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
+  // determiner: 'must be' or 'must not be'
+  var determiner;
+
+  if (typeof expected === 'string' && startsWith(expected, 'not ')) {
+    determiner = 'must not be';
+    expected = expected.replace(/^not /, '');
+  } else {
+    determiner = 'must be';
+  }
+
+  var msg;
+
+  if (endsWith(name, ' argument')) {
+    // For cases like 'first argument'
+    msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
+  } else {
+    var type = includes(name, '.') ? 'property' : 'argument';
+    msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
+  }
+
+  msg += ". Received type ".concat(typeof actual);
+  return msg;
+}, TypeError);
+createErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');
+createErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {
+  return 'The ' + name + ' method is not implemented';
+});
+createErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');
+createErrorType('ERR_STREAM_DESTROYED', function (name) {
+  return 'Cannot call ' + name + ' after a stream was destroyed';
+});
+createErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
+createErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');
+createErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');
+createErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
+createErrorType('ERR_UNKNOWN_ENCODING', function (arg) {
+  return 'Unknown encoding: ' + arg;
+}, TypeError);
+createErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');
+module.exports.q = codes;
+
+
+/***/ }),
+
+/***/ 673:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+/* provided dependency */ var process = __webpack_require__(2695);
+// Copyright Joyent, Inc. and other Node contributors.
+//
+// Permission is hereby granted, free of charge, to any person obtaining a
+// copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to permit
+// persons to whom the Software is furnished to do so, subject to the
+// following conditions:
+//
+// The above copyright notice and this permission notice shall be included
+// in all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
+// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
+// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
+// USE OR OTHER DEALINGS IN THE SOFTWARE.
+// a duplex stream is just a stream that is both readable and writable.
+// Since JS doesn't have multiple prototypal inheritance, this class
+// prototypally inherits from Readable, and then parasitically from
+// Writable.
+
+/*<replacement>*/
+
+var objectKeys = Object.keys || function (obj) {
+  var keys = [];
+
+  for (var key in obj) {
+    keys.push(key);
+  }
+
+  return keys;
+};
+/*</replacement>*/
+
+
+module.exports = Duplex;
+
+var Readable = __webpack_require__(5006);
+
+var Writable = __webpack_require__(8719);
+
+__webpack_require__(3730)(Duplex, Readable);
+
+{
+  // Allow the keys array to be GC'ed.
+  var keys = objectKeys(Writable.prototype);
+
+  for (var v = 0; v < keys.length; v++) {
+    var method = keys[v];
+    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
+  }
+}
+
+function Duplex(options) {
+  if (!(this instanceof Duplex)) return new Duplex(options);
+  Readable.call(this, options);
+  Writable.call(this, options);
+  this.allowHalfOpen = true;
+
+  if (options) {
+    if (options.readable === false) this.readable = false;
+    if (options.writable === false) this.writable = false;
+
+    if (options.allowHalfOpen === false) {
+      this.allowHalfOpen = false;
+      this.once('end', onend);
+    }
+  }
+}
+
+Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
+  // making it explicit this property is not enumerable
+  // because otherwise some prototype manipulation in
+  // userland will fail
+  enumerable: false,
+  get: function get() {
+    return this._writableState.highWaterMark;
+  }
+});
+Object.defineProperty(Duplex.prototype, 'writableBuffer', {
+  // making it explicit this property is not enumerable
+  // because otherwise some prototype manipulation in
+  // userland will fail
+  enumerable: false,
+  get: function get() {
+    return this._writableState && this._writableState.getBuffer();
+  }
+});
+Object.defineProperty(Duplex.prototype, 'writableLength', {
+  // making it explicit this property is not enumerable
+  // because otherwise some prototype manipulation in
+  // userland will fail
+  enumerable: false,
+  get: function get() {
+    return this._writableState.length;
+  }
+}); // the no-half-open enforcer
+
+function onend() {
+  // If the writable side ended, then we're ok.
+  if (this._writableState.ended) return; // no more data can be written.
+  // But allow more writes to happen in this tick.
+
+  process.nextTick(onEndNT, this);
+}
+
+function onEndNT(self) {
+  self.end();
+}
+
+Object.defineProperty(Duplex.prototype, 'destroyed', {
+  // making it explicit this property is not enumerable
+  // because otherwise some prototype manipulation in
+  // userland will fail
+  enumerable: false,
+  get: function get() {
+    if (this._readableState === undefined || this._writableState === undefined) {
+      return false;
+    }
+
+    return this._readableState.destroyed && this._writableState.destroyed;
+  },
+  set: function set(value) {
+    // we ignore the value if the stream
+    // has not been initialized yet
+    if (this._readableState === undefined || this._writableState === undefined) {
+      return;
+    } // backward compatibility, the user is explicitly
+    // managing destroyed
+
+
+    this._readableState.destroyed = value;
+    this._writableState.destroyed = value;
+  }
+});
+
+/***/ }),
+
+/***/ 4343:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+// Copyright Joyent, Inc. and other Node contributors.
+//
+// Permission is hereby granted, free of charge, to any person obtaining a
+// copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to permit
+// persons to whom the Software is furnished to do so, subject to the
+// following conditions:
+//
+// The above copyright notice and this permission notice shall be included
+// in all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
+// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
+// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
+// USE OR OTHER DEALINGS IN THE SOFTWARE.
+// a passthrough stream.
+// basically just the most minimal sort of Transform stream.
+// Every written chunk gets output as-is.
+
+
+module.exports = PassThrough;
+
+var Transform = __webpack_require__(8597);
+
+__webpack_require__(3730)(PassThrough, Transform);
+
+function PassThrough(options) {
+  if (!(this instanceof PassThrough)) return new PassThrough(options);
+  Transform.call(this, options);
+}
+
+PassThrough.prototype._transform = function (chunk, encoding, cb) {
+  cb(null, chunk);
+};
+
+/***/ }),
+
+/***/ 5006:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+/* provided dependency */ var process = __webpack_require__(2695);
+// Copyright Joyent, Inc. and other Node contributors.
+//
+// Permission is hereby granted, free of charge, to any person obtaining a
+// copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to permit
+// persons to whom the Software is furnished to do so, subject to the
+// following conditions:
+//
+// The above copyright notice and this permission notice shall be included
+// in all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
+// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
+// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
+// USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+
+module.exports = Readable;
+/*<replacement>*/
+
+var Duplex;
+/*</replacement>*/
+
+Readable.ReadableState = ReadableState;
+/*<replacement>*/
+
+var EE = __webpack_require__(488).EventEmitter;
+
+var EElistenerCount = function EElistenerCount(emitter, type) {
+  return emitter.listeners(type).length;
+};
+/*</replacement>*/
+
+/*<replacement>*/
+
+
+var Stream = __webpack_require__(8208);
+/*</replacement>*/
+
+
+var Buffer = __webpack_require__(7866).Buffer;
+
+var OurUint8Array = __webpack_require__.g.Uint8Array || function () {};
+
+function _uint8ArrayToBuffer(chunk) {
+  return Buffer.from(chunk);
+}
+
+function _isUint8Array(obj) {
+  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
+}
+/*<replacement>*/
+
+
+var debugUtil = __webpack_require__(6029);
+
+var debug;
+
+if (debugUtil && debugUtil.debuglog) {
+  debug = debugUtil.debuglog('stream');
+} else {
+  debug = function debug() {};
+}
+/*</replacement>*/
+
+
+var BufferList = __webpack_require__(4506);
+
+var destroyImpl = __webpack_require__(3390);
+
+var _require = __webpack_require__(1111),
+    getHighWaterMark = _require.getHighWaterMark;
+
+var _require$codes = __webpack_require__(553)/* .codes */ .q,
+    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
+    ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,
+    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
+    ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; // Lazy loaded to improve the startup performance.
+
+
+var StringDecoder;
+var createReadableStreamAsyncIterator;
+var from;
+
+__webpack_require__(3730)(Readable, Stream);
+
+var errorOrDestroy = destroyImpl.errorOrDestroy;
+var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];
+
+function prependListener(emitter, event, fn) {
+  // Sadly this is not cacheable as some libraries bundle their own
+  // event emitter implementation with them.
+  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any
+  // userland ones.  NEVER DO THIS. This is here only because this code needs
+  // to continue to work with older versions of Node.js that do not include
+  // the prependListener() method. The goal is to eventually remove this hack.
+
+  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
+}
+
+function ReadableState(options, stream, isDuplex) {
+  Duplex = Duplex || __webpack_require__(673);
+  options = options || {}; // Duplex streams are both readable and writable, but share
+  // the same options object.
+  // However, some cases require setting options to different
+  // values for the readable and the writable sides of the duplex stream.
+  // These options can be provided separately as readableXXX and writableXXX.
+
+  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to
+  // make all the buffer merging and length checks go away
+
+  this.objectMode = !!options.objectMode;
+  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer
+  // Note: 0 is a valid value, means "don't call _read preemptively ever"
+
+  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the
+  // linked list can remove elements from the beginning faster than
+  // array.shift()
+
+  this.buffer = new BufferList();
+  this.length = 0;
+  this.pipes = null;
+  this.pipesCount = 0;
+  this.flowing = null;
+  this.ended = false;
+  this.endEmitted = false;
+  this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted
+  // immediately, or on a later tick.  We set this to true at first, because
+  // any actions that shouldn't happen until "later" should generally also
+  // not happen before the first read call.
+
+  this.sync = true; // whenever we return null, then we set a flag to say
+  // that we're awaiting a 'readable' event emission.
+
+  this.needReadable = false;
+  this.emittedReadable = false;
+  this.readableListening = false;
+  this.resumeScheduled = false;
+  this.paused = true; // Should close be emitted on destroy. Defaults to true.
+
+  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'end' (and potentially 'finish')
+
+  this.autoDestroy = !!options.autoDestroy; // has it been destroyed
+
+  this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string
+  // encoding is 'binary' so we have to make this configurable.
+  // Everything else in the universe uses 'utf8', though.
+
+  this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s
+
+  this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled
+
+  this.readingMore = false;
+  this.decoder = null;
+  this.encoding = null;
+
+  if (options.encoding) {
+    if (!StringDecoder) StringDecoder = __webpack_require__(7361)/* .StringDecoder */ .s;
+    this.decoder = new StringDecoder(options.encoding);
+    this.encoding = options.encoding;
+  }
+}
+
+function Readable(options) {
+  Duplex = Duplex || __webpack_require__(673);
+  if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside
+  // the ReadableState constructor, at least with V8 6.5
+
+  var isDuplex = this instanceof Duplex;
+  this._readableState = new ReadableState(options, this, isDuplex); // legacy
+
+  this.readable = true;
+
+  if (options) {
+    if (typeof options.read === 'function') this._read = options.read;
+    if (typeof options.destroy === 'function') this._destroy = options.destroy;
+  }
+
+  Stream.call(this);
+}
+
+Object.defineProperty(Readable.prototype, 'destroyed', {
+  // making it explicit this property is not enumerable
+  // because otherwise some prototype manipulation in
+  // userland will fail
+  enumerable: false,
+  get: function get() {
+    if (this._readableState === undefined) {
+      return false;
+    }
+
+    return this._readableState.destroyed;
+  },
+  set: function set(value) {
+    // we ignore the value if the stream
+    // has not been initialized yet
+    if (!this._readableState) {
+      return;
+    } // backward compatibility, the user is explicitly
+    // managing destroyed
+
+
+    this._readableState.destroyed = value;
+  }
+});
+Readable.prototype.destroy = destroyImpl.destroy;
+Readable.prototype._undestroy = destroyImpl.undestroy;
+
+Readable.prototype._destroy = function (err, cb) {
+  cb(err);
+}; // Manually shove something into the read() buffer.
+// This returns true if the highWaterMark has not been hit yet,
+// similar to how Writable.write() returns true if you should
+// write() some more.
+
+
+Readable.prototype.push = function (chunk, encoding) {
+  var state = this._readableState;
+  var skipChunkCheck;
+
+  if (!state.objectMode) {
+    if (typeof chunk === 'string') {
+      encoding = encoding || state.defaultEncoding;
+
+      if (encoding !== state.encoding) {
+        chunk = Buffer.from(chunk, encoding);
+        encoding = '';
+      }
+
+      skipChunkCheck = true;
+    }
+  } else {
+    skipChunkCheck = true;
+  }
+
+  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
+}; // Unshift should *always* be something directly out of read()
+
+
+Readable.prototype.unshift = function (chunk) {
+  return readableAddChunk(this, chunk, null, true, false);
+};
+
+function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
+  debug('readableAddChunk', chunk);
+  var state = stream._readableState;
+
+  if (chunk === null) {
+    state.reading = false;
+    onEofChunk(stream, state);
+  } else {
+    var er;
+    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
+
+    if (er) {
+      errorOrDestroy(stream, er);
+    } else if (state.objectMode || chunk && chunk.length > 0) {
+      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
+        chunk = _uint8ArrayToBuffer(chunk);
+      }
+
+      if (addToFront) {
+        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);
+      } else if (state.ended) {
+        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
+      } else if (state.destroyed) {
+        return false;
+      } else {
+        state.reading = false;
+
+        if (state.decoder && !encoding) {
+          chunk = state.decoder.write(chunk);
+          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
+        } else {
+          addChunk(stream, state, chunk, false);
+        }
+      }
+    } else if (!addToFront) {
+      state.reading = false;
+      maybeReadMore(stream, state);
+    }
+  } // We can push more data if we are below the highWaterMark.
+  // Also, if we have no data yet, we can stand some more bytes.
+  // This is to work around cases where hwm=0, such as the repl.
+
+
+  return !state.ended && (state.length < state.highWaterMark || state.length === 0);
+}
+
+function addChunk(stream, state, chunk, addToFront) {
+  if (state.flowing && state.length === 0 && !state.sync) {
+    state.awaitDrain = 0;
+    stream.emit('data', chunk);
+  } else {
+    // update the buffer info.
+    state.length += state.objectMode ? 1 : chunk.length;
+    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
+    if (state.needReadable) emitReadable(stream);
+  }
+
+  maybeReadMore(stream, state);
+}
+
+function chunkInvalid(state, chunk) {
+  var er;
+
+  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
+    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
+  }
+
+  return er;
+}
+
+Readable.prototype.isPaused = function () {
+  return this._readableState.flowing === false;
+}; // backwards compatibility.
+
+
+Readable.prototype.setEncoding = function (enc) {
+  if (!StringDecoder) StringDecoder = __webpack_require__(7361)/* .StringDecoder */ .s;
+  var decoder = new StringDecoder(enc);
+  this._readableState.decoder = decoder; // If setEncoding(null), decoder.encoding equals utf8
+
+  this._readableState.encoding = this._readableState.decoder.encoding; // Iterate over current buffer to convert already stored Buffers:
+
+  var p = this._readableState.buffer.head;
+  var content = '';
+
+  while (p !== null) {
+    content += decoder.write(p.data);
+    p = p.next;
+  }
+
+  this._readableState.buffer.clear();
+
+  if (content !== '') this._readableState.buffer.push(content);
+  this._readableState.length = content.length;
+  return this;
+}; // Don't raise the hwm > 1GB
+
+
+var MAX_HWM = 0x40000000;
+
+function computeNewHighWaterMark(n) {
+  if (n >= MAX_HWM) {
+    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
+    n = MAX_HWM;
+  } else {
+    // Get the next highest power of 2 to prevent increasing hwm excessively in
+    // tiny amounts
+    n--;
+    n |= n >>> 1;
+    n |= n >>> 2;
+    n |= n >>> 4;
+    n |= n >>> 8;
+    n |= n >>> 16;
+    n++;
+  }
+
+  return n;
+} // This function is designed to be inlinable, so please take care when making
+// changes to the function body.
+
+
+function howMuchToRead(n, state) {
+  if (n <= 0 || state.length === 0 && state.ended) return 0;
+  if (state.objectMode) return 1;
+
+  if (n !== n) {
+    // Only flow one buffer at a time
+    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
+  } // If we're asking for more than the current hwm, then raise the hwm.
+
+
+  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
+  if (n <= state.length) return n; // Don't have enough
+
+  if (!state.ended) {
+    state.needReadable = true;
+    return 0;
+  }
+
+  return state.length;
+} // you can override either this method, or the async _read(n) below.
+
+
+Readable.prototype.read = function (n) {
+  debug('read', n);
+  n = parseInt(n, 10);
+  var state = this._readableState;
+  var nOrig = n;
+  if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we
+  // already have a bunch of data in the buffer, then just trigger
+  // the 'readable' event and move on.
+
+  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
+    debug('read: emitReadable', state.length, state.ended);
+    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
+    return null;
+  }
+
+  n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.
+
+  if (n === 0 && state.ended) {
+    if (state.length === 0) endReadable(this);
+    return null;
+  } // All the actual chunk generation logic needs to be
+  // *below* the call to _read.  The reason is that in certain
+  // synthetic stream cases, such as passthrough streams, _read
+  // may be a completely synchronous operation which may change
+  // the state of the read buffer, providing enough data when
+  // before there was *not* enough.
+  //
+  // So, the steps are:
+  // 1. Figure out what the state of things will be after we do
+  // a read from the buffer.
+  //
+  // 2. If that resulting state will trigger a _read, then call _read.
+  // Note that this may be asynchronous, or synchronous.  Yes, it is
+  // deeply ugly to write APIs this way, but that still doesn't mean
+  // that the Readable class should behave improperly, as streams are
+  // designed to be sync/async agnostic.
+  // Take note if the _read call is sync or async (ie, if the read call
+  // has returned yet), so that we know whether or not it's safe to emit
+  // 'readable' etc.
+  //
+  // 3. Actually pull the requested chunks out of the buffer and return.
+  // if we need a readable event, then we need to do some reading.
+
+
+  var doRead = state.needReadable;
+  debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some
+
+  if (state.length === 0 || state.length - n < state.highWaterMark) {
+    doRead = true;
+    debug('length less than watermark', doRead);
+  } // however, if we've ended, then there's no point, and if we're already
+  // reading, then it's unnecessary.
+
+
+  if (state.ended || state.reading) {
+    doRead = false;
+    debug('reading or ended', doRead);
+  } else if (doRead) {
+    debug('do read');
+    state.reading = true;
+    state.sync = true; // if the length is currently zero, then we *need* a readable event.
+
+    if (state.length === 0) state.needReadable = true; // call internal read method
+
+    this._read(state.highWaterMark);
+
+    state.sync = false; // If _read pushed data synchronously, then `reading` will be false,
+    // and we need to re-evaluate how much data we can return to the user.
+
+    if (!state.reading) n = howMuchToRead(nOrig, state);
+  }
+
+  var ret;
+  if (n > 0) ret = fromList(n, state);else ret = null;
+
+  if (ret === null) {
+    state.needReadable = state.length <= state.highWaterMark;
+    n = 0;
+  } else {
+    state.length -= n;
+    state.awaitDrain = 0;
+  }
+
+  if (state.length === 0) {
+    // If we have nothing in the buffer, then we want to know
+    // as soon as we *do* get something into the buffer.
+    if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.
+
+    if (nOrig !== n && state.ended) endReadable(this);
+  }
+
+  if (ret !== null) this.emit('data', ret);
+  return ret;
+};
+
+function onEofChunk(stream, state) {
+  debug('onEofChunk');
+  if (state.ended) return;
+
+  if (state.decoder) {
+    var chunk = state.decoder.end();
+
+    if (chunk && chunk.length) {
+      state.buffer.push(chunk);
+      state.length += state.objectMode ? 1 : chunk.length;
+    }
+  }
+
+  state.ended = true;
+
+  if (state.sync) {
+    // if we are sync, wait until next tick to emit the data.
+    // Otherwise we risk emitting data in the flow()
+    // the readable code triggers during a read() call
+    emitReadable(stream);
+  } else {
+    // emit 'readable' now to make sure it gets picked up.
+    state.needReadable = false;
+
+    if (!state.emittedReadable) {
+      state.emittedReadable = true;
+      emitReadable_(stream);
+    }
+  }
+} // Don't emit readable right away in sync mode, because this can trigger
+// another read() call => stack overflow.  This way, it might trigger
+// a nextTick recursion warning, but that's not so bad.
+
+
+function emitReadable(stream) {
+  var state = stream._readableState;
+  debug('emitReadable', state.needReadable, state.emittedReadable);
+  state.needReadable = false;
+
+  if (!state.emittedReadable) {
+    debug('emitReadable', state.flowing);
+    state.emittedReadable = true;
+    process.nextTick(emitReadable_, stream);
+  }
+}
+
+function emitReadable_(stream) {
+  var state = stream._readableState;
+  debug('emitReadable_', state.destroyed, state.length, state.ended);
+
+  if (!state.destroyed && (state.length || state.ended)) {
+    stream.emit('readable');
+    state.emittedReadable = false;
+  } // The stream needs another readable event if
+  // 1. It is not flowing, as the flow mechanism will take
+  //    care of it.
+  // 2. It is not ended.
+  // 3. It is below the highWaterMark, so we can schedule
+  //    another readable later.
+
+
+  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
+  flow(stream);
+} // at this point, the user has presumably seen the 'readable' event,
+// and called read() to consume some data.  that may have triggered
+// in turn another _read(n) call, in which case reading = true if
+// it's in progress.
+// However, if we're not ended, or reading, and the length < hwm,
+// then go ahead and try to read some more preemptively.
+
+
+function maybeReadMore(stream, state) {
+  if (!state.readingMore) {
+    state.readingMore = true;
+    process.nextTick(maybeReadMore_, stream, state);
+  }
+}
+
+function maybeReadMore_(stream, state) {
+  // Attempt to read more data if we should.
+  //
+  // The conditions for reading more data are (one of):
+  // - Not enough data buffered (state.length < state.highWaterMark). The loop
+  //   is responsible for filling the buffer with enough data if such data
+  //   is available. If highWaterMark is 0 and we are not in the flowing mode
+  //   we should _not_ attempt to buffer any extra data. We'll get more data
+  //   when the stream consumer calls read() instead.
+  // - No data in the buffer, and the stream is in flowing mode. In this mode
+  //   the loop below is responsible for ensuring read() is called. Failing to
+  //   call read here would abort the flow and there's no other mechanism for
+  //   continuing the flow if the stream consumer has just subscribed to the
+  //   'data' event.
+  //
+  // In addition to the above conditions to keep reading data, the following
+  // conditions prevent the data from being read:
+  // - The stream has ended (state.ended).
+  // - There is already a pending 'read' operation (state.reading). This is a
+  //   case where the the stream has called the implementation defined _read()
+  //   method, but they are processing the call asynchronously and have _not_
+  //   called push() with new data. In this case we skip performing more
+  //   read()s. The execution ends in this method again after the _read() ends
+  //   up calling push() with more data.
+  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
+    var len = state.length;
+    debug('maybeReadMore read 0');
+    stream.read(0);
+    if (len === state.length) // didn't get any data, stop spinning.
+      break;
+  }
+
+  state.readingMore = false;
+} // abstract method.  to be overridden in specific implementation classes.
+// call cb(er, data) where data is <= n in length.
+// for virtual (non-string, non-buffer) streams, "length" is somewhat
+// arbitrary, and perhaps not very meaningful.
+
+
+Readable.prototype._read = function (n) {
+  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));
+};
+
+Readable.prototype.pipe = function (dest, pipeOpts) {
+  var src = this;
+  var state = this._readableState;
+
+  switch (state.pipesCount) {
+    case 0:
+      state.pipes = dest;
+      break;
+
+    case 1:
+      state.pipes = [state.pipes, dest];
+      break;
+
+    default:
+      state.pipes.push(dest);
+      break;
+  }
+
+  state.pipesCount += 1;
+  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
+  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
+  var endFn = doEnd ? onend : unpipe;
+  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);
+  dest.on('unpipe', onunpipe);
+
+  function onunpipe(readable, unpipeInfo) {
+    debug('onunpipe');
+
+    if (readable === src) {
+      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
+        unpipeInfo.hasUnpiped = true;
+        cleanup();
+      }
+    }
+  }
+
+  function onend() {
+    debug('onend');
+    dest.end();
+  } // when the dest drains, it reduces the awaitDrain counter
+  // on the source.  This would be more elegant with a .once()
+  // handler in flow(), but adding and removing repeatedly is
+  // too slow.
+
+
+  var ondrain = pipeOnDrain(src);
+  dest.on('drain', ondrain);
+  var cleanedUp = false;
+
+  function cleanup() {
+    debug('cleanup'); // cleanup event handlers once the pipe is broken
+
+    dest.removeListener('close', onclose);
+    dest.removeListener('finish', onfinish);
+    dest.removeListener('drain', ondrain);
+    dest.removeListener('error', onerror);
+    dest.removeListener('unpipe', onunpipe);
+    src.removeListener('end', onend);
+    src.removeListener('end', unpipe);
+    src.removeListener('data', ondata);
+    cleanedUp = true; // if the reader is waiting for a drain event from this
+    // specific writer, then it would cause it to never start
+    // flowing again.
+    // So, if this is awaiting a drain, then we just call it now.
+    // If we don't know, then assume that we are waiting for one.
+
+    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
+  }
+
+  src.on('data', ondata);
+
+  function ondata(chunk) {
+    debug('ondata');
+    var ret = dest.write(chunk);
+    debug('dest.write', ret);
+
+    if (ret === false) {
+      // If the user unpiped during `dest.write()`, it is possible
+      // to get stuck in a permanently paused state if that write
+      // also returned false.
+      // => Check whether `dest` is still a piping destination.
+      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
+        debug('false write response, pause', state.awaitDrain);
+        state.awaitDrain++;
+      }
+
+      src.pause();
+    }
+  } // if the dest has an error, then stop piping into it.
+  // however, don't suppress the throwing behavior for this.
+
+
+  function onerror(er) {
+    debug('onerror', er);
+    unpipe();
+    dest.removeListener('error', onerror);
+    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);
+  } // Make sure our error handler is attached before userland ones.
+
+
+  prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.
+
+  function onclose() {
+    dest.removeListener('finish', onfinish);
+    unpipe();
+  }
+
+  dest.once('close', onclose);
+
+  function onfinish() {
+    debug('onfinish');
+    dest.removeListener('close', onclose);
+    unpipe();
+  }
+
+  dest.once('finish', onfinish);
+
+  function unpipe() {
+    debug('unpipe');
+    src.unpipe(dest);
+  } // tell the dest that it's being piped to
+
+
+  dest.emit('pipe', src); // start the flow if it hasn't been started already.
+
+  if (!state.flowing) {
+    debug('pipe resume');
+    src.resume();
+  }
+
+  return dest;
+};
+
+function pipeOnDrain(src) {
+  return function pipeOnDrainFunctionResult() {
+    var state = src._readableState;
+    debug('pipeOnDrain', state.awaitDrain);
+    if (state.awaitDrain) state.awaitDrain--;
+
+    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
+      state.flowing = true;
+      flow(src);
+    }
+  };
+}
+
+Readable.prototype.unpipe = function (dest) {
+  var state = this._readableState;
+  var unpipeInfo = {
+    hasUnpiped: false
+  }; // if we're not piping anywhere, then do nothing.
+
+  if (state.pipesCount === 0) return this; // just one destination.  most common case.
+
+  if (state.pipesCount === 1) {
+    // passed in one, but it's not the right one.
+    if (dest && dest !== state.pipes) return this;
+    if (!dest) dest = state.pipes; // got a match.
+
+    state.pipes = null;
+    state.pipesCount = 0;
+    state.flowing = false;
+    if (dest) dest.emit('unpipe', this, unpipeInfo);
+    return this;
+  } // slow case. multiple pipe destinations.
+
+
+  if (!dest) {
+    // remove all.
+    var dests = state.pipes;
+    var len = state.pipesCount;
+    state.pipes = null;
+    state.pipesCount = 0;
+    state.flowing = false;
+
+    for (var i = 0; i < len; i++) {
+      dests[i].emit('unpipe', this, {
+        hasUnpiped: false
+      });
+    }
+
+    return this;
+  } // try to find the right one.
+
+
+  var index = indexOf(state.pipes, dest);
+  if (index === -1) return this;
+  state.pipes.splice(index, 1);
+  state.pipesCount -= 1;
+  if (state.pipesCount === 1) state.pipes = state.pipes[0];
+  dest.emit('unpipe', this, unpipeInfo);
+  return this;
+}; // set up data events if they are asked for
+// Ensure readable listeners eventually get something
+
+
+Readable.prototype.on = function (ev, fn) {
+  var res = Stream.prototype.on.call(this, ev, fn);
+  var state = this._readableState;
+
+  if (ev === 'data') {
+    // update readableListening so that resume() may be a no-op
+    // a few lines down. This is needed to support once('readable').
+    state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused
+
+    if (state.flowing !== false) this.resume();
+  } else if (ev === 'readable') {
+    if (!state.endEmitted && !state.readableListening) {
+      state.readableListening = state.needReadable = true;
+      state.flowing = false;
+      state.emittedReadable = false;
+      debug('on readable', state.length, state.reading);
+
+      if (state.length) {
+        emitReadable(this);
+      } else if (!state.reading) {
+        process.nextTick(nReadingNextTick, this);
+      }
+    }
+  }
+
+  return res;
+};
+
+Readable.prototype.addListener = Readable.prototype.on;
+
+Readable.prototype.removeListener = function (ev, fn) {
+  var res = Stream.prototype.removeListener.call(this, ev, fn);
+
+  if (ev === 'readable') {
+    // We need to check if there is someone still listening to
+    // readable and reset the state. However this needs to happen
+    // after readable has been emitted but before I/O (nextTick) to
+    // support once('readable', fn) cycles. This means that calling
+    // resume within the same tick will have no
+    // effect.
+    process.nextTick(updateReadableListening, this);
+  }
+
+  return res;
+};
+
+Readable.prototype.removeAllListeners = function (ev) {
+  var res = Stream.prototype.removeAllListeners.apply(this, arguments);
+
+  if (ev === 'readable' || ev === undefined) {
+    // We need to check if there is someone still listening to
+    // readable and reset the state. However this needs to happen
+    // after readable has been emitted but before I/O (nextTick) to
+    // support once('readable', fn) cycles. This means that calling
+    // resume within the same tick will have no
+    // effect.
+    process.nextTick(updateReadableListening, this);
+  }
+
+  return res;
+};
+
+function updateReadableListening(self) {
+  var state = self._readableState;
+  state.readableListening = self.listenerCount('readable') > 0;
+
+  if (state.resumeScheduled && !state.paused) {
+    // flowing needs to be set to true now, otherwise
+    // the upcoming resume will not flow.
+    state.flowing = true; // crude way to check if we should resume
+  } else if (self.listenerCount('data') > 0) {
+    self.resume();
+  }
+}
+
+function nReadingNextTick(self) {
+  debug('readable nexttick read 0');
+  self.read(0);
+} // pause() and resume() are remnants of the legacy readable stream API
+// If the user uses them, then switch into old mode.
+
+
+Readable.prototype.resume = function () {
+  var state = this._readableState;
+
+  if (!state.flowing) {
+    debug('resume'); // we flow only if there is no one listening
+    // for readable, but we still have to call
+    // resume()
+
+    state.flowing = !state.readableListening;
+    resume(this, state);
+  }
+
+  state.paused = false;
+  return this;
+};
+
+function resume(stream, state) {
+  if (!state.resumeScheduled) {
+    state.resumeScheduled = true;
+    process.nextTick(resume_, stream, state);
+  }
+}
+
+function resume_(stream, state) {
+  debug('resume', state.reading);
+
+  if (!state.reading) {
+    stream.read(0);
+  }
+
+  state.resumeScheduled = false;
+  stream.emit('resume');
+  flow(stream);
+  if (state.flowing && !state.reading) stream.read(0);
+}
+
+Readable.prototype.pause = function () {
+  debug('call pause flowing=%j', this._readableState.flowing);
+
+  if (this._readableState.flowing !== false) {
+    debug('pause');
+    this._readableState.flowing = false;
+    this.emit('pause');
+  }
+
+  this._readableState.paused = true;
+  return this;
+};
+
+function flow(stream) {
+  var state = stream._readableState;
+  debug('flow', state.flowing);
+
+  while (state.flowing && stream.read() !== null) {
+    ;
+  }
+} // wrap an old-style stream as the async data source.
+// This is *not* part of the readable stream interface.
+// It is an ugly unfortunate mess of history.
+
+
+Readable.prototype.wrap = function (stream) {
+  var _this = this;
+
+  var state = this._readableState;
+  var paused = false;
+  stream.on('end', function () {
+    debug('wrapped end');
+
+    if (state.decoder && !state.ended) {
+      var chunk = state.decoder.end();
+      if (chunk && chunk.length) _this.push(chunk);
+    }
+
+    _this.push(null);
+  });
+  stream.on('data', function (chunk) {
+    debug('wrapped data');
+    if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode
+
+    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;
+
+    var ret = _this.push(chunk);
+
+    if (!ret) {
+      paused = true;
+      stream.pause();
+    }
+  }); // proxy all the other methods.
+  // important when wrapping filters and duplexes.
+
+  for (var i in stream) {
+    if (this[i] === undefined && typeof stream[i] === 'function') {
+      this[i] = function methodWrap(method) {
+        return function methodWrapReturnFunction() {
+          return stream[method].apply(stream, arguments);
+        };
+      }(i);
+    }
+  } // proxy certain important events.
+
+
+  for (var n = 0; n < kProxyEvents.length; n++) {
+    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
+  } // when we try to consume some more bytes, simply unpause the
+  // underlying stream.
+
+
+  this._read = function (n) {
+    debug('wrapped _read', n);
+
+    if (paused) {
+      paused = false;
+      stream.resume();
+    }
+  };
+
+  return this;
+};
+
+if (typeof Symbol === 'function') {
+  Readable.prototype[Symbol.asyncIterator] = function () {
+    if (createReadableStreamAsyncIterator === undefined) {
+      createReadableStreamAsyncIterator = __webpack_require__(8187);
+    }
+
+    return createReadableStreamAsyncIterator(this);
+  };
+}
+
+Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
+  // making it explicit this property is not enumerable
+  // because otherwise some prototype manipulation in
+  // userland will fail
+  enumerable: false,
+  get: function get() {
+    return this._readableState.highWaterMark;
+  }
+});
+Object.defineProperty(Readable.prototype, 'readableBuffer', {
+  // making it explicit this property is not enumerable
+  // because otherwise some prototype manipulation in
+  // userland will fail
+  enumerable: false,
+  get: function get() {
+    return this._readableState && this._readableState.buffer;
+  }
+});
+Object.defineProperty(Readable.prototype, 'readableFlowing', {
+  // making it explicit this property is not enumerable
+  // because otherwise some prototype manipulation in
+  // userland will fail
+  enumerable: false,
+  get: function get() {
+    return this._readableState.flowing;
+  },
+  set: function set(state) {
+    if (this._readableState) {
+      this._readableState.flowing = state;
+    }
+  }
+}); // exposed for testing purposes only.
+
+Readable._fromList = fromList;
+Object.defineProperty(Readable.prototype, 'readableLength', {
+  // making it explicit this property is not enumerable
+  // because otherwise some prototype manipulation in
+  // userland will fail
+  enumerable: false,
+  get: function get() {
+    return this._readableState.length;
+  }
+}); // Pluck off n bytes from an array of buffers.
+// Length is the combined lengths of all the buffers in the list.
+// This function is designed to be inlinable, so please take care when making
+// changes to the function body.
+
+function fromList(n, state) {
+  // nothing buffered
+  if (state.length === 0) return null;
+  var ret;
+  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
+    // read it all, truncate the list
+    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);
+    state.buffer.clear();
+  } else {
+    // read part of list
+    ret = state.buffer.consume(n, state.decoder);
+  }
+  return ret;
+}
+
+function endReadable(stream) {
+  var state = stream._readableState;
+  debug('endReadable', state.endEmitted);
+
+  if (!state.endEmitted) {
+    state.ended = true;
+    process.nextTick(endReadableNT, state, stream);
+  }
+}
+
+function endReadableNT(state, stream) {
+  debug('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.
+
+  if (!state.endEmitted && state.length === 0) {
+    state.endEmitted = true;
+    stream.readable = false;
+    stream.emit('end');
+
+    if (state.autoDestroy) {
+      // In case of duplex streams we need a way to detect
+      // if the writable side is ready for autoDestroy as well
+      var wState = stream._writableState;
+
+      if (!wState || wState.autoDestroy && wState.finished) {
+        stream.destroy();
+      }
+    }
+  }
+}
+
+if (typeof Symbol === 'function') {
+  Readable.from = function (iterable, opts) {
+    if (from === undefined) {
+      from = __webpack_require__(3733);
+    }
+
+    return from(Readable, iterable, opts);
+  };
+}
+
+function indexOf(xs, x) {
+  for (var i = 0, l = xs.length; i < l; i++) {
+    if (xs[i] === x) return i;
+  }
+
+  return -1;
+}
+
+/***/ }),
+
+/***/ 8597:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+// Copyright Joyent, Inc. and other Node contributors.
+//
+// Permission is hereby granted, free of charge, to any person obtaining a
+// copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to permit
+// persons to whom the Software is furnished to do so, subject to the
+// following conditions:
+//
+// The above copyright notice and this permission notice shall be included
+// in all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
+// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
+// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
+// USE OR OTHER DEALINGS IN THE SOFTWARE.
+// a transform stream is a readable/writable stream where you do
+// something with the data.  Sometimes it's called a "filter",
+// but that's not a great name for it, since that implies a thing where
+// some bits pass through, and others are simply ignored.  (That would
+// be a valid example of a transform, of course.)
+//
+// While the output is causally related to the input, it's not a
+// necessarily symmetric or synchronous transformation.  For example,
+// a zlib stream might take multiple plain-text writes(), and then
+// emit a single compressed chunk some time in the future.
+//
+// Here's how this works:
+//
+// The Transform stream has all the aspects of the readable and writable
+// stream classes.  When you write(chunk), that calls _write(chunk,cb)
+// internally, and returns false if there's a lot of pending writes
+// buffered up.  When you call read(), that calls _read(n) until
+// there's enough pending readable data buffered up.
+//
+// In a transform stream, the written data is placed in a buffer.  When
+// _read(n) is called, it transforms the queued up data, calling the
+// buffered _write cb's as it consumes chunks.  If consuming a single
+// written chunk would result in multiple output chunks, then the first
+// outputted bit calls the readcb, and subsequent chunks just go into
+// the read buffer, and will cause it to emit 'readable' if necessary.
+//
+// This way, back-pressure is actually determined by the reading side,
+// since _read has to be called to start processing a new chunk.  However,
+// a pathological inflate type of transform can cause excessive buffering
+// here.  For example, imagine a stream where every byte of input is
+// interpreted as an integer from 0-255, and then results in that many
+// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
+// 1kb of data being output.  In this case, you could write a very small
+// amount of input, and end up with a very large amount of output.  In
+// such a pathological inflating mechanism, there'd be no way to tell
+// the system to stop doing the transform.  A single 4MB write could
+// cause the system to run out of memory.
+//
+// However, even in such a pathological case, only a single written chunk
+// would be consumed, and then the rest would wait (un-transformed) until
+// the results of the previous transformed chunk were consumed.
+
+
+module.exports = Transform;
+
+var _require$codes = __webpack_require__(553)/* .codes */ .q,
+    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
+    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
+    ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,
+    ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
+
+var Duplex = __webpack_require__(673);
+
+__webpack_require__(3730)(Transform, Duplex);
+
+function afterTransform(er, data) {
+  var ts = this._transformState;
+  ts.transforming = false;
+  var cb = ts.writecb;
+
+  if (cb === null) {
+    return this.emit('error', new ERR_MULTIPLE_CALLBACK());
+  }
+
+  ts.writechunk = null;
+  ts.writecb = null;
+  if (data != null) // single equals check for both `null` and `undefined`
+    this.push(data);
+  cb(er);
+  var rs = this._readableState;
+  rs.reading = false;
+
+  if (rs.needReadable || rs.length < rs.highWaterMark) {
+    this._read(rs.highWaterMark);
+  }
+}
+
+function Transform(options) {
+  if (!(this instanceof Transform)) return new Transform(options);
+  Duplex.call(this, options);
+  this._transformState = {
+    afterTransform: afterTransform.bind(this),
+    needTransform: false,
+    transforming: false,
+    writecb: null,
+    writechunk: null,
+    writeencoding: null
+  }; // start out asking for a readable event once data is transformed.
+
+  this._readableState.needReadable = true; // we have implemented the _read method, and done the other things
+  // that Readable wants before the first _read call, so unset the
+  // sync guard flag.
+
+  this._readableState.sync = false;
+
+  if (options) {
+    if (typeof options.transform === 'function') this._transform = options.transform;
+    if (typeof options.flush === 'function') this._flush = options.flush;
+  } // When the writable side finishes, then flush out anything remaining.
+
+
+  this.on('prefinish', prefinish);
+}
+
+function prefinish() {
+  var _this = this;
+
+  if (typeof this._flush === 'function' && !this._readableState.destroyed) {
+    this._flush(function (er, data) {
+      done(_this, er, data);
+    });
+  } else {
+    done(this, null, null);
+  }
+}
+
+Transform.prototype.push = function (chunk, encoding) {
+  this._transformState.needTransform = false;
+  return Duplex.prototype.push.call(this, chunk, encoding);
+}; // This is the part where you do stuff!
+// override this function in implementation classes.
+// 'chunk' is an input chunk.
+//
+// Call `push(newChunk)` to pass along transformed output
+// to the readable side.  You may call 'push' zero or more times.
+//
+// Call `cb(err)` when you are done with this chunk.  If you pass
+// an error, then that'll put the hurt on the whole operation.  If you
+// never call cb(), then you'll never get another chunk.
+
+
+Transform.prototype._transform = function (chunk, encoding, cb) {
+  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));
+};
+
+Transform.prototype._write = function (chunk, encoding, cb) {
+  var ts = this._transformState;
+  ts.writecb = cb;
+  ts.writechunk = chunk;
+  ts.writeencoding = encoding;
+
+  if (!ts.transforming) {
+    var rs = this._readableState;
+    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
+  }
+}; // Doesn't matter what the args are here.
+// _transform does all the work.
+// That we got here means that the readable side wants more data.
+
+
+Transform.prototype._read = function (n) {
+  var ts = this._transformState;
+
+  if (ts.writechunk !== null && !ts.transforming) {
+    ts.transforming = true;
+
+    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
+  } else {
+    // mark that we need a transform, so that any data that comes in
+    // will get processed, now that we've asked for it.
+    ts.needTransform = true;
+  }
+};
+
+Transform.prototype._destroy = function (err, cb) {
+  Duplex.prototype._destroy.call(this, err, function (err2) {
+    cb(err2);
+  });
+};
+
+function done(stream, er, data) {
+  if (er) return stream.emit('error', er);
+  if (data != null) // single equals check for both `null` and `undefined`
+    stream.push(data); // TODO(BridgeAR): Write a test for these two error cases
+  // if there's nothing in the write buffer, then that means
+  // that nothing more will ever be provided
+
+  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
+  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
+  return stream.push(null);
+}
+
+/***/ }),
+
+/***/ 8719:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+/* provided dependency */ var process = __webpack_require__(2695);
+// Copyright Joyent, Inc. and other Node contributors.
+//
+// Permission is hereby granted, free of charge, to any person obtaining a
+// copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to permit
+// persons to whom the Software is furnished to do so, subject to the
+// following conditions:
+//
+// The above copyright notice and this permission notice shall be included
+// in all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
+// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
+// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
+// USE OR OTHER DEALINGS IN THE SOFTWARE.
+// A bit simpler than readable streams.
+// Implement an async ._write(chunk, encoding, cb), and it'll handle all
+// the drain event emission and buffering.
+
+
+module.exports = Writable;
+/* <replacement> */
+
+function WriteReq(chunk, encoding, cb) {
+  this.chunk = chunk;
+  this.encoding = encoding;
+  this.callback = cb;
+  this.next = null;
+} // It seems a linked list but it is not
+// there will be only 2 of these for each stream
+
+
+function CorkedRequest(state) {
+  var _this = this;
+
+  this.next = null;
+  this.entry = null;
+
+  this.finish = function () {
+    onCorkedFinish(_this, state);
+  };
+}
+/* </replacement> */
+
+/*<replacement>*/
+
+
+var Duplex;
+/*</replacement>*/
+
+Writable.WritableState = WritableState;
+/*<replacement>*/
+
+var internalUtil = {
+  deprecate: __webpack_require__(72)
+};
+/*</replacement>*/
+
+/*<replacement>*/
+
+var Stream = __webpack_require__(8208);
+/*</replacement>*/
+
+
+var Buffer = __webpack_require__(7866).Buffer;
+
+var OurUint8Array = __webpack_require__.g.Uint8Array || function () {};
+
+function _uint8ArrayToBuffer(chunk) {
+  return Buffer.from(chunk);
+}
+
+function _isUint8Array(obj) {
+  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
+}
+
+var destroyImpl = __webpack_require__(3390);
+
+var _require = __webpack_require__(1111),
+    getHighWaterMark = _require.getHighWaterMark;
+
+var _require$codes = __webpack_require__(553)/* .codes */ .q,
+    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
+    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
+    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
+    ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,
+    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,
+    ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,
+    ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,
+    ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
+
+var errorOrDestroy = destroyImpl.errorOrDestroy;
+
+__webpack_require__(3730)(Writable, Stream);
+
+function nop() {}
+
+function WritableState(options, stream, isDuplex) {
+  Duplex = Duplex || __webpack_require__(673);
+  options = options || {}; // Duplex streams are both readable and writable, but share
+  // the same options object.
+  // However, some cases require setting options to different
+  // values for the readable and the writable sides of the duplex stream,
+  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.
+
+  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream
+  // contains buffers or objects.
+
+  this.objectMode = !!options.objectMode;
+  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false
+  // Note: 0 is a valid value, means that we always return false if
+  // the entire buffer is not flushed immediately on write()
+
+  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex); // if _final has been called
+
+  this.finalCalled = false; // drain event flag.
+
+  this.needDrain = false; // at the start of calling end()
+
+  this.ending = false; // when end() has been called, and returned
+
+  this.ended = false; // when 'finish' is emitted
+
+  this.finished = false; // has it been destroyed
+
+  this.destroyed = false; // should we decode strings into buffers before passing to _write?
+  // this is here so that some node-core streams can optimize string
+  // handling at a lower level.
+
+  var noDecode = options.decodeStrings === false;
+  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string
+  // encoding is 'binary' so we have to make this configurable.
+  // Everything else in the universe uses 'utf8', though.
+
+  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement
+  // of how much we're waiting to get pushed to some underlying
+  // socket or file.
+
+  this.length = 0; // a flag to see when we're in the middle of a write.
+
+  this.writing = false; // when true all writes will be buffered until .uncork() call
+
+  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,
+  // or on a later tick.  We set this to true at first, because any
+  // actions that shouldn't happen until "later" should generally also
+  // not happen before the first write call.
+
+  this.sync = true; // a flag to know if we're processing previously buffered items, which
+  // may call the _write() callback in the same tick, so that we don't
+  // end up in an overlapped onwrite situation.
+
+  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)
+
+  this.onwrite = function (er) {
+    onwrite(stream, er);
+  }; // the callback that the user supplies to write(chunk,encoding,cb)
+
+
+  this.writecb = null; // the amount that is being written when _write is called.
+
+  this.writelen = 0;
+  this.bufferedRequest = null;
+  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks
+  // this must be 0 before 'finish' can be emitted
+
+  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs
+  // This is relevant for synchronous Transform streams
+
+  this.prefinished = false; // True if the error was already emitted and should not be thrown again
+
+  this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.
+
+  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'finish' (and potentially 'end')
+
+  this.autoDestroy = !!options.autoDestroy; // count buffered requests
+
+  this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always
+  // one allocated and free to use, and we maintain at most two
+
+  this.corkedRequestsFree = new CorkedRequest(this);
+}
+
+WritableState.prototype.getBuffer = function getBuffer() {
+  var current = this.bufferedRequest;
+  var out = [];
+
+  while (current) {
+    out.push(current);
+    current = current.next;
+  }
+
+  return out;
+};
+
+(function () {
+  try {
+    Object.defineProperty(WritableState.prototype, 'buffer', {
+      get: internalUtil.deprecate(function writableStateBufferGetter() {
+        return this.getBuffer();
+      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
+    });
+  } catch (_) {}
+})(); // Test _writableState for inheritance to account for Duplex streams,
+// whose prototype chain only points to Readable.
+
+
+var realHasInstance;
+
+if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
+  realHasInstance = Function.prototype[Symbol.hasInstance];
+  Object.defineProperty(Writable, Symbol.hasInstance, {
+    value: function value(object) {
+      if (realHasInstance.call(this, object)) return true;
+      if (this !== Writable) return false;
+      return object && object._writableState instanceof WritableState;
+    }
+  });
+} else {
+  realHasInstance = function realHasInstance(object) {
+    return object instanceof this;
+  };
+}
+
+function Writable(options) {
+  Duplex = Duplex || __webpack_require__(673); // Writable ctor is applied to Duplexes, too.
+  // `realHasInstance` is necessary because using plain `instanceof`
+  // would return false, as no `_writableState` property is attached.
+  // Trying to use the custom `instanceof` for Writable here will also break the
+  // Node.js LazyTransform implementation, which has a non-trivial getter for
+  // `_writableState` that would lead to infinite recursion.
+  // Checking for a Stream.Duplex instance is faster here instead of inside
+  // the WritableState constructor, at least with V8 6.5
+
+  var isDuplex = this instanceof Duplex;
+  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
+  this._writableState = new WritableState(options, this, isDuplex); // legacy.
+
+  this.writable = true;
+
+  if (options) {
+    if (typeof options.write === 'function') this._write = options.write;
+    if (typeof options.writev === 'function') this._writev = options.writev;
+    if (typeof options.destroy === 'function') this._destroy = options.destroy;
+    if (typeof options.final === 'function') this._final = options.final;
+  }
+
+  Stream.call(this);
+} // Otherwise people can pipe Writable streams, which is just wrong.
+
+
+Writable.prototype.pipe = function () {
+  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
+};
+
+function writeAfterEnd(stream, cb) {
+  var er = new ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb
+
+  errorOrDestroy(stream, er);
+  process.nextTick(cb, er);
+} // Checks that a user-supplied chunk is valid, especially for the particular
+// mode the stream is in. Currently this means that `null` is never accepted
+// and undefined/non-string values are only allowed in object mode.
+
+
+function validChunk(stream, state, chunk, cb) {
+  var er;
+
+  if (chunk === null) {
+    er = new ERR_STREAM_NULL_VALUES();
+  } else if (typeof chunk !== 'string' && !state.objectMode) {
+    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);
+  }
+
+  if (er) {
+    errorOrDestroy(stream, er);
+    process.nextTick(cb, er);
+    return false;
+  }
+
+  return true;
+}
+
+Writable.prototype.write = function (chunk, encoding, cb) {
+  var state = this._writableState;
+  var ret = false;
+
+  var isBuf = !state.objectMode && _isUint8Array(chunk);
+
+  if (isBuf && !Buffer.isBuffer(chunk)) {
+    chunk = _uint8ArrayToBuffer(chunk);
+  }
+
+  if (typeof encoding === 'function') {
+    cb = encoding;
+    encoding = null;
+  }
+
+  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
+  if (typeof cb !== 'function') cb = nop;
+  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
+    state.pendingcb++;
+    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
+  }
+  return ret;
+};
+
+Writable.prototype.cork = function () {
+  this._writableState.corked++;
+};
+
+Writable.prototype.uncork = function () {
+  var state = this._writableState;
+
+  if (state.corked) {
+    state.corked--;
+    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
+  }
+};
+
+Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
+  // node::ParseEncoding() requires lower case.
+  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
+  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
+  this._writableState.defaultEncoding = encoding;
+  return this;
+};
+
+Object.defineProperty(Writable.prototype, 'writableBuffer', {
+  // making it explicit this property is not enumerable
+  // because otherwise some prototype manipulation in
+  // userland will fail
+  enumerable: false,
+  get: function get() {
+    return this._writableState && this._writableState.getBuffer();
+  }
+});
+
+function decodeChunk(state, chunk, encoding) {
+  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
+    chunk = Buffer.from(chunk, encoding);
+  }
+
+  return chunk;
+}
+
+Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
+  // making it explicit this property is not enumerable
+  // because otherwise some prototype manipulation in
+  // userland will fail
+  enumerable: false,
+  get: function get() {
+    return this._writableState.highWaterMark;
+  }
+}); // if we're already writing something, then just put this
+// in the queue, and wait our turn.  Otherwise, call _write
+// If we return false, then we need a drain event, so set that flag.
+
+function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
+  if (!isBuf) {
+    var newChunk = decodeChunk(state, chunk, encoding);
+
+    if (chunk !== newChunk) {
+      isBuf = true;
+      encoding = 'buffer';
+      chunk = newChunk;
+    }
+  }
+
+  var len = state.objectMode ? 1 : chunk.length;
+  state.length += len;
+  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.
+
+  if (!ret) state.needDrain = true;
+
+  if (state.writing || state.corked) {
+    var last = state.lastBufferedRequest;
+    state.lastBufferedRequest = {
+      chunk: chunk,
+      encoding: encoding,
+      isBuf: isBuf,
+      callback: cb,
+      next: null
+    };
+
+    if (last) {
+      last.next = state.lastBufferedRequest;
+    } else {
+      state.bufferedRequest = state.lastBufferedRequest;
+    }
+
+    state.bufferedRequestCount += 1;
+  } else {
+    doWrite(stream, state, false, len, chunk, encoding, cb);
+  }
+
+  return ret;
+}
+
+function doWrite(stream, state, writev, len, chunk, encoding, cb) {
+  state.writelen = len;
+  state.writecb = cb;
+  state.writing = true;
+  state.sync = true;
+  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
+  state.sync = false;
+}
+
+function onwriteError(stream, state, sync, er, cb) {
+  --state.pendingcb;
+
+  if (sync) {
+    // defer the callback if we are being called synchronously
+    // to avoid piling up things on the stack
+    process.nextTick(cb, er); // this can emit finish, and it will always happen
+    // after error
+
+    process.nextTick(finishMaybe, stream, state);
+    stream._writableState.errorEmitted = true;
+    errorOrDestroy(stream, er);
+  } else {
+    // the caller expect this to happen before if
+    // it is async
+    cb(er);
+    stream._writableState.errorEmitted = true;
+    errorOrDestroy(stream, er); // this can emit finish, but finish must
+    // always follow error
+
+    finishMaybe(stream, state);
+  }
+}
+
+function onwriteStateUpdate(state) {
+  state.writing = false;
+  state.writecb = null;
+  state.length -= state.writelen;
+  state.writelen = 0;
+}
+
+function onwrite(stream, er) {
+  var state = stream._writableState;
+  var sync = state.sync;
+  var cb = state.writecb;
+  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();
+  onwriteStateUpdate(state);
+  if (er) onwriteError(stream, state, sync, er, cb);else {
+    // Check if we're actually ready to finish, but don't emit yet
+    var finished = needFinish(state) || stream.destroyed;
+
+    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
+      clearBuffer(stream, state);
+    }
+
+    if (sync) {
+      process.nextTick(afterWrite, stream, state, finished, cb);
+    } else {
+      afterWrite(stream, state, finished, cb);
+    }
+  }
+}
+
+function afterWrite(stream, state, finished, cb) {
+  if (!finished) onwriteDrain(stream, state);
+  state.pendingcb--;
+  cb();
+  finishMaybe(stream, state);
+} // Must force callback to be called on nextTick, so that we don't
+// emit 'drain' before the write() consumer gets the 'false' return
+// value, and has a chance to attach a 'drain' listener.
+
+
+function onwriteDrain(stream, state) {
+  if (state.length === 0 && state.needDrain) {
+    state.needDrain = false;
+    stream.emit('drain');
+  }
+} // if there's something in the buffer waiting, then process it
+
+
+function clearBuffer(stream, state) {
+  state.bufferProcessing = true;
+  var entry = state.bufferedRequest;
+
+  if (stream._writev && entry && entry.next) {
+    // Fast case, write everything using _writev()
+    var l = state.bufferedRequestCount;
+    var buffer = new Array(l);
+    var holder = state.corkedRequestsFree;
+    holder.entry = entry;
+    var count = 0;
+    var allBuffers = true;
+
+    while (entry) {
+      buffer[count] = entry;
+      if (!entry.isBuf) allBuffers = false;
+      entry = entry.next;
+      count += 1;
+    }
+
+    buffer.allBuffers = allBuffers;
+    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time
+    // as the hot path ends with doWrite
+
+    state.pendingcb++;
+    state.lastBufferedRequest = null;
+
+    if (holder.next) {
+      state.corkedRequestsFree = holder.next;
+      holder.next = null;
+    } else {
+      state.corkedRequestsFree = new CorkedRequest(state);
+    }
+
+    state.bufferedRequestCount = 0;
+  } else {
+    // Slow case, write chunks one-by-one
+    while (entry) {
+      var chunk = entry.chunk;
+      var encoding = entry.encoding;
+      var cb = entry.callback;
+      var len = state.objectMode ? 1 : chunk.length;
+      doWrite(stream, state, false, len, chunk, encoding, cb);
+      entry = entry.next;
+      state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then
+      // it means that we need to wait until it does.
+      // also, that means that the chunk and cb are currently
+      // being processed, so move the buffer counter past them.
+
+      if (state.writing) {
+        break;
+      }
+    }
+
+    if (entry === null) state.lastBufferedRequest = null;
+  }
+
+  state.bufferedRequest = entry;
+  state.bufferProcessing = false;
+}
+
+Writable.prototype._write = function (chunk, encoding, cb) {
+  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));
+};
+
+Writable.prototype._writev = null;
+
+Writable.prototype.end = function (chunk, encoding, cb) {
+  var state = this._writableState;
+
+  if (typeof chunk === 'function') {
+    cb = chunk;
+    chunk = null;
+    encoding = null;
+  } else if (typeof encoding === 'function') {
+    cb = encoding;
+    encoding = null;
+  }
+
+  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks
+
+  if (state.corked) {
+    state.corked = 1;
+    this.uncork();
+  } // ignore unnecessary end() calls.
+
+
+  if (!state.ending) endWritable(this, state, cb);
+  return this;
+};
+
+Object.defineProperty(Writable.prototype, 'writableLength', {
+  // making it explicit this property is not enumerable
+  // because otherwise some prototype manipulation in
+  // userland will fail
+  enumerable: false,
+  get: function get() {
+    return this._writableState.length;
+  }
+});
+
+function needFinish(state) {
+  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
+}
+
+function callFinal(stream, state) {
+  stream._final(function (err) {
+    state.pendingcb--;
+
+    if (err) {
+      errorOrDestroy(stream, err);
+    }
+
+    state.prefinished = true;
+    stream.emit('prefinish');
+    finishMaybe(stream, state);
+  });
+}
+
+function prefinish(stream, state) {
+  if (!state.prefinished && !state.finalCalled) {
+    if (typeof stream._final === 'function' && !state.destroyed) {
+      state.pendingcb++;
+      state.finalCalled = true;
+      process.nextTick(callFinal, stream, state);
+    } else {
+      state.prefinished = true;
+      stream.emit('prefinish');
+    }
+  }
+}
+
+function finishMaybe(stream, state) {
+  var need = needFinish(state);
+
+  if (need) {
+    prefinish(stream, state);
+
+    if (state.pendingcb === 0) {
+      state.finished = true;
+      stream.emit('finish');
+
+      if (state.autoDestroy) {
+        // In case of duplex streams we need a way to detect
+        // if the readable side is ready for autoDestroy as well
+        var rState = stream._readableState;
+
+        if (!rState || rState.autoDestroy && rState.endEmitted) {
+          stream.destroy();
+        }
+      }
+    }
+  }
+
+  return need;
+}
+
+function endWritable(stream, state, cb) {
+  state.ending = true;
+  finishMaybe(stream, state);
+
+  if (cb) {
+    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);
+  }
+
+  state.ended = true;
+  stream.writable = false;
+}
+
+function onCorkedFinish(corkReq, state, err) {
+  var entry = corkReq.entry;
+  corkReq.entry = null;
+
+  while (entry) {
+    var cb = entry.callback;
+    state.pendingcb--;
+    cb(err);
+    entry = entry.next;
+  } // reuse the free corkReq.
+
+
+  state.corkedRequestsFree.next = corkReq;
+}
+
+Object.defineProperty(Writable.prototype, 'destroyed', {
+  // making it explicit this property is not enumerable
+  // because otherwise some prototype manipulation in
+  // userland will fail
+  enumerable: false,
+  get: function get() {
+    if (this._writableState === undefined) {
+      return false;
+    }
+
+    return this._writableState.destroyed;
+  },
+  set: function set(value) {
+    // we ignore the value if the stream
+    // has not been initialized yet
+    if (!this._writableState) {
+      return;
+    } // backward compatibility, the user is explicitly
+    // managing destroyed
+
+
+    this._writableState.destroyed = value;
+  }
+});
+Writable.prototype.destroy = destroyImpl.destroy;
+Writable.prototype._undestroy = destroyImpl.undestroy;
+
+Writable.prototype._destroy = function (err, cb) {
+  cb(err);
+};
+
+/***/ }),
+
+/***/ 8187:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+/* provided dependency */ var process = __webpack_require__(2695);
+
+
+var _Object$setPrototypeO;
+
+function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+var finished = __webpack_require__(2426);
+
+var kLastResolve = Symbol('lastResolve');
+var kLastReject = Symbol('lastReject');
+var kError = Symbol('error');
+var kEnded = Symbol('ended');
+var kLastPromise = Symbol('lastPromise');
+var kHandlePromise = Symbol('handlePromise');
+var kStream = Symbol('stream');
+
+function createIterResult(value, done) {
+  return {
+    value: value,
+    done: done
+  };
+}
+
+function readAndResolve(iter) {
+  var resolve = iter[kLastResolve];
+
+  if (resolve !== null) {
+    var data = iter[kStream].read(); // we defer if data is null
+    // we can be expecting either 'end' or
+    // 'error'
+
+    if (data !== null) {
+      iter[kLastPromise] = null;
+      iter[kLastResolve] = null;
+      iter[kLastReject] = null;
+      resolve(createIterResult(data, false));
+    }
+  }
+}
+
+function onReadable(iter) {
+  // we wait for the next tick, because it might
+  // emit an error with process.nextTick
+  process.nextTick(readAndResolve, iter);
+}
+
+function wrapForNext(lastPromise, iter) {
+  return function (resolve, reject) {
+    lastPromise.then(function () {
+      if (iter[kEnded]) {
+        resolve(createIterResult(undefined, true));
+        return;
+      }
+
+      iter[kHandlePromise](resolve, reject);
+    }, reject);
+  };
+}
+
+var AsyncIteratorPrototype = Object.getPrototypeOf(function () {});
+var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
+  get stream() {
+    return this[kStream];
+  },
+
+  next: function next() {
+    var _this = this;
+
+    // if we have detected an error in the meanwhile
+    // reject straight away
+    var error = this[kError];
+
+    if (error !== null) {
+      return Promise.reject(error);
+    }
+
+    if (this[kEnded]) {
+      return Promise.resolve(createIterResult(undefined, true));
+    }
+
+    if (this[kStream].destroyed) {
+      // We need to defer via nextTick because if .destroy(err) is
+      // called, the error will be emitted via nextTick, and
+      // we cannot guarantee that there is no error lingering around
+      // waiting to be emitted.
+      return new Promise(function (resolve, reject) {
+        process.nextTick(function () {
+          if (_this[kError]) {
+            reject(_this[kError]);
+          } else {
+            resolve(createIterResult(undefined, true));
+          }
+        });
+      });
+    } // if we have multiple next() calls
+    // we will wait for the previous Promise to finish
+    // this logic is optimized to support for await loops,
+    // where next() is only called once at a time
+
+
+    var lastPromise = this[kLastPromise];
+    var promise;
+
+    if (lastPromise) {
+      promise = new Promise(wrapForNext(lastPromise, this));
+    } else {
+      // fast path needed to support multiple this.push()
+      // without triggering the next() queue
+      var data = this[kStream].read();
+
+      if (data !== null) {
+        return Promise.resolve(createIterResult(data, false));
+      }
+
+      promise = new Promise(this[kHandlePromise]);
+    }
+
+    this[kLastPromise] = promise;
+    return promise;
+  }
+}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {
+  return this;
+}), _defineProperty(_Object$setPrototypeO, "return", function _return() {
+  var _this2 = this;
+
+  // destroy(err, cb) is a private API
+  // we can guarantee we have that here, because we control the
+  // Readable class this is attached to
+  return new Promise(function (resolve, reject) {
+    _this2[kStream].destroy(null, function (err) {
+      if (err) {
+        reject(err);
+        return;
+      }
+
+      resolve(createIterResult(undefined, true));
+    });
+  });
+}), _Object$setPrototypeO), AsyncIteratorPrototype);
+
+var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
+  var _Object$create;
+
+  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
+    value: stream,
+    writable: true
+  }), _defineProperty(_Object$create, kLastResolve, {
+    value: null,
+    writable: true
+  }), _defineProperty(_Object$create, kLastReject, {
+    value: null,
+    writable: true
+  }), _defineProperty(_Object$create, kError, {
+    value: null,
+    writable: true
+  }), _defineProperty(_Object$create, kEnded, {
+    value: stream._readableState.endEmitted,
+    writable: true
+  }), _defineProperty(_Object$create, kHandlePromise, {
+    value: function value(resolve, reject) {
+      var data = iterator[kStream].read();
+
+      if (data) {
+        iterator[kLastPromise] = null;
+        iterator[kLastResolve] = null;
+        iterator[kLastReject] = null;
+        resolve(createIterResult(data, false));
+      } else {
+        iterator[kLastResolve] = resolve;
+        iterator[kLastReject] = reject;
+      }
+    },
+    writable: true
+  }), _Object$create));
+  iterator[kLastPromise] = null;
+  finished(stream, function (err) {
+    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
+      var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise
+      // returned by next() and store the error
+
+      if (reject !== null) {
+        iterator[kLastPromise] = null;
+        iterator[kLastResolve] = null;
+        iterator[kLastReject] = null;
+        reject(err);
+      }
+
+      iterator[kError] = err;
+      return;
+    }
+
+    var resolve = iterator[kLastResolve];
+
+    if (resolve !== null) {
+      iterator[kLastPromise] = null;
+      iterator[kLastResolve] = null;
+      iterator[kLastReject] = null;
+      resolve(createIterResult(undefined, true));
+    }
+
+    iterator[kEnded] = true;
+  });
+  stream.on('readable', onReadable.bind(null, iterator));
+  return iterator;
+};
+
+module.exports = createReadableStreamAsyncIterator;
+
+/***/ }),
+
+/***/ 4506:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+
+
+function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }
+
+function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
+
+function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
+
+function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
+
+function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }
+
+var _require = __webpack_require__(7866),
+    Buffer = _require.Buffer;
+
+var _require2 = __webpack_require__(462),
+    inspect = _require2.inspect;
+
+var custom = inspect && inspect.custom || 'inspect';
+
+function copyBuffer(src, target, offset) {
+  Buffer.prototype.copy.call(src, target, offset);
+}
+
+module.exports =
+/*#__PURE__*/
+function () {
+  function BufferList() {
+    _classCallCheck(this, BufferList);
+
+    this.head = null;
+    this.tail = null;
+    this.length = 0;
+  }
+
+  _createClass(BufferList, [{
+    key: "push",
+    value: function push(v) {
+      var entry = {
+        data: v,
+        next: null
+      };
+      if (this.length > 0) this.tail.next = entry;else this.head = entry;
+      this.tail = entry;
+      ++this.length;
+    }
+  }, {
+    key: "unshift",
+    value: function unshift(v) {
+      var entry = {
+        data: v,
+        next: this.head
+      };
+      if (this.length === 0) this.tail = entry;
+      this.head = entry;
+      ++this.length;
+    }
+  }, {
+    key: "shift",
+    value: function shift() {
+      if (this.length === 0) return;
+      var ret = this.head.data;
+      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
+      --this.length;
+      return ret;
+    }
+  }, {
+    key: "clear",
+    value: function clear() {
+      this.head = this.tail = null;
+      this.length = 0;
+    }
+  }, {
+    key: "join",
+    value: function join(s) {
+      if (this.length === 0) return '';
+      var p = this.head;
+      var ret = '' + p.data;
+
+      while (p = p.next) {
+        ret += s + p.data;
+      }
+
+      return ret;
+    }
+  }, {
+    key: "concat",
+    value: function concat(n) {
+      if (this.length === 0) return Buffer.alloc(0);
+      var ret = Buffer.allocUnsafe(n >>> 0);
+      var p = this.head;
+      var i = 0;
+
+      while (p) {
+        copyBuffer(p.data, ret, i);
+        i += p.data.length;
+        p = p.next;
+      }
+
+      return ret;
+    } // Consumes a specified amount of bytes or characters from the buffered data.
+
+  }, {
+    key: "consume",
+    value: function consume(n, hasStrings) {
+      var ret;
+
+      if (n < this.head.data.length) {
+        // `slice` is the same for buffers and strings.
+        ret = this.head.data.slice(0, n);
+        this.head.data = this.head.data.slice(n);
+      } else if (n === this.head.data.length) {
+        // First chunk is a perfect match.
+        ret = this.shift();
+      } else {
+        // Result spans more than one buffer.
+        ret = hasStrings ? this._getString(n) : this._getBuffer(n);
+      }
+
+      return ret;
+    }
+  }, {
+    key: "first",
+    value: function first() {
+      return this.head.data;
+    } // Consumes a specified amount of characters from the buffered data.
+
+  }, {
+    key: "_getString",
+    value: function _getString(n) {
+      var p = this.head;
+      var c = 1;
+      var ret = p.data;
+      n -= ret.length;
+
+      while (p = p.next) {
+        var str = p.data;
+        var nb = n > str.length ? str.length : n;
+        if (nb === str.length) ret += str;else ret += str.slice(0, n);
+        n -= nb;
+
+        if (n === 0) {
+          if (nb === str.length) {
+            ++c;
+            if (p.next) this.head = p.next;else this.head = this.tail = null;
+          } else {
+            this.head = p;
+            p.data = str.slice(nb);
+          }
+
+          break;
+        }
+
+        ++c;
+      }
+
+      this.length -= c;
+      return ret;
+    } // Consumes a specified amount of bytes from the buffered data.
+
+  }, {
+    key: "_getBuffer",
+    value: function _getBuffer(n) {
+      var ret = Buffer.allocUnsafe(n);
+      var p = this.head;
+      var c = 1;
+      p.data.copy(ret);
+      n -= p.data.length;
+
+      while (p = p.next) {
+        var buf = p.data;
+        var nb = n > buf.length ? buf.length : n;
+        buf.copy(ret, ret.length - n, 0, nb);
+        n -= nb;
+
+        if (n === 0) {
+          if (nb === buf.length) {
+            ++c;
+            if (p.next) this.head = p.next;else this.head = this.tail = null;
+          } else {
+            this.head = p;
+            p.data = buf.slice(nb);
+          }
+
+          break;
+        }
+
+        ++c;
+      }
+
+      this.length -= c;
+      return ret;
+    } // Make sure the linked list only shows the minimal necessary information.
+
+  }, {
+    key: custom,
+    value: function value(_, options) {
+      return inspect(this, _objectSpread({}, options, {
+        // Only inspect one level.
+        depth: 0,
+        // It should not recurse.
+        customInspect: false
+      }));
+    }
+  }]);
+
+  return BufferList;
+}();
+
+/***/ }),
+
+/***/ 3390:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+/* provided dependency */ var process = __webpack_require__(2695);
+ // undocumented cb() API, needed for core, not for public API
+
+function destroy(err, cb) {
+  var _this = this;
+
+  var readableDestroyed = this._readableState && this._readableState.destroyed;
+  var writableDestroyed = this._writableState && this._writableState.destroyed;
+
+  if (readableDestroyed || writableDestroyed) {
+    if (cb) {
+      cb(err);
+    } else if (err) {
+      if (!this._writableState) {
+        process.nextTick(emitErrorNT, this, err);
+      } else if (!this._writableState.errorEmitted) {
+        this._writableState.errorEmitted = true;
+        process.nextTick(emitErrorNT, this, err);
+      }
+    }
+
+    return this;
+  } // we set destroyed to true before firing error callbacks in order
+  // to make it re-entrance safe in case destroy() is called within callbacks
+
+
+  if (this._readableState) {
+    this._readableState.destroyed = true;
+  } // if this is a duplex stream mark the writable part as destroyed as well
+
+
+  if (this._writableState) {
+    this._writableState.destroyed = true;
+  }
+
+  this._destroy(err || null, function (err) {
+    if (!cb && err) {
+      if (!_this._writableState) {
+        process.nextTick(emitErrorAndCloseNT, _this, err);
+      } else if (!_this._writableState.errorEmitted) {
+        _this._writableState.errorEmitted = true;
+        process.nextTick(emitErrorAndCloseNT, _this, err);
+      } else {
+        process.nextTick(emitCloseNT, _this);
+      }
+    } else if (cb) {
+      process.nextTick(emitCloseNT, _this);
+      cb(err);
+    } else {
+      process.nextTick(emitCloseNT, _this);
+    }
+  });
+
+  return this;
+}
+
+function emitErrorAndCloseNT(self, err) {
+  emitErrorNT(self, err);
+  emitCloseNT(self);
+}
+
+function emitCloseNT(self) {
+  if (self._writableState && !self._writableState.emitClose) return;
+  if (self._readableState && !self._readableState.emitClose) return;
+  self.emit('close');
+}
+
+function undestroy() {
+  if (this._readableState) {
+    this._readableState.destroyed = false;
+    this._readableState.reading = false;
+    this._readableState.ended = false;
+    this._readableState.endEmitted = false;
+  }
+
+  if (this._writableState) {
+    this._writableState.destroyed = false;
+    this._writableState.ended = false;
+    this._writableState.ending = false;
+    this._writableState.finalCalled = false;
+    this._writableState.prefinished = false;
+    this._writableState.finished = false;
+    this._writableState.errorEmitted = false;
+  }
+}
+
+function emitErrorNT(self, err) {
+  self.emit('error', err);
+}
+
+function errorOrDestroy(stream, err) {
+  // We have tests that rely on errors being emitted
+  // in the same tick, so changing this is semver major.
+  // For now when you opt-in to autoDestroy we allow
+  // the error to be emitted nextTick. In a future
+  // semver major update we should change the default to this.
+  var rState = stream._readableState;
+  var wState = stream._writableState;
+  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);
+}
+
+module.exports = {
+  destroy: destroy,
+  undestroy: undestroy,
+  errorOrDestroy: errorOrDestroy
+};
+
+/***/ }),
+
+/***/ 2426:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+// Ported from https://github.com/mafintosh/end-of-stream with
+// permission from the author, Mathias Buus (@mafintosh).
+
+
+var ERR_STREAM_PREMATURE_CLOSE = __webpack_require__(553)/* .codes.ERR_STREAM_PREMATURE_CLOSE */ .q.ERR_STREAM_PREMATURE_CLOSE;
+
+function once(callback) {
+  var called = false;
+  return function () {
+    if (called) return;
+    called = true;
+
+    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
+      args[_key] = arguments[_key];
+    }
+
+    callback.apply(this, args);
+  };
+}
+
+function noop() {}
+
+function isRequest(stream) {
+  return stream.setHeader && typeof stream.abort === 'function';
+}
+
+function eos(stream, opts, callback) {
+  if (typeof opts === 'function') return eos(stream, null, opts);
+  if (!opts) opts = {};
+  callback = once(callback || noop);
+  var readable = opts.readable || opts.readable !== false && stream.readable;
+  var writable = opts.writable || opts.writable !== false && stream.writable;
+
+  var onlegacyfinish = function onlegacyfinish() {
+    if (!stream.writable) onfinish();
+  };
+
+  var writableEnded = stream._writableState && stream._writableState.finished;
+
+  var onfinish = function onfinish() {
+    writable = false;
+    writableEnded = true;
+    if (!readable) callback.call(stream);
+  };
+
+  var readableEnded = stream._readableState && stream._readableState.endEmitted;
+
+  var onend = function onend() {
+    readable = false;
+    readableEnded = true;
+    if (!writable) callback.call(stream);
+  };
+
+  var onerror = function onerror(err) {
+    callback.call(stream, err);
+  };
+
+  var onclose = function onclose() {
+    var err;
+
+    if (readable && !readableEnded) {
+      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
+      return callback.call(stream, err);
+    }
+
+    if (writable && !writableEnded) {
+      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
+      return callback.call(stream, err);
+    }
+  };
+
+  var onrequest = function onrequest() {
+    stream.req.on('finish', onfinish);
+  };
+
+  if (isRequest(stream)) {
+    stream.on('complete', onfinish);
+    stream.on('abort', onclose);
+    if (stream.req) onrequest();else stream.on('request', onrequest);
+  } else if (writable && !stream._writableState) {
+    // legacy streams
+    stream.on('end', onlegacyfinish);
+    stream.on('close', onlegacyfinish);
+  }
+
+  stream.on('end', onend);
+  stream.on('finish', onfinish);
+  if (opts.error !== false) stream.on('error', onerror);
+  stream.on('close', onclose);
+  return function () {
+    stream.removeListener('complete', onfinish);
+    stream.removeListener('abort', onclose);
+    stream.removeListener('request', onrequest);
+    if (stream.req) stream.req.removeListener('finish', onfinish);
+    stream.removeListener('end', onlegacyfinish);
+    stream.removeListener('close', onlegacyfinish);
+    stream.removeListener('finish', onfinish);
+    stream.removeListener('end', onend);
+    stream.removeListener('error', onerror);
+    stream.removeListener('close', onclose);
+  };
+}
+
+module.exports = eos;
+
+/***/ }),
+
+/***/ 3733:
+/***/ ((module) => {
+
+module.exports = function () {
+  throw new Error('Readable.from is not available in the browser')
+};
+
+
+/***/ }),
+
+/***/ 2970:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+// Ported from https://github.com/mafintosh/pump with
+// permission from the author, Mathias Buus (@mafintosh).
+
+
+var eos;
+
+function once(callback) {
+  var called = false;
+  return function () {
+    if (called) return;
+    called = true;
+    callback.apply(void 0, arguments);
+  };
+}
+
+var _require$codes = __webpack_require__(553)/* .codes */ .q,
+    ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,
+    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
+
+function noop(err) {
+  // Rethrow the error if it exists to avoid swallowing it
+  if (err) throw err;
+}
+
+function isRequest(stream) {
+  return stream.setHeader && typeof stream.abort === 'function';
+}
+
+function destroyer(stream, reading, writing, callback) {
+  callback = once(callback);
+  var closed = false;
+  stream.on('close', function () {
+    closed = true;
+  });
+  if (eos === undefined) eos = __webpack_require__(2426);
+  eos(stream, {
+    readable: reading,
+    writable: writing
+  }, function (err) {
+    if (err) return callback(err);
+    closed = true;
+    callback();
+  });
+  var destroyed = false;
+  return function (err) {
+    if (closed) return;
+    if (destroyed) return;
+    destroyed = true; // request.destroy just do .end - .abort is what we want
+
+    if (isRequest(stream)) return stream.abort();
+    if (typeof stream.destroy === 'function') return stream.destroy();
+    callback(err || new ERR_STREAM_DESTROYED('pipe'));
+  };
+}
+
+function call(fn) {
+  fn();
+}
+
+function pipe(from, to) {
+  return from.pipe(to);
+}
+
+function popCallback(streams) {
+  if (!streams.length) return noop;
+  if (typeof streams[streams.length - 1] !== 'function') return noop;
+  return streams.pop();
+}
+
+function pipeline() {
+  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
+    streams[_key] = arguments[_key];
+  }
+
+  var callback = popCallback(streams);
+  if (Array.isArray(streams[0])) streams = streams[0];
+
+  if (streams.length < 2) {
+    throw new ERR_MISSING_ARGS('streams');
+  }
+
+  var error;
+  var destroys = streams.map(function (stream, i) {
+    var reading = i < streams.length - 1;
+    var writing = i > 0;
+    return destroyer(stream, reading, writing, function (err) {
+      if (!error) error = err;
+      if (err) destroys.forEach(call);
+      if (reading) return;
+      destroys.forEach(call);
+      callback(error);
+    });
+  });
+  return streams.reduce(pipe);
+}
+
+module.exports = pipeline;
+
+/***/ }),
+
+/***/ 1111:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+
+
+var ERR_INVALID_OPT_VALUE = __webpack_require__(553)/* .codes.ERR_INVALID_OPT_VALUE */ .q.ERR_INVALID_OPT_VALUE;
+
+function highWaterMarkFrom(options, isDuplex, duplexKey) {
+  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
+}
+
+function getHighWaterMark(state, options, duplexKey, isDuplex) {
+  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
+
+  if (hwm != null) {
+    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
+      var name = isDuplex ? duplexKey : 'highWaterMark';
+      throw new ERR_INVALID_OPT_VALUE(name, hwm);
+    }
+
+    return Math.floor(hwm);
+  } // Default value
+
+
+  return state.objectMode ? 16 : 16 * 1024;
+}
+
+module.exports = {
+  getHighWaterMark: getHighWaterMark
+};
+
+/***/ }),
+
+/***/ 8208:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+module.exports = __webpack_require__(488).EventEmitter;
+
+
+/***/ }),
+
+/***/ 9685:
+/***/ ((module, exports, __webpack_require__) => {
+
+/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
+/* eslint-disable node/no-deprecated-api */
+var buffer = __webpack_require__(7866)
+var Buffer = buffer.Buffer
+
+// alternative to using Object.keys for old browsers
+function copyProps (src, dst) {
+  for (var key in src) {
+    dst[key] = src[key]
+  }
+}
+if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
+  module.exports = buffer
+} else {
+  // Copy properties from require('buffer')
+  copyProps(buffer, exports)
+  exports.Buffer = SafeBuffer
+}
+
+function SafeBuffer (arg, encodingOrOffset, length) {
+  return Buffer(arg, encodingOrOffset, length)
+}
+
+SafeBuffer.prototype = Object.create(Buffer.prototype)
+
+// Copy static methods from Buffer
+copyProps(Buffer, SafeBuffer)
+
+SafeBuffer.from = function (arg, encodingOrOffset, length) {
+  if (typeof arg === 'number') {
+    throw new TypeError('Argument must not be a number')
+  }
+  return Buffer(arg, encodingOrOffset, length)
+}
+
+SafeBuffer.alloc = function (size, fill, encoding) {
+  if (typeof size !== 'number') {
+    throw new TypeError('Argument must be a number')
+  }
+  var buf = Buffer(size)
+  if (fill !== undefined) {
+    if (typeof encoding === 'string') {
+      buf.fill(fill, encoding)
+    } else {
+      buf.fill(fill)
+    }
+  } else {
+    buf.fill(0)
+  }
+  return buf
+}
+
+SafeBuffer.allocUnsafe = function (size) {
+  if (typeof size !== 'number') {
+    throw new TypeError('Argument must be a number')
+  }
+  return Buffer(size)
+}
+
+SafeBuffer.allocUnsafeSlow = function (size) {
+  if (typeof size !== 'number') {
+    throw new TypeError('Argument must be a number')
+  }
+  return buffer.SlowBuffer(size)
+}
+
+
+/***/ }),
+
+/***/ 8981:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+// Copyright Joyent, Inc. and other Node contributors.
+//
+// Permission is hereby granted, free of charge, to any person obtaining a
+// copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to permit
+// persons to whom the Software is furnished to do so, subject to the
+// following conditions:
+//
+// The above copyright notice and this permission notice shall be included
+// in all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
+// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
+// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
+// USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+module.exports = Stream;
+
+var EE = __webpack_require__(488).EventEmitter;
+var inherits = __webpack_require__(3730);
+
+inherits(Stream, EE);
+Stream.Readable = __webpack_require__(5006);
+Stream.Writable = __webpack_require__(8719);
+Stream.Duplex = __webpack_require__(673);
+Stream.Transform = __webpack_require__(8597);
+Stream.PassThrough = __webpack_require__(4343);
+Stream.finished = __webpack_require__(2426)
+Stream.pipeline = __webpack_require__(2970)
+
+// Backwards-compat with node 0.4.x
+Stream.Stream = Stream;
+
+
+
+// old-style streams.  Note that the pipe method (the only relevant
+// part of this class) is overridden in the Readable class.
+
+function Stream() {
+  EE.call(this);
+}
+
+Stream.prototype.pipe = function(dest, options) {
+  var source = this;
+
+  function ondata(chunk) {
+    if (dest.writable) {
+      if (false === dest.write(chunk) && source.pause) {
+        source.pause();
+      }
+    }
+  }
+
+  source.on('data', ondata);
+
+  function ondrain() {
+    if (source.readable && source.resume) {
+      source.resume();
+    }
+  }
+
+  dest.on('drain', ondrain);
+
+  // If the 'end' option is not supplied, dest.end() will be called when
+  // source gets the 'end' or 'close' events.  Only dest.end() once.
+  if (!dest._isStdio && (!options || options.end !== false)) {
+    source.on('end', onend);
+    source.on('close', onclose);
+  }
+
+  var didOnEnd = false;
+  function onend() {
+    if (didOnEnd) return;
+    didOnEnd = true;
+
+    dest.end();
+  }
+
+
+  function onclose() {
+    if (didOnEnd) return;
+    didOnEnd = true;
+
+    if (typeof dest.destroy === 'function') dest.destroy();
+  }
+
+  // don't leave dangling pipes when there are errors.
+  function onerror(er) {
+    cleanup();
+    if (EE.listenerCount(this, 'error') === 0) {
+      throw er; // Unhandled stream error in pipe.
+    }
+  }
+
+  source.on('error', onerror);
+  dest.on('error', onerror);
+
+  // remove all the event listeners that were added.
+  function cleanup() {
+    source.removeListener('data', ondata);
+    dest.removeListener('drain', ondrain);
+
+    source.removeListener('end', onend);
+    source.removeListener('close', onclose);
+
+    source.removeListener('error', onerror);
+    dest.removeListener('error', onerror);
+
+    source.removeListener('end', cleanup);
+    source.removeListener('close', cleanup);
+
+    dest.removeListener('close', cleanup);
+  }
+
+  source.on('end', cleanup);
+  source.on('close', cleanup);
+
+  dest.on('close', cleanup);
+
+  dest.emit('pipe', source);
+
+  // Allow for unix-like usage: A.pipe(B).pipe(C)
+  return dest;
+};
+
+
+/***/ }),
+
+/***/ 7361:
+/***/ ((__unused_webpack_module, exports, __webpack_require__) => {
+
+"use strict";
+// Copyright Joyent, Inc. and other Node contributors.
+//
+// Permission is hereby granted, free of charge, to any person obtaining a
+// copy of this software and associated documentation files (the
+// "Software"), to deal in the Software without restriction, including
+// without limitation the rights to use, copy, modify, merge, publish,
+// distribute, sublicense, and/or sell copies of the Software, and to permit
+// persons to whom the Software is furnished to do so, subject to the
+// following conditions:
+//
+// The above copyright notice and this permission notice shall be included
+// in all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
+// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
+// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
+// USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+
+
+/*<replacement>*/
+
+var Buffer = __webpack_require__(9685).Buffer;
+/*</replacement>*/
+
+var isEncoding = Buffer.isEncoding || function (encoding) {
+  encoding = '' + encoding;
+  switch (encoding && encoding.toLowerCase()) {
+    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
+      return true;
+    default:
+      return false;
+  }
+};
+
+function _normalizeEncoding(enc) {
+  if (!enc) return 'utf8';
+  var retried;
+  while (true) {
+    switch (enc) {
+      case 'utf8':
+      case 'utf-8':
+        return 'utf8';
+      case 'ucs2':
+      case 'ucs-2':
+      case 'utf16le':
+      case 'utf-16le':
+        return 'utf16le';
+      case 'latin1':
+      case 'binary':
+        return 'latin1';
+      case 'base64':
+      case 'ascii':
+      case 'hex':
+        return enc;
+      default:
+        if (retried) return; // undefined
+        enc = ('' + enc).toLowerCase();
+        retried = true;
+    }
+  }
+};
+
+// Do not cache `Buffer.isEncoding` when checking encoding names as some
+// modules monkey-patch it to support additional encodings
+function normalizeEncoding(enc) {
+  var nenc = _normalizeEncoding(enc);
+  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
+  return nenc || enc;
+}
+
+// StringDecoder provides an interface for efficiently splitting a series of
+// buffers into a series of JS strings without breaking apart multi-byte
+// characters.
+exports.s = StringDecoder;
+function StringDecoder(encoding) {
+  this.encoding = normalizeEncoding(encoding);
+  var nb;
+  switch (this.encoding) {
+    case 'utf16le':
+      this.text = utf16Text;
+      this.end = utf16End;
+      nb = 4;
+      break;
+    case 'utf8':
+      this.fillLast = utf8FillLast;
+      nb = 4;
+      break;
+    case 'base64':
+      this.text = base64Text;
+      this.end = base64End;
+      nb = 3;
+      break;
+    default:
+      this.write = simpleWrite;
+      this.end = simpleEnd;
+      return;
+  }
+  this.lastNeed = 0;
+  this.lastTotal = 0;
+  this.lastChar = Buffer.allocUnsafe(nb);
+}
+
+StringDecoder.prototype.write = function (buf) {
+  if (buf.length === 0) return '';
+  var r;
+  var i;
+  if (this.lastNeed) {
+    r = this.fillLast(buf);
+    if (r === undefined) return '';
+    i = this.lastNeed;
+    this.lastNeed = 0;
+  } else {
+    i = 0;
+  }
+  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
+  return r || '';
+};
+
+StringDecoder.prototype.end = utf8End;
+
+// Returns only complete characters in a Buffer
+StringDecoder.prototype.text = utf8Text;
+
+// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
+StringDecoder.prototype.fillLast = function (buf) {
+  if (this.lastNeed <= buf.length) {
+    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
+    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
+  }
+  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
+  this.lastNeed -= buf.length;
+};
+
+// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
+// continuation byte. If an invalid byte is detected, -2 is returned.
+function utf8CheckByte(byte) {
+  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
+  return byte >> 6 === 0x02 ? -1 : -2;
+}
+
+// Checks at most 3 bytes at the end of a Buffer in order to detect an
+// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
+// needed to complete the UTF-8 character (if applicable) are returned.
+function utf8CheckIncomplete(self, buf, i) {
+  var j = buf.length - 1;
+  if (j < i) return 0;
+  var nb = utf8CheckByte(buf[j]);
+  if (nb >= 0) {
+    if (nb > 0) self.lastNeed = nb - 1;
+    return nb;
+  }
+  if (--j < i || nb === -2) return 0;
+  nb = utf8CheckByte(buf[j]);
+  if (nb >= 0) {
+    if (nb > 0) self.lastNeed = nb - 2;
+    return nb;
+  }
+  if (--j < i || nb === -2) return 0;
+  nb = utf8CheckByte(buf[j]);
+  if (nb >= 0) {
+    if (nb > 0) {
+      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
+    }
+    return nb;
+  }
+  return 0;
+}
+
+// Validates as many continuation bytes for a multi-byte UTF-8 character as
+// needed or are available. If we see a non-continuation byte where we expect
+// one, we "replace" the validated continuation bytes we've seen so far with
+// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
+// behavior. The continuation byte check is included three times in the case
+// where all of the continuation bytes for a character exist in the same buffer.
+// It is also done this way as a slight performance increase instead of using a
+// loop.
+function utf8CheckExtraBytes(self, buf, p) {
+  if ((buf[0] & 0xC0) !== 0x80) {
+    self.lastNeed = 0;
+    return '\ufffd';
+  }
+  if (self.lastNeed > 1 && buf.length > 1) {
+    if ((buf[1] & 0xC0) !== 0x80) {
+      self.lastNeed = 1;
+      return '\ufffd';
+    }
+    if (self.lastNeed > 2 && buf.length > 2) {
+      if ((buf[2] & 0xC0) !== 0x80) {
+        self.lastNeed = 2;
+        return '\ufffd';
+      }
+    }
+  }
+}
+
+// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
+function utf8FillLast(buf) {
+  var p = this.lastTotal - this.lastNeed;
+  var r = utf8CheckExtraBytes(this, buf, p);
+  if (r !== undefined) return r;
+  if (this.lastNeed <= buf.length) {
+    buf.copy(this.lastChar, p, 0, this.lastNeed);
+    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
+  }
+  buf.copy(this.lastChar, p, 0, buf.length);
+  this.lastNeed -= buf.length;
+}
+
+// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
+// partial character, the character's bytes are buffered until the required
+// number of bytes are available.
+function utf8Text(buf, i) {
+  var total = utf8CheckIncomplete(this, buf, i);
+  if (!this.lastNeed) return buf.toString('utf8', i);
+  this.lastTotal = total;
+  var end = buf.length - (total - this.lastNeed);
+  buf.copy(this.lastChar, 0, end);
+  return buf.toString('utf8', i, end);
+}
+
+// For UTF-8, a replacement character is added when ending on a partial
+// character.
+function utf8End(buf) {
+  var r = buf && buf.length ? this.write(buf) : '';
+  if (this.lastNeed) return r + '\ufffd';
+  return r;
+}
+
+// UTF-16LE typically needs two bytes per character, but even if we have an even
+// number of bytes available, we need to check if we end on a leading/high
+// surrogate. In that case, we need to wait for the next two bytes in order to
+// decode the last character properly.
+function utf16Text(buf, i) {
+  if ((buf.length - i) % 2 === 0) {
+    var r = buf.toString('utf16le', i);
+    if (r) {
+      var c = r.charCodeAt(r.length - 1);
+      if (c >= 0xD800 && c <= 0xDBFF) {
+        this.lastNeed = 2;
+        this.lastTotal = 4;
+        this.lastChar[0] = buf[buf.length - 2];
+        this.lastChar[1] = buf[buf.length - 1];
+        return r.slice(0, -1);
+      }
+    }
+    return r;
+  }
+  this.lastNeed = 1;
+  this.lastTotal = 2;
+  this.lastChar[0] = buf[buf.length - 1];
+  return buf.toString('utf16le', i, buf.length - 1);
+}
+
+// For UTF-16LE we do not explicitly append special replacement characters if we
+// end on a partial character, we simply let v8 handle that.
+function utf16End(buf) {
+  var r = buf && buf.length ? this.write(buf) : '';
+  if (this.lastNeed) {
+    var end = this.lastTotal - this.lastNeed;
+    return r + this.lastChar.toString('utf16le', 0, end);
+  }
+  return r;
+}
+
+function base64Text(buf, i) {
+  var n = (buf.length - i) % 3;
+  if (n === 0) return buf.toString('base64', i);
+  this.lastNeed = 3 - n;
+  this.lastTotal = 3;
+  if (n === 1) {
+    this.lastChar[0] = buf[buf.length - 1];
+  } else {
+    this.lastChar[0] = buf[buf.length - 2];
+    this.lastChar[1] = buf[buf.length - 1];
+  }
+  return buf.toString('base64', i, buf.length - n);
+}
+
+function base64End(buf) {
+  var r = buf && buf.length ? this.write(buf) : '';
+  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
+  return r;
+}
+
+// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
+function simpleWrite(buf) {
+  return buf.toString(this.encoding);
+}
+
+function simpleEnd(buf) {
+  return buf && buf.length ? this.write(buf) : '';
+}
+
+/***/ }),
+
+/***/ 2993:
+/***/ ((__unused_webpack_module, exports) => {
+
+"use strict";
+var __webpack_unused_export__;
+
+/*
+
+TypeScript Md5
+==============
+
+Based on work by
+* Joseph Myers: http://www.myersdaily.org/joseph/javascript/md5-text.html
+* Andr Cruz: https://github.com/satazor/SparkMD5
+* Raymond Hill: https://github.com/gorhill/yamd5.js
+
+Effectively a TypeScrypt re-write of Raymond Hill JS Library
+
+The MIT License (MIT)
+
+Copyright (C) 2014 Raymond Hill
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
+
+
+
+            DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE
+                    Version 2, December 2004
+
+ Copyright (C) 2015 Andr Cruz <amdfcruz@gmail.com>
+
+ Everyone is permitted to copy and distribute verbatim or modified
+ copies of this license document, and changing it is allowed as long
+ as the name is changed.
+
+            DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. You just DO WHAT THE FUCK YOU WANT TO.
+
+
+*/
+__webpack_unused_export__ = ({ value: true });
+var Md5 = /** @class */ (function () {
+    function Md5() {
+        this._state = new Int32Array(4);
+        this._buffer = new ArrayBuffer(68);
+        this._buffer8 = new Uint8Array(this._buffer, 0, 68);
+        this._buffer32 = new Uint32Array(this._buffer, 0, 17);
+        this.start();
+    }
+    Md5.hashStr = function (str, raw) {
+        if (raw === void 0) { raw = false; }
+        return this.onePassHasher
+            .start()
+            .appendStr(str)
+            .end(raw);
+    };
+    Md5.hashAsciiStr = function (str, raw) {
+        if (raw === void 0) { raw = false; }
+        return this.onePassHasher
+            .start()
+            .appendAsciiStr(str)
+            .end(raw);
+    };
+    Md5._hex = function (x) {
+        var hc = Md5.hexChars;
+        var ho = Md5.hexOut;
+        var n;
+        var offset;
+        var j;
+        var i;
+        for (i = 0; i < 4; i += 1) {
+            offset = i * 8;
+            n = x[i];
+            for (j = 0; j < 8; j += 2) {
+                ho[offset + 1 + j] = hc.charAt(n & 0x0F);
+                n >>>= 4;
+                ho[offset + 0 + j] = hc.charAt(n & 0x0F);
+                n >>>= 4;
+            }
+        }
+        return ho.join('');
+    };
+    Md5._md5cycle = function (x, k) {
+        var a = x[0];
+        var b = x[1];
+        var c = x[2];
+        var d = x[3];
+        // ff()
+        a += (b & c | ~b & d) + k[0] - 680876936 | 0;
+        a = (a << 7 | a >>> 25) + b | 0;
+        d += (a & b | ~a & c) + k[1] - 389564586 | 0;
+        d = (d << 12 | d >>> 20) + a | 0;
+        c += (d & a | ~d & b) + k[2] + 606105819 | 0;
+        c = (c << 17 | c >>> 15) + d | 0;
+        b += (c & d | ~c & a) + k[3] - 1044525330 | 0;
+        b = (b << 22 | b >>> 10) + c | 0;
+        a += (b & c | ~b & d) + k[4] - 176418897 | 0;
+        a = (a << 7 | a >>> 25) + b | 0;
+        d += (a & b | ~a & c) + k[5] + 1200080426 | 0;
+        d = (d << 12 | d >>> 20) + a | 0;
+        c += (d & a | ~d & b) + k[6] - 1473231341 | 0;
+        c = (c << 17 | c >>> 15) + d | 0;
+        b += (c & d | ~c & a) + k[7] - 45705983 | 0;
+        b = (b << 22 | b >>> 10) + c | 0;
+        a += (b & c | ~b & d) + k[8] + 1770035416 | 0;
+        a = (a << 7 | a >>> 25) + b | 0;
+        d += (a & b | ~a & c) + k[9] - 1958414417 | 0;
+        d = (d << 12 | d >>> 20) + a | 0;
+        c += (d & a | ~d & b) + k[10] - 42063 | 0;
+        c = (c << 17 | c >>> 15) + d | 0;
+        b += (c & d | ~c & a) + k[11] - 1990404162 | 0;
+        b = (b << 22 | b >>> 10) + c | 0;
+        a += (b & c | ~b & d) + k[12] + 1804603682 | 0;
+        a = (a << 7 | a >>> 25) + b | 0;
+        d += (a & b | ~a & c) + k[13] - 40341101 | 0;
+        d = (d << 12 | d >>> 20) + a | 0;
+        c += (d & a | ~d & b) + k[14] - 1502002290 | 0;
+        c = (c << 17 | c >>> 15) + d | 0;
+        b += (c & d | ~c & a) + k[15] + 1236535329 | 0;
+        b = (b << 22 | b >>> 10) + c | 0;
+        // gg()
+        a += (b & d | c & ~d) + k[1] - 165796510 | 0;
+        a = (a << 5 | a >>> 27) + b | 0;
+        d += (a & c | b & ~c) + k[6] - 1069501632 | 0;
+        d = (d << 9 | d >>> 23) + a | 0;
+        c += (d & b | a & ~b) + k[11] + 643717713 | 0;
+        c = (c << 14 | c >>> 18) + d | 0;
+        b += (c & a | d & ~a) + k[0] - 373897302 | 0;
+        b = (b << 20 | b >>> 12) + c | 0;
+        a += (b & d | c & ~d) + k[5] - 701558691 | 0;
+        a = (a << 5 | a >>> 27) + b | 0;
+        d += (a & c | b & ~c) + k[10] + 38016083 | 0;
+        d = (d << 9 | d >>> 23) + a | 0;
+        c += (d & b | a & ~b) + k[15] - 660478335 | 0;
+        c = (c << 14 | c >>> 18) + d | 0;
+        b += (c & a | d & ~a) + k[4] - 405537848 | 0;
+        b = (b << 20 | b >>> 12) + c | 0;
+        a += (b & d | c & ~d) + k[9] + 568446438 | 0;
+        a = (a << 5 | a >>> 27) + b | 0;
+        d += (a & c | b & ~c) + k[14] - 1019803690 | 0;
+        d = (d << 9 | d >>> 23) + a | 0;
+        c += (d & b | a & ~b) + k[3] - 187363961 | 0;
+        c = (c << 14 | c >>> 18) + d | 0;
+        b += (c & a | d & ~a) + k[8] + 1163531501 | 0;
+        b = (b << 20 | b >>> 12) + c | 0;
+        a += (b & d | c & ~d) + k[13] - 1444681467 | 0;
+        a = (a << 5 | a >>> 27) + b | 0;
+        d += (a & c | b & ~c) + k[2] - 51403784 | 0;
+        d = (d << 9 | d >>> 23) + a | 0;
+        c += (d & b | a & ~b) + k[7] + 1735328473 | 0;
+        c = (c << 14 | c >>> 18) + d | 0;
+        b += (c & a | d & ~a) + k[12] - 1926607734 | 0;
+        b = (b << 20 | b >>> 12) + c | 0;
+        // hh()
+        a += (b ^ c ^ d) + k[5] - 378558 | 0;
+        a = (a << 4 | a >>> 28) + b | 0;
+        d += (a ^ b ^ c) + k[8] - 2022574463 | 0;
+        d = (d << 11 | d >>> 21) + a | 0;
+        c += (d ^ a ^ b) + k[11] + 1839030562 | 0;
+        c = (c << 16 | c >>> 16) + d | 0;
+        b += (c ^ d ^ a) + k[14] - 35309556 | 0;
+        b = (b << 23 | b >>> 9) + c | 0;
+        a += (b ^ c ^ d) + k[1] - 1530992060 | 0;
+        a = (a << 4 | a >>> 28) + b | 0;
+        d += (a ^ b ^ c) + k[4] + 1272893353 | 0;
+        d = (d << 11 | d >>> 21) + a | 0;
+        c += (d ^ a ^ b) + k[7] - 155497632 | 0;
+        c = (c << 16 | c >>> 16) + d | 0;
+        b += (c ^ d ^ a) + k[10] - 1094730640 | 0;
+        b = (b << 23 | b >>> 9) + c | 0;
+        a += (b ^ c ^ d) + k[13] + 681279174 | 0;
+        a = (a << 4 | a >>> 28) + b | 0;
+        d += (a ^ b ^ c) + k[0] - 358537222 | 0;
+        d = (d << 11 | d >>> 21) + a | 0;
+        c += (d ^ a ^ b) + k[3] - 722521979 | 0;
+        c = (c << 16 | c >>> 16) + d | 0;
+        b += (c ^ d ^ a) + k[6] + 76029189 | 0;
+        b = (b << 23 | b >>> 9) + c | 0;
+        a += (b ^ c ^ d) + k[9] - 640364487 | 0;
+        a = (a << 4 | a >>> 28) + b | 0;
+        d += (a ^ b ^ c) + k[12] - 421815835 | 0;
+        d = (d << 11 | d >>> 21) + a | 0;
+        c += (d ^ a ^ b) + k[15] + 530742520 | 0;
+        c = (c << 16 | c >>> 16) + d | 0;
+        b += (c ^ d ^ a) + k[2] - 995338651 | 0;
+        b = (b << 23 | b >>> 9) + c | 0;
+        // ii()
+        a += (c ^ (b | ~d)) + k[0] - 198630844 | 0;
+        a = (a << 6 | a >>> 26) + b | 0;
+        d += (b ^ (a | ~c)) + k[7] + 1126891415 | 0;
+        d = (d << 10 | d >>> 22) + a | 0;
+        c += (a ^ (d | ~b)) + k[14] - 1416354905 | 0;
+        c = (c << 15 | c >>> 17) + d | 0;
+        b += (d ^ (c | ~a)) + k[5] - 57434055 | 0;
+        b = (b << 21 | b >>> 11) + c | 0;
+        a += (c ^ (b | ~d)) + k[12] + 1700485571 | 0;
+        a = (a << 6 | a >>> 26) + b | 0;
+        d += (b ^ (a | ~c)) + k[3] - 1894986606 | 0;
+        d = (d << 10 | d >>> 22) + a | 0;
+        c += (a ^ (d | ~b)) + k[10] - 1051523 | 0;
+        c = (c << 15 | c >>> 17) + d | 0;
+        b += (d ^ (c | ~a)) + k[1] - 2054922799 | 0;
+        b = (b << 21 | b >>> 11) + c | 0;
+        a += (c ^ (b | ~d)) + k[8] + 1873313359 | 0;
+        a = (a << 6 | a >>> 26) + b | 0;
+        d += (b ^ (a | ~c)) + k[15] - 30611744 | 0;
+        d = (d << 10 | d >>> 22) + a | 0;
+        c += (a ^ (d | ~b)) + k[6] - 1560198380 | 0;
+        c = (c << 15 | c >>> 17) + d | 0;
+        b += (d ^ (c | ~a)) + k[13] + 1309151649 | 0;
+        b = (b << 21 | b >>> 11) + c | 0;
+        a += (c ^ (b | ~d)) + k[4] - 145523070 | 0;
+        a = (a << 6 | a >>> 26) + b | 0;
+        d += (b ^ (a | ~c)) + k[11] - 1120210379 | 0;
+        d = (d << 10 | d >>> 22) + a | 0;
+        c += (a ^ (d | ~b)) + k[2] + 718787259 | 0;
+        c = (c << 15 | c >>> 17) + d | 0;
+        b += (d ^ (c | ~a)) + k[9] - 343485551 | 0;
+        b = (b << 21 | b >>> 11) + c | 0;
+        x[0] = a + x[0] | 0;
+        x[1] = b + x[1] | 0;
+        x[2] = c + x[2] | 0;
+        x[3] = d + x[3] | 0;
+    };
+    Md5.prototype.start = function () {
+        this._dataLength = 0;
+        this._bufferLength = 0;
+        this._state.set(Md5.stateIdentity);
+        return this;
+    };
+    // Char to code point to to array conversion:
+    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/charCodeAt
+    // #Example.3A_Fixing_charCodeAt_to_handle_non-Basic-Multilingual-Plane_characters_if_their_presence_earlier_in_the_string_is_unknown
+    Md5.prototype.appendStr = function (str) {
+        var buf8 = this._buffer8;
+        var buf32 = this._buffer32;
+        var bufLen = this._bufferLength;
+        var code;
+        var i;
+        for (i = 0; i < str.length; i += 1) {
+            code = str.charCodeAt(i);
+            if (code < 128) {
+                buf8[bufLen++] = code;
+            }
+            else if (code < 0x800) {
+                buf8[bufLen++] = (code >>> 6) + 0xC0;
+                buf8[bufLen++] = code & 0x3F | 0x80;
+            }
+            else if (code < 0xD800 || code > 0xDBFF) {
+                buf8[bufLen++] = (code >>> 12) + 0xE0;
+                buf8[bufLen++] = (code >>> 6 & 0x3F) | 0x80;
+                buf8[bufLen++] = (code & 0x3F) | 0x80;
+            }
+            else {
+                code = ((code - 0xD800) * 0x400) + (str.charCodeAt(++i) - 0xDC00) + 0x10000;
+                if (code > 0x10FFFF) {
+                    throw new Error('Unicode standard supports code points up to U+10FFFF');
+                }
+                buf8[bufLen++] = (code >>> 18) + 0xF0;
+                buf8[bufLen++] = (code >>> 12 & 0x3F) | 0x80;
+                buf8[bufLen++] = (code >>> 6 & 0x3F) | 0x80;
+                buf8[bufLen++] = (code & 0x3F) | 0x80;
+            }
+            if (bufLen >= 64) {
+                this._dataLength += 64;
+                Md5._md5cycle(this._state, buf32);
+                bufLen -= 64;
+                buf32[0] = buf32[16];
+            }
+        }
+        this._bufferLength = bufLen;
+        return this;
+    };
+    Md5.prototype.appendAsciiStr = function (str) {
+        var buf8 = this._buffer8;
+        var buf32 = this._buffer32;
+        var bufLen = this._bufferLength;
+        var i;
+        var j = 0;
+        for (;;) {
+            i = Math.min(str.length - j, 64 - bufLen);
+            while (i--) {
+                buf8[bufLen++] = str.charCodeAt(j++);
+            }
+            if (bufLen < 64) {
+                break;
+            }
+            this._dataLength += 64;
+            Md5._md5cycle(this._state, buf32);
+            bufLen = 0;
+        }
+        this._bufferLength = bufLen;
+        return this;
+    };
+    Md5.prototype.appendByteArray = function (input) {
+        var buf8 = this._buffer8;
+        var buf32 = this._buffer32;
+        var bufLen = this._bufferLength;
+        var i;
+        var j = 0;
+        for (;;) {
+            i = Math.min(input.length - j, 64 - bufLen);
+            while (i--) {
+                buf8[bufLen++] = input[j++];
+            }
+            if (bufLen < 64) {
+                break;
+            }
+            this._dataLength += 64;
+            Md5._md5cycle(this._state, buf32);
+            bufLen = 0;
+        }
+        this._bufferLength = bufLen;
+        return this;
+    };
+    Md5.prototype.getState = function () {
+        var self = this;
+        var s = self._state;
+        return {
+            buffer: String.fromCharCode.apply(null, self._buffer8),
+            buflen: self._bufferLength,
+            length: self._dataLength,
+            state: [s[0], s[1], s[2], s[3]]
+        };
+    };
+    Md5.prototype.setState = function (state) {
+        var buf = state.buffer;
+        var x = state.state;
+        var s = this._state;
+        var i;
+        this._dataLength = state.length;
+        this._bufferLength = state.buflen;
+        s[0] = x[0];
+        s[1] = x[1];
+        s[2] = x[2];
+        s[3] = x[3];
+        for (i = 0; i < buf.length; i += 1) {
+            this._buffer8[i] = buf.charCodeAt(i);
+        }
+    };
+    Md5.prototype.end = function (raw) {
+        if (raw === void 0) { raw = false; }
+        var bufLen = this._bufferLength;
+        var buf8 = this._buffer8;
+        var buf32 = this._buffer32;
+        var i = (bufLen >> 2) + 1;
+        var dataBitsLen;
+        this._dataLength += bufLen;
+        buf8[bufLen] = 0x80;
+        buf8[bufLen + 1] = buf8[bufLen + 2] = buf8[bufLen + 3] = 0;
+        buf32.set(Md5.buffer32Identity.subarray(i), i);
+        if (bufLen > 55) {
+            Md5._md5cycle(this._state, buf32);
+            buf32.set(Md5.buffer32Identity);
+        }
+        // Do the final computation based on the tail and length
+        // Beware that the final length may not fit in 32 bits so we take care of that
+        dataBitsLen = this._dataLength * 8;
+        if (dataBitsLen <= 0xFFFFFFFF) {
+            buf32[14] = dataBitsLen;
+        }
+        else {
+            var matches = dataBitsLen.toString(16).match(/(.*?)(.{0,8})$/);
+            if (matches === null) {
+                return;
+            }
+            var lo = parseInt(matches[2], 16);
+            var hi = parseInt(matches[1], 16) || 0;
+            buf32[14] = lo;
+            buf32[15] = hi;
+        }
+        Md5._md5cycle(this._state, buf32);
+        return raw ? this._state : Md5._hex(this._state);
+    };
+    // Private Static Variables
+    Md5.stateIdentity = new Int32Array([1732584193, -271733879, -1732584194, 271733878]);
+    Md5.buffer32Identity = new Int32Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
+    Md5.hexChars = '0123456789abcdef';
+    Md5.hexOut = [];
+    // Permanent instance is to use for one-call hashing
+    Md5.onePassHasher = new Md5();
+    return Md5;
+}());
+exports.V = Md5;
+if (Md5.hashStr('hello') !== '5d41402abc4b2a76b9719d911017c592') {
+    console.error('Md5 self test failed.');
+}
+//# sourceMappingURL=md5.js.map
+
+/***/ }),
+
+/***/ 72:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+
+/**
+ * Module exports.
+ */
+
+module.exports = deprecate;
+
+/**
+ * Mark that a method should not be used.
+ * Returns a modified function which warns once by default.
+ *
+ * If `localStorage.noDeprecation = true` is set, then it is a no-op.
+ *
+ * If `localStorage.throwDeprecation = true` is set, then deprecated functions
+ * will throw an Error when invoked.
+ *
+ * If `localStorage.traceDeprecation = true` is set, then deprecated functions
+ * will invoke `console.trace()` instead of `console.error()`.
+ *
+ * @param {Function} fn - the function to deprecate
+ * @param {String} msg - the string to print to the console when `fn` is invoked
+ * @returns {Function} a new "deprecated" version of `fn`
+ * @api public
+ */
+
+function deprecate (fn, msg) {
+  if (config('noDeprecation')) {
+    return fn;
+  }
+
+  var warned = false;
+  function deprecated() {
+    if (!warned) {
+      if (config('throwDeprecation')) {
+        throw new Error(msg);
+      } else if (config('traceDeprecation')) {
+        console.trace(msg);
+      } else {
+        console.warn(msg);
+      }
+      warned = true;
+    }
+    return fn.apply(this, arguments);
+  }
+
+  return deprecated;
+}
+
+/**
+ * Checks `localStorage` for boolean values for the given `name`.
+ *
+ * @param {String} name
+ * @returns {Boolean}
+ * @api private
+ */
+
+function config (name) {
+  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
+  try {
+    if (!__webpack_require__.g.localStorage) return false;
+  } catch (_) {
+    return false;
+  }
+  var val = __webpack_require__.g.localStorage[name];
+  if (null == val) return false;
+  return String(val).toLowerCase() === 'true';
+}
+
+
+/***/ }),
+
+/***/ 769:
+/***/ ((module) => {
+
+module.exports = function (it) {
+  if (typeof it != 'function') {
+    throw TypeError(String(it) + ' is not a function');
+  } return it;
+};
+
+
+/***/ }),
+
+/***/ 8143:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var isObject = __webpack_require__(6944);
+
+module.exports = function (it) {
+  if (!isObject(it) && it !== null) {
+    throw TypeError("Can't set " + String(it) + ' as a prototype');
+  } return it;
+};
+
+
+/***/ }),
+
+/***/ 9611:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var wellKnownSymbol = __webpack_require__(3706);
+var create = __webpack_require__(2361);
+var definePropertyModule = __webpack_require__(3376);
+
+var UNSCOPABLES = wellKnownSymbol('unscopables');
+var ArrayPrototype = Array.prototype;
+
+// Array.prototype[@@unscopables]
+// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
+if (ArrayPrototype[UNSCOPABLES] == undefined) {
+  definePropertyModule.f(ArrayPrototype, UNSCOPABLES, {
+    configurable: true,
+    value: create(null)
+  });
+}
+
+// add a key to Array.prototype[@@unscopables]
+module.exports = function (key) {
+  ArrayPrototype[UNSCOPABLES][key] = true;
+};
+
+
+/***/ }),
+
+/***/ 2482:
+/***/ ((module) => {
+
+module.exports = function (it, Constructor, name) {
+  if (!(it instanceof Constructor)) {
+    throw TypeError('Incorrect ' + (name ? name + ' ' : '') + 'invocation');
+  } return it;
+};
+
+
+/***/ }),
+
+/***/ 47:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var isObject = __webpack_require__(6944);
+
+module.exports = function (it) {
+  if (!isObject(it)) {
+    throw TypeError(String(it) + ' is not an object');
+  } return it;
+};
+
+
+/***/ }),
+
+/***/ 1774:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+
+var bind = __webpack_require__(4833);
+var toObject = __webpack_require__(4680);
+var callWithSafeIterationClosing = __webpack_require__(3960);
+var isArrayIteratorMethod = __webpack_require__(1008);
+var toLength = __webpack_require__(4954);
+var createProperty = __webpack_require__(2076);
+var getIteratorMethod = __webpack_require__(3126);
+
+// `Array.from` method implementation
+// https://tc39.es/ecma262/#sec-array.from
+module.exports = function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
+  var O = toObject(arrayLike);
+  var C = typeof this == 'function' ? this : Array;
+  var argumentsLength = arguments.length;
+  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
+  var mapping = mapfn !== undefined;
+  var iteratorMethod = getIteratorMethod(O);
+  var index = 0;
+  var length, result, step, iterator, next, value;
+  if (mapping) mapfn = bind(mapfn, argumentsLength > 2 ? arguments[2] : undefined, 2);
+  // if the target is not iterable or it's an array with the default iterator - use a simple case
+  if (iteratorMethod != undefined && !(C == Array && isArrayIteratorMethod(iteratorMethod))) {
+    iterator = iteratorMethod.call(O);
+    next = iterator.next;
+    result = new C();
+    for (;!(step = next.call(iterator)).done; index++) {
+      value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true) : step.value;
+      createProperty(result, index, value);
+    }
+  } else {
+    length = toLength(O.length);
+    result = new C(length);
+    for (;length > index; index++) {
+      value = mapping ? mapfn(O[index], index) : O[index];
+      createProperty(result, index, value);
+    }
+  }
+  result.length = index;
+  return result;
+};
+
+
+/***/ }),
+
+/***/ 1270:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var toIndexedObject = __webpack_require__(8852);
+var toLength = __webpack_require__(4954);
+var toAbsoluteIndex = __webpack_require__(2145);
+
+// `Array.prototype.{ indexOf, includes }` methods implementation
+var createMethod = function (IS_INCLUDES) {
+  return function ($this, el, fromIndex) {
+    var O = toIndexedObject($this);
+    var length = toLength(O.length);
+    var index = toAbsoluteIndex(fromIndex, length);
+    var value;
+    // Array#includes uses SameValueZero equality algorithm
+    // eslint-disable-next-line no-self-compare -- NaN check
+    if (IS_INCLUDES && el != el) while (length > index) {
+      value = O[index++];
+      // eslint-disable-next-line no-self-compare -- NaN check
+      if (value != value) return true;
+    // Array#indexOf ignores holes, Array#includes - not
+    } else for (;length > index; index++) {
+      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
+    } return !IS_INCLUDES && -1;
+  };
+};
+
+module.exports = {
+  // `Array.prototype.includes` method
+  // https://tc39.es/ecma262/#sec-array.prototype.includes
+  includes: createMethod(true),
+  // `Array.prototype.indexOf` method
+  // https://tc39.es/ecma262/#sec-array.prototype.indexof
+  indexOf: createMethod(false)
+};
+
+
+/***/ }),
+
+/***/ 3960:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var anObject = __webpack_require__(47);
+var iteratorClose = __webpack_require__(2608);
+
+// call something on iterator step with safe closing on error
+module.exports = function (iterator, fn, value, ENTRIES) {
+  try {
+    return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);
+  } catch (error) {
+    iteratorClose(iterator);
+    throw error;
+  }
+};
+
+
+/***/ }),
+
+/***/ 3565:
+/***/ ((module) => {
+
+var toString = {}.toString;
+
+module.exports = function (it) {
+  return toString.call(it).slice(8, -1);
+};
+
+
+/***/ }),
+
+/***/ 8753:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var TO_STRING_TAG_SUPPORT = __webpack_require__(939);
+var classofRaw = __webpack_require__(3565);
+var wellKnownSymbol = __webpack_require__(3706);
+
+var TO_STRING_TAG = wellKnownSymbol('toStringTag');
+// ES3 wrong here
+var CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';
+
+// fallback for IE11 Script Access Denied error
+var tryGet = function (it, key) {
+  try {
+    return it[key];
+  } catch (error) { /* empty */ }
+};
+
+// getting tag from ES6+ `Object.prototype.toString`
+module.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {
+  var O, tag, result;
+  return it === undefined ? 'Undefined' : it === null ? 'Null'
+    // @@toStringTag case
+    : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG)) == 'string' ? tag
+    // builtinTag case
+    : CORRECT_ARGUMENTS ? classofRaw(O)
+    // ES3 arguments fallback
+    : (result = classofRaw(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : result;
+};
+
+
+/***/ }),
+
+/***/ 7918:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var has = __webpack_require__(5884);
+var ownKeys = __webpack_require__(8204);
+var getOwnPropertyDescriptorModule = __webpack_require__(7825);
+var definePropertyModule = __webpack_require__(3376);
+
+module.exports = function (target, source) {
+  var keys = ownKeys(source);
+  var defineProperty = definePropertyModule.f;
+  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
+  for (var i = 0; i < keys.length; i++) {
+    var key = keys[i];
+    if (!has(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));
+  }
+};
+
+
+/***/ }),
+
+/***/ 9241:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var fails = __webpack_require__(7841);
+
+module.exports = !fails(function () {
+  function F() { /* empty */ }
+  F.prototype.constructor = null;
+  // eslint-disable-next-line es/no-object-getprototypeof -- required for testing
+  return Object.getPrototypeOf(new F()) !== F.prototype;
+});
+
+
+/***/ }),
+
+/***/ 9670:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+
+var IteratorPrototype = __webpack_require__(888).IteratorPrototype;
+var create = __webpack_require__(2361);
+var createPropertyDescriptor = __webpack_require__(976);
+var setToStringTag = __webpack_require__(9400);
+var Iterators = __webpack_require__(873);
+
+var returnThis = function () { return this; };
+
+module.exports = function (IteratorConstructor, NAME, next) {
+  var TO_STRING_TAG = NAME + ' Iterator';
+  IteratorConstructor.prototype = create(IteratorPrototype, { next: createPropertyDescriptor(1, next) });
+  setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
+  Iterators[TO_STRING_TAG] = returnThis;
+  return IteratorConstructor;
+};
+
+
+/***/ }),
+
+/***/ 4791:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var DESCRIPTORS = __webpack_require__(5542);
+var definePropertyModule = __webpack_require__(3376);
+var createPropertyDescriptor = __webpack_require__(976);
+
+module.exports = DESCRIPTORS ? function (object, key, value) {
+  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
+} : function (object, key, value) {
+  object[key] = value;
+  return object;
+};
+
+
+/***/ }),
+
+/***/ 976:
+/***/ ((module) => {
+
+module.exports = function (bitmap, value) {
+  return {
+    enumerable: !(bitmap & 1),
+    configurable: !(bitmap & 2),
+    writable: !(bitmap & 4),
+    value: value
+  };
+};
+
+
+/***/ }),
+
+/***/ 2076:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+
+var toPropertyKey = __webpack_require__(2694);
+var definePropertyModule = __webpack_require__(3376);
+var createPropertyDescriptor = __webpack_require__(976);
+
+module.exports = function (object, key, value) {
+  var propertyKey = toPropertyKey(key);
+  if (propertyKey in object) definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));
+  else object[propertyKey] = value;
+};
+
+
+/***/ }),
+
+/***/ 3131:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+
+var $ = __webpack_require__(1082);
+var createIteratorConstructor = __webpack_require__(9670);
+var getPrototypeOf = __webpack_require__(8186);
+var setPrototypeOf = __webpack_require__(2686);
+var setToStringTag = __webpack_require__(9400);
+var createNonEnumerableProperty = __webpack_require__(4791);
+var redefine = __webpack_require__(1249);
+var wellKnownSymbol = __webpack_require__(3706);
+var IS_PURE = __webpack_require__(6852);
+var Iterators = __webpack_require__(873);
+var IteratorsCore = __webpack_require__(888);
+
+var IteratorPrototype = IteratorsCore.IteratorPrototype;
+var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
+var ITERATOR = wellKnownSymbol('iterator');
+var KEYS = 'keys';
+var VALUES = 'values';
+var ENTRIES = 'entries';
+
+var returnThis = function () { return this; };
+
+module.exports = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
+  createIteratorConstructor(IteratorConstructor, NAME, next);
+
+  var getIterationMethod = function (KIND) {
+    if (KIND === DEFAULT && defaultIterator) return defaultIterator;
+    if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];
+    switch (KIND) {
+      case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };
+      case VALUES: return function values() { return new IteratorConstructor(this, KIND); };
+      case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };
+    } return function () { return new IteratorConstructor(this); };
+  };
+
+  var TO_STRING_TAG = NAME + ' Iterator';
+  var INCORRECT_VALUES_NAME = false;
+  var IterablePrototype = Iterable.prototype;
+  var nativeIterator = IterablePrototype[ITERATOR]
+    || IterablePrototype['@@iterator']
+    || DEFAULT && IterablePrototype[DEFAULT];
+  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
+  var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
+  var CurrentIteratorPrototype, methods, KEY;
+
+  // fix native
+  if (anyNativeIterator) {
+    CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
+    if (IteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
+      if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
+        if (setPrototypeOf) {
+          setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
+        } else if (typeof CurrentIteratorPrototype[ITERATOR] != 'function') {
+          createNonEnumerableProperty(CurrentIteratorPrototype, ITERATOR, returnThis);
+        }
+      }
+      // Set @@toStringTag to native iterators
+      setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
+      if (IS_PURE) Iterators[TO_STRING_TAG] = returnThis;
+    }
+  }
+
+  // fix Array.prototype.{ values, @@iterator }.name in V8 / FF
+  if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
+    INCORRECT_VALUES_NAME = true;
+    defaultIterator = function values() { return nativeIterator.call(this); };
+  }
+
+  // define iterator
+  if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
+    createNonEnumerableProperty(IterablePrototype, ITERATOR, defaultIterator);
+  }
+  Iterators[NAME] = defaultIterator;
+
+  // export additional methods
+  if (DEFAULT) {
+    methods = {
+      values: getIterationMethod(VALUES),
+      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
+      entries: getIterationMethod(ENTRIES)
+    };
+    if (FORCED) for (KEY in methods) {
+      if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
+        redefine(IterablePrototype, KEY, methods[KEY]);
+      }
+    } else $({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
+  }
+
+  return methods;
+};
+
+
+/***/ }),
+
+/***/ 5542:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var fails = __webpack_require__(7841);
+
+// Detect IE8's incomplete defineProperty implementation
+module.exports = !fails(function () {
+  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
+  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;
+});
+
+
+/***/ }),
+
+/***/ 3879:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var global = __webpack_require__(6874);
+var isObject = __webpack_require__(6944);
+
+var document = global.document;
+// typeof document.createElement is 'object' in old IE
+var EXISTS = isObject(document) && isObject(document.createElement);
+
+module.exports = function (it) {
+  return EXISTS ? document.createElement(it) : {};
+};
+
+
+/***/ }),
+
+/***/ 4229:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var getBuiltIn = __webpack_require__(4578);
+
+module.exports = getBuiltIn('navigator', 'userAgent') || '';
+
+
+/***/ }),
+
+/***/ 579:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var global = __webpack_require__(6874);
+var userAgent = __webpack_require__(4229);
+
+var process = global.process;
+var Deno = global.Deno;
+var versions = process && process.versions || Deno && Deno.version;
+var v8 = versions && versions.v8;
+var match, version;
+
+if (v8) {
+  match = v8.split('.');
+  version = match[0] < 4 ? 1 : match[0] + match[1];
+} else if (userAgent) {
+  match = userAgent.match(/Edge\/(\d+)/);
+  if (!match || match[1] >= 74) {
+    match = userAgent.match(/Chrome\/(\d+)/);
+    if (match) version = match[1];
+  }
+}
+
+module.exports = version && +version;
+
+
+/***/ }),
+
+/***/ 9752:
+/***/ ((module) => {
+
+// IE8- don't enum bug keys
+module.exports = [
+  'constructor',
+  'hasOwnProperty',
+  'isPrototypeOf',
+  'propertyIsEnumerable',
+  'toLocaleString',
+  'toString',
+  'valueOf'
+];
+
+
+/***/ }),
+
+/***/ 1082:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var global = __webpack_require__(6874);
+var getOwnPropertyDescriptor = __webpack_require__(7825).f;
+var createNonEnumerableProperty = __webpack_require__(4791);
+var redefine = __webpack_require__(1249);
+var setGlobal = __webpack_require__(1278);
+var copyConstructorProperties = __webpack_require__(7918);
+var isForced = __webpack_require__(2350);
+
+/*
+  options.target      - name of the target object
+  options.global      - target is the global object
+  options.stat        - export as static methods of target
+  options.proto       - export as prototype methods of target
+  options.real        - real prototype method for the `pure` version
+  options.forced      - export even if the native feature is available
+  options.bind        - bind methods to the target, required for the `pure` version
+  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
+  options.unsafe      - use the simple assignment of property instead of delete + defineProperty
+  options.sham        - add a flag to not completely full polyfills
+  options.enumerable  - export as enumerable property
+  options.noTargetGet - prevent calling a getter on target
+*/
+module.exports = function (options, source) {
+  var TARGET = options.target;
+  var GLOBAL = options.global;
+  var STATIC = options.stat;
+  var FORCED, target, key, targetProperty, sourceProperty, descriptor;
+  if (GLOBAL) {
+    target = global;
+  } else if (STATIC) {
+    target = global[TARGET] || setGlobal(TARGET, {});
+  } else {
+    target = (global[TARGET] || {}).prototype;
+  }
+  if (target) for (key in source) {
+    sourceProperty = source[key];
+    if (options.noTargetGet) {
+      descriptor = getOwnPropertyDescriptor(target, key);
+      targetProperty = descriptor && descriptor.value;
+    } else targetProperty = target[key];
+    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
+    // contained in target
+    if (!FORCED && targetProperty !== undefined) {
+      if (typeof sourceProperty === typeof targetProperty) continue;
+      copyConstructorProperties(sourceProperty, targetProperty);
+    }
+    // add a flag to not completely full polyfills
+    if (options.sham || (targetProperty && targetProperty.sham)) {
+      createNonEnumerableProperty(sourceProperty, 'sham', true);
+    }
+    // extend global
+    redefine(target, key, sourceProperty, options);
+  }
+};
+
+
+/***/ }),
+
+/***/ 7841:
+/***/ ((module) => {
+
+module.exports = function (exec) {
+  try {
+    return !!exec();
+  } catch (error) {
+    return true;
+  }
+};
+
+
+/***/ }),
+
+/***/ 4833:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var aFunction = __webpack_require__(769);
+
+// optional / simple context binding
+module.exports = function (fn, that, length) {
+  aFunction(fn);
+  if (that === undefined) return fn;
+  switch (length) {
+    case 0: return function () {
+      return fn.call(that);
+    };
+    case 1: return function (a) {
+      return fn.call(that, a);
+    };
+    case 2: return function (a, b) {
+      return fn.call(that, a, b);
+    };
+    case 3: return function (a, b, c) {
+      return fn.call(that, a, b, c);
+    };
+  }
+  return function (/* ...args */) {
+    return fn.apply(that, arguments);
+  };
+};
+
+
+/***/ }),
+
+/***/ 4578:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var global = __webpack_require__(6874);
+
+var aFunction = function (variable) {
+  return typeof variable == 'function' ? variable : undefined;
+};
+
+module.exports = function (namespace, method) {
+  return arguments.length < 2 ? aFunction(global[namespace]) : global[namespace] && global[namespace][method];
+};
+
+
+/***/ }),
+
+/***/ 3126:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var classof = __webpack_require__(8753);
+var Iterators = __webpack_require__(873);
+var wellKnownSymbol = __webpack_require__(3706);
+
+var ITERATOR = wellKnownSymbol('iterator');
+
+module.exports = function (it) {
+  if (it != undefined) return it[ITERATOR]
+    || it['@@iterator']
+    || Iterators[classof(it)];
+};
+
+
+/***/ }),
+
+/***/ 7053:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var anObject = __webpack_require__(47);
+var getIteratorMethod = __webpack_require__(3126);
+
+module.exports = function (it) {
+  var iteratorMethod = getIteratorMethod(it);
+  if (typeof iteratorMethod != 'function') {
+    throw TypeError(String(it) + ' is not iterable');
+  } return anObject(iteratorMethod.call(it));
+};
+
+
+/***/ }),
+
+/***/ 6874:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var check = function (it) {
+  return it && it.Math == Math && it;
+};
+
+// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
+module.exports =
+  // eslint-disable-next-line es/no-global-this -- safe
+  check(typeof globalThis == 'object' && globalThis) ||
+  check(typeof window == 'object' && window) ||
+  // eslint-disable-next-line no-restricted-globals -- safe
+  check(typeof self == 'object' && self) ||
+  check(typeof __webpack_require__.g == 'object' && __webpack_require__.g) ||
+  // eslint-disable-next-line no-new-func -- fallback
+  (function () { return this; })() || Function('return this')();
+
+
+/***/ }),
+
+/***/ 5884:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var toObject = __webpack_require__(4680);
+
+var hasOwnProperty = {}.hasOwnProperty;
+
+module.exports = Object.hasOwn || function hasOwn(it, key) {
+  return hasOwnProperty.call(toObject(it), key);
+};
+
+
+/***/ }),
+
+/***/ 5644:
+/***/ ((module) => {
+
+module.exports = {};
+
+
+/***/ }),
+
+/***/ 7666:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var getBuiltIn = __webpack_require__(4578);
+
+module.exports = getBuiltIn('document', 'documentElement');
+
+
+/***/ }),
+
+/***/ 6056:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var DESCRIPTORS = __webpack_require__(5542);
+var fails = __webpack_require__(7841);
+var createElement = __webpack_require__(3879);
+
+// Thank's IE8 for his funny defineProperty
+module.exports = !DESCRIPTORS && !fails(function () {
+  // eslint-disable-next-line es/no-object-defineproperty -- requied for testing
+  return Object.defineProperty(createElement('div'), 'a', {
+    get: function () { return 7; }
+  }).a != 7;
+});
+
+
+/***/ }),
+
+/***/ 8517:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var fails = __webpack_require__(7841);
+var classof = __webpack_require__(3565);
+
+var split = ''.split;
+
+// fallback for non-array-like ES3 and non-enumerable old V8 strings
+module.exports = fails(function () {
+  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
+  // eslint-disable-next-line no-prototype-builtins -- safe
+  return !Object('z').propertyIsEnumerable(0);
+}) ? function (it) {
+  return classof(it) == 'String' ? split.call(it, '') : Object(it);
+} : Object;
+
+
+/***/ }),
+
+/***/ 6090:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var store = __webpack_require__(4925);
+
+var functionToString = Function.toString;
+
+// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper
+if (typeof store.inspectSource != 'function') {
+  store.inspectSource = function (it) {
+    return functionToString.call(it);
+  };
+}
+
+module.exports = store.inspectSource;
+
+
+/***/ }),
+
+/***/ 6619:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var NATIVE_WEAK_MAP = __webpack_require__(9957);
+var global = __webpack_require__(6874);
+var isObject = __webpack_require__(6944);
+var createNonEnumerableProperty = __webpack_require__(4791);
+var objectHas = __webpack_require__(5884);
+var shared = __webpack_require__(4925);
+var sharedKey = __webpack_require__(8698);
+var hiddenKeys = __webpack_require__(5644);
+
+var OBJECT_ALREADY_INITIALIZED = 'Object already initialized';
+var WeakMap = global.WeakMap;
+var set, get, has;
+
+var enforce = function (it) {
+  return has(it) ? get(it) : set(it, {});
+};
+
+var getterFor = function (TYPE) {
+  return function (it) {
+    var state;
+    if (!isObject(it) || (state = get(it)).type !== TYPE) {
+      throw TypeError('Incompatible receiver, ' + TYPE + ' required');
+    } return state;
+  };
+};
+
+if (NATIVE_WEAK_MAP || shared.state) {
+  var store = shared.state || (shared.state = new WeakMap());
+  var wmget = store.get;
+  var wmhas = store.has;
+  var wmset = store.set;
+  set = function (it, metadata) {
+    if (wmhas.call(store, it)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
+    metadata.facade = it;
+    wmset.call(store, it, metadata);
+    return metadata;
+  };
+  get = function (it) {
+    return wmget.call(store, it) || {};
+  };
+  has = function (it) {
+    return wmhas.call(store, it);
+  };
+} else {
+  var STATE = sharedKey('state');
+  hiddenKeys[STATE] = true;
+  set = function (it, metadata) {
+    if (objectHas(it, STATE)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
+    metadata.facade = it;
+    createNonEnumerableProperty(it, STATE, metadata);
+    return metadata;
+  };
+  get = function (it) {
+    return objectHas(it, STATE) ? it[STATE] : {};
+  };
+  has = function (it) {
+    return objectHas(it, STATE);
+  };
+}
+
+module.exports = {
+  set: set,
+  get: get,
+  has: has,
+  enforce: enforce,
+  getterFor: getterFor
+};
+
+
+/***/ }),
+
+/***/ 1008:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var wellKnownSymbol = __webpack_require__(3706);
+var Iterators = __webpack_require__(873);
+
+var ITERATOR = wellKnownSymbol('iterator');
+var ArrayPrototype = Array.prototype;
+
+// check on default Array iterator
+module.exports = function (it) {
+  return it !== undefined && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
+};
+
+
+/***/ }),
+
+/***/ 2350:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var fails = __webpack_require__(7841);
+
+var replacement = /#|\.prototype\./;
+
+var isForced = function (feature, detection) {
+  var value = data[normalize(feature)];
+  return value == POLYFILL ? true
+    : value == NATIVE ? false
+    : typeof detection == 'function' ? fails(detection)
+    : !!detection;
+};
+
+var normalize = isForced.normalize = function (string) {
+  return String(string).replace(replacement, '.').toLowerCase();
+};
+
+var data = isForced.data = {};
+var NATIVE = isForced.NATIVE = 'N';
+var POLYFILL = isForced.POLYFILL = 'P';
+
+module.exports = isForced;
+
+
+/***/ }),
+
+/***/ 6944:
+/***/ ((module) => {
+
+module.exports = function (it) {
+  return typeof it === 'object' ? it !== null : typeof it === 'function';
+};
+
+
+/***/ }),
+
+/***/ 6852:
+/***/ ((module) => {
+
+module.exports = false;
+
+
+/***/ }),
+
+/***/ 8377:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var getBuiltIn = __webpack_require__(4578);
+var USE_SYMBOL_AS_UID = __webpack_require__(4587);
+
+module.exports = USE_SYMBOL_AS_UID ? function (it) {
+  return typeof it == 'symbol';
+} : function (it) {
+  var $Symbol = getBuiltIn('Symbol');
+  return typeof $Symbol == 'function' && Object(it) instanceof $Symbol;
+};
+
+
+/***/ }),
+
+/***/ 2608:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var anObject = __webpack_require__(47);
+
+module.exports = function (iterator) {
+  var returnMethod = iterator['return'];
+  if (returnMethod !== undefined) {
+    return anObject(returnMethod.call(iterator)).value;
+  }
+};
+
+
+/***/ }),
+
+/***/ 888:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+
+var fails = __webpack_require__(7841);
+var getPrototypeOf = __webpack_require__(8186);
+var createNonEnumerableProperty = __webpack_require__(4791);
+var has = __webpack_require__(5884);
+var wellKnownSymbol = __webpack_require__(3706);
+var IS_PURE = __webpack_require__(6852);
+
+var ITERATOR = wellKnownSymbol('iterator');
+var BUGGY_SAFARI_ITERATORS = false;
+
+var returnThis = function () { return this; };
+
+// `%IteratorPrototype%` object
+// https://tc39.es/ecma262/#sec-%iteratorprototype%-object
+var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;
+
+/* eslint-disable es/no-array-prototype-keys -- safe */
+if ([].keys) {
+  arrayIterator = [].keys();
+  // Safari 8 has buggy iterators w/o `next`
+  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;
+  else {
+    PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
+    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
+  }
+}
+
+var NEW_ITERATOR_PROTOTYPE = IteratorPrototype == undefined || fails(function () {
+  var test = {};
+  // FF44- legacy iterators case
+  return IteratorPrototype[ITERATOR].call(test) !== test;
+});
+
+if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype = {};
+
+// `%IteratorPrototype%[@@iterator]()` method
+// https://tc39.es/ecma262/#sec-%iteratorprototype%-@@iterator
+if ((!IS_PURE || NEW_ITERATOR_PROTOTYPE) && !has(IteratorPrototype, ITERATOR)) {
+  createNonEnumerableProperty(IteratorPrototype, ITERATOR, returnThis);
+}
+
+module.exports = {
+  IteratorPrototype: IteratorPrototype,
+  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS
+};
+
+
+/***/ }),
+
+/***/ 873:
+/***/ ((module) => {
+
+module.exports = {};
+
+
+/***/ }),
+
+/***/ 1453:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+/* eslint-disable es/no-symbol -- required for testing */
+var V8_VERSION = __webpack_require__(579);
+var fails = __webpack_require__(7841);
+
+// eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing
+module.exports = !!Object.getOwnPropertySymbols && !fails(function () {
+  var symbol = Symbol();
+  // Chrome 38 Symbol has incorrect toString conversion
+  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances
+  return !String(symbol) || !(Object(symbol) instanceof Symbol) ||
+    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
+    !Symbol.sham && V8_VERSION && V8_VERSION < 41;
+});
+
+
+/***/ }),
+
+/***/ 1781:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var fails = __webpack_require__(7841);
+var wellKnownSymbol = __webpack_require__(3706);
+var IS_PURE = __webpack_require__(6852);
+
+var ITERATOR = wellKnownSymbol('iterator');
+
+module.exports = !fails(function () {
+  var url = new URL('b?a=1&b=2&c=3', 'http://a');
+  var searchParams = url.searchParams;
+  var result = '';
+  url.pathname = 'c%20d';
+  searchParams.forEach(function (value, key) {
+    searchParams['delete']('b');
+    result += key + value;
+  });
+  return (IS_PURE && !url.toJSON)
+    || !searchParams.sort
+    || url.href !== 'http://a/c%20d?a=1&c=3'
+    || searchParams.get('c') !== '3'
+    || String(new URLSearchParams('?a=1')) !== 'a=1'
+    || !searchParams[ITERATOR]
+    // throws in Edge
+    || new URL('https://a@b').username !== 'a'
+    || new URLSearchParams(new URLSearchParams('a=b')).get('a') !== 'b'
+    // not punycoded in Edge
+    || new URL('http://').host !== 'xn--e1aybc'
+    // not escaped in Chrome 62-
+    || new URL('http://a#').hash !== '#%D0%B1'
+    // fails in Chrome 66-
+    || result !== 'a1c3'
+    // throws in Safari
+    || new URL('http://x', undefined).host !== 'x';
+});
+
+
+/***/ }),
+
+/***/ 9957:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var global = __webpack_require__(6874);
+var inspectSource = __webpack_require__(6090);
+
+var WeakMap = global.WeakMap;
+
+module.exports = typeof WeakMap === 'function' && /native code/.test(inspectSource(WeakMap));
+
+
+/***/ }),
+
+/***/ 5277:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+
+var DESCRIPTORS = __webpack_require__(5542);
+var fails = __webpack_require__(7841);
+var objectKeys = __webpack_require__(965);
+var getOwnPropertySymbolsModule = __webpack_require__(1913);
+var propertyIsEnumerableModule = __webpack_require__(3626);
+var toObject = __webpack_require__(4680);
+var IndexedObject = __webpack_require__(8517);
+
+// eslint-disable-next-line es/no-object-assign -- safe
+var $assign = Object.assign;
+// eslint-disable-next-line es/no-object-defineproperty -- required for testing
+var defineProperty = Object.defineProperty;
+
+// `Object.assign` method
+// https://tc39.es/ecma262/#sec-object.assign
+module.exports = !$assign || fails(function () {
+  // should have correct order of operations (Edge bug)
+  if (DESCRIPTORS && $assign({ b: 1 }, $assign(defineProperty({}, 'a', {
+    enumerable: true,
+    get: function () {
+      defineProperty(this, 'b', {
+        value: 3,
+        enumerable: false
+      });
+    }
+  }), { b: 2 })).b !== 1) return true;
+  // should work with symbols and should have deterministic property order (V8 bug)
+  var A = {};
+  var B = {};
+  // eslint-disable-next-line es/no-symbol -- safe
+  var symbol = Symbol();
+  var alphabet = 'abcdefghijklmnopqrst';
+  A[symbol] = 7;
+  alphabet.split('').forEach(function (chr) { B[chr] = chr; });
+  return $assign({}, A)[symbol] != 7 || objectKeys($assign({}, B)).join('') != alphabet;
+}) ? function assign(target, source) { // eslint-disable-line no-unused-vars -- required for `.length`
+  var T = toObject(target);
+  var argumentsLength = arguments.length;
+  var index = 1;
+  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
+  var propertyIsEnumerable = propertyIsEnumerableModule.f;
+  while (argumentsLength > index) {
+    var S = IndexedObject(arguments[index++]);
+    var keys = getOwnPropertySymbols ? objectKeys(S).concat(getOwnPropertySymbols(S)) : objectKeys(S);
+    var length = keys.length;
+    var j = 0;
+    var key;
+    while (length > j) {
+      key = keys[j++];
+      if (!DESCRIPTORS || propertyIsEnumerable.call(S, key)) T[key] = S[key];
+    }
+  } return T;
+} : $assign;
+
+
+/***/ }),
+
+/***/ 2361:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+/* global ActiveXObject -- old IE, WSH */
+var anObject = __webpack_require__(47);
+var defineProperties = __webpack_require__(7852);
+var enumBugKeys = __webpack_require__(9752);
+var hiddenKeys = __webpack_require__(5644);
+var html = __webpack_require__(7666);
+var documentCreateElement = __webpack_require__(3879);
+var sharedKey = __webpack_require__(8698);
+
+var GT = '>';
+var LT = '<';
+var PROTOTYPE = 'prototype';
+var SCRIPT = 'script';
+var IE_PROTO = sharedKey('IE_PROTO');
+
+var EmptyConstructor = function () { /* empty */ };
+
+var scriptTag = function (content) {
+  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
+};
+
+// Create object with fake `null` prototype: use ActiveX Object with cleared prototype
+var NullProtoObjectViaActiveX = function (activeXDocument) {
+  activeXDocument.write(scriptTag(''));
+  activeXDocument.close();
+  var temp = activeXDocument.parentWindow.Object;
+  activeXDocument = null; // avoid memory leak
+  return temp;
+};
+
+// Create object with fake `null` prototype: use iframe Object with cleared prototype
+var NullProtoObjectViaIFrame = function () {
+  // Thrash, waste and sodomy: IE GC bug
+  var iframe = documentCreateElement('iframe');
+  var JS = 'java' + SCRIPT + ':';
+  var iframeDocument;
+  iframe.style.display = 'none';
+  html.appendChild(iframe);
+  // https://github.com/zloirock/core-js/issues/475
+  iframe.src = String(JS);
+  iframeDocument = iframe.contentWindow.document;
+  iframeDocument.open();
+  iframeDocument.write(scriptTag('document.F=Object'));
+  iframeDocument.close();
+  return iframeDocument.F;
+};
+
+// Check for document.domain and active x support
+// No need to use active x approach when document.domain is not set
+// see https://github.com/es-shims/es5-shim/issues/150
+// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
+// avoid IE GC bug
+var activeXDocument;
+var NullProtoObject = function () {
+  try {
+    activeXDocument = new ActiveXObject('htmlfile');
+  } catch (error) { /* ignore */ }
+  NullProtoObject = typeof document != 'undefined'
+    ? document.domain && activeXDocument
+      ? NullProtoObjectViaActiveX(activeXDocument) // old IE
+      : NullProtoObjectViaIFrame()
+    : NullProtoObjectViaActiveX(activeXDocument); // WSH
+  var length = enumBugKeys.length;
+  while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
+  return NullProtoObject();
+};
+
+hiddenKeys[IE_PROTO] = true;
+
+// `Object.create` method
+// https://tc39.es/ecma262/#sec-object.create
+module.exports = Object.create || function create(O, Properties) {
+  var result;
+  if (O !== null) {
+    EmptyConstructor[PROTOTYPE] = anObject(O);
+    result = new EmptyConstructor();
+    EmptyConstructor[PROTOTYPE] = null;
+    // add "__proto__" for Object.getPrototypeOf polyfill
+    result[IE_PROTO] = O;
+  } else result = NullProtoObject();
+  return Properties === undefined ? result : defineProperties(result, Properties);
+};
+
+
+/***/ }),
+
+/***/ 7852:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var DESCRIPTORS = __webpack_require__(5542);
+var definePropertyModule = __webpack_require__(3376);
+var anObject = __webpack_require__(47);
+var objectKeys = __webpack_require__(965);
+
+// `Object.defineProperties` method
+// https://tc39.es/ecma262/#sec-object.defineproperties
+// eslint-disable-next-line es/no-object-defineproperties -- safe
+module.exports = DESCRIPTORS ? Object.defineProperties : function defineProperties(O, Properties) {
+  anObject(O);
+  var keys = objectKeys(Properties);
+  var length = keys.length;
+  var index = 0;
+  var key;
+  while (length > index) definePropertyModule.f(O, key = keys[index++], Properties[key]);
+  return O;
+};
+
+
+/***/ }),
+
+/***/ 3376:
+/***/ ((__unused_webpack_module, exports, __webpack_require__) => {
+
+var DESCRIPTORS = __webpack_require__(5542);
+var IE8_DOM_DEFINE = __webpack_require__(6056);
+var anObject = __webpack_require__(47);
+var toPropertyKey = __webpack_require__(2694);
+
+// eslint-disable-next-line es/no-object-defineproperty -- safe
+var $defineProperty = Object.defineProperty;
+
+// `Object.defineProperty` method
+// https://tc39.es/ecma262/#sec-object.defineproperty
+exports.f = DESCRIPTORS ? $defineProperty : function defineProperty(O, P, Attributes) {
+  anObject(O);
+  P = toPropertyKey(P);
+  anObject(Attributes);
+  if (IE8_DOM_DEFINE) try {
+    return $defineProperty(O, P, Attributes);
+  } catch (error) { /* empty */ }
+  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');
+  if ('value' in Attributes) O[P] = Attributes.value;
+  return O;
+};
+
+
+/***/ }),
+
+/***/ 7825:
+/***/ ((__unused_webpack_module, exports, __webpack_require__) => {
+
+var DESCRIPTORS = __webpack_require__(5542);
+var propertyIsEnumerableModule = __webpack_require__(3626);
+var createPropertyDescriptor = __webpack_require__(976);
+var toIndexedObject = __webpack_require__(8852);
+var toPropertyKey = __webpack_require__(2694);
+var has = __webpack_require__(5884);
+var IE8_DOM_DEFINE = __webpack_require__(6056);
+
+// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
+var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
+
+// `Object.getOwnPropertyDescriptor` method
+// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
+exports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
+  O = toIndexedObject(O);
+  P = toPropertyKey(P);
+  if (IE8_DOM_DEFINE) try {
+    return $getOwnPropertyDescriptor(O, P);
+  } catch (error) { /* empty */ }
+  if (has(O, P)) return createPropertyDescriptor(!propertyIsEnumerableModule.f.call(O, P), O[P]);
+};
+
+
+/***/ }),
+
+/***/ 8401:
+/***/ ((__unused_webpack_module, exports, __webpack_require__) => {
+
+var internalObjectKeys = __webpack_require__(8104);
+var enumBugKeys = __webpack_require__(9752);
+
+var hiddenKeys = enumBugKeys.concat('length', 'prototype');
+
+// `Object.getOwnPropertyNames` method
+// https://tc39.es/ecma262/#sec-object.getownpropertynames
+// eslint-disable-next-line es/no-object-getownpropertynames -- safe
+exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
+  return internalObjectKeys(O, hiddenKeys);
+};
+
+
+/***/ }),
+
+/***/ 1913:
+/***/ ((__unused_webpack_module, exports) => {
+
+// eslint-disable-next-line es/no-object-getownpropertysymbols -- safe
+exports.f = Object.getOwnPropertySymbols;
+
+
+/***/ }),
+
+/***/ 8186:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var has = __webpack_require__(5884);
+var toObject = __webpack_require__(4680);
+var sharedKey = __webpack_require__(8698);
+var CORRECT_PROTOTYPE_GETTER = __webpack_require__(9241);
+
+var IE_PROTO = sharedKey('IE_PROTO');
+var ObjectPrototype = Object.prototype;
+
+// `Object.getPrototypeOf` method
+// https://tc39.es/ecma262/#sec-object.getprototypeof
+// eslint-disable-next-line es/no-object-getprototypeof -- safe
+module.exports = CORRECT_PROTOTYPE_GETTER ? Object.getPrototypeOf : function (O) {
+  O = toObject(O);
+  if (has(O, IE_PROTO)) return O[IE_PROTO];
+  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
+    return O.constructor.prototype;
+  } return O instanceof Object ? ObjectPrototype : null;
+};
+
+
+/***/ }),
+
+/***/ 8104:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var has = __webpack_require__(5884);
+var toIndexedObject = __webpack_require__(8852);
+var indexOf = __webpack_require__(1270).indexOf;
+var hiddenKeys = __webpack_require__(5644);
+
+module.exports = function (object, names) {
+  var O = toIndexedObject(object);
+  var i = 0;
+  var result = [];
+  var key;
+  for (key in O) !has(hiddenKeys, key) && has(O, key) && result.push(key);
+  // Don't enum bug & hidden keys
+  while (names.length > i) if (has(O, key = names[i++])) {
+    ~indexOf(result, key) || result.push(key);
+  }
+  return result;
+};
+
+
+/***/ }),
+
+/***/ 965:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var internalObjectKeys = __webpack_require__(8104);
+var enumBugKeys = __webpack_require__(9752);
+
+// `Object.keys` method
+// https://tc39.es/ecma262/#sec-object.keys
+// eslint-disable-next-line es/no-object-keys -- safe
+module.exports = Object.keys || function keys(O) {
+  return internalObjectKeys(O, enumBugKeys);
+};
+
+
+/***/ }),
+
+/***/ 3626:
+/***/ ((__unused_webpack_module, exports) => {
+
+"use strict";
+
+var $propertyIsEnumerable = {}.propertyIsEnumerable;
+// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
+var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
+
+// Nashorn ~ JDK8 bug
+var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);
+
+// `Object.prototype.propertyIsEnumerable` method implementation
+// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable
+exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
+  var descriptor = getOwnPropertyDescriptor(this, V);
+  return !!descriptor && descriptor.enumerable;
+} : $propertyIsEnumerable;
+
+
+/***/ }),
+
+/***/ 2686:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+/* eslint-disable no-proto -- safe */
+var anObject = __webpack_require__(47);
+var aPossiblePrototype = __webpack_require__(8143);
+
+// `Object.setPrototypeOf` method
+// https://tc39.es/ecma262/#sec-object.setprototypeof
+// Works with __proto__ only. Old v8 can't work with null proto objects.
+// eslint-disable-next-line es/no-object-setprototypeof -- safe
+module.exports = Object.setPrototypeOf || ('__proto__' in {} ? function () {
+  var CORRECT_SETTER = false;
+  var test = {};
+  var setter;
+  try {
+    // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
+    setter = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set;
+    setter.call(test, []);
+    CORRECT_SETTER = test instanceof Array;
+  } catch (error) { /* empty */ }
+  return function setPrototypeOf(O, proto) {
+    anObject(O);
+    aPossiblePrototype(proto);
+    if (CORRECT_SETTER) setter.call(O, proto);
+    else O.__proto__ = proto;
+    return O;
+  };
+}() : undefined);
+
+
+/***/ }),
+
+/***/ 2392:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var isObject = __webpack_require__(6944);
+
+// `OrdinaryToPrimitive` abstract operation
+// https://tc39.es/ecma262/#sec-ordinarytoprimitive
+module.exports = function (input, pref) {
+  var fn, val;
+  if (pref === 'string' && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
+  if (typeof (fn = input.valueOf) == 'function' && !isObject(val = fn.call(input))) return val;
+  if (pref !== 'string' && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
+  throw TypeError("Can't convert object to primitive value");
+};
+
+
+/***/ }),
+
+/***/ 8204:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var getBuiltIn = __webpack_require__(4578);
+var getOwnPropertyNamesModule = __webpack_require__(8401);
+var getOwnPropertySymbolsModule = __webpack_require__(1913);
+var anObject = __webpack_require__(47);
+
+// all object keys, includes non-enumerable and symbols
+module.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
+  var keys = getOwnPropertyNamesModule.f(anObject(it));
+  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
+  return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;
+};
+
+
+/***/ }),
+
+/***/ 7490:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var redefine = __webpack_require__(1249);
+
+module.exports = function (target, src, options) {
+  for (var key in src) redefine(target, key, src[key], options);
+  return target;
+};
+
+
+/***/ }),
+
+/***/ 1249:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var global = __webpack_require__(6874);
+var createNonEnumerableProperty = __webpack_require__(4791);
+var has = __webpack_require__(5884);
+var setGlobal = __webpack_require__(1278);
+var inspectSource = __webpack_require__(6090);
+var InternalStateModule = __webpack_require__(6619);
+
+var getInternalState = InternalStateModule.get;
+var enforceInternalState = InternalStateModule.enforce;
+var TEMPLATE = String(String).split('String');
+
+(module.exports = function (O, key, value, options) {
+  var unsafe = options ? !!options.unsafe : false;
+  var simple = options ? !!options.enumerable : false;
+  var noTargetGet = options ? !!options.noTargetGet : false;
+  var state;
+  if (typeof value == 'function') {
+    if (typeof key == 'string' && !has(value, 'name')) {
+      createNonEnumerableProperty(value, 'name', key);
+    }
+    state = enforceInternalState(value);
+    if (!state.source) {
+      state.source = TEMPLATE.join(typeof key == 'string' ? key : '');
+    }
+  }
+  if (O === global) {
+    if (simple) O[key] = value;
+    else setGlobal(key, value);
+    return;
+  } else if (!unsafe) {
+    delete O[key];
+  } else if (!noTargetGet && O[key]) {
+    simple = true;
+  }
+  if (simple) O[key] = value;
+  else createNonEnumerableProperty(O, key, value);
+// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
+})(Function.prototype, 'toString', function toString() {
+  return typeof this == 'function' && getInternalState(this).source || inspectSource(this);
+});
+
+
+/***/ }),
+
+/***/ 164:
+/***/ ((module) => {
+
+// `RequireObjectCoercible` abstract operation
+// https://tc39.es/ecma262/#sec-requireobjectcoercible
+module.exports = function (it) {
+  if (it == undefined) throw TypeError("Can't call method on " + it);
+  return it;
+};
+
+
+/***/ }),
+
+/***/ 1278:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var global = __webpack_require__(6874);
+
+module.exports = function (key, value) {
+  try {
+    // eslint-disable-next-line es/no-object-defineproperty -- safe
+    Object.defineProperty(global, key, { value: value, configurable: true, writable: true });
+  } catch (error) {
+    global[key] = value;
+  } return value;
+};
+
+
+/***/ }),
+
+/***/ 9400:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var defineProperty = __webpack_require__(3376).f;
+var has = __webpack_require__(5884);
+var wellKnownSymbol = __webpack_require__(3706);
+
+var TO_STRING_TAG = wellKnownSymbol('toStringTag');
+
+module.exports = function (it, TAG, STATIC) {
+  if (it && !has(it = STATIC ? it : it.prototype, TO_STRING_TAG)) {
+    defineProperty(it, TO_STRING_TAG, { configurable: true, value: TAG });
+  }
+};
+
+
+/***/ }),
+
+/***/ 8698:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var shared = __webpack_require__(3215);
+var uid = __webpack_require__(8435);
+
+var keys = shared('keys');
+
+module.exports = function (key) {
+  return keys[key] || (keys[key] = uid(key));
+};
+
+
+/***/ }),
+
+/***/ 4925:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var global = __webpack_require__(6874);
+var setGlobal = __webpack_require__(1278);
+
+var SHARED = '__core-js_shared__';
+var store = global[SHARED] || setGlobal(SHARED, {});
+
+module.exports = store;
+
+
+/***/ }),
+
+/***/ 3215:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var IS_PURE = __webpack_require__(6852);
+var store = __webpack_require__(4925);
+
+(module.exports = function (key, value) {
+  return store[key] || (store[key] = value !== undefined ? value : {});
+})('versions', []).push({
+  version: '3.16.2',
+  mode: IS_PURE ? 'pure' : 'global',
+  copyright: ' 2021 Denis Pushkarev (zloirock.ru)'
+});
+
+
+/***/ }),
+
+/***/ 6174:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var toInteger = __webpack_require__(7896);
+var toString = __webpack_require__(401);
+var requireObjectCoercible = __webpack_require__(164);
+
+// `String.prototype.codePointAt` methods implementation
+var createMethod = function (CONVERT_TO_STRING) {
+  return function ($this, pos) {
+    var S = toString(requireObjectCoercible($this));
+    var position = toInteger(pos);
+    var size = S.length;
+    var first, second;
+    if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
+    first = S.charCodeAt(position);
+    return first < 0xD800 || first > 0xDBFF || position + 1 === size
+      || (second = S.charCodeAt(position + 1)) < 0xDC00 || second > 0xDFFF
+        ? CONVERT_TO_STRING ? S.charAt(position) : first
+        : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
+  };
+};
+
+module.exports = {
+  // `String.prototype.codePointAt` method
+  // https://tc39.es/ecma262/#sec-string.prototype.codepointat
+  codeAt: createMethod(false),
+  // `String.prototype.at` method
+  // https://github.com/mathiasbynens/String.prototype.at
+  charAt: createMethod(true)
+};
+
+
+/***/ }),
+
+/***/ 8:
+/***/ ((module) => {
+
+"use strict";
+
+// based on https://github.com/bestiejs/punycode.js/blob/master/punycode.js
+var maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1
+var base = 36;
+var tMin = 1;
+var tMax = 26;
+var skew = 38;
+var damp = 700;
+var initialBias = 72;
+var initialN = 128; // 0x80
+var delimiter = '-'; // '\x2D'
+var regexNonASCII = /[^\0-\u007E]/; // non-ASCII chars
+var regexSeparators = /[.\u3002\uFF0E\uFF61]/g; // RFC 3490 separators
+var OVERFLOW_ERROR = 'Overflow: input needs wider integers to process';
+var baseMinusTMin = base - tMin;
+var floor = Math.floor;
+var stringFromCharCode = String.fromCharCode;
+
+/**
+ * Creates an array containing the numeric code points of each Unicode
+ * character in the string. While JavaScript uses UCS-2 internally,
+ * this function will convert a pair of surrogate halves (each of which
+ * UCS-2 exposes as separate characters) into a single code point,
+ * matching UTF-16.
+ */
+var ucs2decode = function (string) {
+  var output = [];
+  var counter = 0;
+  var length = string.length;
+  while (counter < length) {
+    var value = string.charCodeAt(counter++);
+    if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
+      // It's a high surrogate, and there is a next character.
+      var extra = string.charCodeAt(counter++);
+      if ((extra & 0xFC00) == 0xDC00) { // Low surrogate.
+        output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
+      } else {
+        // It's an unmatched surrogate; only append this code unit, in case the
+        // next code unit is the high surrogate of a surrogate pair.
+        output.push(value);
+        counter--;
+      }
+    } else {
+      output.push(value);
+    }
+  }
+  return output;
+};
+
+/**
+ * Converts a digit/integer into a basic code point.
+ */
+var digitToBasic = function (digit) {
+  //  0..25 map to ASCII a..z or A..Z
+  // 26..35 map to ASCII 0..9
+  return digit + 22 + 75 * (digit < 26);
+};
+
+/**
+ * Bias adaptation function as per section 3.4 of RFC 3492.
+ * https://tools.ietf.org/html/rfc3492#section-3.4
+ */
+var adapt = function (delta, numPoints, firstTime) {
+  var k = 0;
+  delta = firstTime ? floor(delta / damp) : delta >> 1;
+  delta += floor(delta / numPoints);
+  for (; delta > baseMinusTMin * tMax >> 1; k += base) {
+    delta = floor(delta / baseMinusTMin);
+  }
+  return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
+};
+
+/**
+ * Converts a string of Unicode symbols (e.g. a domain name label) to a
+ * Punycode string of ASCII-only symbols.
+ */
+// eslint-disable-next-line max-statements -- TODO
+var encode = function (input) {
+  var output = [];
+
+  // Convert the input in UCS-2 to an array of Unicode code points.
+  input = ucs2decode(input);
+
+  // Cache the length.
+  var inputLength = input.length;
+
+  // Initialize the state.
+  var n = initialN;
+  var delta = 0;
+  var bias = initialBias;
+  var i, currentValue;
+
+  // Handle the basic code points.
+  for (i = 0; i < input.length; i++) {
+    currentValue = input[i];
+    if (currentValue < 0x80) {
+      output.push(stringFromCharCode(currentValue));
+    }
+  }
+
+  var basicLength = output.length; // number of basic code points.
+  var handledCPCount = basicLength; // number of code points that have been handled;
+
+  // Finish the basic string with a delimiter unless it's empty.
+  if (basicLength) {
+    output.push(delimiter);
+  }
+
+  // Main encoding loop:
+  while (handledCPCount < inputLength) {
+    // All non-basic code points < n have been handled already. Find the next larger one:
+    var m = maxInt;
+    for (i = 0; i < input.length; i++) {
+      currentValue = input[i];
+      if (currentValue >= n && currentValue < m) {
+        m = currentValue;
+      }
+    }
+
+    // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>, but guard against overflow.
+    var handledCPCountPlusOne = handledCPCount + 1;
+    if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
+      throw RangeError(OVERFLOW_ERROR);
+    }
+
+    delta += (m - n) * handledCPCountPlusOne;
+    n = m;
+
+    for (i = 0; i < input.length; i++) {
+      currentValue = input[i];
+      if (currentValue < n && ++delta > maxInt) {
+        throw RangeError(OVERFLOW_ERROR);
+      }
+      if (currentValue == n) {
+        // Represent delta as a generalized variable-length integer.
+        var q = delta;
+        for (var k = base; /* no condition */; k += base) {
+          var t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
+          if (q < t) break;
+          var qMinusT = q - t;
+          var baseMinusT = base - t;
+          output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT)));
+          q = floor(qMinusT / baseMinusT);
+        }
+
+        output.push(stringFromCharCode(digitToBasic(q)));
+        bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
+        delta = 0;
+        ++handledCPCount;
+      }
+    }
+
+    ++delta;
+    ++n;
+  }
+  return output.join('');
+};
+
+module.exports = function (input) {
+  var encoded = [];
+  var labels = input.toLowerCase().replace(regexSeparators, '\u002E').split('.');
+  var i, label;
+  for (i = 0; i < labels.length; i++) {
+    label = labels[i];
+    encoded.push(regexNonASCII.test(label) ? 'xn--' + encode(label) : label);
+  }
+  return encoded.join('.');
+};
+
+
+/***/ }),
+
+/***/ 2145:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var toInteger = __webpack_require__(7896);
+
+var max = Math.max;
+var min = Math.min;
+
+// Helper for a popular repeating case of the spec:
+// Let integer be ? ToInteger(index).
+// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
+module.exports = function (index, length) {
+  var integer = toInteger(index);
+  return integer < 0 ? max(integer + length, 0) : min(integer, length);
+};
+
+
+/***/ }),
+
+/***/ 8852:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+// toObject with fallback for non-array-like ES3 strings
+var IndexedObject = __webpack_require__(8517);
+var requireObjectCoercible = __webpack_require__(164);
+
+module.exports = function (it) {
+  return IndexedObject(requireObjectCoercible(it));
+};
+
+
+/***/ }),
+
+/***/ 7896:
+/***/ ((module) => {
+
+var ceil = Math.ceil;
+var floor = Math.floor;
+
+// `ToInteger` abstract operation
+// https://tc39.es/ecma262/#sec-tointeger
+module.exports = function (argument) {
+  return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);
+};
+
+
+/***/ }),
+
+/***/ 4954:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var toInteger = __webpack_require__(7896);
+
+var min = Math.min;
+
+// `ToLength` abstract operation
+// https://tc39.es/ecma262/#sec-tolength
+module.exports = function (argument) {
+  return argument > 0 ? min(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
+};
+
+
+/***/ }),
+
+/***/ 4680:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var requireObjectCoercible = __webpack_require__(164);
+
+// `ToObject` abstract operation
+// https://tc39.es/ecma262/#sec-toobject
+module.exports = function (argument) {
+  return Object(requireObjectCoercible(argument));
+};
+
+
+/***/ }),
+
+/***/ 2034:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var isObject = __webpack_require__(6944);
+var isSymbol = __webpack_require__(8377);
+var ordinaryToPrimitive = __webpack_require__(2392);
+var wellKnownSymbol = __webpack_require__(3706);
+
+var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');
+
+// `ToPrimitive` abstract operation
+// https://tc39.es/ecma262/#sec-toprimitive
+module.exports = function (input, pref) {
+  if (!isObject(input) || isSymbol(input)) return input;
+  var exoticToPrim = input[TO_PRIMITIVE];
+  var result;
+  if (exoticToPrim !== undefined) {
+    if (pref === undefined) pref = 'default';
+    result = exoticToPrim.call(input, pref);
+    if (!isObject(result) || isSymbol(result)) return result;
+    throw TypeError("Can't convert object to primitive value");
+  }
+  if (pref === undefined) pref = 'number';
+  return ordinaryToPrimitive(input, pref);
+};
+
+
+/***/ }),
+
+/***/ 2694:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var toPrimitive = __webpack_require__(2034);
+var isSymbol = __webpack_require__(8377);
+
+// `ToPropertyKey` abstract operation
+// https://tc39.es/ecma262/#sec-topropertykey
+module.exports = function (argument) {
+  var key = toPrimitive(argument, 'string');
+  return isSymbol(key) ? key : String(key);
+};
+
+
+/***/ }),
+
+/***/ 939:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var wellKnownSymbol = __webpack_require__(3706);
+
+var TO_STRING_TAG = wellKnownSymbol('toStringTag');
+var test = {};
+
+test[TO_STRING_TAG] = 'z';
+
+module.exports = String(test) === '[object z]';
+
+
+/***/ }),
+
+/***/ 401:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var isSymbol = __webpack_require__(8377);
+
+module.exports = function (argument) {
+  if (isSymbol(argument)) throw TypeError('Cannot convert a Symbol value to a string');
+  return String(argument);
+};
+
+
+/***/ }),
+
+/***/ 8435:
+/***/ ((module) => {
+
+var id = 0;
+var postfix = Math.random();
+
+module.exports = function (key) {
+  return 'Symbol(' + String(key === undefined ? '' : key) + ')_' + (++id + postfix).toString(36);
+};
+
+
+/***/ }),
+
+/***/ 4587:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+/* eslint-disable es/no-symbol -- required for testing */
+var NATIVE_SYMBOL = __webpack_require__(1453);
+
+module.exports = NATIVE_SYMBOL
+  && !Symbol.sham
+  && typeof Symbol.iterator == 'symbol';
+
+
+/***/ }),
+
+/***/ 3706:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+var global = __webpack_require__(6874);
+var shared = __webpack_require__(3215);
+var has = __webpack_require__(5884);
+var uid = __webpack_require__(8435);
+var NATIVE_SYMBOL = __webpack_require__(1453);
+var USE_SYMBOL_AS_UID = __webpack_require__(4587);
+
+var WellKnownSymbolsStore = shared('wks');
+var Symbol = global.Symbol;
+var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol : Symbol && Symbol.withoutSetter || uid;
+
+module.exports = function (name) {
+  if (!has(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == 'string')) {
+    if (NATIVE_SYMBOL && has(Symbol, name)) {
+      WellKnownSymbolsStore[name] = Symbol[name];
+    } else {
+      WellKnownSymbolsStore[name] = createWellKnownSymbol('Symbol.' + name);
+    }
+  } return WellKnownSymbolsStore[name];
+};
+
+
+/***/ }),
+
+/***/ 2837:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+
+var toIndexedObject = __webpack_require__(8852);
+var addToUnscopables = __webpack_require__(9611);
+var Iterators = __webpack_require__(873);
+var InternalStateModule = __webpack_require__(6619);
+var defineIterator = __webpack_require__(3131);
+
+var ARRAY_ITERATOR = 'Array Iterator';
+var setInternalState = InternalStateModule.set;
+var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);
+
+// `Array.prototype.entries` method
+// https://tc39.es/ecma262/#sec-array.prototype.entries
+// `Array.prototype.keys` method
+// https://tc39.es/ecma262/#sec-array.prototype.keys
+// `Array.prototype.values` method
+// https://tc39.es/ecma262/#sec-array.prototype.values
+// `Array.prototype[@@iterator]` method
+// https://tc39.es/ecma262/#sec-array.prototype-@@iterator
+// `CreateArrayIterator` internal method
+// https://tc39.es/ecma262/#sec-createarrayiterator
+module.exports = defineIterator(Array, 'Array', function (iterated, kind) {
+  setInternalState(this, {
+    type: ARRAY_ITERATOR,
+    target: toIndexedObject(iterated), // target
+    index: 0,                          // next index
+    kind: kind                         // kind
+  });
+// `%ArrayIteratorPrototype%.next` method
+// https://tc39.es/ecma262/#sec-%arrayiteratorprototype%.next
+}, function () {
+  var state = getInternalState(this);
+  var target = state.target;
+  var kind = state.kind;
+  var index = state.index++;
+  if (!target || index >= target.length) {
+    state.target = undefined;
+    return { value: undefined, done: true };
+  }
+  if (kind == 'keys') return { value: index, done: false };
+  if (kind == 'values') return { value: target[index], done: false };
+  return { value: [index, target[index]], done: false };
+}, 'values');
+
+// argumentsList[@@iterator] is %ArrayProto_values%
+// https://tc39.es/ecma262/#sec-createunmappedargumentsobject
+// https://tc39.es/ecma262/#sec-createmappedargumentsobject
+Iterators.Arguments = Iterators.Array;
+
+// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
+addToUnscopables('keys');
+addToUnscopables('values');
+addToUnscopables('entries');
+
+
+/***/ }),
+
+/***/ 6949:
+/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+
+var charAt = __webpack_require__(6174).charAt;
+var toString = __webpack_require__(401);
+var InternalStateModule = __webpack_require__(6619);
+var defineIterator = __webpack_require__(3131);
+
+var STRING_ITERATOR = 'String Iterator';
+var setInternalState = InternalStateModule.set;
+var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);
+
+// `String.prototype[@@iterator]` method
+// https://tc39.es/ecma262/#sec-string.prototype-@@iterator
+defineIterator(String, 'String', function (iterated) {
+  setInternalState(this, {
+    type: STRING_ITERATOR,
+    string: toString(iterated),
+    index: 0
+  });
+// `%StringIteratorPrototype%.next` method
+// https://tc39.es/ecma262/#sec-%stringiteratorprototype%.next
+}, function next() {
+  var state = getInternalState(this);
+  var string = state.string;
+  var index = state.index;
+  var point;
+  if (index >= string.length) return { value: undefined, done: true };
+  point = charAt(string, index);
+  state.index += point.length;
+  return { value: point, done: false };
+});
+
+
+/***/ }),
+
+/***/ 2303:
+/***/ ((module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+
+// TODO: in core-js@4, move /modules/ dependencies to public entries for better optimization by tools like `preset-env`
+__webpack_require__(2837);
+var $ = __webpack_require__(1082);
+var getBuiltIn = __webpack_require__(4578);
+var USE_NATIVE_URL = __webpack_require__(1781);
+var redefine = __webpack_require__(1249);
+var redefineAll = __webpack_require__(7490);
+var setToStringTag = __webpack_require__(9400);
+var createIteratorConstructor = __webpack_require__(9670);
+var InternalStateModule = __webpack_require__(6619);
+var anInstance = __webpack_require__(2482);
+var hasOwn = __webpack_require__(5884);
+var bind = __webpack_require__(4833);
+var classof = __webpack_require__(8753);
+var anObject = __webpack_require__(47);
+var isObject = __webpack_require__(6944);
+var $toString = __webpack_require__(401);
+var create = __webpack_require__(2361);
+var createPropertyDescriptor = __webpack_require__(976);
+var getIterator = __webpack_require__(7053);
+var getIteratorMethod = __webpack_require__(3126);
+var wellKnownSymbol = __webpack_require__(3706);
+
+var nativeFetch = getBuiltIn('fetch');
+var NativeRequest = getBuiltIn('Request');
+var RequestPrototype = NativeRequest && NativeRequest.prototype;
+var Headers = getBuiltIn('Headers');
+var ITERATOR = wellKnownSymbol('iterator');
+var URL_SEARCH_PARAMS = 'URLSearchParams';
+var URL_SEARCH_PARAMS_ITERATOR = URL_SEARCH_PARAMS + 'Iterator';
+var setInternalState = InternalStateModule.set;
+var getInternalParamsState = InternalStateModule.getterFor(URL_SEARCH_PARAMS);
+var getInternalIteratorState = InternalStateModule.getterFor(URL_SEARCH_PARAMS_ITERATOR);
+
+var plus = /\+/g;
+var sequences = Array(4);
+
+var percentSequence = function (bytes) {
+  return sequences[bytes - 1] || (sequences[bytes - 1] = RegExp('((?:%[\\da-f]{2}){' + bytes + '})', 'gi'));
+};
+
+var percentDecode = function (sequence) {
+  try {
+    return decodeURIComponent(sequence);
+  } catch (error) {
+    return sequence;
+  }
+};
+
+var deserialize = function (it) {
+  var result = it.replace(plus, ' ');
+  var bytes = 4;
+  try {
+    return decodeURIComponent(result);
+  } catch (error) {
+    while (bytes) {
+      result = result.replace(percentSequence(bytes--), percentDecode);
+    }
+    return result;
+  }
+};
+
+var find = /[!'()~]|%20/g;
+
+var replace = {
+  '!': '%21',
+  "'": '%27',
+  '(': '%28',
+  ')': '%29',
+  '~': '%7E',
+  '%20': '+'
+};
+
+var replacer = function (match) {
+  return replace[match];
+};
+
+var serialize = function (it) {
+  return encodeURIComponent(it).replace(find, replacer);
+};
+
+var parseSearchParams = function (result, query) {
+  if (query) {
+    var attributes = query.split('&');
+    var index = 0;
+    var attribute, entry;
+    while (index < attributes.length) {
+      attribute = attributes[index++];
+      if (attribute.length) {
+        entry = attribute.split('=');
+        result.push({
+          key: deserialize(entry.shift()),
+          value: deserialize(entry.join('='))
+        });
+      }
+    }
+  }
+};
+
+var updateSearchParams = function (query) {
+  this.entries.length = 0;
+  parseSearchParams(this.entries, query);
+};
+
+var validateArgumentsLength = function (passed, required) {
+  if (passed < required) throw TypeError('Not enough arguments');
+};
+
+var URLSearchParamsIterator = createIteratorConstructor(function Iterator(params, kind) {
+  setInternalState(this, {
+    type: URL_SEARCH_PARAMS_ITERATOR,
+    iterator: getIterator(getInternalParamsState(params).entries),
+    kind: kind
+  });
+}, 'Iterator', function next() {
+  var state = getInternalIteratorState(this);
+  var kind = state.kind;
+  var step = state.iterator.next();
+  var entry = step.value;
+  if (!step.done) {
+    step.value = kind === 'keys' ? entry.key : kind === 'values' ? entry.value : [entry.key, entry.value];
+  } return step;
+});
+
+// `URLSearchParams` constructor
+// https://url.spec.whatwg.org/#interface-urlsearchparams
+var URLSearchParamsConstructor = function URLSearchParams(/* init */) {
+  anInstance(this, URLSearchParamsConstructor, URL_SEARCH_PARAMS);
+  var init = arguments.length > 0 ? arguments[0] : undefined;
+  var that = this;
+  var entries = [];
+  var iteratorMethod, iterator, next, step, entryIterator, entryNext, first, second, key;
+
+  setInternalState(that, {
+    type: URL_SEARCH_PARAMS,
+    entries: entries,
+    updateURL: function () { /* empty */ },
+    updateSearchParams: updateSearchParams
+  });
+
+  if (init !== undefined) {
+    if (isObject(init)) {
+      iteratorMethod = getIteratorMethod(init);
+      if (typeof iteratorMethod === 'function') {
+        iterator = iteratorMethod.call(init);
+        next = iterator.next;
+        while (!(step = next.call(iterator)).done) {
+          entryIterator = getIterator(anObject(step.value));
+          entryNext = entryIterator.next;
+          if (
+            (first = entryNext.call(entryIterator)).done ||
+            (second = entryNext.call(entryIterator)).done ||
+            !entryNext.call(entryIterator).done
+          ) throw TypeError('Expected sequence with length 2');
+          entries.push({ key: $toString(first.value), value: $toString(second.value) });
+        }
+      } else for (key in init) if (hasOwn(init, key)) entries.push({ key: key, value: $toString(init[key]) });
+    } else {
+      parseSearchParams(
+        entries,
+        typeof init === 'string' ? init.charAt(0) === '?' ? init.slice(1) : init : $toString(init)
+      );
+    }
+  }
+};
+
+var URLSearchParamsPrototype = URLSearchParamsConstructor.prototype;
+
+redefineAll(URLSearchParamsPrototype, {
+  // `URLSearchParams.prototype.append` method
+  // https://url.spec.whatwg.org/#dom-urlsearchparams-append
+  append: function append(name, value) {
+    validateArgumentsLength(arguments.length, 2);
+    var state = getInternalParamsState(this);
+    state.entries.push({ key: $toString(name), value: $toString(value) });
+    state.updateURL();
+  },
+  // `URLSearchParams.prototype.delete` method
+  // https://url.spec.whatwg.org/#dom-urlsearchparams-delete
+  'delete': function (name) {
+    validateArgumentsLength(arguments.length, 1);
+    var state = getInternalParamsState(this);
+    var entries = state.entries;
+    var key = $toString(name);
+    var index = 0;
+    while (index < entries.length) {
+      if (entries[index].key === key) entries.splice(index, 1);
+      else index++;
+    }
+    state.updateURL();
+  },
+  // `URLSearchParams.prototype.get` method
+  // https://url.spec.whatwg.org/#dom-urlsearchparams-get
+  get: function get(name) {
+    validateArgumentsLength(arguments.length, 1);
+    var entries = getInternalParamsState(this).entries;
+    var key = $toString(name);
+    var index = 0;
+    for (; index < entries.length; index++) {
+      if (entries[index].key === key) return entries[index].value;
+    }
+    return null;
+  },
+  // `URLSearchParams.prototype.getAll` method
+  // https://url.spec.whatwg.org/#dom-urlsearchparams-getall
+  getAll: function getAll(name) {
+    validateArgumentsLength(arguments.length, 1);
+    var entries = getInternalParamsState(this).entries;
+    var key = $toString(name);
+    var result = [];
+    var index = 0;
+    for (; index < entries.length; index++) {
+      if (entries[index].key === key) result.push(entries[index].value);
+    }
+    return result;
+  },
+  // `URLSearchParams.prototype.has` method
+  // https://url.spec.whatwg.org/#dom-urlsearchparams-has
+  has: function has(name) {
+    validateArgumentsLength(arguments.length, 1);
+    var entries = getInternalParamsState(this).entries;
+    var key = $toString(name);
+    var index = 0;
+    while (index < entries.length) {
+      if (entries[index++].key === key) return true;
+    }
+    return false;
+  },
+  // `URLSearchParams.prototype.set` method
+  // https://url.spec.whatwg.org/#dom-urlsearchparams-set
+  set: function set(name, value) {
+    validateArgumentsLength(arguments.length, 1);
+    var state = getInternalParamsState(this);
+    var entries = state.entries;
+    var found = false;
+    var key = $toString(name);
+    var val = $toString(value);
+    var index = 0;
+    var entry;
+    for (; index < entries.length; index++) {
+      entry = entries[index];
+      if (entry.key === key) {
+        if (found) entries.splice(index--, 1);
+        else {
+          found = true;
+          entry.value = val;
+        }
+      }
+    }
+    if (!found) entries.push({ key: key, value: val });
+    state.updateURL();
+  },
+  // `URLSearchParams.prototype.sort` method
+  // https://url.spec.whatwg.org/#dom-urlsearchparams-sort
+  sort: function sort() {
+    var state = getInternalParamsState(this);
+    var entries = state.entries;
+    // Array#sort is not stable in some engines
+    var slice = entries.slice();
+    var entry, entriesIndex, sliceIndex;
+    entries.length = 0;
+    for (sliceIndex = 0; sliceIndex < slice.length; sliceIndex++) {
+      entry = slice[sliceIndex];
+      for (entriesIndex = 0; entriesIndex < sliceIndex; entriesIndex++) {
+        if (entries[entriesIndex].key > entry.key) {
+          entries.splice(entriesIndex, 0, entry);
+          break;
+        }
+      }
+      if (entriesIndex === sliceIndex) entries.push(entry);
+    }
+    state.updateURL();
+  },
+  // `URLSearchParams.prototype.forEach` method
+  forEach: function forEach(callback /* , thisArg */) {
+    var entries = getInternalParamsState(this).entries;
+    var boundFunction = bind(callback, arguments.length > 1 ? arguments[1] : undefined, 3);
+    var index = 0;
+    var entry;
+    while (index < entries.length) {
+      entry = entries[index++];
+      boundFunction(entry.value, entry.key, this);
+    }
+  },
+  // `URLSearchParams.prototype.keys` method
+  keys: function keys() {
+    return new URLSearchParamsIterator(this, 'keys');
+  },
+  // `URLSearchParams.prototype.values` method
+  values: function values() {
+    return new URLSearchParamsIterator(this, 'values');
+  },
+  // `URLSearchParams.prototype.entries` method
+  entries: function entries() {
+    return new URLSearchParamsIterator(this, 'entries');
+  }
+}, { enumerable: true });
+
+// `URLSearchParams.prototype[@@iterator]` method
+redefine(URLSearchParamsPrototype, ITERATOR, URLSearchParamsPrototype.entries);
+
+// `URLSearchParams.prototype.toString` method
+// https://url.spec.whatwg.org/#urlsearchparams-stringification-behavior
+redefine(URLSearchParamsPrototype, 'toString', function toString() {
+  var entries = getInternalParamsState(this).entries;
+  var result = [];
+  var index = 0;
+  var entry;
+  while (index < entries.length) {
+    entry = entries[index++];
+    result.push(serialize(entry.key) + '=' + serialize(entry.value));
+  } return result.join('&');
+}, { enumerable: true });
+
+setToStringTag(URLSearchParamsConstructor, URL_SEARCH_PARAMS);
+
+$({ global: true, forced: !USE_NATIVE_URL }, {
+  URLSearchParams: URLSearchParamsConstructor
+});
+
+// Wrap `fetch` and `Request` for correct work with polyfilled `URLSearchParams`
+if (!USE_NATIVE_URL && typeof Headers == 'function') {
+  var wrapRequestOptions = function (init) {
+    if (isObject(init)) {
+      var body = init.body;
+      var headers;
+      if (classof(body) === URL_SEARCH_PARAMS) {
+        headers = init.headers ? new Headers(init.headers) : new Headers();
+        if (!headers.has('content-type')) {
+          headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
+        }
+        return create(init, {
+          body: createPropertyDescriptor(0, String(body)),
+          headers: createPropertyDescriptor(0, headers)
+        });
+      }
+    } return init;
+  };
+
+  if (typeof nativeFetch == 'function') {
+    $({ global: true, enumerable: true, forced: true }, {
+      fetch: function fetch(input /* , init */) {
+        return nativeFetch(input, arguments.length > 1 ? wrapRequestOptions(arguments[1]) : {});
+      }
+    });
+  }
+
+  if (typeof NativeRequest == 'function') {
+    var RequestConstructor = function Request(input /* , init */) {
+      anInstance(this, RequestConstructor, 'Request');
+      return new NativeRequest(input, arguments.length > 1 ? wrapRequestOptions(arguments[1]) : {});
+    };
+
+    RequestPrototype.constructor = RequestConstructor;
+    RequestConstructor.prototype = RequestPrototype;
+
+    $({ global: true, forced: true }, {
+      Request: RequestConstructor
+    });
+  }
+}
+
+module.exports = {
+  URLSearchParams: URLSearchParamsConstructor,
+  getState: getInternalParamsState
+};
+
+
+/***/ }),
+
+/***/ 2743:
+/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {
+
+"use strict";
+
+// TODO: in core-js@4, move /modules/ dependencies to public entries for better optimization by tools like `preset-env`
+__webpack_require__(6949);
+var $ = __webpack_require__(1082);
+var DESCRIPTORS = __webpack_require__(5542);
+var USE_NATIVE_URL = __webpack_require__(1781);
+var global = __webpack_require__(6874);
+var defineProperties = __webpack_require__(7852);
+var redefine = __webpack_require__(1249);
+var anInstance = __webpack_require__(2482);
+var has = __webpack_require__(5884);
+var assign = __webpack_require__(5277);
+var arrayFrom = __webpack_require__(1774);
+var codeAt = __webpack_require__(6174).codeAt;
+var toASCII = __webpack_require__(8);
+var $toString = __webpack_require__(401);
+var setToStringTag = __webpack_require__(9400);
+var URLSearchParamsModule = __webpack_require__(2303);
+var InternalStateModule = __webpack_require__(6619);
+
+var NativeURL = global.URL;
+var URLSearchParams = URLSearchParamsModule.URLSearchParams;
+var getInternalSearchParamsState = URLSearchParamsModule.getState;
+var setInternalState = InternalStateModule.set;
+var getInternalURLState = InternalStateModule.getterFor('URL');
+var floor = Math.floor;
+var pow = Math.pow;
+
+var INVALID_AUTHORITY = 'Invalid authority';
+var INVALID_SCHEME = 'Invalid scheme';
+var INVALID_HOST = 'Invalid host';
+var INVALID_PORT = 'Invalid port';
+
+var ALPHA = /[A-Za-z]/;
+// eslint-disable-next-line regexp/no-obscure-range -- safe
+var ALPHANUMERIC = /[\d+-.A-Za-z]/;
+var DIGIT = /\d/;
+var HEX_START = /^0x/i;
+var OCT = /^[0-7]+$/;
+var DEC = /^\d+$/;
+var HEX = /^[\dA-Fa-f]+$/;
+/* eslint-disable no-control-regex -- safe */
+var FORBIDDEN_HOST_CODE_POINT = /[\0\t\n\r #%/:<>?@[\\\]^|]/;
+var FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT = /[\0\t\n\r #/:<>?@[\\\]^|]/;
+var LEADING_AND_TRAILING_C0_CONTROL_OR_SPACE = /^[\u0000-\u0020]+|[\u0000-\u0020]+$/g;
+var TAB_AND_NEW_LINE = /[\t\n\r]/g;
+/* eslint-enable no-control-regex -- safe */
+var EOF;
+
+var parseHost = function (url, input) {
+  var result, codePoints, index;
+  if (input.charAt(0) == '[') {
+    if (input.charAt(input.length - 1) != ']') return INVALID_HOST;
+    result = parseIPv6(input.slice(1, -1));
+    if (!result) return INVALID_HOST;
+    url.host = result;
+  // opaque host
+  } else if (!isSpecial(url)) {
+    if (FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT.test(input)) return INVALID_HOST;
+    result = '';
+    codePoints = arrayFrom(input);
+    for (index = 0; index < codePoints.length; index++) {
+      result += percentEncode(codePoints[index], C0ControlPercentEncodeSet);
+    }
+    url.host = result;
+  } else {
+    input = toASCII(input);
+    if (FORBIDDEN_HOST_CODE_POINT.test(input)) return INVALID_HOST;
+    result = parseIPv4(input);
+    if (result === null) return INVALID_HOST;
+    url.host = result;
+  }
+};
+
+var parseIPv4 = function (input) {
+  var parts = input.split('.');
+  var partsLength, numbers, index, part, radix, number, ipv4;
+  if (parts.length && parts[parts.length - 1] == '') {
+    parts.pop();
+  }
+  partsLength = parts.length;
+  if (partsLength > 4) return input;
+  numbers = [];
+  for (index = 0; index < partsLength; index++) {
+    part = parts[index];
+    if (part == '') return input;
+    radix = 10;
+    if (part.length > 1 && part.charAt(0) == '0') {
+      radix = HEX_START.test(part) ? 16 : 8;
+      part = part.slice(radix == 8 ? 1 : 2);
+    }
+    if (part === '') {
+      number = 0;
+    } else {
+      if (!(radix == 10 ? DEC : radix == 8 ? OCT : HEX).test(part)) return input;
+      number = parseInt(part, radix);
+    }
+    numbers.push(number);
+  }
+  for (index = 0; index < partsLength; index++) {
+    number = numbers[index];
+    if (index == partsLength - 1) {
+      if (number >= pow(256, 5 - partsLength)) return null;
+    } else if (number > 255) return null;
+  }
+  ipv4 = numbers.pop();
+  for (index = 0; index < numbers.length; index++) {
+    ipv4 += numbers[index] * pow(256, 3 - index);
+  }
+  return ipv4;
+};
+
+// eslint-disable-next-line max-statements -- TODO
+var parseIPv6 = function (input) {
+  var address = [0, 0, 0, 0, 0, 0, 0, 0];
+  var pieceIndex = 0;
+  var compress = null;
+  var pointer = 0;
+  var value, length, numbersSeen, ipv4Piece, number, swaps, swap;
+
+  var char = function () {
+    return input.charAt(pointer);
+  };
+
+  if (char() == ':') {
+    if (input.charAt(1) != ':') return;
+    pointer += 2;
+    pieceIndex++;
+    compress = pieceIndex;
+  }
+  while (char()) {
+    if (pieceIndex == 8) return;
+    if (char() == ':') {
+      if (compress !== null) return;
+      pointer++;
+      pieceIndex++;
+      compress = pieceIndex;
+      continue;
+    }
+    value = length = 0;
+    while (length < 4 && HEX.test(char())) {
+      value = value * 16 + parseInt(char(), 16);
+      pointer++;
+      length++;
+    }
+    if (char() == '.') {
+      if (length == 0) return;
+      pointer -= length;
+      if (pieceIndex > 6) return;
+      numbersSeen = 0;
+      while (char()) {
+        ipv4Piece = null;
+        if (numbersSeen > 0) {
+          if (char() == '.' && numbersSeen < 4) pointer++;
+          else return;
+        }
+        if (!DIGIT.test(char())) return;
+        while (DIGIT.test(char())) {
+          number = parseInt(char(), 10);
+          if (ipv4Piece === null) ipv4Piece = number;
+          else if (ipv4Piece == 0) return;
+          else ipv4Piece = ipv4Piece * 10 + number;
+          if (ipv4Piece > 255) return;
+          pointer++;
+        }
+        address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
+        numbersSeen++;
+        if (numbersSeen == 2 || numbersSeen == 4) pieceIndex++;
+      }
+      if (numbersSeen != 4) return;
+      break;
+    } else if (char() == ':') {
+      pointer++;
+      if (!char()) return;
+    } else if (char()) return;
+    address[pieceIndex++] = value;
+  }
+  if (compress !== null) {
+    swaps = pieceIndex - compress;
+    pieceIndex = 7;
+    while (pieceIndex != 0 && swaps > 0) {
+      swap = address[pieceIndex];
+      address[pieceIndex--] = address[compress + swaps - 1];
+      address[compress + --swaps] = swap;
+    }
+  } else if (pieceIndex != 8) return;
+  return address;
+};
+
+var findLongestZeroSequence = function (ipv6) {
+  var maxIndex = null;
+  var maxLength = 1;
+  var currStart = null;
+  var currLength = 0;
+  var index = 0;
+  for (; index < 8; index++) {
+    if (ipv6[index] !== 0) {
+      if (currLength > maxLength) {
+        maxIndex = currStart;
+        maxLength = currLength;
+      }
+      currStart = null;
+      currLength = 0;
+    } else {
+      if (currStart === null) currStart = index;
+      ++currLength;
+    }
+  }
+  if (currLength > maxLength) {
+    maxIndex = currStart;
+    maxLength = currLength;
+  }
+  return maxIndex;
+};
+
+var serializeHost = function (host) {
+  var result, index, compress, ignore0;
+  // ipv4
+  if (typeof host == 'number') {
+    result = [];
+    for (index = 0; index < 4; index++) {
+      result.unshift(host % 256);
+      host = floor(host / 256);
+    } return result.join('.');
+  // ipv6
+  } else if (typeof host == 'object') {
+    result = '';
+    compress = findLongestZeroSequence(host);
+    for (index = 0; index < 8; index++) {
+      if (ignore0 && host[index] === 0) continue;
+      if (ignore0) ignore0 = false;
+      if (compress === index) {
+        result += index ? ':' : '::';
+        ignore0 = true;
+      } else {
+        result += host[index].toString(16);
+        if (index < 7) result += ':';
+      }
+    }
+    return '[' + result + ']';
+  } return host;
+};
+
+var C0ControlPercentEncodeSet = {};
+var fragmentPercentEncodeSet = assign({}, C0ControlPercentEncodeSet, {
+  ' ': 1, '"': 1, '<': 1, '>': 1, '`': 1
+});
+var pathPercentEncodeSet = assign({}, fragmentPercentEncodeSet, {
+  '#': 1, '?': 1, '{': 1, '}': 1
+});
+var userinfoPercentEncodeSet = assign({}, pathPercentEncodeSet, {
+  '/': 1, ':': 1, ';': 1, '=': 1, '@': 1, '[': 1, '\\': 1, ']': 1, '^': 1, '|': 1
+});
+
+var percentEncode = function (char, set) {
+  var code = codeAt(char, 0);
+  return code > 0x20 && code < 0x7F && !has(set, char) ? char : encodeURIComponent(char);
+};
+
+var specialSchemes = {
+  ftp: 21,
+  file: null,
+  http: 80,
+  https: 443,
+  ws: 80,
+  wss: 443
+};
+
+var isSpecial = function (url) {
+  return has(specialSchemes, url.scheme);
+};
+
+var includesCredentials = function (url) {
+  return url.username != '' || url.password != '';
+};
+
+var cannotHaveUsernamePasswordPort = function (url) {
+  return !url.host || url.cannotBeABaseURL || url.scheme == 'file';
+};
+
+var isWindowsDriveLetter = function (string, normalized) {
+  var second;
+  return string.length == 2 && ALPHA.test(string.charAt(0))
+    && ((second = string.charAt(1)) == ':' || (!normalized && second == '|'));
+};
+
+var startsWithWindowsDriveLetter = function (string) {
+  var third;
+  return string.length > 1 && isWindowsDriveLetter(string.slice(0, 2)) && (
+    string.length == 2 ||
+    ((third = string.charAt(2)) === '/' || third === '\\' || third === '?' || third === '#')
+  );
+};
+
+var shortenURLsPath = function (url) {
+  var path = url.path;
+  var pathSize = path.length;
+  if (pathSize && (url.scheme != 'file' || pathSize != 1 || !isWindowsDriveLetter(path[0], true))) {
+    path.pop();
+  }
+};
+
+var isSingleDot = function (segment) {
+  return segment === '.' || segment.toLowerCase() === '%2e';
+};
+
+var isDoubleDot = function (segment) {
+  segment = segment.toLowerCase();
+  return segment === '..' || segment === '%2e.' || segment === '.%2e' || segment === '%2e%2e';
+};
+
+// States:
+var SCHEME_START = {};
+var SCHEME = {};
+var NO_SCHEME = {};
+var SPECIAL_RELATIVE_OR_AUTHORITY = {};
+var PATH_OR_AUTHORITY = {};
+var RELATIVE = {};
+var RELATIVE_SLASH = {};
+var SPECIAL_AUTHORITY_SLASHES = {};
+var SPECIAL_AUTHORITY_IGNORE_SLASHES = {};
+var AUTHORITY = {};
+var HOST = {};
+var HOSTNAME = {};
+var PORT = {};
+var FILE = {};
+var FILE_SLASH = {};
+var FILE_HOST = {};
+var PATH_START = {};
+var PATH = {};
+var CANNOT_BE_A_BASE_URL_PATH = {};
+var QUERY = {};
+var FRAGMENT = {};
+
+// eslint-disable-next-line max-statements -- TODO
+var parseURL = function (url, input, stateOverride, base) {
+  var state = stateOverride || SCHEME_START;
+  var pointer = 0;
+  var buffer = '';
+  var seenAt = false;
+  var seenBracket = false;
+  var seenPasswordToken = false;
+  var codePoints, char, bufferCodePoints, failure;
+
+  if (!stateOverride) {
+    url.scheme = '';
+    url.username = '';
+    url.password = '';
+    url.host = null;
+    url.port = null;
+    url.path = [];
+    url.query = null;
+    url.fragment = null;
+    url.cannotBeABaseURL = false;
+    input = input.replace(LEADING_AND_TRAILING_C0_CONTROL_OR_SPACE, '');
+  }
+
+  input = input.replace(TAB_AND_NEW_LINE, '');
+
+  codePoints = arrayFrom(input);
+
+  while (pointer <= codePoints.length) {
+    char = codePoints[pointer];
+    switch (state) {
+      case SCHEME_START:
+        if (char && ALPHA.test(char)) {
+          buffer += char.toLowerCase();
+          state = SCHEME;
+        } else if (!stateOverride) {
+          state = NO_SCHEME;
+          continue;
+        } else return INVALID_SCHEME;
+        break;
+
+      case SCHEME:
+        if (char && (ALPHANUMERIC.test(char) || char == '+' || char == '-' || char == '.')) {
+          buffer += char.toLowerCase();
+        } else if (char == ':') {
+          if (stateOverride && (
+            (isSpecial(url) != has(specialSchemes, buffer)) ||
+            (buffer == 'file' && (includesCredentials(url) || url.port !== null)) ||
+            (url.scheme == 'file' && !url.host)
+          )) return;
+          url.scheme = buffer;
+          if (stateOverride) {
+            if (isSpecial(url) && specialSchemes[url.scheme] == url.port) url.port = null;
+            return;
+          }
+          buffer = '';
+          if (url.scheme == 'file') {
+            state = FILE;
+          } else if (isSpecial(url) && base && base.scheme == url.scheme) {
+            state = SPECIAL_RELATIVE_OR_AUTHORITY;
+          } else if (isSpecial(url)) {
+            state = SPECIAL_AUTHORITY_SLASHES;
+          } else if (codePoints[pointer + 1] == '/') {
+            state = PATH_OR_AUTHORITY;
+            pointer++;
+          } else {
+            url.cannotBeABaseURL = true;
+            url.path.push('');
+            state = CANNOT_BE_A_BASE_URL_PATH;
+          }
+        } else if (!stateOverride) {
+          buffer = '';
+          state = NO_SCHEME;
+          pointer = 0;
+          continue;
+        } else return INVALID_SCHEME;
+        break;
+
+      case NO_SCHEME:
+        if (!base || (base.cannotBeABaseURL && char != '#')) return INVALID_SCHEME;
+        if (base.cannotBeABaseURL && char == '#') {
+          url.scheme = base.scheme;
+          url.path = base.path.slice();
+          url.query = base.query;
+          url.fragment = '';
+          url.cannotBeABaseURL = true;
+          state = FRAGMENT;
+          break;
+        }
+        state = base.scheme == 'file' ? FILE : RELATIVE;
+        continue;
+
+      case SPECIAL_RELATIVE_OR_AUTHORITY:
+        if (char == '/' && codePoints[pointer + 1] == '/') {
+          state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
+          pointer++;
+        } else {
+          state = RELATIVE;
+          continue;
+        } break;
+
+      case PATH_OR_AUTHORITY:
+        if (char == '/') {
+          state = AUTHORITY;
+          break;
+        } else {
+          state = PATH;
+          continue;
+        }
+
+      case RELATIVE:
+        url.scheme = base.scheme;
+        if (char == EOF) {
+          url.username = base.username;
+          url.password = base.password;
+          url.host = base.host;
+          url.port = base.port;
+          url.path = base.path.slice();
+          url.query = base.query;
+        } else if (char == '/' || (char == '\\' && isSpecial(url))) {
+          state = RELATIVE_SLASH;
+        } else if (char == '?') {
+          url.username = base.username;
+          url.password = base.password;
+          url.host = base.host;
+          url.port = base.port;
+          url.path = base.path.slice();
+          url.query = '';
+          state = QUERY;
+        } else if (char == '#') {
+          url.username = base.username;
+          url.password = base.password;
+          url.host = base.host;
+          url.port = base.port;
+          url.path = base.path.slice();
+          url.query = base.query;
+          url.fragment = '';
+          state = FRAGMENT;
+        } else {
+          url.username = base.username;
+          url.password = base.password;
+          url.host = base.host;
+          url.port = base.port;
+          url.path = base.path.slice();
+          url.path.pop();
+          state = PATH;
+          continue;
+        } break;
+
+      case RELATIVE_SLASH:
+        if (isSpecial(url) && (char == '/' || char == '\\')) {
+          state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
+        } else if (char == '/') {
+          state = AUTHORITY;
+        } else {
+          url.username = base.username;
+          url.password = base.password;
+          url.host = base.host;
+          url.port = base.port;
+          state = PATH;
+          continue;
+        } break;
+
+      case SPECIAL_AUTHORITY_SLASHES:
+        state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
+        if (char != '/' || buffer.charAt(pointer + 1) != '/') continue;
+        pointer++;
+        break;
+
+      case SPECIAL_AUTHORITY_IGNORE_SLASHES:
+        if (char != '/' && char != '\\') {
+          state = AUTHORITY;
+          continue;
+        } break;
+
+      case AUTHORITY:
+        if (char == '@') {
+          if (seenAt) buffer = '%40' + buffer;
+          seenAt = true;
+          bufferCodePoints = arrayFrom(buffer);
+          for (var i = 0; i < bufferCodePoints.length; i++) {
+            var codePoint = bufferCodePoints[i];
+            if (codePoint == ':' && !seenPasswordToken) {
+              seenPasswordToken = true;
+              continue;
+            }
+            var encodedCodePoints = percentEncode(codePoint, userinfoPercentEncodeSet);
+            if (seenPasswordToken) url.password += encodedCodePoints;
+            else url.username += encodedCodePoints;
+          }
+          buffer = '';
+        } else if (
+          char == EOF || char == '/' || char == '?' || char == '#' ||
+          (char == '\\' && isSpecial(url))
+        ) {
+          if (seenAt && buffer == '') return INVALID_AUTHORITY;
+          pointer -= arrayFrom(buffer).length + 1;
+          buffer = '';
+          state = HOST;
+        } else buffer += char;
+        break;
+
+      case HOST:
+      case HOSTNAME:
+        if (stateOverride && url.scheme == 'file') {
+          state = FILE_HOST;
+          continue;
+        } else if (char == ':' && !seenBracket) {
+          if (buffer == '') return INVALID_HOST;
+          failure = parseHost(url, buffer);
+          if (failure) return failure;
+          buffer = '';
+          state = PORT;
+          if (stateOverride == HOSTNAME) return;
+        } else if (
+          char == EOF || char == '/' || char == '?' || char == '#' ||
+          (char == '\\' && isSpecial(url))
+        ) {
+          if (isSpecial(url) && buffer == '') return INVALID_HOST;
+          if (stateOverride && buffer == '' && (includesCredentials(url) || url.port !== null)) return;
+          failure = parseHost(url, buffer);
+          if (failure) return failure;
+          buffer = '';
+          state = PATH_START;
+          if (stateOverride) return;
+          continue;
+        } else {
+          if (char == '[') seenBracket = true;
+          else if (char == ']') seenBracket = false;
+          buffer += char;
+        } break;
+
+      case PORT:
+        if (DIGIT.test(char)) {
+          buffer += char;
+        } else if (
+          char == EOF || char == '/' || char == '?' || char == '#' ||
+          (char == '\\' && isSpecial(url)) ||
+          stateOverride
+        ) {
+          if (buffer != '') {
+            var port = parseInt(buffer, 10);
+            if (port > 0xFFFF) return INVALID_PORT;
+            url.port = (isSpecial(url) && port === specialSchemes[url.scheme]) ? null : port;
+            buffer = '';
+          }
+          if (stateOverride) return;
+          state = PATH_START;
+          continue;
+        } else return INVALID_PORT;
+        break;
+
+      case FILE:
+        url.scheme = 'file';
+        if (char == '/' || char == '\\') state = FILE_SLASH;
+        else if (base && base.scheme == 'file') {
+          if (char == EOF) {
+            url.host = base.host;
+            url.path = base.path.slice();
+            url.query = base.query;
+          } else if (char == '?') {
+            url.host = base.host;
+            url.path = base.path.slice();
+            url.query = '';
+            state = QUERY;
+          } else if (char == '#') {
+            url.host = base.host;
+            url.path = base.path.slice();
+            url.query = base.query;
+            url.fragment = '';
+            state = FRAGMENT;
+          } else {
+            if (!startsWithWindowsDriveLetter(codePoints.slice(pointer).join(''))) {
+              url.host = base.host;
+              url.path = base.path.slice();
+              shortenURLsPath(url);
+            }
+            state = PATH;
+            continue;
+          }
+        } else {
+          state = PATH;
+          continue;
+        } break;
+
+      case FILE_SLASH:
+        if (char == '/' || char == '\\') {
+          state = FILE_HOST;
+          break;
+        }
+        if (base && base.scheme == 'file' && !startsWithWindowsDriveLetter(codePoints.slice(pointer).join(''))) {
+          if (isWindowsDriveLetter(base.path[0], true)) url.path.push(base.path[0]);
+          else url.host = base.host;
+        }
+        state = PATH;
+        continue;
+
+      case FILE_HOST:
+        if (char == EOF || char == '/' || char == '\\' || char == '?' || char == '#') {
+          if (!stateOverride && isWindowsDriveLetter(buffer)) {
+            state = PATH;
+          } else if (buffer == '') {
+            url.host = '';
+            if (stateOverride) return;
+            state = PATH_START;
+          } else {
+            failure = parseHost(url, buffer);
+            if (failure) return failure;
+            if (url.host == 'localhost') url.host = '';
+            if (stateOverride) return;
+            buffer = '';
+            state = PATH_START;
+          } continue;
+        } else buffer += char;
+        break;
+
+      case PATH_START:
+        if (isSpecial(url)) {
+          state = PATH;
+          if (char != '/' && char != '\\') continue;
+        } else if (!stateOverride && char == '?') {
+          url.query = '';
+          state = QUERY;
+        } else if (!stateOverride && char == '#') {
+          url.fragment = '';
+          state = FRAGMENT;
+        } else if (char != EOF) {
+          state = PATH;
+          if (char != '/') continue;
+        } break;
+
+      case PATH:
+        if (
+          char == EOF || char == '/' ||
+          (char == '\\' && isSpecial(url)) ||
+          (!stateOverride && (char == '?' || char == '#'))
+        ) {
+          if (isDoubleDot(buffer)) {
+            shortenURLsPath(url);
+            if (char != '/' && !(char == '\\' && isSpecial(url))) {
+              url.path.push('');
+            }
+          } else if (isSingleDot(buffer)) {
+            if (char != '/' && !(char == '\\' && isSpecial(url))) {
+              url.path.push('');
+            }
+          } else {
+            if (url.scheme == 'file' && !url.path.length && isWindowsDriveLetter(buffer)) {
+              if (url.host) url.host = '';
+              buffer = buffer.charAt(0) + ':'; // normalize windows drive letter
+            }
+            url.path.push(buffer);
+          }
+          buffer = '';
+          if (url.scheme == 'file' && (char == EOF || char == '?' || char == '#')) {
+            while (url.path.length > 1 && url.path[0] === '') {
+              url.path.shift();
+            }
+          }
+          if (char == '?') {
+            url.query = '';
+            state = QUERY;
+          } else if (char == '#') {
+            url.fragment = '';
+            state = FRAGMENT;
+          }
+        } else {
+          buffer += percentEncode(char, pathPercentEncodeSet);
+        } break;
+
+      case CANNOT_BE_A_BASE_URL_PATH:
+        if (char == '?') {
+          url.query = '';
+          state = QUERY;
+        } else if (char == '#') {
+          url.fragment = '';
+          state = FRAGMENT;
+        } else if (char != EOF) {
+          url.path[0] += percentEncode(char, C0ControlPercentEncodeSet);
+        } break;
+
+      case QUERY:
+        if (!stateOverride && char == '#') {
+          url.fragment = '';
+          state = FRAGMENT;
+        } else if (char != EOF) {
+          if (char == "'" && isSpecial(url)) url.query += '%27';
+          else if (char == '#') url.query += '%23';
+          else url.query += percentEncode(char, C0ControlPercentEncodeSet);
+        } break;
+
+      case FRAGMENT:
+        if (char != EOF) url.fragment += percentEncode(char, fragmentPercentEncodeSet);
+        break;
+    }
+
+    pointer++;
+  }
+};
+
+// `URL` constructor
+// https://url.spec.whatwg.org/#url-class
+var URLConstructor = function URL(url /* , base */) {
+  var that = anInstance(this, URLConstructor, 'URL');
+  var base = arguments.length > 1 ? arguments[1] : undefined;
+  var urlString = $toString(url);
+  var state = setInternalState(that, { type: 'URL' });
+  var baseState, failure;
+  if (base !== undefined) {
+    if (base instanceof URLConstructor) baseState = getInternalURLState(base);
+    else {
+      failure = parseURL(baseState = {}, $toString(base));
+      if (failure) throw TypeError(failure);
+    }
+  }
+  failure = parseURL(state, urlString, null, baseState);
+  if (failure) throw TypeError(failure);
+  var searchParams = state.searchParams = new URLSearchParams();
+  var searchParamsState = getInternalSearchParamsState(searchParams);
+  searchParamsState.updateSearchParams(state.query);
+  searchParamsState.updateURL = function () {
+    state.query = String(searchParams) || null;
+  };
+  if (!DESCRIPTORS) {
+    that.href = serializeURL.call(that);
+    that.origin = getOrigin.call(that);
+    that.protocol = getProtocol.call(that);
+    that.username = getUsername.call(that);
+    that.password = getPassword.call(that);
+    that.host = getHost.call(that);
+    that.hostname = getHostname.call(that);
+    that.port = getPort.call(that);
+    that.pathname = getPathname.call(that);
+    that.search = getSearch.call(that);
+    that.searchParams = getSearchParams.call(that);
+    that.hash = getHash.call(that);
+  }
+};
+
+var URLPrototype = URLConstructor.prototype;
+
+var serializeURL = function () {
+  var url = getInternalURLState(this);
+  var scheme = url.scheme;
+  var username = url.username;
+  var password = url.password;
+  var host = url.host;
+  var port = url.port;
+  var path = url.path;
+  var query = url.query;
+  var fragment = url.fragment;
+  var output = scheme + ':';
+  if (host !== null) {
+    output += '//';
+    if (includesCredentials(url)) {
+      output += username + (password ? ':' + password : '') + '@';
+    }
+    output += serializeHost(host);
+    if (port !== null) output += ':' + port;
+  } else if (scheme == 'file') output += '//';
+  output += url.cannotBeABaseURL ? path[0] : path.length ? '/' + path.join('/') : '';
+  if (query !== null) output += '?' + query;
+  if (fragment !== null) output += '#' + fragment;
+  return output;
+};
+
+var getOrigin = function () {
+  var url = getInternalURLState(this);
+  var scheme = url.scheme;
+  var port = url.port;
+  if (scheme == 'blob') try {
+    return new URLConstructor(scheme.path[0]).origin;
+  } catch (error) {
+    return 'null';
+  }
+  if (scheme == 'file' || !isSpecial(url)) return 'null';
+  return scheme + '://' + serializeHost(url.host) + (port !== null ? ':' + port : '');
+};
+
+var getProtocol = function () {
+  return getInternalURLState(this).scheme + ':';
+};
+
+var getUsername = function () {
+  return getInternalURLState(this).username;
+};
+
+var getPassword = function () {
+  return getInternalURLState(this).password;
+};
+
+var getHost = function () {
+  var url = getInternalURLState(this);
+  var host = url.host;
+  var port = url.port;
+  return host === null ? ''
+    : port === null ? serializeHost(host)
+    : serializeHost(host) + ':' + port;
+};
+
+var getHostname = function () {
+  var host = getInternalURLState(this).host;
+  return host === null ? '' : serializeHost(host);
+};
+
+var getPort = function () {
+  var port = getInternalURLState(this).port;
+  return port === null ? '' : String(port);
+};
+
+var getPathname = function () {
+  var url = getInternalURLState(this);
+  var path = url.path;
+  return url.cannotBeABaseURL ? path[0] : path.length ? '/' + path.join('/') : '';
+};
+
+var getSearch = function () {
+  var query = getInternalURLState(this).query;
+  return query ? '?' + query : '';
+};
+
+var getSearchParams = function () {
+  return getInternalURLState(this).searchParams;
+};
+
+var getHash = function () {
+  var fragment = getInternalURLState(this).fragment;
+  return fragment ? '#' + fragment : '';
+};
+
+var accessorDescriptor = function (getter, setter) {
+  return { get: getter, set: setter, configurable: true, enumerable: true };
+};
+
+if (DESCRIPTORS) {
+  defineProperties(URLPrototype, {
+    // `URL.prototype.href` accessors pair
+    // https://url.spec.whatwg.org/#dom-url-href
+    href: accessorDescriptor(serializeURL, function (href) {
+      var url = getInternalURLState(this);
+      var urlString = $toString(href);
+      var failure = parseURL(url, urlString);
+      if (failure) throw TypeError(failure);
+      getInternalSearchParamsState(url.searchParams).updateSearchParams(url.query);
+    }),
+    // `URL.prototype.origin` getter
+    // https://url.spec.whatwg.org/#dom-url-origin
+    origin: accessorDescriptor(getOrigin),
+    // `URL.prototype.protocol` accessors pair
+    // https://url.spec.whatwg.org/#dom-url-protocol
+    protocol: accessorDescriptor(getProtocol, function (protocol) {
+      var url = getInternalURLState(this);
+      parseURL(url, $toString(protocol) + ':', SCHEME_START);
+    }),
+    // `URL.prototype.username` accessors pair
+    // https://url.spec.whatwg.org/#dom-url-username
+    username: accessorDescriptor(getUsername, function (username) {
+      var url = getInternalURLState(this);
+      var codePoints = arrayFrom($toString(username));
+      if (cannotHaveUsernamePasswordPort(url)) return;
+      url.username = '';
+      for (var i = 0; i < codePoints.length; i++) {
+        url.username += percentEncode(codePoints[i], userinfoPercentEncodeSet);
+      }
+    }),
+    // `URL.prototype.password` accessors pair
+    // https://url.spec.whatwg.org/#dom-url-password
+    password: accessorDescriptor(getPassword, function (password) {
+      var url = getInternalURLState(this);
+      var codePoints = arrayFrom($toString(password));
+      if (cannotHaveUsernamePasswordPort(url)) return;
+      url.password = '';
+      for (var i = 0; i < codePoints.length; i++) {
+        url.password += percentEncode(codePoints[i], userinfoPercentEncodeSet);
+      }
+    }),
+    // `URL.prototype.host` accessors pair
+    // https://url.spec.whatwg.org/#dom-url-host
+    host: accessorDescriptor(getHost, function (host) {
+      var url = getInternalURLState(this);
+      if (url.cannotBeABaseURL) return;
+      parseURL(url, $toString(host), HOST);
+    }),
+    // `URL.prototype.hostname` accessors pair
+    // https://url.spec.whatwg.org/#dom-url-hostname
+    hostname: accessorDescriptor(getHostname, function (hostname) {
+      var url = getInternalURLState(this);
+      if (url.cannotBeABaseURL) return;
+      parseURL(url, $toString(hostname), HOSTNAME);
+    }),
+    // `URL.prototype.port` accessors pair
+    // https://url.spec.whatwg.org/#dom-url-port
+    port: accessorDescriptor(getPort, function (port) {
+      var url = getInternalURLState(this);
+      if (cannotHaveUsernamePasswordPort(url)) return;
+      port = $toString(port);
+      if (port == '') url.port = null;
+      else parseURL(url, port, PORT);
+    }),
+    // `URL.prototype.pathname` accessors pair
+    // https://url.spec.whatwg.org/#dom-url-pathname
+    pathname: accessorDescriptor(getPathname, function (pathname) {
+      var url = getInternalURLState(this);
+      if (url.cannotBeABaseURL) return;
+      url.path = [];
+      parseURL(url, $toString(pathname), PATH_START);
+    }),
+    // `URL.prototype.search` accessors pair
+    // https://url.spec.whatwg.org/#dom-url-search
+    search: accessorDescriptor(getSearch, function (search) {
+      var url = getInternalURLState(this);
+      search = $toString(search);
+      if (search == '') {
+        url.query = null;
+      } else {
+        if ('?' == search.charAt(0)) search = search.slice(1);
+        url.query = '';
+        parseURL(url, search, QUERY);
+      }
+      getInternalSearchParamsState(url.searchParams).updateSearchParams(url.query);
+    }),
+    // `URL.prototype.searchParams` getter
+    // https://url.spec.whatwg.org/#dom-url-searchparams
+    searchParams: accessorDescriptor(getSearchParams),
+    // `URL.prototype.hash` accessors pair
+    // https://url.spec.whatwg.org/#dom-url-hash
+    hash: accessorDescriptor(getHash, function (hash) {
+      var url = getInternalURLState(this);
+      hash = $toString(hash);
+      if (hash == '') {
+        url.fragment = null;
+        return;
+      }
+      if ('#' == hash.charAt(0)) hash = hash.slice(1);
+      url.fragment = '';
+      parseURL(url, hash, FRAGMENT);
+    })
+  });
+}
+
+// `URL.prototype.toJSON` method
+// https://url.spec.whatwg.org/#dom-url-tojson
+redefine(URLPrototype, 'toJSON', function toJSON() {
+  return serializeURL.call(this);
+}, { enumerable: true });
+
+// `URL.prototype.toString` method
+// https://url.spec.whatwg.org/#URL-stringification-behavior
+redefine(URLPrototype, 'toString', function toString() {
+  return serializeURL.call(this);
+}, { enumerable: true });
+
+if (NativeURL) {
+  var nativeCreateObjectURL = NativeURL.createObjectURL;
+  var nativeRevokeObjectURL = NativeURL.revokeObjectURL;
+  // `URL.createObjectURL` method
+  // https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL
+  // eslint-disable-next-line no-unused-vars -- required for `.length`
+  if (nativeCreateObjectURL) redefine(URLConstructor, 'createObjectURL', function createObjectURL(blob) {
+    return nativeCreateObjectURL.apply(NativeURL, arguments);
+  });
+  // `URL.revokeObjectURL` method
+  // https://developer.mozilla.org/en-US/docs/Web/API/URL/revokeObjectURL
+  // eslint-disable-next-line no-unused-vars -- required for `.length`
+  if (nativeRevokeObjectURL) redefine(URLConstructor, 'revokeObjectURL', function revokeObjectURL(url) {
+    return nativeRevokeObjectURL.apply(NativeURL, arguments);
+  });
+}
+
+setToStringTag(URLConstructor, 'URL');
+
+$({ global: true, forced: !USE_NATIVE_URL, sham: !DESCRIPTORS }, {
+  URL: URLConstructor
+});
+
+
+/***/ }),
+
+/***/ 462:
+/***/ (() => {
+
+/* (ignored) */
+
+/***/ }),
+
+/***/ 6029:
+/***/ (() => {
+
+/* (ignored) */
+
+/***/ })
+
+/******/ 	});
+/************************************************************************/
+/******/ 	// The module cache
+/******/ 	var __webpack_module_cache__ = {};
+/******/ 	
+/******/ 	// The require function
+/******/ 	function __webpack_require__(moduleId) {
+/******/ 		// Check if module is in cache
+/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
+/******/ 		if (cachedModule !== undefined) {
+/******/ 			return cachedModule.exports;
+/******/ 		}
+/******/ 		// Create a new module (and put it into the cache)
+/******/ 		var module = __webpack_module_cache__[moduleId] = {
+/******/ 			// no module.id needed
+/******/ 			// no module.loaded needed
+/******/ 			exports: {}
+/******/ 		};
+/******/ 	
+/******/ 		// Execute the module function
+/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
+/******/ 	
+/******/ 		// Return the exports of the module
+/******/ 		return module.exports;
+/******/ 	}
+/******/ 	
+/************************************************************************/
+/******/ 	/* webpack/runtime/compat get default export */
+/******/ 	(() => {
+/******/ 		// getDefaultExport function for compatibility with non-harmony modules
+/******/ 		__webpack_require__.n = (module) => {
+/******/ 			var getter = module && module.__esModule ?
+/******/ 				() => (module['default']) :
+/******/ 				() => (module);
+/******/ 			__webpack_require__.d(getter, { a: getter });
+/******/ 			return getter;
+/******/ 		};
+/******/ 	})();
+/******/ 	
+/******/ 	/* webpack/runtime/define property getters */
+/******/ 	(() => {
+/******/ 		// define getter functions for harmony exports
+/******/ 		__webpack_require__.d = (exports, definition) => {
+/******/ 			for(var key in definition) {
+/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
+/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
+/******/ 				}
+/******/ 			}
+/******/ 		};
+/******/ 	})();
+/******/ 	
+/******/ 	/* webpack/runtime/global */
+/******/ 	(() => {
+/******/ 		__webpack_require__.g = (function() {
+/******/ 			if (typeof globalThis === 'object') return globalThis;
+/******/ 			try {
+/******/ 				return this || new Function('return this')();
+/******/ 			} catch (e) {
+/******/ 				if (typeof window === 'object') return window;
+/******/ 			}
+/******/ 		})();
+/******/ 	})();
+/******/ 	
+/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
+/******/ 	(() => {
+/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
+/******/ 	})();
+/******/ 	
+/******/ 	/* webpack/runtime/make namespace object */
+/******/ 	(() => {
+/******/ 		// define __esModule on exports
+/******/ 		__webpack_require__.r = (exports) => {
+/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
+/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
+/******/ 			}
+/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
+/******/ 		};
+/******/ 	})();
+/******/ 	
+/************************************************************************/
+var __webpack_exports__ = {};
+// This entry need to be wrapped in an IIFE because it need to be in strict mode.
+(() => {
+"use strict";
+// ESM COMPAT FLAG
+__webpack_require__.r(__webpack_exports__);
+
+// EXPORTS
+__webpack_require__.d(__webpack_exports__, {
+  "AACDepay": () => (/* reexport */ AACDepay),
+  "BasicDepay": () => (/* reexport */ BasicDepay),
+  "CanvasSink": () => (/* reexport */ CanvasSink),
+  "H264Depay": () => (/* reexport */ H264Depay),
+  "Html5CanvasPipeline": () => (/* reexport */ Html5CanvasPipeline),
+  "Html5VideoMetadataPipeline": () => (/* reexport */ Html5VideoMetadataPipeline),
+  "Html5VideoPipeline": () => (/* reexport */ Html5VideoPipeline),
+  "HttpMsePipeline": () => (/* reexport */ HttpMsePipeline),
+  "HttpSource": () => (/* reexport */ HttpSource),
+  "Inspector": () => (/* reexport */ Inspector),
+  "JPEGDepay": () => (/* reexport */ JPEGDepay),
+  "MessageType": () => (/* reexport */ MessageType),
+  "MetadataPipeline": () => (/* reexport */ MetadataPipeline),
+  "Mp4Capture": () => (/* reexport */ Mp4Capture),
+  "Mp4Muxer": () => (/* reexport */ Mp4Muxer),
+  "MseSink": () => (/* reexport */ MseSink),
+  "ONVIFDepay": () => (/* reexport */ ONVIFDepay),
+  "Pipeline": () => (/* reexport */ Pipeline),
+  "RTCPPacketType": () => (/* reexport */ RTCPPacketType),
+  "RTSPResponseError": () => (/* reexport */ RTSPResponseError),
+  "RTSP_METHOD": () => (/* reexport */ RTSP_METHOD),
+  "RtspMjpegPipeline": () => (/* reexport */ RtspMjpegPipeline),
+  "RtspMp4Pipeline": () => (/* reexport */ RtspMp4Pipeline),
+  "RtspParser": () => (/* reexport */ RtspParser),
+  "RtspPipeline": () => (/* reexport */ RtspPipeline),
+  "RtspSession": () => (/* reexport */ RtspSession),
+  "SDESItem": () => (/* reexport */ SDESItem),
+  "SR": () => (/* reexport */ SR),
+  "Scheduler": () => (/* reexport */ Scheduler),
+  "Sink": () => (/* reexport */ Sink),
+  "Source": () => (/* reexport */ Source),
+  "Tube": () => (/* reexport */ Tube),
+  "WSSource": () => (/* reexport */ WSSource),
+  "WsSdpPipeline": () => (/* reexport */ WsSdpPipeline),
+  "addRTSPRetry": () => (/* reexport */ addRTSPRetry),
+  "bodyOffset": () => (/* reexport */ bodyOffset),
+  "cSrc": () => (/* reexport */ cSrc),
+  "cSrcCount": () => (/* reexport */ cSrcCount),
+  "components": () => (/* reexport */ index_browser_namespaceObject),
+  "connectionEnded": () => (/* reexport */ connectionEnded),
+  "contentBase": () => (/* reexport */ contentBase),
+  "contentLocation": () => (/* reexport */ contentLocation),
+  "createTransform": () => (/* reexport */ createTransform),
+  "extHeader": () => (/* reexport */ extHeader),
+  "extHeaderLength": () => (/* reexport */ extHeaderLength),
+  "extension": () => (/* reexport */ extension),
+  "extractHeaderValue": () => (/* reexport */ extractHeaderValue),
+  "extractURIs": () => (/* reexport */ extractURIs),
+  "getTime": () => (/* reexport */ getTime),
+  "isRtcpApp": () => (/* reexport */ isRtcpApp),
+  "isRtcpBye": () => (/* reexport */ isRtcpBye),
+  "isRtcpRR": () => (/* reexport */ isRtcpRR),
+  "isRtcpSDES": () => (/* reexport */ isRtcpSDES),
+  "isRtcpSR": () => (/* reexport */ isRtcpSR),
+  "marker": () => (/* reexport */ marker),
+  "messageFromBuffer": () => (/* reexport */ messageFromBuffer),
+  "padding": () => (/* reexport */ padding),
+  "parse": () => (/* reexport */ sdp_parse),
+  "parseRtcp": () => (/* reexport */ parseRtcp),
+  "payload": () => (/* reexport */ payload),
+  "payloadType": () => (/* reexport */ payloadType),
+  "pipelines": () => (/* reexport */ pipelines_index_browser_namespaceObject),
+  "range": () => (/* reexport */ range),
+  "rtcpMessageFromBuffer": () => (/* reexport */ rtcpMessageFromBuffer),
+  "sSrc": () => (/* reexport */ sSrc),
+  "sequence": () => (/* reexport */ sequence),
+  "sequenceNumber": () => (/* reexport */ sequenceNumber),
+  "sessionId": () => (/* reexport */ sessionId),
+  "sessionTimeout": () => (/* reexport */ sessionTimeout),
+  "statusCode": () => (/* reexport */ statusCode),
+  "timestamp": () => (/* reexport */ timestamp),
+  "utils": () => (/* reexport */ utils_index_browser_namespaceObject),
+  "version": () => (/* reexport */ version)
+});
+
+// NAMESPACE OBJECT: ./lib/components/index.browser.ts
+var index_browser_namespaceObject = {};
+__webpack_require__.r(index_browser_namespaceObject);
+__webpack_require__.d(index_browser_namespaceObject, {
+  "AACDepay": () => (AACDepay),
+  "BasicDepay": () => (BasicDepay),
+  "CanvasSink": () => (CanvasSink),
+  "H264Depay": () => (H264Depay),
+  "HttpSource": () => (HttpSource),
+  "Inspector": () => (Inspector),
+  "JPEGDepay": () => (JPEGDepay),
+  "MessageType": () => (MessageType),
+  "Mp4Capture": () => (Mp4Capture),
+  "Mp4Muxer": () => (Mp4Muxer),
+  "MseSink": () => (MseSink),
+  "ONVIFDepay": () => (ONVIFDepay),
+  "RTSPResponseError": () => (RTSPResponseError),
+  "RTSP_METHOD": () => (RTSP_METHOD),
+  "RtspParser": () => (RtspParser),
+  "RtspSession": () => (RtspSession),
+  "Sink": () => (Sink),
+  "Source": () => (Source),
+  "Tube": () => (Tube),
+  "WSSource": () => (WSSource),
+  "createTransform": () => (createTransform)
+});
+
+// NAMESPACE OBJECT: ./lib/pipelines/index.browser.ts
+var pipelines_index_browser_namespaceObject = {};
+__webpack_require__.r(pipelines_index_browser_namespaceObject);
+__webpack_require__.d(pipelines_index_browser_namespaceObject, {
+  "Html5CanvasPipeline": () => (Html5CanvasPipeline),
+  "Html5VideoMetadataPipeline": () => (Html5VideoMetadataPipeline),
+  "Html5VideoPipeline": () => (Html5VideoPipeline),
+  "HttpMsePipeline": () => (HttpMsePipeline),
+  "MetadataPipeline": () => (MetadataPipeline),
+  "Pipeline": () => (Pipeline),
+  "RtspMjpegPipeline": () => (RtspMjpegPipeline),
+  "RtspMp4Pipeline": () => (RtspMp4Pipeline),
+  "RtspPipeline": () => (RtspPipeline),
+  "WsSdpPipeline": () => (WsSdpPipeline)
+});
+
+// NAMESPACE OBJECT: ./lib/utils/index.browser.ts
+var utils_index_browser_namespaceObject = {};
+__webpack_require__.r(utils_index_browser_namespaceObject);
+__webpack_require__.d(utils_index_browser_namespaceObject, {
+  "RTCPPacketType": () => (RTCPPacketType),
+  "SDESItem": () => (SDESItem),
+  "SR": () => (SR),
+  "Scheduler": () => (Scheduler),
+  "addRTSPRetry": () => (addRTSPRetry),
+  "bodyOffset": () => (bodyOffset),
+  "cSrc": () => (cSrc),
+  "cSrcCount": () => (cSrcCount),
+  "connectionEnded": () => (connectionEnded),
+  "contentBase": () => (contentBase),
+  "contentLocation": () => (contentLocation),
+  "extHeader": () => (extHeader),
+  "extHeaderLength": () => (extHeaderLength),
+  "extension": () => (extension),
+  "extractHeaderValue": () => (extractHeaderValue),
+  "extractURIs": () => (extractURIs),
+  "getTime": () => (getTime),
+  "isRtcpApp": () => (isRtcpApp),
+  "isRtcpBye": () => (isRtcpBye),
+  "isRtcpRR": () => (isRtcpRR),
+  "isRtcpSDES": () => (isRtcpSDES),
+  "isRtcpSR": () => (isRtcpSR),
+  "marker": () => (marker),
+  "messageFromBuffer": () => (messageFromBuffer),
+  "padding": () => (padding),
+  "parse": () => (sdp_parse),
+  "parseRtcp": () => (parseRtcp),
+  "payload": () => (payload),
+  "payloadType": () => (payloadType),
+  "range": () => (range),
+  "rtcpMessageFromBuffer": () => (rtcpMessageFromBuffer),
+  "sSrc": () => (sSrc),
+  "sequence": () => (sequence),
+  "sequenceNumber": () => (sequenceNumber),
+  "sessionId": () => (sessionId),
+  "sessionTimeout": () => (sessionTimeout),
+  "statusCode": () => (statusCode),
+  "timestamp": () => (timestamp),
+  "version": () => (version)
+});
+
+// EXTERNAL MODULE: ./.yarn/cache/stream-browserify-npm-3.0.0-4c0bd97245-4c47ef64d6.zip/node_modules/stream-browserify/index.js
+var stream_browserify = __webpack_require__(8981);
+;// CONCATENATED MODULE: ./lib/components/helpers/stream-factory.ts
+/* provided dependency */ var Buffer = __webpack_require__(7866)["Buffer"];
+
+class StreamFactory {
+  /**
+   * Creates a writable stream that sends all messages written to the stream
+   * to a callback function and then considers it written.
+   * @param fn  The callback to be invoked on the message
+   */
+  static consumer(fn = () => {
+    /* */
+  }) {
+    return new stream_browserify.Writable({
+      objectMode: true,
+
+      write(msg, _encoding, callback) {
+        fn(msg);
+        callback();
+      }
+
+    });
+  }
+
+  static peeker(fn) {
+    if (typeof fn !== 'function') {
+      throw new Error('you must supply a function');
+    }
+
+    return new stream_browserify.Transform({
+      objectMode: true,
+
+      transform(msg, _encoding, callback) {
+        fn(msg);
+        callback(undefined, msg);
+      }
+
+    });
+  }
+  /**
+   * Creates a readable stream that sends a message for each element of an array.
+   * @param arr  The array with elements to be turned into a stream.
+   */
+
+
+  static producer(messages) {
+    let counter = 0;
+    return new stream_browserify.Readable({
+      objectMode: true,
+
+      read() {
+        if (messages !== undefined) {
+          if (counter < messages.length) {
+            this.push(messages[counter++]);
+          } else {
+            // End the stream
+            this.push(null);
+          }
+        }
+      }
+
+    });
+  }
+
+  static recorder(type, fileStream) {
+    return new stream_browserify.Transform({
+      objectMode: true,
+
+      transform(msg, encoding, callback) {
+        const timestamp = Date.now(); // Replace binary data with base64 string
+
+        const message = Object.assign({}, msg, {
+          data: msg.data.toString('base64')
+        });
+        fileStream.write(JSON.stringify({
+          type,
+          timestamp,
+          message
+        }, null, 2));
+        fileStream.write(',\n');
+        callback(undefined, msg);
+      }
+
+    });
+  }
+  /**
+   * Yield binary messages from JSON packet array until depleted.
+   * @return {Generator} Returns a JSON packet iterator.
+   */
+
+
+  static replayer(packets) {
+    let packetCounter = 0;
+    let lastTimestamp = packets[0].timestamp;
+    return new stream_browserify.Readable({
+      objectMode: true,
+
+      read() {
+        const packet = packets[packetCounter++];
+
+        if (packet) {
+          const {
+            type,
+            timestamp,
+            message
+          } = packet;
+          const delay = timestamp - lastTimestamp;
+          lastTimestamp = timestamp;
+
+          if (message) {
+            const data = message.data ? Buffer.from(message.data, 'base64') : Buffer.alloc(0);
+            const msg = Object.assign({}, message, {
+              data
+            });
+            this.push({
+              type,
+              delay,
+              msg
+            });
+          } else {
+            this.push({
+              type,
+              delay,
+              msg: null
+            });
+          }
+        } else {
+          this.push(null);
+        }
+      }
+
+    });
+  }
+
+}
+;// CONCATENATED MODULE: ./lib/components/component.ts
+function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+
+
+
+/**
+ * Component
+ *
+ * A component is a set of bi-directional streams consisting of an 'incoming'
+ * and 'outgoing' stream.
+ *
+ * They contain references to other components so they can form a linked list of
+ * components, i.e. a pipeline. When linking components, the incoming and
+ * outgoing streams are piped, so that data flowing through the incoming stream
+ * is transfered to the next component, and data in the outgoing stream flows
+ * to the previous component.
+ *
+ * Components at the end of such a pipeline typically connect the incoming and
+ * outgoing streams to a data source or data sink.
+ *
+ * Typically, for a component that is connected to two other components, both
+ * incoming and outgoing will be Transform streams. For a source, 'incoming'
+ * will be a Readable stream and 'outgoing' a Writable stream, while for a sink
+ * it is reversed. Both source and sink could also use a single Duplex stream,
+ * with incoming === outgoing.
+ *
+ * server end-point                          client end-point
+ *  /-------------      -----------------      -------------\
+ *  |  Writable  |  <-  |   Transform   |  <-  |  Readable  |
+ *  |   source   |      |      tube     |      |    sink    |
+ *  |  Readable  |  ->  |   Transform   |  ->  |  Writable  |
+ *  \-------------      -----------------      -------------/
+ */
+class AbstractComponent {
+  constructor() {
+    _defineProperty(this, "incoming", void 0);
+
+    _defineProperty(this, "outgoing", void 0);
+
+    _defineProperty(this, "next", void 0);
+
+    _defineProperty(this, "prev", void 0);
+
+    _defineProperty(this, "_incomingErrorHandler", void 0);
+
+    _defineProperty(this, "_outgoingErrorHandler", void 0);
+  }
+
+}
+/**
+ * Source component
+ *
+ * A component that can only have a next component connected (no previous) and
+ * where the incoming and outgoing streams are connected to an external data
+ * source.
+ */
+
+
+class Source extends AbstractComponent {
+  /**
+   * Set up a source component that has a message list as data source.
+   *
+   * @param messages - List of objects (with data property) to emit on the
+   * incoming stream
+   */
+  static fromMessages(messages) {
+    const component = new Source(StreamFactory.producer(messages), StreamFactory.consumer());
+    return component;
+  }
+
+  constructor(incoming = new stream_browserify.Readable({
+    objectMode: true
+  }), outgoing = new stream_browserify.Writable({
+    objectMode: true
+  })) {
+    super();
+
+    _defineProperty(this, "incoming", void 0);
+
+    _defineProperty(this, "outgoing", void 0);
+
+    _defineProperty(this, "next", void 0);
+
+    _defineProperty(this, "prev", void 0);
+
+    this.incoming = incoming;
+    this.outgoing = outgoing;
+    this.next = null;
+    this.prev = null;
+  }
+  /**
+   * Attach another component so the the 'down' stream flows into the
+   * next component 'down' stream and the 'up' stream of the other component
+   * flows into the 'up' stream of this component. This is what establishes the
+   * meaning of 'up' and 'down'.
+   * @param  next - The component to connect.
+   * @return A reference to the connected component.
+   *
+   *      -------------- pipe --------------
+   *  <-  |  outgoing  |  <-  |  outgoing  | <-
+   *      |    this    |      |    next    |
+   *  ->  |  incoming  |  ->  |  incoming  | ->
+   *      -------------- pipe --------------
+   */
+
+
+  connect(next) {
+    // If the next component is not there, we want to return this component
+    // so that it is possible to continue to chain. If there is a next component,
+    // but this component already has a next one, or the next one already has a
+    // previous component, throw an error.
+    if (next === null) {
+      return this;
+    } else if (this.next !== null || next.prev !== null) {
+      throw new Error('connection failed: component(s) already connected');
+    }
+
+    if (!this.incoming.readable || !this.outgoing.writable) {
+      throw new Error('connection failed: this component not compatible');
+    }
+
+    if (!next.incoming.writable || !next.outgoing.readable) {
+      throw new Error('connection failed: next component not compatible');
+    }
+
+    try {
+      this.incoming.pipe(next.incoming);
+      next.outgoing.pipe(this.outgoing);
+    } catch (e) {
+      throw new Error(`connection failed: ${e.message}`);
+    }
+    /**
+     * Propagate errors back upstream, this assures an error will be propagated
+     * to all previous streams (but not further than any endpoints). What happens
+     * when an error is emitted on a stream is up to the stream's implementation.
+     */
+
+
+    const incomingErrorHandler = err => {
+      this.incoming.emit('error', err);
+    };
+
+    next.incoming.on('error', incomingErrorHandler);
+
+    const outgoingErrorHandler = err => {
+      next.outgoing.emit('error', err);
+    };
+
+    this.outgoing.on('error', outgoingErrorHandler); // Keep a bidirectional linked list of components by storing
+    // a reference to the next component and the listeners that we set up.
+
+    this.next = next;
+    next.prev = this;
+    this._incomingErrorHandler = incomingErrorHandler;
+    this._outgoingErrorHandler = outgoingErrorHandler;
+    return next;
+  }
+  /**
+   * Disconnect the next connected component. When there is no next component
+   * the function will just do nothing.
+   * @return {Component} - A reference to this component.
+   */
+
+
+  disconnect() {
+    const next = this.next;
+
+    if (next !== null) {
+      this.incoming.unpipe(next.incoming);
+      next.outgoing.unpipe(this.outgoing);
+
+      if (typeof this._incomingErrorHandler !== 'undefined') {
+        next.incoming.removeListener('error', this._incomingErrorHandler);
+      }
+
+      if (typeof this._outgoingErrorHandler !== 'undefined') {
+        this.outgoing.removeListener('error', this._outgoingErrorHandler);
+      }
+
+      this.next = null;
+      next.prev = null;
+      delete this._incomingErrorHandler;
+      delete this._outgoingErrorHandler;
+    }
+
+    return this;
+  }
+
+}
+/**
+ * Tube component
+ *
+ * A component where both incoming and outgoing streams are Duplex streams, and
+ * can be connected to a previous and next component, typically in the middle of
+ * a pipeline.
+ */
+
+class Tube extends Source {
+  /**
+   * Create a component that calls a handler function for each message passing
+   * through, but otherwise just passes data through.
+   *
+   * Can be used to log messages passing through a pipeline.
+   */
+  static fromHandlers(fnIncoming, fnOutgoing) {
+    const incomingStream = fnIncoming ? StreamFactory.peeker(fnIncoming) : undefined;
+    const outgoingStream = fnOutgoing ? StreamFactory.peeker(fnOutgoing) : undefined;
+    return new Tube(incomingStream, outgoingStream);
+  }
+
+  constructor(incoming = new stream_browserify.PassThrough({
+    objectMode: true
+  }), outgoing = new stream_browserify.PassThrough({
+    objectMode: true
+  })) {
+    super(incoming, outgoing);
+
+    _defineProperty(this, "incoming", void 0);
+
+    _defineProperty(this, "outgoing", void 0);
+
+    this.incoming = incoming;
+    this.outgoing = outgoing;
+  }
+
+}
+/**
+ * Sink component
+ *
+ * A component that can only have a previous component connected (no next) and
+ * where the incoming and outgoing streams are connected to an external data
+ * source.
+ */
+
+class Sink extends AbstractComponent {
+  /**
+   * Create a component that swallows incoming data (calling fn on it).  To
+   * print data, you would use fn = console.log.
+   *
+   * @param fn - The callback to use for the incoming data.
+   */
+  static fromHandler(fn) {
+    const component = new Sink(StreamFactory.consumer(fn), StreamFactory.producer(undefined)); // A sink should propagate when stream is ending.
+
+    component.incoming.on('finish', () => {
+      component.outgoing.push(null);
+    });
+    return component;
+  }
+
+  constructor(incoming = new stream_browserify.Writable({
+    objectMode: true
+  }), outgoing = new stream_browserify.Readable({
+    objectMode: true
+  })) {
+    super();
+
+    _defineProperty(this, "incoming", void 0);
+
+    _defineProperty(this, "outgoing", void 0);
+
+    _defineProperty(this, "next", void 0);
+
+    _defineProperty(this, "prev", void 0);
+
+    this.incoming = incoming;
+    this.outgoing = outgoing;
+    this.next = null;
+    this.prev = null;
+  }
+
+  connect() {
+    throw new Error('connection failed: attempting to connect after a sink');
+  }
+
+  disconnect() {
+    return this;
+  }
+
+}
+;// CONCATENATED MODULE: ./lib/utils/bits.ts
+const POS = [0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01];
+;// CONCATENATED MODULE: ./lib/utils/protocols/rtp.ts
+/* provided dependency */ var rtp_Buffer = __webpack_require__(7866)["Buffer"];
+ // Real Time Protocol (RTP)
+// https://tools.ietf.org/html/rfc3550#section-5.1
+
+/*
+RTP Fixed Header Fields
+
+  0               1               2               3
+  0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7
+  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  |V=2|P|X|  CC   |M|     PT      |       sequence number         |
+  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  |                           timestamp                           |
+  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  |           synchronization source (SSRC) identifier            |
+  +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
+  |            contributing source (CSRC) identifiers             |
+  |                             ....                              |
+  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  |   profile-specific ext. id    | profile-specific ext. length  |
+  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  |                 profile-specific extension                    |
+  |                             ....                              |
+  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+*/
+
+const version = buffer => {
+  return buffer[0] >>> 6;
+};
+const padding = buffer => {
+  return !!(buffer[0] & POS[2]);
+};
+const extension = buffer => {
+  return !!(buffer[0] & POS[3]);
+};
+const cSrcCount = buffer => {
+  return buffer[0] & 0x0f;
+};
+const marker = buffer => {
+  return !!(buffer[1] & POS[0]);
+};
+const payloadType = buffer => {
+  return buffer[1] & 0x7f;
+};
+const sequenceNumber = buffer => {
+  return buffer.readUInt16BE(2);
+};
+const timestamp = buffer => {
+  return buffer.readUInt32BE(4);
+};
+const sSrc = buffer => {
+  return buffer.readUInt32BE(8);
+};
+const cSrc = (buffer, rank = 0) => {
+  return cSrcCount(buffer) > rank ? buffer.readUInt32BE(12 + rank * 4) : 0;
+};
+const extHeaderLength = buffer => {
+  return !extension(buffer) ? 0 : buffer.readUInt16BE(12 + cSrcCount(buffer) * 4 + 2);
+};
+const extHeader = buffer => {
+  return extHeaderLength(buffer) === 0 ? rtp_Buffer.from([]) : buffer.slice(12 + cSrcCount(buffer) * 4, 12 + cSrcCount(buffer) * 4 + 4 + extHeaderLength(buffer) * 4);
+};
+const payload = buffer => {
+  return !extension(buffer) ? buffer.slice(12 + cSrcCount(buffer) * 4) : buffer.slice(12 + cSrcCount(buffer) * 4 + 4 + extHeaderLength(buffer) * 4);
+};
+;// CONCATENATED MODULE: ./lib/components/message.ts
+let MessageType;
+
+(function (MessageType) {
+  MessageType[MessageType["UNKNOWN"] = 0] = "UNKNOWN";
+  MessageType[MessageType["RAW"] = 1] = "RAW";
+  MessageType[MessageType["RTP"] = 2] = "RTP";
+  MessageType[MessageType["RTCP"] = 3] = "RTCP";
+  MessageType[MessageType["RTSP"] = 4] = "RTSP";
+  MessageType[MessageType["SDP"] = 5] = "SDP";
+  MessageType[MessageType["ELEMENTARY"] = 6] = "ELEMENTARY";
+  MessageType[MessageType["H264"] = 7] = "H264";
+  MessageType[MessageType["ISOM"] = 8] = "ISOM";
+  MessageType[MessageType["XML"] = 9] = "XML";
+  MessageType[MessageType["JPEG"] = 10] = "JPEG";
+})(MessageType || (MessageType = {}));
+;// CONCATENATED MODULE: ./lib/components/aacdepay/parser.ts
+
+
+/*
+From RFC 3640 https://tools.ietf.org/html/rfc3640
+  2.11.  Global Structure of Payload Format
+
+     The RTP payload following the RTP header, contains three octet-
+     aligned data sections, of which the first two MAY be empty, see
+     Figure 1.
+
+           +---------+-----------+-----------+---------------+
+           | RTP     | AU Header | Auxiliary | Access Unit   |
+           | Header  | Section   | Section   | Data Section  |
+           +---------+-----------+-----------+---------------+
+
+                     <----------RTP Packet Payload----------->
+
+              Figure 1: Data sections within an RTP packet
+Note that auxilary section is empty for AAC-hbr
+
+  3.2.1.  The AU Header Section
+
+   When present, the AU Header Section consists of the AU-headers-length
+   field, followed by a number of AU-headers, see Figure 2.
+
+      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- .. -+-+-+-+-+-+-+-+-+-+
+      |AU-headers-length|AU-header|AU-header|      |AU-header|padding|
+      |                 |   (1)   |   (2)   |      |   (n)   | bits  |
+      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- .. -+-+-+-+-+-+-+-+-+-+
+
+                   Figure 2: The AU Header Section
+*/
+
+function parse(rtp, hasHeader, callback) {
+  const buffer = payload(rtp.data);
+  let headerLength = 0;
+
+  if (hasHeader) {
+    const auHeaderLengthInBits = buffer.readUInt16BE(0);
+    headerLength = 2 + (auHeaderLengthInBits + auHeaderLengthInBits % 8) / 8; // Add padding
+  }
+
+  const packet = {
+    type: MessageType.ELEMENTARY,
+    data: buffer.slice(headerLength),
+    payloadType: payloadType(rtp.data),
+    timestamp: timestamp(rtp.data),
+    ntpTimestamp: rtp.ntpTimestamp
+  };
+  callback(packet);
+}
+;// CONCATENATED MODULE: ./lib/components/messageStreams.ts
+
+const createTransform = transform => {
+  return new stream_browserify.Transform({
+    objectMode: true,
+    transform
+  });
+};
+;// CONCATENATED MODULE: ./lib/components/aacdepay/index.ts
+
+
+
+
+
+/*
+media: [{ type: 'video',
+   port: '0',
+   proto: 'RTP/AVP',
+   fmt: '96',
+   rtpmap: '96 H264/90000',
+   fmtp: {
+      format: '96',
+      parameters: {
+        'packetization-mode': '1',
+        'profile-level-id': '4d0029',
+        'sprop-parameter-sets': 'Z00AKeKQDwBE/LgLcBAQGkHiRFQ=,aO48gA==',
+      },
+    },
+   control: 'rtsp://hostname/axis-media/media.amp/stream=0?audio=1&video=1',
+   framerate: '25.000000',
+   transform: [[1, 0, 0], [0, 0.75, 0], [0, 0, 1]] },
+   { type: 'audio',
+     port: '0',
+     proto: 'RTP/AVP',
+     fmt: '97',
+     fmtp: {
+       parameters: {
+         bitrate: '32000',
+         config: '1408',
+         indexdeltalength: '3',
+         indexlength: '3',
+         mode: 'AAC-hbr',
+         'profile-level-id': '2',
+         sizelength: '13',
+         streamtype: '5'
+       },
+       format: '97'
+     },
+     rtpmap: '97 MPEG4-GENERIC/16000/1',
+     control: 'rtsp://hostname/axis-media/media.amp/stream=1?audio=1&video=1' }]
+*/
+
+class AACDepay extends Tube {
+  constructor() {
+    let AACPayloadType;
+    let hasHeader;
+    const incoming = createTransform(function (msg, encoding, callback) {
+      if (msg.type === MessageType.SDP) {
+        // Check if there is an AAC track in the SDP
+        let validMedia;
+
+        for (const media of msg.sdp.media) {
+          if (media.type === 'audio' && media.fmtp && media.fmtp.parameters && media.fmtp.parameters.mode === 'AAC-hbr') {
+            validMedia = media;
+          }
+        }
+
+        if (validMedia && validMedia.rtpmap !== undefined) {
+          AACPayloadType = Number(validMedia.rtpmap.payloadType);
+          const parameters = validMedia.fmtp.parameters; // Required
+
+          const sizeLength = Number(parameters.sizelength) || 0;
+          const indexLength = Number(parameters.indexlength) || 0;
+          const indexDeltaLength = Number(parameters.indexdeltalength) || 0; // Optionals
+
+          const CTSDeltaLength = Number(parameters.ctsdeltalength) || 0;
+          const DTSDeltaLength = Number(parameters.dtsdeltalength) || 0;
+          const RandomAccessIndication = Number(parameters.randomaccessindication) || 0;
+          const StreamStateIndication = Number(parameters.streamstateindication) || 0;
+          const AuxiliaryDataSizeLength = Number(parameters.auxiliarydatasizelength) || 0;
+          hasHeader = sizeLength + Math.max(indexLength, indexDeltaLength) + CTSDeltaLength + DTSDeltaLength + RandomAccessIndication + StreamStateIndication + AuxiliaryDataSizeLength > 0;
+        }
+
+        callback(undefined, msg);
+      } else if (msg.type === MessageType.RTP && payloadType(msg.data) === AACPayloadType) {
+        parse(msg, hasHeader, this.push.bind(this));
+        callback();
+      } else {
+        // Not a message we should handle
+        callback(undefined, msg);
+      }
+    }); // outgoing will be defaulted to a PassThrough stream
+
+    super(incoming);
+  }
+
+}
+;// CONCATENATED MODULE: ./lib/components/basicdepay/index.ts
+/* provided dependency */ var basicdepay_Buffer = __webpack_require__(7866)["Buffer"];
+
+
+
+
+class BasicDepay extends Tube {
+  constructor(rtpPayloadType) {
+    if (rtpPayloadType === undefined) {
+      throw new Error('you must supply a payload type to BasicDepayComponent');
+    }
+
+    let buffer = basicdepay_Buffer.alloc(0);
+    const incoming = createTransform(function (msg, encoding, callback) {
+      if (msg.type === MessageType.RTP && payloadType(msg.data) === rtpPayloadType) {
+        const rtpPayload = payload(msg.data);
+        buffer = basicdepay_Buffer.concat([buffer, rtpPayload]);
+
+        if (marker(msg.data)) {
+          if (buffer.length > 0) {
+            this.push({
+              data: buffer,
+              timestamp: timestamp(msg.data),
+              ntpTimestamp: msg.ntpTimestamp,
+              payloadType: payloadType(msg.data),
+              type: MessageType.ELEMENTARY
+            });
+          }
+
+          buffer = basicdepay_Buffer.alloc(0);
+        }
+
+        callback();
+      } else {
+        // Not a message we should handle
+        callback(undefined, msg);
+      }
+    }); // outgoing will be defaulted to a PassThrough stream
+
+    super(incoming);
+  }
+
+}
+// EXTERNAL MODULE: ./.yarn/unplugged/core-js-npm-3.16.2-c7ce9e8d48/node_modules/core-js/modules/web.url.js
+var web_url = __webpack_require__(2743);
+;// CONCATENATED MODULE: ./lib/utils/clock.ts
+function clock_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+/**
+ * Clock
+ *
+ * A simple timer to keep track of elapsed time,
+ * which can be retrieved with the `now` method.
+ * The clock is initially in a stopped state, during
+ * which the elapsed time does not increase. When
+ * started, the clock will return the total elapsed
+ * time since the first start / last reset.
+ *
+ * As a convenience, start/stop are aliased as
+ * play/pause, to mimic a media element (for use
+ * as a playback clock). The `currentTime` getter
+ * returns the elapsed time in seconds (floating
+ * point), also as a convenienve to closely match
+ * the behaviour of a video element.
+ */
+class Clock {
+  constructor() {
+    clock_defineProperty(this, "started", void 0);
+
+    clock_defineProperty(this, "stopped", void 0);
+
+    clock_defineProperty(this, "elapsed", void 0);
+
+    this.elapsed = 0;
+    this.started = 0;
+    this.stopped = true;
+  }
+
+  start() {
+    if (this.stopped) {
+      this.started = window.performance.now();
+      this.stopped = false;
+    }
+  }
+
+  stop() {
+    if (!this.stopped) {
+      this.elapsed = this.now();
+      this.stopped = true;
+    }
+  }
+
+  reset() {
+    this.elapsed = 0;
+    this.started = 0;
+    this.stopped = true;
+  } // Gives the elapsed time in milliseconds since the
+  // clock was first started (after last reset).
+
+
+  now() {
+    if (this.stopped) {
+      return this.elapsed;
+    } else {
+      return this.elapsed + (window.performance.now() - this.started);
+    }
+  }
+
+  play() {
+    this.start();
+  }
+
+  pause() {
+    this.stop();
+  } // Gives the elapsed time in seconds since last reset.
+
+
+  get currentTime() {
+    return this.now() / 1000;
+  }
+
+}
+;// CONCATENATED MODULE: ./lib/utils/scheduler.ts
+function scheduler_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+// The default tolerance for matching the handler
+// invocation to clock presentation time.
+const DEFAULT_TOLERANCE = 10;
+/**
+ * A scheduler that can decide when to execute a certain
+ * timestamped callback so that it happens in sync with a video
+ * element.
+ *
+ * To use it:
+ *
+ * (1) Initialize a new Scheduler with a clock (to synchronize
+ * against) and a callback (to be called when a message is in
+ * sync with the video). The clock can be a HTMLVideoElement,
+ * or anything that has a `currentTime` property which gives
+ * the current presentation time in seconds, and a `pause` and
+ * `play` method to control playback.
+ *
+ * (2) Call the `run` method every time a new message arrives
+ * that you want to schedule (it needs to have an ntpTimestamp).
+ * As soon at the presentation time is known, call the `init`
+ * method and pass in that time, so that the scheduler can
+ * start to schedule the callbacks. From then on, whenever
+ * a message in the queue has a timestamp that matches the
+ * current presentation time of the video, your callback will
+ * fire.
+ */
+
+class Scheduler {
+  /**
+   * Creates an instance of Scheduler.
+   * @param clock - The clock to use (so we can control playback)
+   * @param handler - The callback to invoke when a message is in sync
+   * @param tolerance - The milliseconds defining "in sync" (default = 10)
+   */
+  constructor(clock, handler, tolerance = DEFAULT_TOLERANCE) {
+    scheduler_defineProperty(this, "_clock", void 0);
+
+    scheduler_defineProperty(this, "_handler", void 0);
+
+    scheduler_defineProperty(this, "_tolerance", void 0);
+
+    scheduler_defineProperty(this, "_nextRun", void 0);
+
+    scheduler_defineProperty(this, "_nextPlay", void 0);
+
+    scheduler_defineProperty(this, "_fifo", void 0);
+
+    scheduler_defineProperty(this, "_ntpPresentationTime", void 0);
+
+    scheduler_defineProperty(this, "_suspended", void 0);
+
+    this._clock = clock;
+    this._handler = handler;
+    this._tolerance = tolerance;
+    this._nextRun = 0;
+    this._nextPlay = 0;
+    this._fifo = [];
+    this._ntpPresentationTime = 0;
+    this._suspended = false;
+  }
+  /**
+   * Bring the scheduler back to it's initial state.
+   */
+
+
+  reset() {
+    clearTimeout(this._nextRun);
+    clearTimeout(this._nextPlay);
+    this._fifo = [];
+    this._ntpPresentationTime = 0;
+    this._suspended = false;
+  }
+  /**
+   * Initialize the scheduler.
+   *
+   * @param ntpPresentationTime - The offset representing the start of the presentation
+   */
+
+
+  init(ntpPresentationTime) {
+    this._ntpPresentationTime = ntpPresentationTime;
+  }
+  /**
+   * Suspend the scheduler.
+   *
+   * This releases control of the clock and stops any scheduling activity.
+   * Note that this doesn't mean the clock will be in a particular state
+   * (could be started or stopped), just that the scheduler will no longer
+   * control it.
+   */
+
+
+  suspend() {
+    clearTimeout(this._nextPlay);
+    this._suspended = true;
+  }
+  /**
+   * Resume the scheduler.
+   *
+   * This gives back control of the clock and the ability
+   * to schedule messages. The scheduler will immediately
+   * try to do that on resume.
+   */
+
+
+  resume() {
+    this._suspended = false;
+    this.run(undefined);
+  }
+  /**
+   * Run the scheduler.
+   *
+   * @param newMessage - New message to schedule.
+   */
+
+
+  run(newMessage) {
+    clearTimeout(this._nextRun); // If there is no way to schedule anything, just return.
+    // The first schedule will happen for the first .run that
+    // is called after the presentation time has been initialized.
+
+    if (typeof this._ntpPresentationTime === 'undefined') {
+      return;
+    } // If there is a new message, add it to the FIFO queue
+
+
+    if (typeof newMessage !== 'undefined') {
+      this._fifo.push(newMessage);
+    } // If the scheduler is suspended, we can only keep the
+    // messages and not do anything with them.
+
+
+    if (this._suspended) {
+      return;
+    } // If there are no messages, we don't need to bother or
+    // even re-schedule, because the new call to .run() will
+    // have to come from outside with a new message.
+
+
+    if (this._fifo.length === 0) {
+      return;
+    } // There is at least one message in the FIFO queue, either
+    // display it, or re-schedule the method for later execution
+
+
+    let timeToPresent = 0;
+    let currentMessage;
+
+    do {
+      const msg = this._fifo.shift();
+
+      if (msg === undefined) {
+        throw new Error('internal error: message should never be undefined');
+      }
+
+      currentMessage = msg;
+      const ntpTimestamp = currentMessage.ntpTimestamp;
+
+      if (ntpTimestamp === undefined) {
+        continue;
+      }
+
+      const presentationTime = ntpTimestamp - this._ntpPresentationTime;
+      timeToPresent = presentationTime - this._clock.currentTime * 1000; // If the message is within a tolerance of the presentation time
+      // then call the handler.
+
+      if (Math.abs(timeToPresent) < this._tolerance) {
+        this._handler && this._handler(currentMessage);
+      }
+    } while (timeToPresent < this._tolerance && this._fifo.length > 0);
+
+    if (timeToPresent < -this._tolerance) {
+      // We ran out of messages, delay the video with the same amount
+      // of delay as the last message had on the FIFO queue.
+      // Since we don't have any messages in the queue right now,
+      // the only way for anything to happen is if scheduler.run
+      // is called.
+      clearTimeout(this._nextPlay);
+
+      this._clock.pause();
+
+      this._nextPlay = window.setTimeout(() => this._clock.play(), -timeToPresent);
+    } else if (timeToPresent > this._tolerance) {
+      // message is later than video, add it back to the queue and
+      // re-run the scheduling at a later point in time
+      this._fifo.unshift(currentMessage);
+
+      this._nextRun = window.setTimeout(() => this.run(undefined), timeToPresent);
+    }
+  }
+
+}
+;// CONCATENATED MODULE: ./lib/components/canvas/index.ts
+
+
+function canvas_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+
+
+
+
+
+
+const resetInfo = info => {
+  info.bitrate = 0;
+  info.framerate = 0;
+  info.renderedFrames = 0;
+};
+
+const generateUpdateInfo = clockrate => {
+  let cumulativeByteLength = 0;
+  let cumulativeDuration = 0;
+  let cumulativeFrames = 0;
+  return (info, {
+    byteLength,
+    duration
+  }) => {
+    cumulativeByteLength += byteLength;
+    cumulativeDuration += duration;
+    cumulativeFrames++; // Update the cumulative number size (bytes) and duration (ticks), and if
+    // the duration exceeds the clockrate (meaning longer than 1 second of info),
+    // then compute a new bitrate and reset cumulative size and duration.
+
+    if (cumulativeDuration >= clockrate) {
+      const bits = 8 * cumulativeByteLength;
+      const frames = cumulativeFrames;
+      const seconds = cumulativeDuration / clockrate;
+      info.bitrate = bits / seconds;
+      info.framerate = frames / seconds;
+      cumulativeByteLength = 0;
+      cumulativeDuration = 0;
+      cumulativeFrames = 0;
+    }
+  };
+};
+/**
+ * Canvas component
+ *
+ * Draws an incoming stream of JPEG images onto a <canvas> element.
+ * The RTP timestamps are used to schedule the drawing of the images.
+ * An instance can be used as a 'clock' itself, e.g. with a scheduler.
+ *
+ * The following handlers can be set on a component instance:
+ *  - onCanplay: will be called when the first frame is ready and
+ *               the correct frame size has been set on the canvas.
+ *               At this point, the clock can be started by calling
+ *               `.play()` method on the component.
+ *  - onSync: will be called when the presentation time offset is
+ *            known, with the latter as argument (in UNIX milliseconds)
+ *
+ */
+
+
+class CanvasSink extends Sink {
+  /**
+   * @param  el - The <canvas> element to draw incoming JPEG messages on.
+   */
+  constructor(el) {
+    if (el === undefined) {
+      throw new Error('canvas element argument missing');
+    }
+
+    let firstTimestamp = 0;
+    let lastTimestamp = 0;
+    let clockrate = 0;
+    const info = {
+      bitrate: 0,
+      framerate: 0,
+      renderedFrames: 0
+    };
+    let updateInfo; // The createImageBitmap function is supported in Chrome and Firefox
+    // (https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/createImageBitmap)
+    // Note: drawImage can also be used instead of transferFromImageBitmap, but it caused
+    // very large memory use in Chrome (goes up to ~2-3GB, then drops again).
+    // Do do not call el.getContext twice, safari returns null for second call
+
+    let ctx = null;
+
+    if (window.createImageBitmap !== undefined) {
+      ctx = el.getContext('bitmaprenderer');
+    }
+
+    if (ctx === null) {
+      ctx = el.getContext('2d');
+    } // Set up the drawing callback to be used by the scheduler,
+    // it receives a blob of a JPEG image.
+
+
+    let drawImageBlob;
+
+    if (ctx === null) {
+      drawImageBlob = () => {
+        /** NOOP */
+      };
+    } else if ('transferFromImageBitmap' in ctx) {
+      const ctxBitmaprenderer = ctx;
+
+      drawImageBlob = ({
+        blob
+      }) => {
+        info.renderedFrames++;
+        window.createImageBitmap(blob).then(imageBitmap => {
+          ctxBitmaprenderer.transferFromImageBitmap(imageBitmap);
+        }).catch(() => {
+          /** ignore */
+        });
+      };
+    } else {
+      const ctx2d = ctx;
+      const img = new Image();
+
+      img.onload = () => {
+        ctx2d.drawImage(img, 0, 0);
+      };
+
+      drawImageBlob = ({
+        blob
+      }) => {
+        info.renderedFrames++;
+        const url = window.URL.createObjectURL(blob);
+        img.src = url;
+      };
+    } // Because we don't have an element that plays video for us,
+    // we have to use our own clock. The clock can be started/stopped
+    // with the `play` and `pause` methods, and has a `currentTime`
+    // property that keeps track of the presentation time.
+    // The scheduler will use the clock (instead of e.g. a video element)
+    // to determine when to display the JPEG images.
+
+
+    const clock = new Clock();
+    const scheduler = new Scheduler(clock, drawImageBlob);
+    let ntpPresentationTime = 0;
+
+    const onCanplay = () => {
+      this.onCanplay && this.onCanplay();
+    };
+
+    const onSync = ntpPresentationTime => {
+      this.onSync && this.onSync(ntpPresentationTime);
+    }; // Set up an incoming stream and attach it to the image drawing function.
+
+
+    const incoming = new stream_browserify.Writable({
+      objectMode: true,
+      write: (msg, encoding, callback) => {
+        if (msg.type === MessageType.SDP) {
+          // start of a new movie, reset timers
+          clock.reset();
+          scheduler.reset(); // Initialize first timestamp and clockrate
+
+          firstTimestamp = 0;
+          const jpegMedia = msg.sdp.media.find(media => {
+            return media.type === 'video' && media.rtpmap !== undefined && media.rtpmap.encodingName === 'JPEG';
+          });
+
+          if (jpegMedia !== undefined && jpegMedia.rtpmap !== undefined) {
+            clockrate = jpegMedia.rtpmap.clockrate; // Initialize the framerate/bitrate data
+
+            resetInfo(info);
+            updateInfo = generateUpdateInfo(clockrate);
+          }
+
+          callback();
+        } else if (msg.type === MessageType.JPEG) {
+          const {
+            timestamp,
+            ntpTimestamp
+          } = msg; // If first frame, store its timestamp, initialize
+          // the scheduler with 0 and start the clock.
+          // Also set the proper size on the canvas.
+
+          if (!firstTimestamp) {
+            // Initialize timing
+            firstTimestamp = timestamp;
+            lastTimestamp = timestamp; // Initialize frame size
+
+            const {
+              width,
+              height
+            } = msg.framesize;
+            el.width = width;
+            el.height = height; // Notify that we can play at this point
+
+            scheduler.init(0);
+          } // Compute millisecond presentation time (with offset 0
+          // as we initialized the scheduler with 0).
+
+
+          const presentationTime = 1000 * (timestamp - firstTimestamp) / clockrate;
+          const blob = new window.Blob([msg.data], {
+            type: 'image/jpeg'
+          }); // If the actual UTC time of the start of presentation isn't known yet,
+          // and we do have an ntpTimestamp, then compute it here and notify.
+
+          if (!ntpPresentationTime && ntpTimestamp) {
+            ntpPresentationTime = ntpTimestamp - presentationTime;
+            onSync(ntpPresentationTime);
+          }
+
+          scheduler.run({
+            ntpTimestamp: presentationTime,
+            blob
+          }); // Notify that we can now start the clock.
+
+          if (timestamp === firstTimestamp) {
+            onCanplay();
+          } // Update bitrate/framerate
+
+
+          updateInfo(info, {
+            byteLength: msg.data.length,
+            duration: timestamp - lastTimestamp
+          });
+          lastTimestamp = timestamp;
+          callback();
+        } else {
+          callback();
+        }
+      }
+    }); // Set up an outgoing stream.
+
+    const outgoing = new stream_browserify.Readable({
+      objectMode: true,
+      read: function () {//
+      }
+    }); // When an error is sent on the outgoing stream, whine about it.
+
+    outgoing.on('error', () => {
+      console.warn('outgoing stream broke somewhere');
+    });
+    super(incoming, outgoing);
+
+    canvas_defineProperty(this, "onCanplay", void 0);
+
+    canvas_defineProperty(this, "onSync", void 0);
+
+    canvas_defineProperty(this, "_clock", void 0);
+
+    canvas_defineProperty(this, "_scheduler", void 0);
+
+    canvas_defineProperty(this, "_info", void 0);
+
+    this._clock = clock;
+    this._scheduler = scheduler;
+    this._info = info;
+    this.onCanplay = undefined;
+    this.onSync = undefined;
+  }
+  /**
+   * Retrieve the current presentation time (seconds)
+   */
+
+
+  get currentTime() {
+    return this._clock.currentTime;
+  }
+  /**
+   * Pause the presentation.
+   */
+
+
+  pause() {
+    this._scheduler.suspend();
+
+    this._clock.pause();
+  }
+  /**
+   * Start the presentation.
+   */
+
+
+  play() {
+    this._clock.play();
+
+    this._scheduler.resume();
+  }
+
+  get bitrate() {
+    return this._info.bitrate;
+  }
+
+  get framerate() {
+    return this._info.framerate;
+  }
+
+}
+// EXTERNAL MODULE: ./.yarn/__virtual__/debug-virtual-c8b34b81df/0/cache/debug-npm-4.3.2-f0148b6afe-820ea160e2.zip/node_modules/debug/src/browser.js
+var browser = __webpack_require__(7997);
+var browser_default = /*#__PURE__*/__webpack_require__.n(browser);
+;// CONCATENATED MODULE: ./lib/components/h264depay/parser.ts
+/* provided dependency */ var parser_Buffer = __webpack_require__(7866)["Buffer"];
+function parser_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+
+
+
+let NAL_TYPES;
+/*
+First byte in payload (rtp payload header):
+      +---------------+
+      |0|1|2|3|4|5|6|7|
+      +-+-+-+-+-+-+-+-+
+      |F|NRI|  Type   |
+      +---------------+
+
+2nd byte in payload: FU header (if type in first byte is 28)
+      +---------------+
+      |0|1|2|3|4|5|6|7|
+      +-+-+-+-+-+-+-+-+
+      |S|E|R|  Type   | S = start, E = end
+      +---------------+
+*/
+
+(function (NAL_TYPES) {
+  NAL_TYPES[NAL_TYPES["UNSPECIFIED"] = 0] = "UNSPECIFIED";
+  NAL_TYPES[NAL_TYPES["NON_IDR_PICTURE"] = 1] = "NON_IDR_PICTURE";
+  NAL_TYPES[NAL_TYPES["IDR_PICTURE"] = 5] = "IDR_PICTURE";
+  NAL_TYPES[NAL_TYPES["SPS"] = 7] = "SPS";
+  NAL_TYPES[NAL_TYPES["PPS"] = 8] = "PPS";
+})(NAL_TYPES || (NAL_TYPES = {}));
+
+const h264Debug = browser_default()('msl:h264depay');
+class H264DepayParser {
+  constructor() {
+    parser_defineProperty(this, "_buffer", void 0);
+
+    this._buffer = parser_Buffer.alloc(0);
+  }
+
+  parse(rtp) {
+    const rtpPayload = payload(rtp.data);
+    const type = rtpPayload[0] & 0x1f;
+
+    if (type === 28) {
+      /* FU-A NALU */
+      const fuIndicator = rtpPayload[0];
+      const fuHeader = rtpPayload[1];
+      const startBit = !!(fuHeader >> 7);
+      const nalType = fuHeader & 0x1f;
+      const nal = fuIndicator & 0xe0 | nalType;
+      const stopBit = fuHeader & 64;
+
+      if (startBit) {
+        this._buffer = parser_Buffer.concat([parser_Buffer.from([0, 0, 0, 0, nal]), rtpPayload.slice(2)]);
+        return null;
+      } else if (stopBit) {
+        /* receieved end bit */
+        const h264frame = parser_Buffer.concat([this._buffer, rtpPayload.slice(2)]);
+        h264frame.writeUInt32BE(h264frame.length - 4, 0);
+        const msg = {
+          data: h264frame,
+          type: MessageType.H264,
+          timestamp: timestamp(rtp.data),
+          ntpTimestamp: rtp.ntpTimestamp,
+          payloadType: payloadType(rtp.data),
+          nalType: nalType
+        };
+        this._buffer = parser_Buffer.alloc(0);
+        return msg;
+      } else {
+        // Put the received data on the buffer and cut the header bytes
+        this._buffer = parser_Buffer.concat([this._buffer, rtpPayload.slice(2)]);
+        return null;
+      }
+    } else if ((type === NAL_TYPES.NON_IDR_PICTURE || type === NAL_TYPES.IDR_PICTURE) && this._buffer.length === 0) {
+      /* Single NALU */
+      const h264frame = parser_Buffer.concat([parser_Buffer.from([0, 0, 0, 0]), rtpPayload]);
+      h264frame.writeUInt32BE(h264frame.length - 4, 0);
+      const msg = {
+        data: h264frame,
+        type: MessageType.H264,
+        timestamp: timestamp(rtp.data),
+        ntpTimestamp: rtp.ntpTimestamp,
+        payloadType: payloadType(rtp.data),
+        nalType: type
+      };
+      this._buffer = parser_Buffer.alloc(0);
+      return msg;
+    } else {
+      h264Debug(`H264depayComponent can only extract types 1,5 and 28, got ${type}`);
+      this._buffer = parser_Buffer.alloc(0);
+      return null;
+    }
+  }
+
+}
+;// CONCATENATED MODULE: ./lib/components/h264depay/index.ts
+/* provided dependency */ var h264depay_Buffer = __webpack_require__(7866)["Buffer"];
+function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }
+
+function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { h264depay_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
+
+function h264depay_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+
+
+
+
+
+class H264Depay extends Tube {
+  constructor() {
+    let h264PayloadType;
+    let idrFound = false;
+    let packets = [];
+    const h264DepayParser = new H264DepayParser(); // Incoming
+
+    const incoming = new stream_browserify.Transform({
+      objectMode: true,
+      transform: function (msg, _encoding, callback) {
+        // Get correct payload types from sdp to identify video and audio
+        if (msg.type === MessageType.SDP) {
+          const h264Media = msg.sdp.media.find(media => {
+            return media.type === 'video' && media.rtpmap !== undefined && media.rtpmap.encodingName === 'H264';
+          });
+
+          if (h264Media !== undefined && h264Media.rtpmap !== undefined) {
+            h264PayloadType = h264Media.rtpmap.payloadType;
+          }
+
+          callback(undefined, msg); // Pass on the original SDP message
+        } else if (msg.type === MessageType.RTP && payloadType(msg.data) === h264PayloadType) {
+          const endOfFrame = marker(msg.data);
+          const h264Message = h264DepayParser.parse(msg); // Skip if not a full H264 frame, or when there hasn't been an I-frame yet
+
+          if (h264Message === null || !idrFound && h264Message.nalType !== NAL_TYPES.IDR_PICTURE) {
+            callback();
+            return;
+          }
+
+          idrFound = true; // H.264 over RTP uses the RTP marker bit to indicate a complete
+          // frame.  At this point, the packets can be used to construct a
+          // complete message.
+
+          packets.push(h264Message.data);
+
+          if (endOfFrame) {
+            this.push(_objectSpread(_objectSpread({}, h264Message), {}, {
+              data: packets.length === 1 ? packets[0] : h264depay_Buffer.concat(packets)
+            }));
+            packets = [];
+          }
+
+          callback();
+        } else {
+          // Not a message we should handle
+          callback(undefined, msg);
+        }
+      }
+    }); // outgoing will be defaulted to a PassThrough stream
+
+    super(incoming);
+  }
+
+}
+;// CONCATENATED MODULE: ./lib/components/http-source/index.ts
+/* provided dependency */ var http_source_Buffer = __webpack_require__(7866)["Buffer"];
+function http_source_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }
+
+function http_source_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { http_source_ownKeys(Object(source), true).forEach(function (key) { http_source_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { http_source_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
+
+function http_source_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+
+
+
+
+const debug = browser_default()('msl:http-source');
+class HttpSource extends Source {
+  /**
+   * Create an HTTP component.
+   *
+   * The constructor sets a single readable stream from a fetch.
+   */
+  constructor(config) {
+    const {
+      uri,
+      options
+    } = config;
+    /**
+     * Set up an incoming stream and attach it to the socket.
+     */
+
+    const incoming = new stream_browserify.Readable({
+      objectMode: true,
+      read: function () {//
+      }
+    }); // When an error is sent on the incoming stream, close the socket.
+
+    incoming.on('error', e => {
+      console.warn('closing socket due to incoming error', e);
+      this._reader && this._reader.cancel();
+    });
+    /**
+     * initialize the component.
+     */
+
+    super(incoming); // When a read is requested, continue to pull data
+
+    http_source_defineProperty(this, "uri", void 0);
+
+    http_source_defineProperty(this, "options", void 0);
+
+    http_source_defineProperty(this, "length", void 0);
+
+    http_source_defineProperty(this, "onHeaders", void 0);
+
+    http_source_defineProperty(this, "onServerClose", void 0);
+
+    http_source_defineProperty(this, "_reader", void 0);
+
+    http_source_defineProperty(this, "_abortController", void 0);
+
+    http_source_defineProperty(this, "_allDone", void 0);
+
+    incoming._read = () => {
+      this._pull();
+    };
+
+    this.uri = uri;
+    this.options = options;
+    this._allDone = false;
+  }
+
+  play() {
+    if (this.uri === undefined) {
+      throw new Error('cannot start playing when there is no URI');
+    }
+
+    this._abortController = new AbortController();
+    this.length = 0;
+    fetch(this.uri, http_source_objectSpread({
+      credentials: 'include',
+      signal: this._abortController.signal
+    }, this.options)).then(rsp => {
+      if (rsp.body === null) {
+        throw new Error('empty response body');
+      }
+
+      this.onHeaders && this.onHeaders(rsp.headers);
+      this._reader = rsp.body.getReader();
+
+      this._pull();
+    }).catch(err => {
+      console.error('http-source: fetch failed: ', err);
+    });
+  }
+
+  abort() {
+    this._reader && this._reader.cancel().catch(err => {
+      console.log('http-source: cancel reader failed: ', err);
+    });
+    this._abortController && this._abortController.abort();
+  }
+
+  _isClosed() {
+    return this._allDone;
+  }
+
+  _close() {
+    var _this$onServerClose;
+
+    this._reader = undefined;
+    this._allDone = true;
+    this.incoming.push(null);
+    (_this$onServerClose = this.onServerClose) === null || _this$onServerClose === void 0 ? void 0 : _this$onServerClose.call(this);
+  }
+
+  _pull() {
+    if (this._reader === undefined) {
+      return;
+    }
+
+    this._reader.read().then(({
+      done,
+      value
+    }) => {
+      if (done) {
+        if (!this._isClosed()) {
+          debug('fetch completed, total downloaded: ', this.length, ' bytes');
+
+          this._close();
+        }
+
+        return;
+      }
+
+      if (value === undefined) {
+        throw new Error('expected value to be defined');
+      }
+
+      if (this.length === undefined) {
+        throw new Error('expected length to be defined');
+      }
+
+      this.length += value.length;
+      const buffer = http_source_Buffer.from(value);
+
+      if (!this.incoming.push({
+        data: buffer,
+        type: MessageType.RAW
+      })) {
+        // Something happened down stream that it is no longer processing the
+        // incoming data, and the stream buffer got full.
+        // This could be because we are downloading too much data at once,
+        // or because the downstream is frozen. The latter is most likely
+        // when dealing with a live stream (as in that case we would expect
+        // downstream to be able to handle the data).
+        debug('downstream back pressure: pausing read');
+      } else {
+        // It's ok to read more data
+        this._pull();
+      }
+    }).catch(err => {
+      debug('http-source: read failed: ', err);
+
+      if (!this._isClosed()) {
+        this._close();
+      }
+    });
+  }
+
+}
+;// CONCATENATED MODULE: ./lib/components/inspector/index.ts
+
+
+
+const generateLogger = (prefix, type) => {
+  let lastTimestamp = Date.now();
+
+  const log = msg => {
+    const timestamp = Date.now();
+    console.log(`${prefix}: +${timestamp - lastTimestamp}ms`, msg);
+    lastTimestamp = timestamp;
+  };
+
+  if (type === undefined) {
+    return log;
+  } else {
+    return msg => msg.type === type && log(msg);
+  }
+};
+/**
+ * Component that logs whatever is passing through.
+ */
+
+
+class Inspector extends Tube {
+  /**
+   * Create a new inspector component.
+   * @argument {String} type  The type of message to log (default is to log all).
+   * @return {undefined}
+   */
+  constructor(type) {
+    const incomingLogger = generateLogger('incoming', type);
+    const incoming = new stream_browserify.Transform({
+      objectMode: true,
+      transform: function (msg, encoding, callback) {
+        incomingLogger(msg);
+        callback(undefined, msg);
+      }
+    });
+    const outgoingLogger = generateLogger('outgoing', type);
+    const outgoing = new stream_browserify.Transform({
+      objectMode: true,
+      transform: function (msg, encoding, callback) {
+        outgoingLogger(msg);
+        callback(undefined, msg);
+      }
+    });
+    super(incoming, outgoing);
+  }
+
+}
+;// CONCATENATED MODULE: ./lib/components/jpegdepay/headers.ts
+/* provided dependency */ var headers_Buffer = __webpack_require__(7866)["Buffer"];
+/**
+ * Generate frame and scan headers that can be prepended to the
+ * RTP/JPEG data payload to produce a JPEG compressed image in
+ * interchange format.
+ *
+ * For detailed information, check Appendix A of:
+ * https://tools.ietf.org/html/rfc2435
+ */
+function makeImageHeader() {
+  return headers_Buffer.from([0xff, 0xd8]);
+}
+function makeQuantHeader(precision, qTable) {
+  const lumSize = precision & 1 ? 128 : 64;
+  const chmSize = precision & 2 ? 128 : 64;
+
+  if (qTable.length !== lumSize + chmSize) {
+    throw new Error('invalid quantization table');
+  }
+
+  const lumaPrefix = headers_Buffer.from([0xff, 0xdb, 0, lumSize + 3, 0]);
+  const chromaPrefix = headers_Buffer.from([0xff, 0xdb, 0, chmSize + 3, 1]);
+  return headers_Buffer.concat([lumaPrefix, qTable.slice(0, lumSize), chromaPrefix, qTable.slice(lumSize)]);
+}
+function makeFrameHeader(width, height, type) {
+  return headers_Buffer.from([0xff, 0xc0, // SOF_0 (Start Of Frame)
+  0, 17, 8, height >> 8, height, width >> 8, width, 3, 0, type === 0 ? 0x21 : 0x22, 0, 1, 0x11, 1, 2, 0x11, 1]);
+} // prettier-ignore
+
+const LUM_DC_CODELENS = [0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0]; // prettier-ignore
+
+const LUM_DC_SYMBOLS = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]; // prettier-ignore
+
+const LUM_AC_CODELENS = [0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 0x7d]; // prettier-ignore
+
+const LUM_AC_SYMBOLS = [0x01, 0x02, 0x03, 0x00, 0x04, 0x11, 0x05, 0x12, 0x21, 0x31, 0x41, 0x06, 0x13, 0x51, 0x61, 0x07, 0x22, 0x71, 0x14, 0x32, 0x81, 0x91, 0xa1, 0x08, 0x23, 0x42, 0xb1, 0xc1, 0x15, 0x52, 0xd1, 0xf0, 0x24, 0x33, 0x62, 0x72, 0x82, 0x09, 0x0a, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa]; // prettier-ignore
+
+const CHM_DC_CODELENS = [0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0]; // prettier-ignore
+
+const CHM_DC_SYMBOLS = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]; // prettier-ignore
+
+const CHM_AC_CODELENS = [0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 0x77]; // prettier-ignore
+
+const CHM_AC_SYMBOLS = [0x00, 0x01, 0x02, 0x03, 0x11, 0x04, 0x05, 0x21, 0x31, 0x06, 0x12, 0x41, 0x51, 0x07, 0x61, 0x71, 0x13, 0x22, 0x32, 0x81, 0x08, 0x14, 0x42, 0x91, 0xa1, 0xb1, 0xc1, 0x09, 0x23, 0x33, 0x52, 0xf0, 0x15, 0x62, 0x72, 0xd1, 0x0a, 0x16, 0x24, 0x34, 0xe1, 0x25, 0xf1, 0x17, 0x18, 0x19, 0x1a, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa];
+function makeHuffmanHeader() {
+  const LUM_DC_BUFFER = [[0xff, 0xc4, 0, 3 + LUM_DC_CODELENS.length + LUM_DC_SYMBOLS.length, 0 << 4 | 0], LUM_DC_CODELENS, LUM_DC_SYMBOLS];
+  const LUM_AC_BUFFER = [[0xff, 0xc4, 0, 3 + LUM_AC_CODELENS.length + LUM_AC_SYMBOLS.length, 1 << 4 | 0], LUM_AC_CODELENS, LUM_AC_SYMBOLS];
+  const CHM_DC_BUFFER = [[0xff, 0xc4, 0, 3 + CHM_DC_CODELENS.length + CHM_DC_SYMBOLS.length, 0 << 4 | 1], CHM_DC_CODELENS, CHM_DC_SYMBOLS];
+  const CHM_AC_BUFFER = [[0xff, 0xc4, 0, 3 + CHM_AC_CODELENS.length + CHM_AC_SYMBOLS.length, 1 << 4 | 1], CHM_AC_CODELENS, CHM_AC_SYMBOLS];
+  return headers_Buffer.concat([...LUM_DC_BUFFER.map(headers_Buffer.from), ...LUM_AC_BUFFER.map(headers_Buffer.from), ...CHM_DC_BUFFER.map(headers_Buffer.from), ...CHM_AC_BUFFER.map(headers_Buffer.from)]);
+}
+function makeScanHeader() {
+  return headers_Buffer.from([0xff, 0xda, // SOS (Start Of Scan)
+  0, 12, 3, 0, 0, 1, 0x11, 2, 0x11, 0, 63, 0]);
+}
+function makeDRIHeader(dri) {
+  return headers_Buffer.from([0xff, 0xdd, 0x00, 4, dri >> 8, dri & 0xff]);
+}
+;// CONCATENATED MODULE: ./lib/utils/clamp.ts
+function clamp(val, min, max) {
+  return val > max ? max : val < min ? min : val;
+}
+;// CONCATENATED MODULE: ./lib/components/jpegdepay/make-qtable.ts
+/* provided dependency */ var make_qtable_Buffer = __webpack_require__(7866)["Buffer"];
+
+/**
+ * @function makeQtable
+ * Creating a quantization table from a Q factor
+ * Example Code from RFC 2435 Appendix A ported to TypeScript
+ *
+ * Default luminance/chrominance quantization tables in RFC example are not in zig-zag order.
+ * The RFC does not mention that default tables should be in zig-zag ordering,
+ * but they say that about the included tables. RFC sample code appears to have a mistake.
+ * All the tested cameras and LGPL projects use zig-zag default tables.
+ * So we use zig-zaged tables from ISO/IEC 10918-1 Annex K Section K.1
+ * @see https://tools.ietf.org/html/rfc2435
+ * @see https://www.iso.org/standard/18902.html
+ */
+// prettier-ignore
+
+const jpegLumaQuantizer = [16, 11, 12, 14, 12, 10, 16, 14, 13, 14, 18, 17, 16, 19, 24, 40, 26, 24, 22, 22, 24, 49, 35, 37, 29, 40, 58, 51, 61, 60, 57, 51, 56, 55, 64, 72, 92, 78, 64, 68, 87, 69, 55, 56, 80, 109, 81, 87, 95, 98, 103, 104, 103, 62, 77, 113, 121, 112, 100, 120, 92, 101, 103, 99]; // prettier-ignore
+
+const jpeChromaQuantizer = [17, 18, 18, 24, 21, 24, 47, 26, 26, 47, 99, 66, 56, 66, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99];
+function makeQtable(Q) {
+  const factor = clamp(Q, 1, 99);
+  const buffer = make_qtable_Buffer.alloc(128);
+  const S = Q < 50 ? Math.floor(5000 / factor) : 200 - factor * 2;
+
+  for (let i = 0; i < 64; i++) {
+    const lq = Math.floor((jpegLumaQuantizer[i] * S + 50) / 100);
+    const cq = Math.floor((jpeChromaQuantizer[i] * S + 50) / 100);
+    buffer.writeUInt8(clamp(lq, 1, 255), i);
+    buffer.writeUInt8(clamp(cq, 1, 255), i + 64);
+  }
+
+  return buffer;
+}
+;// CONCATENATED MODULE: ./lib/components/jpegdepay/parser.ts
+/* provided dependency */ var jpegdepay_parser_Buffer = __webpack_require__(7866)["Buffer"];
+
+
+
+/**
+ * Each packet contains a special JPEG header which immediately follows
+ * the RTP header.  The first 8 bytes of this header, called the "main
+ * JPEG header", are as follows:*
+ *  0                   1                   2                   3
+ *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+ * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ * | Type-specific |              Fragment Offset                  |
+ * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ * |      Type     |       Q       |     Width     |     Height    |
+ * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ */
+
+/**
+ * Restart Marker header: when using types 64-127
+ *  0                   1                   2                   3
+ *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+ * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ * |       Restart Interval        |F|L|       Restart Count       |
+ * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ */
+
+/**
+ * Quantization Table header: when using Q values 128-255
+ *  0                   1                   2                   3
+ *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+ * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ * |      MBZ      |   Precision   |             Length            |
+ * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ * |                    Quantization Table Data                    |
+ * |                              ...                              |
+ * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+ */
+
+function jpegDepayFactory(defaultWidth = 0, defaultHeight = 0) {
+  const IMAGE_HEADER = makeImageHeader();
+  const HUFFMAN_HEADER = makeHuffmanHeader();
+  const SCAN_HEADER = makeScanHeader();
+  return function jpegDepay(packets) {
+    let metadata;
+    const fragments = [];
+
+    for (const packet of packets) {
+      let fragment = payload(packet); // Parse and extract JPEG header.
+
+      const typeSpecific = fragment.readUInt8(0);
+      const fragmentOffset = fragment.readUInt8(1) << 16 | fragment.readUInt8(2) << 8 | fragment.readUInt8(3);
+      const type = fragment.readUInt8(4);
+      const Q = fragment.readUInt8(5);
+      const width = fragment.readUInt8(6) * 8 || defaultWidth;
+      const height = fragment.readUInt8(7) * 8 || defaultHeight;
+      fragment = fragment.slice(8); // Parse and extract Restart Marker header if present.
+
+      let DRI = 0;
+
+      if (type >= 64 && type <= 127) {
+        DRI = fragment.readUInt16BE(0);
+        fragment = fragment.slice(4);
+      } // Parse and extract Quantization Table header if present.
+
+
+      if (Q >= 128 && fragmentOffset === 0) {
+        // const MBZ = fragment.readUInt8()
+        const precision = fragment.readUInt8(1);
+        const length = fragment.readUInt16BE(2);
+        const qTable = fragment.slice(4, 4 + length);
+        metadata = {
+          typeSpecific,
+          type,
+          width,
+          height,
+          DRI,
+          precision,
+          qTable
+        };
+        fragment = fragment.slice(4 + length);
+      } // Compute Quantization Table
+      else if (Q < 128 && fragmentOffset === 0) {
+          const precision = 0;
+          const qTable = makeQtable(Q);
+          metadata = {
+            typeSpecific,
+            type,
+            width,
+            height,
+            DRI,
+            precision,
+            qTable
+          };
+        }
+
+      fragments.push(fragment);
+    }
+
+    if (metadata === undefined) {
+      throw new Error('no quantization header present');
+    }
+
+    const {
+      precision,
+      qTable,
+      type,
+      width,
+      height
+    } = metadata;
+    const quantHeader = makeQuantHeader(precision, qTable);
+    const driHeader = metadata.DRI === 0 ? jpegdepay_parser_Buffer.alloc(0) : makeDRIHeader(metadata.DRI);
+    const frameHeader = makeFrameHeader(width, height, type);
+    return {
+      size: {
+        width,
+        height
+      },
+      data: jpegdepay_parser_Buffer.concat([IMAGE_HEADER, quantHeader, driHeader, frameHeader, HUFFMAN_HEADER, SCAN_HEADER, ...fragments])
+    };
+  };
+}
+;// CONCATENATED MODULE: ./lib/components/jpegdepay/index.ts
+
+
+
+
+
+class JPEGDepay extends Tube {
+  constructor() {
+    let jpegPayloadType;
+    let packets = [];
+    let jpegDepay;
+    const incoming = new stream_browserify.Transform({
+      objectMode: true,
+      transform: function (msg, encoding, callback) {
+        if (msg.type === MessageType.SDP) {
+          const jpegMedia = msg.sdp.media.find(media => {
+            return media.type === 'video' && media.rtpmap !== undefined && media.rtpmap.encodingName === 'JPEG';
+          });
+
+          if (jpegMedia !== undefined && jpegMedia.rtpmap !== undefined) {
+            jpegPayloadType = Number(jpegMedia.rtpmap.payloadType);
+            const framesize = jpegMedia.framesize; // `framesize` is an SDP field that is present in e.g. Axis camera's
+            // and is used because the width and height that can be sent inside
+            // the JPEG header are both limited to 2040.
+            // If present, we use this width and height as the default values
+            // to be used by the jpeg depay function, otherwise we ignore this
+            // and let the JPEG header inside the RTP packets determine this.
+
+            if (framesize !== undefined) {
+              const [width, height] = framesize; // msg.framesize = { width, height }
+
+              jpegDepay = jpegDepayFactory(width, height);
+            } else {
+              jpegDepay = jpegDepayFactory();
+            }
+          }
+
+          callback(undefined, msg);
+        } else if (msg.type === MessageType.RTP && payloadType(msg.data) === jpegPayloadType) {
+          packets.push(msg.data); // JPEG over RTP uses the RTP marker bit to indicate end
+          // of fragmentation. At this point, the packets can be used
+          // to reconstruct a JPEG frame.
+
+          if (marker(msg.data) && packets.length > 0) {
+            const jpegFrame = jpegDepay(packets);
+            this.push({
+              timestamp: timestamp(msg.data),
+              ntpTimestamp: msg.ntpTimestamp,
+              payloadType: payloadType(msg.data),
+              data: jpegFrame.data,
+              framesize: jpegFrame.size,
+              type: MessageType.JPEG
+            });
+            packets = [];
+          }
+
+          callback();
+        } else {
+          // Not a message we should handle
+          callback(undefined, msg);
+        }
+      }
+    }); // outgoing will be defaulted to a PassThrough stream
+
+    super(incoming);
+  }
+
+}
+;// CONCATENATED MODULE: ./lib/components/mp4capture/index.ts
+/* provided dependency */ var mp4capture_Buffer = __webpack_require__(7866)["Buffer"];
+function mp4capture_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+
+
+
+
+const MAX_CAPTURE_BYTES = 225000000; // 5 min at a rate of 6 Mbit/s
+
+/**
+ * Component that records MP4 data.
+ */
+
+class Mp4Capture extends Tube {
+  constructor(maxSize = MAX_CAPTURE_BYTES) {
+    const incoming = new stream_browserify.Transform({
+      objectMode: true,
+      transform: (msg, _encoding, callback) => {
+        // Arrival of ISOM with tracks indicates new movie, start recording if active.
+        if (this._active && msg.type === MessageType.ISOM && msg.tracks !== undefined) {
+          this._capture = true;
+        } // If capture enabled, record all ISOM (MP4) boxes
+
+
+        if (this._capture && msg.type === MessageType.ISOM) {
+          if (this._bufferOffset < this._buffer.byteLength - msg.data.byteLength) {
+            msg.data.copy(this._buffer, this._bufferOffset);
+            this._bufferOffset += msg.data.byteLength;
+          } else {
+            this.stop();
+          }
+        } // Always pass on all messages
+
+
+        callback(undefined, msg);
+      }
+    }); // Stop any recording when the stream is closed.
+
+    incoming.on('finish', () => {
+      this.stop();
+    });
+    super(incoming);
+
+    mp4capture_defineProperty(this, "_active", void 0);
+
+    mp4capture_defineProperty(this, "_capture", void 0);
+
+    mp4capture_defineProperty(this, "_captureCallback", void 0);
+
+    mp4capture_defineProperty(this, "_bufferOffset", void 0);
+
+    mp4capture_defineProperty(this, "_bufferSize", void 0);
+
+    mp4capture_defineProperty(this, "_buffer", void 0);
+
+    this._buffer = mp4capture_Buffer.allocUnsafe(0);
+    this._bufferSize = maxSize;
+    this._bufferOffset = 0;
+    this._active = false;
+    this._capture = false;
+
+    this._captureCallback = () => {
+      /** noop */
+    };
+  }
+  /**
+   * Activate video capture. The capture will begin when a new movie starts,
+   * and will terminate when the movie ends or when the buffer is full. On
+   * termination, the callback you passed will be called with the captured
+   * data as argument.
+   * @param callback  Will be called when data is captured.
+   */
+
+
+  start(callback) {
+    if (!this._active) {
+      browser_default()('msl:capture:start')(callback);
+      this._captureCallback = callback;
+      this._buffer = mp4capture_Buffer.allocUnsafe(this._bufferSize);
+      this._bufferOffset = 0;
+      this._active = true;
+    }
+  }
+  /**
+   * Deactivate video capture. This ends an ongoing capture and prevents
+   * any further capturing.
+   */
+
+
+  stop() {
+    if (this._active) {
+      browser_default()('msl:capture:stop')(`captured bytes: ${this._bufferOffset}`);
+
+      try {
+        this._captureCallback(this._buffer.slice(0, this._bufferOffset));
+      } catch (e) {
+        console.error(e);
+      }
+
+      this._buffer = mp4capture_Buffer.allocUnsafe(0);
+      this._bufferOffset = 0;
+      this._active = false;
+      this._capture = false;
+    }
+  }
+
+}
+;// CONCATENATED MODULE: ./lib/components/mp4muxer/helpers/isom.ts
+/* provided dependency */ var isom_Buffer = __webpack_require__(7866)["Buffer"];
+function isom_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+// Elements: parts of a box that hold values.
+// They should have a:
+// - byteLength
+// - value (can be accessed from outside to set/retrieve)
+// - store(buffer, offset) -> write the value to a buffer
+// - load(buffer, offset) -> read data and store in value
+// Constants
+const UINT32_RANGE = Math.pow(2, 32);
+
+class BoxElement {
+  constructor(size) {
+    isom_defineProperty(this, "byteLength", void 0);
+
+    isom_defineProperty(this, "value", void 0);
+
+    this.byteLength = size;
+  }
+
+}
+
+class Empty extends BoxElement {
+  constructor(size = 0) {
+    super(size);
+
+    isom_defineProperty(this, "copy", (buffer, offset) => {
+      buffer.fill(0, offset, offset + this.byteLength);
+    });
+  }
+
+  load() {
+    /** noop */
+  }
+
+}
+
+class CharArray extends BoxElement {
+  constructor(s) {
+    super(s.length);
+
+    isom_defineProperty(this, "value", void 0);
+
+    isom_defineProperty(this, "copy", (buffer, offset) => {
+      for (let i = 0; i < this.byteLength; i += 1) {
+        buffer[offset + i] = this.value.charCodeAt(i);
+      }
+    });
+
+    isom_defineProperty(this, "load", (buffer, offset) => {
+      this.value = buffer.slice(offset, offset + this.byteLength).toString('ascii');
+    });
+
+    this.value = s;
+  }
+
+}
+
+class UInt8 extends BoxElement {
+  constructor(scalar = 0) {
+    super(1);
+
+    isom_defineProperty(this, "value", void 0);
+
+    isom_defineProperty(this, "copy", (buffer, offset) => {
+      buffer.writeUInt8(this.value, offset);
+    });
+
+    isom_defineProperty(this, "load", (buffer, offset) => {
+      this.value = buffer.readUInt8(offset);
+    });
+
+    this.value = scalar;
+  }
+
+}
+
+class UInt8Array extends BoxElement {
+  constructor(array) {
+    super(array.length);
+
+    isom_defineProperty(this, "value", void 0);
+
+    isom_defineProperty(this, "copy", (buffer, offset) => {
+      for (let i = 0; i < this.value.length; ++i) {
+        buffer.writeUInt8(this.value[i], offset + i);
+      }
+    });
+
+    isom_defineProperty(this, "load", (buffer, offset) => {
+      for (let i = 0; i < this.value.length; ++i) {
+        this.value[i] = buffer.readUInt8(offset + i);
+      }
+    });
+
+    this.value = array;
+  }
+
+}
+
+class UInt16BE extends BoxElement {
+  constructor(scalar = 0) {
+    super(2);
+
+    isom_defineProperty(this, "value", void 0);
+
+    isom_defineProperty(this, "copy", (buffer, offset) => {
+      buffer.writeUInt16BE(this.value, offset);
+    });
+
+    isom_defineProperty(this, "load", (buffer, offset) => {
+      this.value = buffer.readUInt16BE(offset);
+    });
+
+    this.value = scalar;
+  }
+
+}
+
+class UInt24BE extends BoxElement {
+  constructor(scalar = 0) {
+    super(3);
+
+    isom_defineProperty(this, "value", void 0);
+
+    isom_defineProperty(this, "copy", (buffer, offset) => {
+      buffer.writeUInt8(this.value >> 16 & 0xff, offset);
+      buffer.writeUInt8(this.value >> 8 & 0xff, offset + 1);
+      buffer.writeUInt8(this.value & 0xff, offset + 2);
+    });
+
+    isom_defineProperty(this, "load", (buffer, offset) => {
+      this.value = buffer.readUInt8(offset) << 16 + buffer.readUInt8(offset + 1) << 8 + buffer.readUInt8(offset + 2);
+    });
+
+    this.value = scalar;
+  }
+
+}
+
+class UInt16BEArray extends BoxElement {
+  constructor(array) {
+    super(array.length * 2);
+
+    isom_defineProperty(this, "value", void 0);
+
+    isom_defineProperty(this, "copy", (buffer, offset) => {
+      for (let i = 0; i < this.value.length; ++i) {
+        buffer.writeUInt16BE(this.value[i], offset + 2 * i);
+      }
+    });
+
+    isom_defineProperty(this, "load", (buffer, offset) => {
+      for (let i = 0; i < this.value.length; ++i) {
+        this.value[i] = buffer.readUInt16BE(offset + 2 * i);
+      }
+    });
+
+    this.value = array;
+  }
+
+}
+
+class UInt32BE extends BoxElement {
+  constructor(scalar = 0) {
+    super(4);
+
+    isom_defineProperty(this, "value", void 0);
+
+    isom_defineProperty(this, "copy", (buffer, offset) => {
+      buffer.writeUInt32BE(this.value, offset);
+    });
+
+    isom_defineProperty(this, "load", (buffer, offset) => {
+      this.value = buffer.readUInt32BE(offset);
+    });
+
+    this.value = scalar;
+  }
+
+}
+
+class UInt32BEArray extends BoxElement {
+  constructor(array) {
+    super(array.length * 4);
+
+    isom_defineProperty(this, "value", void 0);
+
+    isom_defineProperty(this, "copy", (buffer, offset) => {
+      for (let i = 0; i < this.value.length; ++i) {
+        buffer.writeUInt32BE(this.value[i], offset + 4 * i);
+      }
+    });
+
+    isom_defineProperty(this, "load", (buffer, offset) => {
+      for (let i = 0; i < this.value.length; ++i) {
+        this.value[i] = buffer.readUInt32BE(offset + 4 * i);
+      }
+    });
+
+    this.value = array;
+  }
+
+}
+
+class UInt64BE extends BoxElement {
+  constructor(scalar = 0) {
+    super(8);
+
+    isom_defineProperty(this, "value", void 0);
+
+    isom_defineProperty(this, "copy", (buffer, offset) => {
+      const high = this.value / UINT32_RANGE | 0;
+      const low = this.value - high * UINT32_RANGE;
+      buffer.writeUInt32BE(high, offset);
+      buffer.writeUInt32BE(low, offset + 4);
+    });
+
+    isom_defineProperty(this, "load", (buffer, offset) => {
+      const high = buffer.readUInt32BE(offset);
+      const low = buffer.readUInt32BE(offset + 4);
+      this.value = high * UINT32_RANGE + low;
+    });
+
+    this.value = scalar;
+  }
+
+}
+/**
+ * Class factory for a parameter set element. A parameter set groups a size,
+ * and an array of parameter sets consisting each of a size and a byte array.
+ * These elements are used by the avcC box.
+ * @param  [sizeMask=0x00]  A bit mask to use for the size.
+ * @return An element type that groups parameter sets.
+ */
+
+
+const createParameterSetArrayClass = function (sizeMask = 0x00) {
+  return class ParameterSetArray extends BoxElement {
+    /**
+     * Takes an array of byte-arrays
+     * @param  array The array of byte arrays
+     */
+    constructor(array) {
+      super(0); // this.setLengths = array.map((byteArray) => byteArray.length);
+
+      isom_defineProperty(this, "value", void 0);
+
+      isom_defineProperty(this, "copy", (buffer, offset) => {
+        let i = 0;
+
+        for (const element of this.value) {
+          element.copy(buffer, offset + i);
+          i += element.byteLength;
+        }
+      });
+
+      isom_defineProperty(this, "load", () => {
+        /** noop */
+      });
+
+      this.value = array.reduce((flatArray, byteArray) => {
+        return flatArray.concat(new UInt16BE(byteArray.length), new UInt8Array(byteArray));
+      }, [new UInt8(sizeMask | array.length)]);
+      this.byteLength = this.value.reduce((total, element) => total + element.byteLength, 0);
+    }
+
+  };
+};
+
+/**
+ * Specifications for a selection of ISO BMFF box types.
+ *
+ * Most of these are defined in ISO/IEC 14496-12,
+ * For specific boxes like avc1/avcC/mp4a/esds the exact document is specified
+ * with the appropriate box/descriptor.
+ *
+ * To add a new box, follow the same pattern: you need an object with at least
+ * the property 'box' (which is 'Box' or 'FullBox') and for non-container boxes
+ * you need also a 'body' property specifying the elements that the box contains.
+ * The values assigned to each element in the spec are used as default.
+ */
+const BOXSPEC = {
+  // File Type Box
+  ftyp: {
+    container: 'file',
+    mandatory: true,
+    quantity: 'one',
+    box: 'Box',
+    is_container: true,
+    body: [['major_brand', CharArray, 'isom'], ['minor_version', UInt32BE, 0], ['compatible_brands', CharArray, 'mp41'] // ['compatible_brands1', CharArray, 'iso2'],
+    // ['compatible_brands2', CharArray, 'dash'],
+    ]
+  },
+  // Movie Container
+  moov: {
+    container: 'file',
+    mandatory: true,
+    quantity: 'one',
+    box: 'Box',
+    is_container: true
+  },
+  // Movie Data Box
+  mdat: {
+    container: 'file',
+    mandatory: false,
+    quantity: 'any',
+    box: 'Box',
+    is_container: false,
+    body: []
+  },
+  // Movie Header Box
+  mvhd: {
+    container: 'moov',
+    mandatory: true,
+    quantity: 'one',
+    box: 'FullBox',
+    is_container: false,
+    body: [['creation_time', UInt32BE, 0], ['modification_time', UInt32BE, 0], ['timescale', UInt32BE, 1000], // time-scale for entire presentation, default = milliseconds
+    ['duration', UInt32BE, 0xffffffff], // length of entire presentation, default = undetermined
+    ['rate', UInt32BE, 0x00010000], // fixed point 16.16, preferred playback rate, default = 1.0
+    ['volume', UInt16BE, 0x0100], // fixed point 8.8, preferred playback volume, default = 1.0
+    ['reserved', Empty, 10], // transformation matrix, default = unity
+    ['matrix', UInt32BEArray, [0x00010000, 0, 0, 0, 0x00010000, 0, 0, 0, 0x40000000]], ['pre_defined', Empty, 24], ['next_track_ID', UInt32BE, 0xffffffff] // next unused track ID, default = unknown
+    ]
+  },
+  // Track Container
+  trak: {
+    container: 'moov',
+    mandatory: true,
+    quantity: 'one+',
+    box: 'Box',
+    is_container: true
+  },
+  // Track Header Box
+  tkhd: {
+    container: 'trak',
+    mandatory: true,
+    quantity: 'one',
+    box: 'FullBox',
+    is_container: false,
+    // Flag values for the track header:
+    // 0x000001 Track_enabled: track enabled (otherwise ignored)
+    // 0x000002 Track_in_movie: track used in presentation
+    // 0x000004 Track_in_preview: used when previewing presentation
+    config: {
+      flags: 0x000003 // track enabled and used in presentation
+
+    },
+    body: [['creation_time', UInt32BE, 0], ['modification_time', UInt32BE, 0], ['track_ID', UInt32BE, 1], // Track identifier, cannot be 0
+    ['reserved', Empty, 4], ['duration', UInt32BE, 0], // Duration of track using timescale of mvhd box
+    ['reserved2', Empty, 8], ['layer', UInt16BE, 0], // Front-to-back ordering, lower is closer to viewer
+    ['alternate_group', UInt16BE, 0], // Possible grouping of tracks
+    ['volume', UInt16BE, 0x0100], // Track's relative audio volume 8.8 fixed point
+    ['reserved3', Empty, 2], ['matrix', UInt32BEArray, [0x00010000, 0, 0, 0, 0x00010000, 0, 0, 0, 0x40000000]], ['width', UInt32BE, 0], // Visual presentation width, 16.16 fixed point
+    ['height', UInt32BE, 0] // Visual presentation height, 16.16 fixed point
+    ]
+  },
+  // Track Reference Box
+  tref: {
+    container: 'trak',
+    mandatory: false,
+    quantity: 'one-',
+    box: 'Box',
+    is_container: false
+  },
+  // Media Container
+  mdia: {
+    container: 'trak',
+    mandatory: false,
+    quantity: 'one',
+    box: 'Box',
+    is_container: true
+  },
+  // Media Header Box
+  mdhd: {
+    container: 'mdia',
+    mandatory: false,
+    quantity: 'one',
+    box: 'FullBox',
+    is_container: false,
+    body: [['creation_time', UInt32BE, 0], ['modification_time', UInt32BE, 0], ['timescale', UInt32BE, 1000], // time-scale for entire presentation, default = milliseconds
+    ['duration', UInt32BE, 0xffffffff], // length of entire presentation, default = undetermined
+    ['language', UInt16BE, 0], // ISO 639-2 lanugage code, three lower-case letters, stored as
+    ['pre_defined', UInt16BE, 0]]
+  },
+  // Handler Reference Box
+  hdlr: {
+    container: 'mdia',
+    mandatory: true,
+    quantity: 'one',
+    box: 'FullBox',
+    is_container: false,
+    body: [['predefined', UInt32BE, 0], ['handler_type', CharArray, 'vide'], // 'vide', 'soun', or 'hint'
+    ['reserved', Empty, 12], ['name', CharArray, 'VideoHandler\0']]
+  },
+  // Media Information Container
+  minf: {
+    container: 'mdia',
+    mandatory: true,
+    quantity: 'one',
+    box: 'Box',
+    is_container: true
+  },
+  // Video Media Header Box
+  vmhd: {
+    container: 'minf',
+    mandatory: true,
+    quantity: 'one',
+    box: 'FullBox',
+    is_container: false,
+    config: {
+      flags: 0x000001
+    },
+    body: [['graphicsmode', UInt16BE, 0], // Composition mode of the video track, 0 = overwrite
+    ['opcolor', UInt16BEArray, [0, 0, 0]] // Red green blue, for use by graphics modes
+    ]
+  },
+  // Sound Media Header Box
+  smhd: {
+    container: 'minf',
+    mandatory: true,
+    quantity: 'one',
+    box: 'FullBox',
+    is_container: false,
+    body: [// Place mono track in stereo space:
+    //  8.8 fixed point, 0 = center, -1.0 = left, 1.0 = right
+    ['balance', UInt16BE, 0x0000], ['reserved', UInt16BE]]
+  },
+  // Data Information Container
+  dinf: {
+    container: 'minf',
+    mandatory: true,
+    quantity: 'one',
+    box: 'Box',
+    is_container: true
+  },
+  // Data Reference Box
+  dref: {
+    // When adding elements to this box, update the entry_count value!
+    container: 'dinf',
+    mandatory: true,
+    quantity: 'one',
+    box: 'FullBox',
+    is_container: true,
+    body: [['entry_count', UInt32BE, 0] // Number of entries.
+    ]
+  },
+  'url ': {
+    container: 'dref',
+    mandatory: true,
+    quantity: 'one+',
+    box: 'FullBox',
+    is_container: false,
+    // Flag values:
+    // 0x000001 Local reference, which means empty URL
+    config: {
+      flags: 0x000001
+    },
+    body: [// ['location', CharArray, ''],
+    ]
+  },
+  // Sample Table Container
+  stbl: {
+    container: 'minf',
+    mandatory: true,
+    quantity: 'one',
+    box: 'Box',
+    is_container: true
+  },
+  // Decoding Time to Sample Box
+  stts: {
+    container: 'stbl',
+    mandatory: true,
+    quantity: 'one',
+    box: 'FullBox',
+    is_container: false,
+    body: [['entry_count', UInt32BE, 0] // For each entry these two elements:
+    // ['sample_count', UInt32BE, 0], // Number of consecutive samples with same delta
+    // ['sample_delta', UInt32BE, 0], // Delta of each sample
+    ]
+  },
+  stsd: {
+    container: 'stbl',
+    mandatory: true,
+    quantity: 'one',
+    box: 'FullBox',
+    is_container: true,
+    body: [['entry_count', UInt32BE, 1] // For each entry, one of these three boxes depending on the handler:
+    // VisualSampleEntry, AudioSampleEntry, HintSampleEntry
+    ]
+  },
+
+  /*
+  ISO/IEC 14496-12:2005(E) 8.16.2 (pp. 28)
+  aligned(8) abstract class SampleEntry (unsigned int(32) format)
+    extends Box(format){
+    const unsigned int(8)[6] reserved = 0;
+    unsigned int(16) data_reference_index;
+  }
+  class VisualSampleEntry(codingname) extends SampleEntry (codingname){
+    unsigned int(16) pre_defined = 0;
+    const unsigned int(16) reserved = 0;
+    unsigned int(32)[3] pre_defined = 0;
+    unsigned int(16) width;
+    unsigned int(16) height;
+    template unsigned int(32) horizresolution = 0x00480000; // 72 dpi
+    template unsigned int(32) vertresolution = 0x00480000; // 72 dpi
+    const unsigned int(32) reserved = 0;
+    template unsigned int(16) frame_count = 1;
+    string[32] compressorname;
+    template unsigned int(16) depth = 0x0018;
+    int(16) pre_defined = -1;
+  }
+  ISO/IEC 14496-15:2004(E) 5.3.4.1 (pp. 14)
+  class AVCSampleEntry() extends VisualSampleEntry (avc1){
+    AVCConfigurationBox config;
+    MPEG4BitRateBox (); // optional
+    MPEG4ExtensionDescriptorsBox (); // optional
+  }
+  */
+  avc1: {
+    container: 'stsd',
+    mandatory: false,
+    quantity: 'one',
+    box: 'Box',
+    is_container: true,
+    body: [['reserved', Empty, 6], ['data_reference_index', UInt16BE, 1], ['pre_defined', UInt16BE, 0], ['reserved2', Empty, 2], ['pre_defined2', UInt32BEArray, [0, 0, 0]], ['width', UInt16BE, 1920], ['height', UInt16BE, 1080], ['horizresolution', UInt32BE, 0x00480000], ['vertresolution', UInt32BE, 0x00480000], ['reserved3', UInt32BE, 0], ['frame_count', UInt16BE, 1], ['compressorname', UInt8Array, isom_Buffer.alloc(32)], ['depth', UInt16BE, 0x0018], ['pre_defined3', UInt16BE, 0xffff]]
+  },
+
+  /*
+  class AVCConfigurationBox extends Box(avcC) {
+    AVCDecoderConfigurationRecord() AVCConfig;
+  }
+  ISO/IEC 14496-15:2004(E) 5.2.4.1.1 (pp. 12)
+  aligned(8) class AVCDecoderConfigurationRecord {
+    unsigned int(8) configurationVersion = 1;
+    unsigned int(8) AVCProfileIndication;
+    unsigned int(8) profile_compatibility;
+    unsigned int(8) AVCLevelIndication;
+    bit(6) reserved = 111111b;
+    unsigned int(2) lengthSizeMinusOne;
+    bit(3) reserved = 111b;
+    unsigned int(5) numOfSequenceParameterSets;
+    for (i=0; i< numOfSequenceParameterSets; i++) {
+      unsigned int(16) sequenceParameterSetLength ;
+      bit(8*sequenceParameterSetLength) sequenceParameterSetNALUnit;
+    }
+    unsigned int(8) numOfPictureParameterSets;
+    for (i=0; i< numOfPictureParameterSets; i++) {
+      unsigned int(16) pictureParameterSetLength;
+      bit(8*pictureParameterSetLength) pictureParameterSetNALUnit;
+    }
+  }
+  */
+  avcC: {
+    container: 'avc1',
+    mandatory: false,
+    quantity: 'one',
+    box: 'Box',
+    is_container: false,
+    body: [['configurationVersion', UInt8, 1], ['AVCProfileIndication', UInt8, 0x4d], ['profile_compatibility', UInt8, 0x00], ['AVCLevelIndication', UInt8, 0x29], // size = reserved 0b111111 + 0b11 NALUnitLength (0b11 = 4-byte)
+    ['lengthSizeMinusOne', UInt8, 0b11111111], // Example SPS (length 20):
+    //   [0x67, 0x4d, 0x00, 0x29, 0xe2, 0x90, 0x0f, 0x00,
+    //    0x44, 0xfc, 0xb8, 0x0b, 0x70, 0x10, 0x10, 0x1a,
+    //    0x41, 0xe2, 0x44, 0x54]
+    // number of sets = reserved 0b111 + number of SPS (0b00001 = 1)
+    // ['numOfSequenceParameterSets', UInt8, 0b11100001],
+    // ['sequenceParameterSetLength', UInt16BE, 0], // Lenght in bytes of the SPS that follows
+    // ['sequenceParameterSetNALUnit', UInt8Array, []],
+    // These are packed in a single custom element:
+    ['sequenceParameterSets', createParameterSetArrayClass(0xe0), []], // Example PPS (length 4):
+    //   [0x68, 0xee, 0x3c, 0x80]
+    // ['numOfPictureParameterSets', UInt8, 1], // number of PPS
+    // ['pictureParameterSetLength', UInt16BE, 0], // Length in bytes of the PPS that follows
+    // ['pictureParameterSetNALUnit', UInt8Array, []]
+    // These are packed in a single custom element:
+    ['pictureParameterSets', createParameterSetArrayClass(), []]]
+  },
+
+  /*
+  ISO/IEC 14496-12:2005(E) 8.16.2 (pp. 28)
+  aligned(8) abstract class SampleEntry (unsigned int(32) format)
+    extends Box(format){
+    const unsigned int(8)[6] reserved = 0;
+    unsigned int(16) data_reference_index;
+  }
+  class AudioSampleEntry(codingname) extends SampleEntry (codingname){
+    const unsigned int(32)[2] reserved = 0;
+    template unsigned int(16) channelcount = 2;
+    template unsigned int(16) samplesize = 16;
+    unsigned int(16) pre_defined = 0;
+    const unsigned int(16) reserved = 0 ;
+    template unsigned int(32) samplerate = {timescale of media}<<16;
+  }
+  */
+  mp4a: {
+    container: 'stsd',
+    mandatory: false,
+    quantity: 'one',
+    box: 'Box',
+    is_container: true,
+    body: [['reserved', Empty, 6], ['data_reference_index', UInt16BE, 1], ['reserved2', UInt32BEArray, [0, 0]], ['channelcount', UInt16BE, 2], ['samplesize', UInt16BE, 16], ['pre_defined', UInt16BE, 0], ['reserved3', UInt16BE, 0], ['samplerate', UInt32BE, 0] // 16.16 bit floating point
+    ]
+  },
+
+  /* Elementary stream descriptor
+  basic box that holds only an ESDescriptor
+  reference: 'https://developer.apple.com/library/content/documentation/QuickTime/
+  QTFF/QTFFChap3/qtff3.html#//apple_ref/doc/uid/TP40000939-CH205-124774'
+  Descriptors have a tag that identifies them, specified in ISO/IEC 14496-1 8.3.12
+  ISO/IEC 14496-1 8.3.3 (pp. 24) ES_Descriptor
+  aligned(8) class ES_Descriptor : bit(8) tag=ES_DescrTag {
+    bit(8) length;
+    bit(16) ES_ID;
+    bit(1) streamDependenceFlag;
+    bit(1) URL_Flag;
+    const bit(1) reserved=1;
+    bit(5) streamPriority;
+    if (streamDependenceFlag)
+      bit(16) dependsOn_ES_ID;
+    if (URL_Flag)
+      bit(8) URLstring[length-3-(streamDependencFlag*2)];
+    ExtensionDescriptor extDescr[0 .. 255];
+    LanguageDescriptor langDescr[0 .. 1];
+    DecoderConfigDescriptor decConfigDescr;
+    SLConfigDescriptor slConfigDescr;
+    IPI_DescPointer ipiPtr[0 .. 1];
+    IP_IdentificationDataSet ipIDS[0 .. 1];
+    QoS_Descriptor qosDescr[0 .. 1];
+  }
+  aligned(8) class DecoderConfigDescriptor
+    : bit(8) tag=DecoderConfigDescrTag {
+    bit(8) length;
+    bit(8) objectProfileIndication;
+    bit(6) streamType;
+    bit(1) upStream;
+    const bit(1) reserved=1;
+    bit(24) bufferSizeDB;
+    bit(32) maxBitrate;
+    bit(32) avgBitrate;
+    DecoderSpecificInfo decSpecificInfo[];
+  }
+  aligned(8) class DecoderSpecificInfoShort extends DecoderSpecificInfo
+  : bit(8) tag=DecSpecificInfoShortTag
+  {
+    bit(8) length;
+    bit(8) specificInfo[length];
+  }
+  aligned(8) class SLConfigDescriptor : bit(8) tag=SLConfigDescrTag {
+    bit(8) length;
+    bit(8) predefined;
+    if (predefined==0) {
+      bit(1) useAccessUnitStartFlag;
+      bit(1) useAccessUnitEndFlag;
+      bit(1) useRandomAccessPointFlag;
+      bit(1) usePaddingFlag;
+      bit(1) useTimeStampsFlag;
+      bit(1) useWallClockTimeStampFlag;
+      bit(1) useIdleFlag;
+      bit(1) durationFlag;
+      bit(32) timeStampResolution;
+      bit(32) OCRResolution;
+      bit(8) timeStampLength; // must be less than 64
+      bit(8) OCRLength;
+      // must be less than 64
+      bit(8) AU_Length;
+      // must be less than 32
+      bit(8) instantBitrateLength;
+      bit(4) degradationPriorityLength;
+      bit(4) seqNumLength;
+      if (durationFlag) {
+        bit(32) timeScale;
+        bit(16) accessUnitDuration;
+        bit(16) compositionUnitDuration;
+      }
+      if (!useTimeStampsFlag) {
+        if (useWallClockTimeStampFlag)
+          double(64) wallClockTimeStamp;
+        bit(timeStampLength) startDecodingTimeStamp;
+        bit(timeStampLength) startCompositionTimeStamp;
+      }
+    }
+    aligned(8) bit(1) OCRstreamFlag;
+    const bit(7) reserved=0b1111.111;
+    if (OCRstreamFlag)
+      bit(16) OCR_ES_Id;
+  }
+  */
+  esds: {
+    container: 'mp4a',
+    mandatory: false,
+    quantity: 'one',
+    box: 'FullBox',
+    is_container: false,
+    body: [['ES_DescrTag', UInt8, 3], // length of the remainder of this descriptor in byte,
+    // excluding trailing embedded descriptors.
+    ['ES_DescrLength', UInt8, 25], ['ES_ID', UInt16BE, 1], ['flagsAndStreamPriority', UInt8, 0], ['DecoderConfigDescrTag', UInt8, 4], // length of the remainder of this descriptor in bytes,
+    // excluding trailing embedded descriptors.
+    ['DecoderConfigDescrLength', UInt8, 17], ['objectProfileIndication', UInt8, 0x40], ['streamTypeUpstreamReserved', UInt8, 0x15], ['bufferSizeDB', UInt8Array, [0, 0, 0]], ['maxBitRate', UInt32BE, 0], ['avgBitRate', UInt32BE, 0], ['DecSpecificInfoShortTag', UInt8, 5], ['DecSpecificInfoShortLength', UInt8, 2], ['audioConfigBytes', UInt16BE, 0], ['SLConfigDescrTag', UInt8, 6], ['SLConfigDescrLength', UInt8, 1], ['SLConfigDescrPredefined', UInt8, 0x02] // ISO use
+    ]
+  },
+  // Sample Size Box
+  stsz: {
+    container: 'stbl',
+    mandatory: true,
+    quantity: 'one',
+    box: 'FullBox',
+    is_container: false,
+    body: [['sample_size', UInt32BE, 0], ['sample_count', UInt32BE, 0] // For each sample up to sample_count, append an entry_size:
+    // ['entry_size', UInt32BE, ],
+    ]
+  },
+  // Sample To Chunk Box
+  stsc: {
+    container: 'stbl',
+    mandatory: true,
+    quantity: 'one',
+    box: 'FullBox',
+    is_container: false,
+    body: [['entry_count', UInt32BE, 0] // For each entry up to entry_count, append these elements:
+    // ['first_chunk', UInt32BE, ],
+    // ['samples_per_chunk', UInt32BE, ],
+    // ['samples_description_index', UInt32BE, ],
+    ]
+  },
+  // Chunk Offset Box
+  stco: {
+    container: 'stbl',
+    mandatory: true,
+    quantity: 'one',
+    box: 'FullBox',
+    is_container: false,
+    body: [['entry_count', UInt32BE, 0] // For each entry up to entry_count, append an element:
+    // ['chunk_offset', UInt32BE, ],
+    ]
+  },
+  // Sync Sample Box
+  stss: {
+    container: 'stbl',
+    mandatory: false,
+    quantity: 'one-',
+    box: 'FullBox',
+    is_container: false,
+    body: [['entry_count', UInt32BE, 0] // For each entry up to entry_count, append an element:
+    // ['sample_number', UInt32BE, ],
+    ]
+  },
+  // Edit Box
+  edts: {
+    container: 'trak',
+    mandatory: false,
+    quantity: 'one-',
+    box: 'Box',
+    is_container: true
+  },
+  // Edit List Box
+  elst: {
+    container: 'edts',
+    mandatory: false,
+    quantity: 'one-',
+    box: 'FullBox',
+    is_container: false,
+    body: [['entry_count', UInt32BE, 1], ['segment_duration', UInt32BE, 0], ['media_time', UInt32BE, 0xffffffff], ['media_rate_integer', UInt16BE, 1], ['media_rate_fraction', UInt16BE, 0]]
+  },
+  mvex: {
+    container: 'moov',
+    mandatory: false,
+    quantity: 'one-',
+    box: 'Box',
+    is_container: true
+  },
+  mehd: {
+    container: 'mvex',
+    mandatory: false,
+    quantity: 'one-',
+    box: 'FullBox',
+    is_container: false,
+    body: [['fragment_duration', UInt32BE, 0] // Total duration of movie
+    ]
+  },
+  trex: {
+    container: 'mvex',
+    mandatory: true,
+    quantity: 'one+',
+    box: 'FullBox',
+    is_container: false,
+    body: [['track_ID', UInt32BE, 1], // The track to which this data is applicable
+    ['default_sample_description_index', UInt32BE, 1], ['default_sample_duration', UInt32BE, 0], ['default_sample_size', UInt32BE, 0], ['default_sample_flags', UInt32BE, 0]]
+  },
+  moof: {
+    container: 'file',
+    mandatory: false,
+    quantity: 'zero+',
+    box: 'Box',
+    is_container: false
+  },
+  mfhd: {
+    container: 'moof',
+    mandatory: true,
+    quantity: 'one',
+    box: 'FullBox',
+    is_container: false,
+    body: [['sequence_number', UInt32BE, 0] // A number associated with this fragment
+    ]
+  },
+  traf: {
+    container: 'moof',
+    mandatory: false,
+    quantity: 'zero+',
+    box: 'Box',
+    is_container: true
+  },
+  tfhd: {
+    container: 'traf',
+    mandatory: true,
+    quantity: 'one',
+    box: 'FullBox',
+    is_container: false,
+    // Flag values for the track fragment header:
+    // 0x000001 base-data-offset-present
+    // 0x000002 sample-description-index-present
+    // 0x000008 default-sample-duration-present
+    // 0x000010 default-sample-size-present
+    // 0x000020 default-sample-flags-present
+    // 0x010000 duration-is-empty
+    // 0x020000 default-base-is-moof
+    config: {
+      flags: 0x000020 // default sample flags present
+
+    },
+    body: [['track_ID', UInt32BE, 1], // The track to which this data is applicable
+    // ['base_data_offset', UInt64BE, 0],
+    // ['default_sample_description_index', UInt32BE, 0],
+    // ['default_sample_duration', UInt32BE, 0],
+    // ['default_sample_size', UInt32BE, 0],
+    ['default_sample_flags', UInt32BE, 0]]
+  },
+  tfdt: {
+    container: 'traf',
+    mandatory: false,
+    quantity: 'one-',
+    box: 'FullBox',
+    is_container: false,
+    config: {
+      version: 1 // Version 1 uses 64-bit value for baseMediaDecodeTime
+
+    },
+    body: [['baseMediaDecodeTime', UInt64BE, 0]]
+  },
+  trun: {
+    container: 'traf',
+    mandatory: false,
+    quantity: 'zero+',
+    box: 'FullBox',
+    is_container: false,
+    // Flag values for the track fragment header:
+    // 0x000001 data-offset-present
+    // 0x000004 first-sample-flags-present
+    // 0x000100 sample-duration-present
+    // 0x000200 sample-size-present
+    // 0x000400 sample-flags-present
+    // 0x000800 sample-composition-time-offsets-present
+    config: {
+      flags: 0x000305 // default sample flags present
+
+    },
+    body: [['sample_count', UInt32BE, 1], // How many samples there are
+    ['data_offset', UInt32BE, 0], ['first_sample_flags', UInt32BE, 0], ['sample_duration', UInt32BE, 0], ['sample_size', UInt32BE, 0] // ['sample_flags', UInt32BE, 0],
+    // ['sample_composition_time_offset', UInt32BE, 0],
+    ]
+  },
+  // Unknown Box, used for parsing
+  '....': {
+    box: 'Box',
+    is_container: false,
+    body: []
+  },
+  // File Box, special box without any headers
+  file: {
+    box: 'None',
+    is_container: true,
+    mandatory: true,
+    quantity: 'one'
+  }
+};
+/**
+ * Helper functions to generate some standard elements that are needed by
+ * all types of boxes.
+ * All boxes have a length and type, where so-called full boxes have an
+ * additional 4-bytes (1-byte version and 3-byte flags fields).
+ */
+
+class Header {
+  static None() {
+    return [];
+  }
+
+  static Box(type) {
+    return [['size', UInt32BE, 0], ['type', CharArray, type]];
+  }
+
+  static FullBox(type) {
+    return [].concat(this.Box(type), [['version', UInt8, 0x00], ['flags', UInt24BE, 0x000000]]);
+  }
+
+}
+/**
+ * Box class.
+ *
+ * Defines a box as an entity similar to a C struct, where the struct is
+ * represented by a Map of elements.
+ * Each element is an object with at least:
+ *  - a 'byteLength' property (size of element in bytes)
+ *  - a 'copy' method (BufferMutation signature)
+ */
+
+
+class Box extends BoxElement {
+  /**
+   * Create a new Box.
+   * @param  type   4-character ASCII string
+   * @param  config Configuration holding (key: value) fields
+   */
+  constructor(type, config) {
+    super(0);
+
+    isom_defineProperty(this, "type", void 0);
+
+    isom_defineProperty(this, "config", void 0);
+
+    isom_defineProperty(this, "struct", void 0);
+
+    this.type = type;
+    const spec = BOXSPEC[this.type];
+
+    if (spec === undefined) {
+      throw new Error(`unknown box type: ${type}`);
+    }
+
+    this.config = Object.assign({}, spec.config, config);
+    const header = Header[spec.box](this.type);
+    const body = spec.body || []; // Uglify changes the name of the original class, so this doesn't work.
+    // TODO: find a better way to check for this.
+    // if (spec.body === undefined && this.constructor.name !== 'Container') {
+    //   throw new Error(`Body missing but '${type}' is not a container box`);
+    // }
+    // Initialize all elements, an element is something with a byteLength
+
+    this.struct = new Map();
+    let offset = 0;
+
+    for (const [key, Type, defaultValue] of [].concat(header, body)) {
+      if (this.has(key)) {
+        throw new Error('Trying to add existing key');
+      }
+
+      let value = defaultValue;
+
+      if (this.config[key]) {
+        value = this.config[key];
+      }
+
+      const element = new Type(value);
+      this.struct.set(key, {
+        offset,
+        element
+      });
+      offset += element.byteLength;
+    }
+
+    this.byteLength = offset;
+  }
+  /**
+   * Get access to an element based on it's name.
+   * @param  key The element's name
+   * @return Object with 'byteLength' property and 'copy' method
+   */
+
+
+  element(key) {
+    const value = this.struct.get(key);
+
+    if (value === undefined) {
+      throw new Error('invalid key');
+    }
+
+    return value.element;
+  }
+  /**
+   * Set an element's value.
+   * @param  key The element's name
+   * @param  value The element's (new) value
+   */
+
+
+  set(key, value) {
+    this.element(key).value = value;
+  }
+  /**
+   * Get an element's value.
+   * @param  key The element's name
+   * @return The element's value
+   */
+
+
+  get(key) {
+    return this.element(key).value;
+  }
+  /**
+   * Get an element's offset.
+   * @param  key The element's name
+   * @return The element's offset
+   */
+
+
+  offset(key) {
+    const value = this.struct.get(key);
+
+    if (value === undefined) {
+      throw new Error('invalid key');
+    }
+
+    return value.offset;
+  }
+  /**
+   * Check if a certain element exists
+   * @param  key The element's name
+   * @return true if the element is known, false if not
+   */
+
+
+  has(key) {
+    return this.struct.has(key);
+  }
+  /**
+   * Add a new element to the box.
+   * @param key     A _new_ non-existing element name.
+   * @param element Something with a 'byteLength' property and 'copy' method.
+   * @return this box, so that 'add' can be used in a chain
+   */
+
+
+  add(key, element) {
+    if (this.has(key)) {
+      throw new Error('Trying to add existing key');
+    }
+
+    this.struct.set(key, {
+      offset: this.byteLength,
+      element
+    });
+    this.byteLength += element.byteLength;
+    return this;
+  }
+  /**
+   * Create a buffer and copy all element values to it.
+   * @return Data representing the box.
+   */
+
+
+  buffer() {
+    const buffer = isom_Buffer.allocUnsafe(this.byteLength);
+    this.copy(buffer);
+    return buffer;
+  }
+  /**
+   * Copy all values of the box into an existing buffer.
+   * @param  buffer     The target buffer to accept the box data
+   * @param  [offset=0] The number of bytes into the target to start at.
+   */
+
+
+  copy(buffer, offset = 0) {
+    // Before writing, make sure the size property is set correctly.
+    this.set('size', this.byteLength);
+
+    for (const entry of this.struct.values()) {
+      entry.element.copy(buffer, offset + entry.offset);
+    }
+  }
+  /**
+   * Read element values from a box's data representation.
+   * @param  buffer     The source buffer with box data
+   * @param  [offset=0] The number of bytes into the source to start at.
+   */
+
+
+  load(buffer, offset = 0) {
+    for (const entry of this.struct.values()) {
+      if (entry.element.load !== undefined) {
+        entry.element.load(buffer, offset + entry.offset);
+      }
+    }
+  }
+  /**
+   * Pretty-format an entire box as an element/box hierarchy.
+   * @param  [indent=0] How large an indentation to use for the hierarchy
+   */
+
+
+  format(indent = 0) {
+    const lines = [' '.repeat(indent) + `[${this.type}] (${this.byteLength})`];
+
+    for (const [key, entry] of this.struct) {
+      const element = entry.element;
+
+      if (element.format !== undefined) {
+        lines.push(element.format(indent + 2));
+      } else {
+        lines.push(' '.repeat(indent + 2) + `${key} = ${element.value} (${element.byteLength})`);
+      }
+    }
+
+    return lines.join('\n');
+  }
+  /**
+   * Pretty-print an entire box as an element/box hierarchy.
+   * @param  [indent=0] How large an indentation to use for the hierarchy
+   */
+
+
+  print(indent) {
+    console.warn(this.format(indent));
+  }
+
+}
+/**
+ * Container class
+ *
+ * special box with an 'add' method which allows appending of other boxes,
+ * and a 'parse' method to extract contained boxes.
+ */
+
+class Container extends Box {
+  /**
+   * Create a new container box
+   * @param  type   4-character ASCII string
+   * @param  config Configuration holding (key: value) fields
+   * @param  boxes  One or more boxes to append.
+   */
+  constructor(type, config, ...boxes) {
+    super(type, config);
+
+    isom_defineProperty(this, "boxSize", void 0);
+
+    this.boxSize = 0;
+    this.append(...boxes);
+  }
+  /**
+   * Add one or more boxes to the container.
+   * @param boxes The box(es) to append
+   * @return this container, so that add can be used in a chain
+   */
+
+
+  append(...boxes) {
+    for (const box of boxes) {
+      this.add(`box_${this.boxSize++}`, box);
+    }
+
+    return this;
+  }
+  /**
+   * Parse a container box by looking for boxes that it contains, and
+   * recursively proceed when it is another container.
+   *
+   * FIXME: this cannot properly handle different versions of the FullBox,
+   * currenlty the loader is hardcoded to the version used in this file.
+   * Also, appearance of an esds box is assumed to be AAC audio information,
+   * while the avcC box signals H.264 video information.
+   *
+   * @param  data The data to parse.
+   */
+
+
+  parse(data) {
+    const tracks = [];
+
+    while (data.byteLength > 0) {
+      const type = new CharArray('....');
+      type.load(data, 4);
+      const boxType = type.value;
+      const spec = BOXSPEC[boxType];
+      let box;
+
+      if (spec !== undefined) {
+        if (spec.is_container) {
+          box = new Container(boxType);
+          box.load(data);
+          const boxTracks = box.parse(data.slice(box.byteLength, box.get('size')));
+          tracks.push(...boxTracks);
+        } else {
+          box = new Box(boxType);
+          box.load(data); // Handle 2 kinds of tracks with streaming MP4: video or audio
+
+          if (boxType === 'avcC') {
+            const profile = box.element('AVCProfileIndication').value.toString(16).padStart(2, 0);
+            const compat = box.element('profile_compatibility').value.toString(16).padStart(2, 0);
+            const level = box.element('AVCLevelIndication').value.toString(16).padStart(2, 0);
+            tracks.push({
+              type: 'video',
+              mime: `avc1.${profile}${compat}${level}`
+            });
+          } else if (boxType === 'esds') {
+            const audioConfigBytes = box.element('audioConfigBytes').value;
+            const objectTypeIndication = audioConfigBytes >>> 11 & 0x001f;
+            tracks.push({
+              type: 'audio',
+              mime: `mp4a.40.${objectTypeIndication}`
+            });
+          }
+        }
+      } else {
+        box = new Box('....');
+        box.load(data);
+        box.type = box.get('type');
+      }
+
+      this.append(box);
+      data = data.slice(box.get('size'));
+    }
+
+    return tracks;
+  }
+
+}
+;// CONCATENATED MODULE: ./lib/components/mp4muxer/helpers/aacSettings.ts
+ // All audio object types defined in ISO/IEC 14496-3 pp. 40
+
+const AUDIO_OBJECT_TYPE_NAMES = {
+  1: 'AAC Main',
+  2: 'AAC LC'
+}; // All frequencies defined in ISO/IEC 14496-3 pp. 42
+
+const FREQUENCY_VALUES = {
+  0: '96 kHz',
+  1: '88.2 kHz',
+  2: '64 kHz',
+  3: '48 kHz',
+  4: '44.1 kHz',
+  5: '32 kHz',
+  6: '24 kHz',
+  7: '22.05 kHz',
+  8: '16 kHz',
+  9: '12 kHz',
+  10: '11.025 kHz',
+  11: '8 kHz',
+  12: '7.35 kHz'
+}; // All channels defined in ISO/IEC 14496-3 pp. 42
+
+const CHANNEL_CONFIG_NAMES = {
+  1: 'Mono',
+  2: 'Stereo'
+};
+
+const aacEncodingName = audioConfigBytes => {
+  const audioObjectType = audioConfigBytes >>> 11 & 0x001f;
+  const frequencyIndex = audioConfigBytes >>> 7 & 0x000f;
+  const channelConfig = audioConfigBytes >>> 3 & 0x000f;
+  const audioType = AUDIO_OBJECT_TYPE_NAMES[audioObjectType] || `AAC (${audioObjectType})`;
+  const samplingRate = FREQUENCY_VALUES[frequencyIndex] || 'unknown';
+  const channels = CHANNEL_CONFIG_NAMES[channelConfig] || channelConfig.toString();
+  return {
+    coding: audioType,
+    samplingRate,
+    channels
+  };
+};
+
+const aacSettings = (media, date, trackId) => {
+  /*
+   * Example SDP media segment for MPEG4-GENERIC audio:
+   *
+   {
+     "type": "audio",
+     "port": "0",
+     "proto": "RTP/AVP",
+     "fmt": "97",
+     "connectionData": {
+       "netType": "IN",
+       "addrType": "IP4",
+       "connectionAddress": "0.0.0.0"
+     },
+     "bwtype": "AS",
+     "bandwidth": "32",
+     "rtpmap": {
+       "payloadType": "97",
+       "encodingName": "MPEG4-GENERIC",
+       "clockrate": "16000",
+       "encodingParameters": "1"
+     },
+     "fmtp": {
+       "format": "97",
+       "parameters": {
+         "streamtype": "5",
+         "profile-level-id": "2",
+         "mode": "AAC-hbr",
+         "config": "1408",
+         "sizelength": "13",
+         "indexlength": "3",
+         "indexdeltalength": "3",
+         "bitrate": "32000"
+       }
+     },
+     "control": "rtsp://hostname/axis-media/media.amp/stream=1?audio=1"
+   }
+    */
+  const bitrate = Number(media.fmtp.parameters.bitrate) || 320000; // sometimes AAC fmtp.parameters.config much more that expected UInt16
+
+  /*
+              {
+                "bandwidth": "128",
+                "bwtype": "AS",
+                "control": "trackID=1",
+                "fmt": 97,
+                "fmtp": {
+                    "format": "97",
+                    "parameters": {
+                        "config": "121056E500",
+                        "indexdeltalength": "3",
+                        "indexlength": "3",
+                        "mode": "AAC-hbr",
+                        "profile-level-id": "1",
+                        "sizelength": "13"
+                    }
+                },
+                "port": 0,
+                "protocol": "RTP/AVP",
+                "rtpmap": {
+                    "clockrate": 44100,
+                    "encodingName": "MPEG4-GENERIC",
+                    "encodingParameters": "2",
+                    "payloadType": 97
+                },
+                "type": "audio"
+            }
+  */
+  // const audioConfigBytes = parseInt(media.fmtp.parameters.config, 16);
+
+  const audioConfigBytes = parseInt(media.fmtp.parameters.config.substr(0, 4), 16);
+  const audioObjectType = audioConfigBytes >>> 11 & 0x001f;
+  return {
+    tkhd: {
+      track_ID: trackId,
+      creation_time: date,
+      modification_time: date,
+      width: 0,
+      height: 0,
+      volume: 1
+    },
+    mdhd: {
+      timescale: Number(media.rtpmap.clockrate),
+      creation_time: date,
+      modification_time: date,
+      duration: 0
+    },
+    hdlr: {
+      handler_type: 'soun',
+      name: 'SoundHandler\0' // 00 soundhandler, add 00 if things screws up
+
+    },
+    mediaHeaderBox: new Box('smhd'),
+    sampleEntryBox: new Container('mp4a', {
+      samplerate: media.rtpmap.clockrate << 16 >>> 0 // FIXME: Is this  correct?
+
+    }, new Box('esds', {
+      audioConfigBytes: audioConfigBytes,
+      // Converting from hex string to int
+      maxBitRate: bitrate,
+      avgBitRate: bitrate
+    })),
+
+    /*
+    https://wiki.multimedia.cx/index.php/Understanding_AAC
+    AAC is a variable bitrate (VBR) block-based codec where each block decodes
+    to 1024 time-domain samples, which means that a single block (or frame?) is
+    1024 ticks long, which we take as default here.
+    */
+    defaultFrameDuration: 1024,
+    // MIME type
+    mime: `mp4a.40.${audioObjectType}`,
+    codec: aacEncodingName(audioConfigBytes)
+  };
+};
+;// CONCATENATED MODULE: ./lib/components/mp4muxer/helpers/utils.ts
+function b64ToUint6(nChr) {
+  return nChr > 64 && nChr < 91 ? nChr - 65 : nChr > 96 && nChr < 123 ? nChr - 71 : nChr > 47 && nChr < 58 ? nChr + 4 : nChr === 43 ? 62 : nChr === 47 ? 63 : 0;
+} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Base64_encoding_and_decoding
+
+function base64DecToArr(sBase64, nBlocksSize) {
+  const sB64Enc = sBase64.replace(/[^A-Za-z0-9+/]/g, '');
+  const nInLen = sB64Enc.length;
+  const nOutLen = nBlocksSize ? Math.ceil((nInLen * 3 + 1 >> 2) / nBlocksSize) * nBlocksSize : nInLen * 3 + 1 >> 2;
+  const taBytes = new Uint8Array(nOutLen);
+  let nMod3;
+  let nMod4;
+  let nUint24 = 0;
+  let nOutIdx = 0;
+
+  for (let nInIdx = 0; nInIdx < nInLen; nInIdx++) {
+    nMod4 = nInIdx & 3;
+    nUint24 |= b64ToUint6(sB64Enc.charCodeAt(nInIdx)) << 18 - 6 * nMod4;
+
+    if (nMod4 === 3 || nInLen - nInIdx === 1) {
+      for (nMod3 = 0; nMod3 < 3 && nOutIdx < nOutLen; nMod3++, nOutIdx++) {
+        taBytes[nOutIdx] = nUint24 >>> (16 >>> nMod3 & 24) & 255;
+      }
+
+      nUint24 = 0;
+    }
+  }
+
+  return taBytes;
+}
+;// CONCATENATED MODULE: ./lib/components/mp4muxer/helpers/bufferreader.ts
+function bufferreader_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+/**
+ * Defines functions for reading from a binary buffer. Works similair to the
+ * DataView object, but uses bitshifts instead for performance.
+ * @class BufferReader
+ * @constructor
+ * @param buffer - An ArrayBuffer to be read from.
+ */
+class BufferReader {
+  constructor(buffer) {
+    bufferreader_defineProperty(this, "_buffer", void 0);
+
+    bufferreader_defineProperty(this, "_dataView", void 0);
+
+    bufferreader_defineProperty(this, "_offset", void 0);
+
+    bufferreader_defineProperty(this, "_bitpos", void 0);
+
+    bufferreader_defineProperty(this, "_byte", void 0);
+
+    this._buffer = buffer;
+    this._dataView = new DataView(this._buffer);
+    this._offset = 0;
+    this._bitpos = 0;
+    this._byte = 0;
+  }
+  /**
+   * Reads 8-bit of data from the buffer.
+   * @method readUint8
+   * @param  offset - Index in the buffer.
+   * @return An unsigned 8-bit integer.
+   */
+
+
+  readUint8(offset) {
+    return this._dataView.getUint8(offset);
+  }
+  /**
+   * Reads 16-bit of data from the buffer.
+   * @method readUint16
+   * @param  offset - Index in the buffer.
+   * @return An unsigned 16-bit integer.
+   */
+
+
+  readUint16(offset) {
+    return this._dataView.getUint16(offset);
+  }
+  /**
+   * Reads 32-bit of data from the buffer.
+   * @method readUint32
+   * @param  offset - Index in the buffer.
+   * @return An unsigned 32-bit integer.
+   */
+
+
+  readUint32(offset) {
+    return this._dataView.getUint32(offset);
+  }
+  /**
+   * Reads the next byte of data from the buffer and increaments the offset.
+   * @method readNext
+   * @return {Number} An unsigned 8-bit integer.
+   */
+
+
+  readNext() {
+    const value = this.readUint8(this._offset);
+    this._offset += 1;
+    return value;
+  }
+
+  readBits(length) {
+    if (length > 32 || length === 0) {
+      throw new Error('length has to be between 0 - 31 bits');
+    }
+
+    let result = 0;
+
+    for (let i = 1; i <= length; ++i) {
+      if (this._bitpos === 0) {
+        /* Previous byte all read out. Get a new one. */
+        this._byte = this.readNext();
+      }
+      /* Shift result one left to make room for another bit,
+      then add the next bit on the stream. */
+
+
+      result = result << 1 | this._byte >> 8 - ++this._bitpos & 0x01;
+      this._bitpos %= 8;
+    }
+
+    return result;
+  }
+
+  readUnsignedExpGolomb() {
+    let bitsToRead = 0;
+
+    while (this.readBits(1) !== 1) {
+      bitsToRead++;
+    }
+
+    if (bitsToRead === 0) {
+      return 0;
+      /* Easy peasy, just a single 1. This is 0 in exp golomb */
+    }
+
+    if (bitsToRead >= 31) {
+      throw new Error('read unsigned exponential Golomb: internal error');
+    }
+    /* Read all bits part of this number */
+
+
+    let n = this.readBits(bitsToRead);
+    /* Move in the 1 read by while-statement above */
+
+    n |= 0x1 << bitsToRead;
+    return n - 1;
+    /* Because result in exp golomb is one larger */
+  }
+
+  readSignedExpGolomb() {
+    let r = this.readUnsignedExpGolomb();
+
+    if (r & 0x01) {
+      r = r + 1 >> 1;
+    } else {
+      r = -(r >> 1);
+    }
+
+    return r;
+  }
+  /**
+   * Returns the size of the buffer
+   * @method readSize
+   * @return {Number} The buffer size.
+   */
+
+
+  size() {
+    return this._buffer.byteLength;
+  }
+  /**
+   * Returns an instance of the buffer as an unsigned 8-bit integer array.
+   * @method getUint8Array
+   * @return {Uint8Array} Unsigned 8-bit integer representation of the buffer
+   */
+
+
+  getUint8Array() {
+    return new Uint8Array(this._buffer);
+  }
+  /**
+   * Returns the buffer object
+   * @method getArrayBuffer
+   * @return {ArrayBuffer} The buffer used the BufferReader
+   */
+
+
+  getArrayBuffer() {
+    return this._buffer;
+  }
+
+}
+;// CONCATENATED MODULE: ./lib/components/mp4muxer/helpers/spsparser.ts
+function spsparser_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+
+class SPSParser {
+  constructor(buffer) {
+    spsparser_defineProperty(this, "reader", void 0);
+
+    this.reader = new BufferReader(buffer);
+  }
+
+  parse() {
+    // nalhdr
+    this.reader.readNext();
+    const profile = this.reader.readNext(); // constraints
+
+    this.reader.readNext();
+    const level = this.reader.readNext(); // seqParameterSetId
+
+    this.reader.readUnsignedExpGolomb();
+
+    if ([100, 110, 122, 244, 44, 83, 86, 118].includes(profile)) {
+      const chromaFormat = this.reader.readUnsignedExpGolomb();
+
+      if (chromaFormat === 3) {
+        // Separate color plane flag
+        this.reader.readBits(1);
+      } // bitDepthLumaMinus8
+
+
+      this.reader.readUnsignedExpGolomb(); // bitDepthChromaMinus8
+
+      this.reader.readUnsignedExpGolomb(); // qpPrimeYZeroTransformBypassFlag
+
+      this.reader.readBits(1);
+      const seqScalingMatrix = this.reader.readBits(1);
+
+      if (seqScalingMatrix) {
+        for (let k = 0; k < (chromaFormat !== 3 ? 8 : 12); k++) {
+          // seqScalingListPresentFlag
+          this.reader.readBits(1); // TODO: More logic goes here..
+        }
+      }
+    } // log2MaxFrameNumMinus4
+
+
+    this.reader.readUnsignedExpGolomb();
+    const picOrderCntType = this.reader.readUnsignedExpGolomb();
+
+    if (picOrderCntType === 0) {
+      // log2MaxPicOrderCntLsbMinus4
+      this.reader.readUnsignedExpGolomb();
+    } else if (picOrderCntType === 1) {
+      let numRefFramesInPic = 0;
+      this.reader.readBits(1);
+      this.reader.readSignedExpGolomb();
+      this.reader.readSignedExpGolomb();
+      numRefFramesInPic = this.reader.readUnsignedExpGolomb();
+
+      for (let i = 0; i < numRefFramesInPic; i++) {
+        this.reader.readSignedExpGolomb();
+      }
+    } // maxNumRefFrames
+
+
+    this.reader.readUnsignedExpGolomb(); // gapsInFrameNumValueAllowedFlag
+
+    this.reader.readBits(1);
+    const picWidthInMbsMinus1 = this.reader.readUnsignedExpGolomb();
+    const picHeightInMapUnitsMinus1 = this.reader.readUnsignedExpGolomb();
+    const picFrameMbsOnlyFlag = this.reader.readBits(1); // direct8x8InferenceFlag
+
+    this.reader.readBits(1);
+    const frameCroppingFlag = this.reader.readBits(1);
+    const frameCropLeftOffset = frameCroppingFlag ? this.reader.readUnsignedExpGolomb() : 0;
+    const frameCropRightOffset = frameCroppingFlag ? this.reader.readUnsignedExpGolomb() : 0;
+    const frameCropTopOffset = frameCroppingFlag ? this.reader.readUnsignedExpGolomb() : 0;
+    const frameCropBottomOffset = frameCroppingFlag ? this.reader.readUnsignedExpGolomb() : 0;
+    const w = (picWidthInMbsMinus1 + 1) * 16 - frameCropLeftOffset * 2 - frameCropRightOffset * 2;
+    const h = (2 - picFrameMbsOnlyFlag) * (picHeightInMapUnitsMinus1 + 1) * 16 - frameCropTopOffset * 2 - frameCropBottomOffset * 2;
+    return {
+      profile: profile,
+      level: level / 10.0,
+      width: w,
+      height: h
+    };
+  }
+
+}
+;// CONCATENATED MODULE: ./lib/components/mp4muxer/helpers/h264Settings.ts
+
+
+
+const PROFILE_NAMES = {
+  66: 'Baseline',
+  77: 'Main',
+  100: 'High'
+};
+
+const h264EncodingName = profileLevelId => {
+  const profileCode = parseInt(profileLevelId.substr(0, 2), 16);
+  const levelCode = parseInt(profileLevelId.substr(4, 2), 16);
+  const profile = PROFILE_NAMES[profileCode] || profileCode.toString();
+  const level = (levelCode / 10).toFixed(1);
+  return {
+    coding: 'H.264',
+    profile,
+    level
+  };
+};
+
+const h264Settings = (media, date, trackId) => {
+  /*
+   * Example SDP media segment for H264 audio:
+   *
+    {
+     "type": "video",
+     "port": "0",
+     "proto": "RTP/AVP",
+     "fmt": "96",
+     "connectionData": {
+       "netType": "IN",
+       "addrType": "IP4",
+       "connectionAddress": "0.0.0.0"
+     },
+     "bwtype": "AS",
+     "bandwidth": "50000",
+     "rtpmap": {
+       "payloadType": "96",
+       "encodingName": "H264",
+       "clockrate": "90000"
+     },
+     "fmtp": {
+       "format": "96",
+       "parameters": {
+         "packetization-mode": "1",
+         "profile-level-id": "4d0029",
+         "sprop-parameter-sets": "Z00AKeKQDwBE/LgLcBAQGkHiRFQ=,aO48gA=="
+       }
+     },
+     "control": "rtsp://hostname/axis-media/media.amp/stream=0?audio=1",
+     "framerate": "25.000000",
+     "transform": [[1,0,0],[0,1,0],[0,0,1]]
+   },
+    */
+  const profileLevelId = media.fmtp.parameters['profile-level-id'];
+  const parameterSets = media.fmtp.parameters['sprop-parameter-sets'].split(',').map(base64DecToArr); // We assume the first set is _the_ SPS (no support for multiple).
+
+  const sps = parameterSets.slice(0, 1); // The remaining sets are all PPS to support more than one.
+
+  const pps = parameterSets.slice(1);
+  const parsedSps = new SPSParser(sps[0].buffer).parse(); // If media framerate is missing in SDP, it is not possible to calculate
+  // the frame duration. Use a fallback value (90000 Hz / 25 fps)
+
+  const FALLBACK_FRAME_DURATION = 3600;
+  return {
+    mediaHeaderBox: new Box('vmhd'),
+    sampleEntryBox: new Container('avc1', {
+      width: parsedSps.width,
+      height: parsedSps.height
+    }, new Box('avcC', {
+      AVCProfileIndication: sps[0][1],
+      profile_compatibility: sps[0][2],
+      AVCLevelIndication: sps[0][3],
+      sequenceParameterSets: sps,
+      pictureParameterSets: pps
+    })),
+    tkhd: {
+      track_ID: trackId,
+      creation_time: date,
+      modification_time: date,
+      width: parsedSps.width << 16,
+      height: parsedSps.height << 16,
+      volume: 0
+    },
+    hdlr: {},
+    mdhd: {
+      timescale: media.rtpmap.clockrate,
+      creation_time: date,
+      modification_time: date,
+      duration: 0
+    },
+    // (ticks / s) / (frames / s) = ticks / frame, e.g. frame duration in ticks
+    defaultFrameDuration: media.framerate !== undefined && media.framerate > 0 ? Number(media.rtpmap.clockrate) / Number(media.framerate) || FALLBACK_FRAME_DURATION : FALLBACK_FRAME_DURATION,
+    // MIME type
+    mime: `avc1.${profileLevelId}`,
+    codec: h264EncodingName(profileLevelId)
+  };
+};
+;// CONCATENATED MODULE: ./lib/components/mp4muxer/helpers/boxbuilder.ts
+function boxbuilder_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+
+
+
+const formatDefaults = {
+  'MPEG4-GENERIC': aacSettings,
+  H264: h264Settings
+};
+
+const createTrackData = () => {
+  return {
+    lastTimestamp: 0,
+    baseMediaDecodeTime: 0,
+    defaultFrameDuration: 0,
+    clockrate: 0,
+    bitrate: 0,
+    framerate: 0,
+    cumulativeByteLength: 0,
+    cumulativeDuration: 0,
+    cumulativeFrames: 0
+  };
+};
+
+const updateRateInfo = (trackData, {
+  byteLength,
+  duration
+}) => {
+  trackData.cumulativeByteLength += byteLength;
+  trackData.cumulativeDuration += duration;
+  trackData.cumulativeFrames++; // Update the cumulative number size (bytes) and duration (ticks), and if
+  // the duration exceeds the clockrate (meaning longer than 1 second of data),
+  // then compute a new bitrate and reset cumulative size and duration.
+
+  if (trackData.cumulativeDuration >= trackData.clockrate) {
+    const bits = 8 * trackData.cumulativeByteLength;
+    const frames = trackData.cumulativeFrames;
+    const seconds = trackData.cumulativeDuration / trackData.clockrate;
+    trackData.bitrate = bits / seconds;
+    trackData.framerate = frames / seconds;
+    trackData.cumulativeByteLength = 0;
+    trackData.cumulativeDuration = 0;
+    trackData.cumulativeFrames = 0;
+  }
+};
+/**
+ * Create boxes for a stream initiated by an sdp object
+ *
+ * @class BoxBuilder
+ */
+
+
+class BoxBuilder {
+  constructor() {
+    boxbuilder_defineProperty(this, "trackIdMap", void 0);
+
+    boxbuilder_defineProperty(this, "sequenceNumber", void 0);
+
+    boxbuilder_defineProperty(this, "ntpPresentationTime", void 0);
+
+    boxbuilder_defineProperty(this, "trackData", void 0);
+
+    boxbuilder_defineProperty(this, "videoTrackId", void 0);
+
+    this.trackIdMap = {};
+    this.sequenceNumber = 0;
+    this.ntpPresentationTime = 0;
+    this.trackData = [];
+  }
+
+  trak(settings) {
+    const trak = new Container('trak');
+    const mdia = new Container('mdia');
+    const minf = new Container('minf');
+    const dinf = new Container('dinf');
+    const dref = new Container('dref');
+    const stbl = new Container('stbl');
+    dref.set('entry_count', 1);
+    trak.append(new Box('tkhd', settings.tkhd), mdia.append(new Box('mdhd', settings.mdhd), new Box('hdlr', settings.hdlr), minf.append(settings.mediaHeaderBox, // vmhd or smhd box (video or sound)
+    dinf.append(dref.append(new Box('url '))), stbl.append(new Container('stsd', undefined, settings.sampleEntryBox), new Box('stts'), new Box('stsc'), new Box('stco'), new Box('stsz'), new Box('stss')))));
+    return trak;
+  }
+  /**
+   * Creates a Moov box from the provided options.
+   * @method moov
+   * @param  sdp - The session description protocol
+   * @param  date - The creation/modification time of the movie
+   * @return Moov object
+   */
+
+
+  moov(sdp, date) {
+    const moov = new Container('moov');
+    moov.append(new Box('mvhd', {
+      creation_time: date,
+      modification_time: date,
+      duration: 0
+    }));
+    const mvex = new Container('mvex'); // For each of the media segments in the SDP structure, we will set up
+    // a track in the MP4 file. For each track, a 'trak' box is added to the
+    // 'moov' box and a 'trex' box is added to the 'mvex' box.
+
+    this.trackIdMap = {};
+    this.sequenceNumber = 0;
+    this.ntpPresentationTime = 0;
+    let trackId = 0;
+    this.trackData = [];
+    sdp.media.forEach(media => {
+      if (media.rtpmap === undefined) {
+        return;
+      }
+
+      const payloadType = media.rtpmap.payloadType;
+      const encoding = media.rtpmap.encodingName;
+      console.log(`encoding ${encoding}, payloadType: ${payloadType}, format: ${formatDefaults[encoding]}`);
+
+      if (formatDefaults[encoding] !== undefined) {
+        // We know how to handle this encoding, add a new track for it, and
+        // register the track for this payloadType.
+        this.trackIdMap[payloadType] = ++trackId; // Mark the video track
+
+        if (media.type.toLowerCase() === 'video') {
+          this.videoTrackId = trackId;
+        } // Extract the settings from the SDP media information based on
+        // the encoding name (H264, MPEG4-GENERIC, ...).
+
+
+        const settings = formatDefaults[encoding](media, date, trackId);
+        media.mime = settings.mime; // add MIME type to the SDP media
+
+        media.codec = settings.codec; // add human readable codec string to the SDP media
+
+        const trackData = createTrackData();
+        trackData.clockrate = media.rtpmap.clockrate; // Set default frame duration (in ticks) for later use
+
+        trackData.defaultFrameDuration = settings.defaultFrameDuration;
+        this.trackData.push(trackData);
+        const trak = this.trak(settings);
+        moov.append(trak);
+        mvex.append(new Box('trex', {
+          track_ID: trackId
+        }));
+      }
+    });
+    moov.append(mvex);
+    return moov;
+  }
+  /**
+   * Boxes that carry actual elementary stream fragment metadata + data.
+   */
+
+  /**
+   * Creates a moof box from the provided fragment metadata.
+   * @method moof
+   * @param  metadata - Track ID, timestamp, bytelength
+   * @return moof Container
+   */
+
+
+  moof(metadata) {
+    const {
+      trackId,
+      timestamp,
+      byteLength
+    } = metadata;
+    const trackOffset = trackId - 1;
+    const trackData = this.trackData[trackOffset]; // The RTP timestamps are unsigned 32 bit and will overflow
+    // at some point. We can guard against the overflow by ORing with 0,
+    // which will bring any difference back into signed 32-bit domain.
+
+    const _duration = trackData.lastTimestamp !== 0 ? timestamp - trackData.lastTimestamp | 0 : trackData.defaultFrameDuration; // if (_duration < 0) {
+    //   console.log(`MOOF duration ${_duration}, ts: ${trackData.lastTimestamp} -> ${timestamp}, default: ${trackData.defaultFrameDuration}`);
+    // }
+
+
+    const duration = _duration > 0 ? _duration : trackData.defaultFrameDuration;
+    trackData.lastTimestamp = _duration > 0 ? timestamp : trackData.lastTimestamp + duration;
+    const moof = new Container('moof');
+    const traf = new Container('traf');
+    const trun = new Box('trun', {
+      sample_duration: duration,
+      sample_size: byteLength,
+      first_sample_flags: 0x40
+    });
+    moof.append(new Box('mfhd', {
+      sequence_number: this.sequenceNumber++
+    }), traf.append(new Box('tfhd', {
+      track_ID: trackId
+    }), new Box('tfdt', {
+      baseMediaDecodeTime: trackData.baseMediaDecodeTime
+    }), trun));
+    trackData.baseMediaDecodeTime += duration; // Correct the trun data offset
+
+    trun.set('data_offset', moof.byteLength + 8);
+    updateRateInfo(trackData, {
+      byteLength,
+      duration
+    });
+    return moof;
+  }
+  /**
+   * Creates an mdat box containing the elementary stream data.
+   * @param  data - Elementary stream data
+   * @return mdat Box
+   */
+
+
+  mdat(data) {
+    const box = new Box('mdat');
+    box.add('data', data);
+    return box;
+  }
+
+  setPresentationTime(trackId, ntpTimestamp) {
+    // Before updating the baseMediaDecodeTime, we check if
+    // there is already a base NTP time to use as a reference
+    // for computing presentation times.
+    if (!this.ntpPresentationTime && ntpTimestamp && trackId === this.videoTrackId) {
+      const trackOffset = trackId - 1;
+      const trackData = this.trackData[trackOffset];
+      this.ntpPresentationTime = ntpTimestamp - 1000 * (trackData.baseMediaDecodeTime / trackData.clockrate);
+    }
+  }
+
+}
+;// CONCATENATED MODULE: ./lib/components/mp4muxer/index.ts
+/* provided dependency */ var mp4muxer_Buffer = __webpack_require__(7866)["Buffer"];
+function mp4muxer_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+
+
+
+
+
+
+
+/**
+ * Component that converts elementary stream data into MP4 boxes honouring
+ * the ISO BMFF Byte Stream (Some extra restrictions are involved).
+ */
+
+class Mp4Muxer extends Tube {
+  /**
+   * Create a new mp4muxer component.
+   * @return {undefined}
+   */
+  constructor() {
+    const boxBuilder = new BoxBuilder();
+
+    const onSync = ntpPresentationTime => {
+      this.onSync && this.onSync(ntpPresentationTime);
+    };
+
+    const incoming = new stream_browserify.Transform({
+      objectMode: true,
+      transform: function (msg, encoding, callback) {
+        if (msg.type === MessageType.SDP) {
+          /**
+           * Arrival of SDP signals the beginning of a new movie.
+           * Set up the ftyp and moov boxes.
+           */
+          // Why is this here? These should be default inside the mvhd box?
+          const now = Math.floor(new Date().getTime() / 1000 + 2082852000);
+          const ftyp = new Box('ftyp');
+          const moov = boxBuilder.moov(msg.sdp, now);
+          const data = mp4muxer_Buffer.allocUnsafe(ftyp.byteLength + moov.byteLength);
+          ftyp.copy(data, 0);
+          moov.copy(data, ftyp.byteLength);
+          browser_default()('msl:mp4:isom')(`ftyp: ${ftyp.format()}`);
+          browser_default()('msl:mp4:isom')(`moov: ${moov.format()}`); // Set up a list of tracks that contain info about
+          // the type of media, encoding, and codec are present.
+
+          const tracks = msg.sdp.media.map(media => {
+            return {
+              type: media.type,
+              encoding: media.rtpmap && media.rtpmap.encodingName,
+              mime: media.mime,
+              codec: media.codec
+            };
+          });
+          this.push({
+            type: MessageType.ISOM,
+            data,
+            tracks,
+            ftyp,
+            moov
+          });
+        } else if (msg.type === MessageType.ELEMENTARY || msg.type === MessageType.H264) {
+          /**
+           * Otherwise we are getting some elementary stream data.
+           * Set up the moof and mdat boxes.
+           */
+          const {
+            payloadType,
+            timestamp,
+            ntpTimestamp
+          } = msg;
+          const trackId = boxBuilder.trackIdMap[payloadType];
+
+          if (trackId) {
+            if (!boxBuilder.ntpPresentationTime) {
+              boxBuilder.setPresentationTime(trackId, ntpTimestamp);
+
+              if (boxBuilder.ntpPresentationTime) {
+                onSync(boxBuilder.ntpPresentationTime);
+              }
+            }
+
+            let checkpointTime;
+            const idrPicture = msg.type === MessageType.H264 ? msg.nalType === NAL_TYPES.IDR_PICTURE : undefined;
+
+            if (boxBuilder.ntpPresentationTime && idrPicture && msg.ntpTimestamp !== undefined) {
+              checkpointTime = (msg.ntpTimestamp - boxBuilder.ntpPresentationTime) / 1000;
+            }
+
+            const byteLength = msg.data.byteLength;
+            const moof = boxBuilder.moof({
+              trackId,
+              timestamp,
+              byteLength
+            });
+            const mdat = boxBuilder.mdat(msg.data);
+            const data = mp4muxer_Buffer.allocUnsafe(moof.byteLength + mdat.byteLength);
+            moof.copy(data, 0);
+            mdat.copy(data, moof.byteLength);
+            this.push({
+              type: MessageType.ISOM,
+              data,
+              moof,
+              mdat,
+              ntpTimestamp,
+              checkpointTime
+            });
+          }
+        } else {
+          // No message type we recognize, pass it on.
+          this.push(msg);
+        }
+
+        callback();
+      }
+    });
+    super(incoming);
+
+    mp4muxer_defineProperty(this, "boxBuilder", void 0);
+
+    mp4muxer_defineProperty(this, "onSync", void 0);
+
+    this.boxBuilder = boxBuilder;
+  }
+
+  get bitrate() {
+    return this.boxBuilder.trackData && this.boxBuilder.trackData.map(data => data.bitrate);
+  }
+
+  get framerate() {
+    return this.boxBuilder.trackData && this.boxBuilder.trackData.map(data => data.framerate);
+  }
+
+  get ntpPresentationTime() {
+    return this.boxBuilder.ntpPresentationTime;
+  }
+
+}
+;// CONCATENATED MODULE: ./lib/utils/protocols/rtcp.ts
+function rtcp_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }
+
+function rtcp_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { rtcp_ownKeys(Object(source), true).forEach(function (key) { rtcp_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { rtcp_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
+
+function rtcp_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+
+ // Real Time Control Protocol (RTCP)
+// https://tools.ietf.org/html/rfc3550#section-6
+
+/*
+Common RTCP packed header:
+
+        0                   1                   2                   3
+        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+header |V=2|P|    RC   |   PT=SR=200   |             length            |
+       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+*/
+
+let RTCPPacketType;
+
+(function (RTCPPacketType) {
+  RTCPPacketType[RTCPPacketType["SR"] = 200] = "SR";
+  RTCPPacketType[RTCPPacketType["RR"] = 201] = "RR";
+  RTCPPacketType[RTCPPacketType["SDES"] = 202] = "SDES";
+  RTCPPacketType[RTCPPacketType["BYE"] = 203] = "BYE";
+  RTCPPacketType[RTCPPacketType["APP"] = 204] = "APP";
+})(RTCPPacketType || (RTCPPacketType = {}));
+
+const parseBase = buffer => ({
+  version: buffer[0] >>> 6,
+  padding: !!(buffer[0] & POS[2]),
+  count: buffer[0] & 0x1f,
+  packetType: buffer.readUInt8(1),
+  length: buffer.readUInt16BE(2)
+});
+
+const parseRtcp = buffer => {
+  const base = parseBase(buffer);
+
+  switch (base.packetType) {
+    case RTCPPacketType.SR:
+      return parseSR(buffer, base);
+
+    case RTCPPacketType.RR:
+      return parseRR(buffer, base);
+
+    case RTCPPacketType.SDES:
+      return parseSDES(buffer, base);
+
+    case RTCPPacketType.BYE:
+      return parseBYE(buffer, base);
+
+    case RTCPPacketType.APP:
+      return parseAPP(buffer, base);
+
+    default:
+      return base;
+  }
+};
+const rtcpMessageFromBuffer = (channel, buffer) => {
+  return {
+    type: MessageType.RTCP,
+    data: buffer,
+    channel,
+    rtcp: parseRtcp(buffer)
+  };
+};
+/*
+SR: Sender Report RTCP Packet
+
+        0                   1                   2                   3
+        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+header |V=2|P|    RC   |   PT=SR=200   |             length            |
+       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+       |                         SSRC of sender                        |
+       +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
+sender |              NTP timestamp, most significant word             |
+info   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+       |             NTP timestamp, least significant word             |
+       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+       |                         RTP timestamp                         |
+       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+       |                     sender's packet count                     |
+       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+       |                      sender's octet count                     |
+       +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
+report |                 SSRC_1 (SSRC of first source)                 |
+block  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  1    | fraction lost |       cumulative number of packets lost       |
+       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+       |           extended highest sequence number received           |
+       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+       |                      interarrival jitter                      |
+       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+       |                         last SR (LSR)                         |
+       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+       |                   delay since last SR (DLSR)                  |
+       +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
+report |                 SSRC_2 (SSRC of second source)                |
+block  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  2    :                               ...                             :
+       +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
+       |                  profile-specific extensions                  |
+       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+*/
+
+const SR = {
+  packetType: 200
+};
+
+const parseReportBlocks = (count, buffer, offset) => {
+  const reports = [];
+
+  for (let reportNumber = 0; reportNumber < count; reportNumber++) {
+    const o = offset + reportNumber * 24;
+    reports.push({
+      syncSource: buffer.readUInt32BE(o + 0),
+      fractionLost: buffer.readUInt8(o + 4),
+      cumulativeNumberOfPacketsLost: buffer.readUIntBE(o + 5, 3),
+      extendedHighestSequenceNumberReceived: buffer.readUInt32BE(o + 8),
+      interarrivalJitter: buffer.readUInt32BE(o + 12),
+      lastSRTimestamp: buffer.readUInt32BE(o + 16),
+      delaySinceLastSR: buffer.readUInt32BE(o + 20)
+    });
+  }
+
+  return reports;
+};
+
+const parseSR = (buffer, base) => rtcp_objectSpread(rtcp_objectSpread({}, base), {}, {
+  syncSource: buffer.readUInt32BE(4),
+  ntpMost: buffer.readUInt32BE(8),
+  ntpLeast: buffer.readUInt32BE(12),
+  rtpTimestamp: buffer.readUInt32BE(16),
+  sendersPacketCount: buffer.readUInt32BE(20),
+  sendersOctetCount: buffer.readUInt32BE(24),
+  reports: parseReportBlocks(base.count, buffer, 28)
+});
+
+const isRtcpSR = rtcp => rtcp.packetType === RTCPPacketType.SR;
+/*
+RR: Receiver Report RTCP Packet
+
+        0                   1                   2                   3
+        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+header |V=2|P|    RC   |   PT=RR=201   |             length            |
+       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+       |                     SSRC of packet sender                     |
+       +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
+report |                 SSRC_1 (SSRC of first source)                 |
+block  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  1    | fraction lost |       cumulative number of packets lost       |
+       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+       |           extended highest sequence number received           |
+       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+       |                      interarrival jitter                      |
+       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+       |                         last SR (LSR)                         |
+       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+       |                   delay since last SR (DLSR)                  |
+       +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
+report |                 SSRC_2 (SSRC of second source)                |
+block  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+  2    :                               ...                             :
+       +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
+       |                  profile-specific extensions                  |
+       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+*/
+
+const parseRR = (buffer, base) => rtcp_objectSpread(rtcp_objectSpread({}, base), {}, {
+  syncSource: buffer.readUInt32BE(4),
+  reports: parseReportBlocks(base.count, buffer, 8)
+});
+
+const isRtcpRR = rtcp => rtcp.packetType === RTCPPacketType.RR;
+/*
+SDES: Source Description RTCP Packet
+
+        0                   1                   2                   3
+        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+header |V=2|P|    SC   |  PT=SDES=202  |             length            |
+       +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
+chunk  |                          SSRC/CSRC_1                          |
+  1    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+       |                           SDES items                          |
+       |                              ...                              |
+       +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
+chunk  |                          SSRC/CSRC_2                          |
+  2    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+       |                           SDES items                          |
+       |                              ...                              |
+       +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
+*/
+
+let SDESItem;
+
+(function (SDESItem) {
+  SDESItem[SDESItem["CNAME"] = 1] = "CNAME";
+  SDESItem[SDESItem["NAME"] = 2] = "NAME";
+  SDESItem[SDESItem["EMAIL"] = 3] = "EMAIL";
+  SDESItem[SDESItem["PHONE"] = 4] = "PHONE";
+  SDESItem[SDESItem["LOC"] = 5] = "LOC";
+  SDESItem[SDESItem["TOOL"] = 6] = "TOOL";
+  SDESItem[SDESItem["NOTE"] = 7] = "NOTE";
+  SDESItem[SDESItem["PRIV"] = 8] = "PRIV";
+})(SDESItem || (SDESItem = {}));
+
+const parseSDES = (buffer, base) => {
+  const sourceDescriptions = [];
+  let offset = 4;
+
+  for (let block = 0; block < base.count; block++) {
+    const chunk = {
+      source: buffer.readUInt32BE(offset),
+      items: []
+    };
+    offset += 4;
+
+    while (true) {
+      const itemType = buffer.readUInt8(offset++);
+
+      if (itemType === 0) {
+        // start next block at word boundary
+        if (offset % 4 !== 0) {
+          offset += 4 - offset % 4;
+        }
+
+        break;
+      }
+
+      const length = buffer.readUInt8(offset++);
+
+      if (itemType === SDESItem.PRIV) {
+        const prefixLength = buffer.readUInt8(offset);
+        const prefix = buffer.toString('utf8', offset + 1, offset + 1 + prefixLength);
+        const value = buffer.toString('utf8', offset + 1 + prefixLength, offset + length);
+        chunk.items.push([SDESItem.PRIV, prefix, value]);
+      } else {
+        const value = buffer.toString('utf8', offset, offset + length);
+        chunk.items.push([itemType, value]);
+      }
+
+      offset += length;
+    }
+
+    sourceDescriptions.push(chunk);
+  }
+
+  return rtcp_objectSpread(rtcp_objectSpread({}, base), {}, {
+    syncSource: buffer.readUInt32BE(4),
+    sourceDescriptions
+  });
+};
+
+const isRtcpSDES = rtcp => rtcp.packetType === RTCPPacketType.SDES;
+/*
+BYE: Goodbye RTCP Packet
+
+       0                   1                   2                   3
+       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+      |V=2|P|    SC   |   PT=BYE=203  |             length            |
+      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+      |                           SSRC/CSRC                           |
+      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+      :                              ...                              :
+      +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
+(opt) |     length    |               reason for leaving            ...
+      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+*/
+
+const parseBYE = (buffer, base) => {
+  const sources = [];
+
+  for (let block = 0; block < base.count; block++) {
+    sources.push(buffer.readUInt32BE(4 + 4 * block));
+  }
+
+  let reason;
+
+  if (base.length > base.count) {
+    const start = 4 + 4 * base.count;
+    const length = buffer.readUInt8(start);
+    reason = buffer.toString('utf-8', start + 1, start + 1 + length);
+  }
+
+  return rtcp_objectSpread(rtcp_objectSpread({}, base), {}, {
+    sources,
+    reason
+  });
+};
+
+const isRtcpBye = rtcp => rtcp.packetType === RTCPPacketType.BYE;
+/*
+APP: Application-Defined RTCP Packet
+
+    0                   1                   2                   3
+    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+   |V=2|P| subtype |   PT=APP=204  |             length            |
+   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+   |                           SSRC/CSRC                           |
+   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+   |                          name (ASCII)                         |
+   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+   |                   application-dependent data                ...
+   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+
+*/
+
+const parseAPP = (buffer, base) => {
+  return rtcp_objectSpread(rtcp_objectSpread({}, base), {}, {
+    subtype: base.count,
+    source: buffer.readUInt32BE(4),
+    name: buffer.toString('ascii', 8, 12),
+    data: buffer.slice(12)
+  });
+};
+
+const isRtcpApp = rtcp => rtcp.packetType === RTCPPacketType.APP;
+;// CONCATENATED MODULE: ./lib/components/mse/index.ts
+
+
+function mse_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+
+
+
+
+
+const TRIGGER_THRESHOLD = 100;
+const mse_debug = browser_default()('msl:mse');
+class MseSink extends Sink {
+  /**
+   * Create a Media component.
+   *
+   * The constructor sets up two streams and connects them to the MediaSource.
+   *
+   * @param el - A video element to connect the media source to
+   */
+  constructor(el) {
+    if (el === undefined) {
+      throw new Error('video element argument missing');
+    }
+
+    let mse;
+    let sourceBuffer;
+    /**
+     * Set up an incoming stream and attach it to the sourceBuffer.
+     */
+
+    const incoming = new stream_browserify.Writable({
+      objectMode: true,
+      write: (msg, _, callback) => {
+        if (msg.type === MessageType.ISOM) {
+          // ISO BMFF Byte Stream data to be added to the source buffer
+          this._done = callback;
+
+          if (msg.tracks !== undefined || msg.mime !== undefined) {
+            const tracks = msg.tracks ?? []; // MIME codecs: https://tools.ietf.org/html/rfc6381
+
+            const mimeCodecs = tracks.map(track => track.mime).filter(mime => mime);
+            const codecs = mimeCodecs.length !== 0 ? mimeCodecs.join(', ') : 'avc1.640029, mp4a.40.2'; // Take MIME type directly from the message, or constructed
+            // from the tracks (with a default fallback to basic H.264).
+
+            const mimeType = msg.mime ?? `video/mp4; codecs="${codecs}"`;
+
+            if (!MediaSource.isTypeSupported(mimeType)) {
+              incoming.emit('error', `unsupported media type: ${mimeType}`);
+              return;
+            } // Start a new movie (new SDP info available)
+
+
+            this._lastCheckpointTime = 0; // Start a new mediaSource and prepare it with a sourceBuffer.
+            // When ready, this component's .onSourceOpen callback will be called
+            // with the mediaSource, and a list of valid/ignored media.
+
+            mse = new MediaSource();
+            el.src = window.URL.createObjectURL(mse);
+
+            const handler = () => {
+              if (mse === undefined) {
+                incoming.emit('error', 'no MediaSource instance');
+                return;
+              } // revoke the object URL to avoid a memory leak
+
+
+              window.URL.revokeObjectURL(el.src);
+              mse.removeEventListener('sourceopen', handler);
+              this.onSourceOpen && this.onSourceOpen(mse, tracks);
+              sourceBuffer = this.addSourceBuffer(el, mse, mimeType);
+
+              sourceBuffer.onerror = e => {
+                console.error('error on SourceBuffer: ', e);
+                incoming.emit('error');
+              };
+
+              try {
+                sourceBuffer.appendBuffer(msg.data);
+              } catch (err) {
+                mse_debug('failed to append to SourceBuffer: ', err, msg);
+              }
+            };
+
+            mse.addEventListener('sourceopen', handler);
+          } else {
+            // Continue current movie
+            this._lastCheckpointTime = msg.checkpointTime !== undefined ? msg.checkpointTime : this._lastCheckpointTime;
+
+            try {
+              var _sourceBuffer;
+
+              (_sourceBuffer = sourceBuffer) === null || _sourceBuffer === void 0 ? void 0 : _sourceBuffer.appendBuffer(msg.data);
+            } catch (e) {
+              mse_debug('failed to append to SourceBuffer: ', e, msg);
+            }
+          }
+        } else if (msg.type === MessageType.RTCP) {
+          if (isRtcpBye(msg.rtcp)) {
+            var _mse;
+
+            ((_mse = mse) === null || _mse === void 0 ? void 0 : _mse.readyState) === 'open' && mse.endOfStream();
+          }
+
+          callback();
+        } else {
+          callback();
+        }
+      }
+    });
+    incoming.on('finish', () => {
+      console.warn('incoming stream finished: end stream');
+      mse && mse.readyState === 'open' && mse.endOfStream();
+    }); // When an error is sent on the incoming stream, close it.
+
+    incoming.on('error', msg => {
+      console.error('error on incoming stream: ', msg);
+
+      if (sourceBuffer && sourceBuffer.updating) {
+        sourceBuffer.addEventListener('updateend', () => {
+          var _mse2;
+
+          ((_mse2 = mse) === null || _mse2 === void 0 ? void 0 : _mse2.readyState) === 'open' && mse.endOfStream();
+        });
+      } else {
+        var _mse3;
+
+        ((_mse3 = mse) === null || _mse3 === void 0 ? void 0 : _mse3.readyState) === 'open' && mse.endOfStream();
+      }
+    });
+    /**
+     * Set up outgoing stream.
+     */
+
+    const outgoing = new stream_browserify.Readable({
+      objectMode: true,
+      read: function () {//
+      }
+    }); // When an error is sent on the outgoing stream, whine about it.
+
+    outgoing.on('error', () => {
+      console.warn('outgoing stream broke somewhere');
+    });
+    /**
+     * initialize the component.
+     */
+
+    super(incoming, outgoing);
+
+    mse_defineProperty(this, "_videoEl", void 0);
+
+    mse_defineProperty(this, "_done", void 0);
+
+    mse_defineProperty(this, "_lastCheckpointTime", void 0);
+
+    mse_defineProperty(this, "onSourceOpen", void 0);
+
+    this._videoEl = el;
+    this._lastCheckpointTime = 0;
+  }
+  /**
+   * Add a new sourceBuffer to the mediaSource and remove old ones.
+   * @param el - The media element holding the media source.
+   * @param mse - The media source the buffer should be attached to.
+   * @param mimeType - MIME type and codecs, e.g.: 'video/mp4; codecs="avc1.4D0029, mp4a.40.2"'
+   */
+
+
+  addSourceBuffer(el, mse, mimeType) {
+    const sourceBuffer = mse.addSourceBuffer(mimeType);
+    let trigger = 0;
+
+    const onUpdateEndHandler = () => {
+      ++trigger;
+
+      if (trigger > TRIGGER_THRESHOLD && sourceBuffer.buffered.length) {
+        trigger = 0;
+        const index = sourceBuffer.buffered.length - 1;
+        const start = sourceBuffer.buffered.start(index);
+        const end = Math.min(el.currentTime, this._lastCheckpointTime) - 10;
+
+        try {
+          // remove all material up to 10 seconds before current time
+          if (end > start) {
+            sourceBuffer.remove(start, end);
+            return; // this._done() will be called on the next updateend event!
+          }
+        } catch (e) {
+          console.warn(e);
+        }
+      }
+
+      this._done && this._done();
+    };
+
+    sourceBuffer.addEventListener('updateend', onUpdateEndHandler);
+    return sourceBuffer;
+  }
+
+  get currentTime() {
+    return this._videoEl.currentTime;
+  }
+
+  async play() {
+    return await this._videoEl.play();
+  }
+
+  pause() {
+    return this._videoEl.pause();
+  }
+
+}
+;// CONCATENATED MODULE: ./lib/components/onvifdepay/index.ts
+/* provided dependency */ var onvifdepay_Buffer = __webpack_require__(7866)["Buffer"];
+
+
+
+
+class ONVIFDepay extends Tube {
+  constructor() {
+    let XMLPayloadType;
+    let packets = [];
+    const incoming = new stream_browserify.Transform({
+      objectMode: true,
+      transform: function (msg, encoding, callback) {
+        if (msg.type === MessageType.SDP) {
+          let validMedia;
+
+          for (const media of msg.sdp.media) {
+            if (media.type === 'application' && media.rtpmap && media.rtpmap.encodingName === 'VND.ONVIF.METADATA') {
+              validMedia = media;
+            }
+          }
+
+          if (validMedia && validMedia.rtpmap) {
+            XMLPayloadType = Number(validMedia.rtpmap.payloadType);
+          }
+
+          callback(undefined, msg);
+        } else if (msg.type === MessageType.RTP && payloadType(msg.data) === XMLPayloadType) {
+          // Add payload to packet stack
+          packets.push(payload(msg.data)); // XML over RTP uses the RTP marker bit to indicate end
+          // of fragmentation. At this point, the packets can be used
+          // to reconstruct an XML packet.
+
+          if (marker(msg.data) && packets.length > 0) {
+            const xmlMsg = {
+              timestamp: timestamp(msg.data),
+              ntpTimestamp: msg.ntpTimestamp,
+              payloadType: payloadType(msg.data),
+              data: onvifdepay_Buffer.concat(packets),
+              type: MessageType.XML
+            };
+            callback(undefined, xmlMsg);
+            packets = [];
+            return;
+          }
+
+          callback();
+        } else {
+          // Not a message we should handle
+          callback(undefined, msg);
+        }
+      }
+    }); // outgoing will be defaulted to a PassThrough stream
+
+    super(incoming);
+  }
+
+}
+;// CONCATENATED MODULE: ./lib/components/rtsp-parser/builder.ts
+/* provided dependency */ var builder_Buffer = __webpack_require__(7866)["Buffer"];
+
+const DEFAULT_PROTOCOL = 'RTSP/1.0';
+const builder = msg => {
+  if (!msg.method || !msg.uri) {
+    throw new Error('message needs to contain a method and a uri');
+  }
+
+  const protocol = msg.protocol || DEFAULT_PROTOCOL;
+  const headers = msg.headers || {};
+  const messageString = [`${msg.method} ${msg.uri} ${protocol}`, Object.entries(headers).map(([key, value]) => key + ': ' + value).join('\r\n'), '\r\n'].join('\r\n');
+  browser_default()('msl:rtsp:outgoing')(messageString);
+  return builder_Buffer.from(messageString);
+};
+;// CONCATENATED MODULE: ./lib/utils/protocols/sdp.ts
+
+
+const extractLineVals = (buffer, lineStart, start = 0) => {
+  const anchor = `\n${lineStart}`;
+  start = buffer.indexOf(anchor, start);
+  let end = 0;
+  const ret = [];
+
+  while (start >= 0) {
+    end = buffer.indexOf('\n', start + anchor.length);
+    ret.push(buffer.toString('ascii', start + anchor.length, end).trim());
+    start = buffer.indexOf(anchor, end);
+  }
+
+  return ret;
+}; // SDP parsing
+
+/**
+ * Identify the start of a session-level or media-level section.
+ * @param  line - The line to parse
+ */
+
+
+const newMediaLevel = line => {
+  return line.match(/^m=/);
+};
+
+const splitOnFirst = (c, text) => {
+  const p = text.indexOf(c);
+
+  if (p < 0) {
+    return [text.slice(0)];
+  } else {
+    return [text.slice(0, p), text.slice(p + 1)];
+  }
+};
+
+const attributeParsers = {
+  fmtp: value => {
+    const [format, stringParameters] = splitOnFirst(' ', value);
+
+    switch (format) {
+      default:
+        const pairs = stringParameters.trim().split(';');
+        const parameters = {};
+        pairs.forEach(pair => {
+          const [key, val] = splitOnFirst('=', pair);
+          const normalizedKey = key.trim().toLowerCase();
+
+          if (normalizedKey !== '') {
+            parameters[normalizedKey] = val.trim();
+          }
+        });
+        return {
+          format,
+          parameters
+        };
+    }
+  },
+  framerate: Number,
+  rtpmap: value => {
+    const [payloadType, encoding] = splitOnFirst(' ', value);
+    const [encodingName, clockrate, encodingParameters] = encoding.toUpperCase().split('/');
+
+    if (encodingParameters === undefined) {
+      return {
+        payloadType: Number(payloadType),
+        encodingName,
+        clockrate: Number(clockrate)
+      };
+    } else {
+      return {
+        payloadType: Number(payloadType),
+        encodingName,
+        clockrate: Number(clockrate),
+        encodingParameters
+      };
+    }
+  },
+  transform: value => {
+    return value.split(';').map(row => row.split(',').map(Number));
+  },
+  'x-sensor-transform': value => {
+    return value.split(';').map(row => row.split(',').map(Number));
+  },
+  framesize: value => {
+    return value.split(' ')[1].split('-').map(Number);
+  }
+};
+
+const parseAttribute = body => {
+  const [attribute, value] = splitOnFirst(':', body);
+
+  if (value === undefined) {
+    return {
+      [attribute]: true
+    };
+  } else {
+    if (attributeParsers[attribute] !== undefined) {
+      return {
+        [attribute]: attributeParsers[attribute](value)
+      };
+    } else {
+      return {
+        [attribute]: value
+      };
+    }
+  }
+};
+
+const extractField = line => {
+  const prefix = line.slice(0, 1);
+  const body = line.slice(2);
+
+  switch (prefix) {
+    case 'v':
+      return {
+        version: body
+      };
+
+    case 'o':
+      const [username, sessionId, sessionVersion, netType, addrType, unicastAddress] = body.split(' ');
+      return {
+        origin: {
+          addrType,
+          netType,
+          sessionId,
+          sessionVersion,
+          unicastAddress,
+          username
+        }
+      };
+
+    case 's':
+      return {
+        sessionName: body
+      };
+
+    case 'i':
+      return {
+        sessionInformation: body
+      };
+
+    case 'u':
+      return {
+        uri: body
+      };
+
+    case 'e':
+      return {
+        email: body
+      };
+
+    case 'p':
+      return {
+        phone: body
+      };
+    // c=<nettype> <addrtype> <connection-address>
+
+    case 'c':
+      const [connectionNetType, connectionAddrType, connectionAddress] = body.split(' ');
+      return {
+        connectionData: {
+          addrType: connectionAddrType,
+          connectionAddress,
+          netType: connectionNetType
+        }
+      };
+    // b=<bwtype>:<bandwidth>
+
+    case 'b':
+      const [bwtype, bandwidth] = body.split(':');
+      return {
+        bwtype,
+        bandwidth
+      };
+    // t=<start-time> <stop-time>
+
+    case 't':
+      const [startTime, stopTime] = body.split(' ').map(Number);
+      return {
+        time: {
+          startTime,
+          stopTime
+        }
+      };
+    // r=<repeat interval> <active duration> <offsets from start-time>
+
+    case 'r':
+      const [repeatInterval, activeDuration, ...offsets] = body.split(' ').map(Number);
+      return {
+        repeatTimes: {
+          repeatInterval,
+          activeDuration,
+          offsets
+        }
+      };
+    // z=<adjustment time> <offset> <adjustment time> <offset> ....
+
+    case 'z':
+      return;
+    // k=<method>
+    // k=<method>:<encryption key>
+
+    case 'k':
+      return;
+    // a=<attribute>
+    // a=<attribute>:<value>
+
+    case 'a':
+      return parseAttribute(body);
+
+    case 'm':
+      // Only the first fmt field is parsed!
+      const [type, port, protocol, fmt] = body.split(' ');
+      return {
+        type,
+        port: Number(port),
+        protocol,
+        fmt: Number(fmt)
+      };
+
+    default: // console.log('unknown SDP prefix ', prefix);
+
+  }
+};
+
+const extractURIs = buffer => {
+  // There is a control URI above the m= line, which should not be used
+  const seekFrom = buffer.indexOf('\nm=');
+  return extractLineVals(buffer, 'a=control:', seekFrom);
+};
+/**
+ * Parse an SDP text into a data structure with session and media objects.
+ *
+ * @param  buffer - The buffer containing the SDP plain text
+ * @return Structured SDP data
+ */
+
+const sdp_parse = buffer => {
+  const sdp = buffer.toString('ascii').split('\n').map(s => s.trim());
+  const struct = {
+    session: {},
+    media: []
+  };
+  let mediaCounter = 0;
+  let current = struct.session;
+
+  for (const line of sdp) {
+    if (newMediaLevel(line)) {
+      struct.media[mediaCounter] = {};
+      current = struct.media[mediaCounter];
+      ++mediaCounter;
+    }
+
+    current = Object.assign(current, extractField(line));
+  }
+
+  return struct;
+};
+const messageFromBuffer = buffer => {
+  return {
+    type: MessageType.SDP,
+    data: buffer,
+    sdp: sdp_parse(buffer)
+  };
+};
+;// CONCATENATED MODULE: ./lib/utils/protocols/rtsp.ts
+/*
+ * The RTSP response format is defined in RFC 7826,
+ * using ABNF notation specified in RFC 5234.
+ * Strings in ABNF rules ("...") are always case insensitive!
+ *
+ * Basic rules to help with the headers below:
+ * ====
+ * CR              =  %x0D ; US-ASCII CR, carriage return (13)
+ * LF              =  %x0A  ; US-ASCII LF, linefeed (10)
+ * SP              =  %x20  ; US-ASCII SP, space (32)
+ * HT              =  %x09  ; US-ASCII HT, horizontal-tab (9)
+ * CRLF            =  CR LF
+ * LWS             =  [CRLF] 1*( SP / HT ) ; Line-breaking whitespace
+ * SWS             =  [LWS] ; Separating whitespace
+ * HCOLON          =  *( SP / HT ) ":" SWS
+ *
+ * RTSP response rules (a `*` means zero or more):
+ * ====
+ * Status-Line  = RTSP-Version SP Status-Code SP Reason-Phrase CRLF
+ * Response     = Status-Line
+ *                *((general-header
+ *                /  response-header
+ *                /  message-body-header) CRLF)
+ *                CRLF
+ *                [ message-body-data ]
+ *
+ * Example response:
+ * ====
+ * RTSP/1.0 200 OK
+ * CSeq: 3
+ * Content-Type: application/sdp
+ * Content-Base: rtsp://192.168.0.3/axis-media/media.amp/
+ * Server: GStreamer RTSP server
+ * Date: Wed, 03 Jun 2015 14:23:42 GMT
+ * Content-Length: 623
+ *
+ * v=0
+ * ....
+ */
+
+/**
+ * Extract the value of a header.
+ *
+ * @param buffer The response bytes
+ * @param header The header to search for
+ */
+const extractHeaderValue = (buffer, header) => {
+  const anchor = `\n${header.toLowerCase()}: `;
+  const start = buffer.toString().toLowerCase().indexOf(anchor);
+
+  if (start >= 0) {
+    const end = buffer.indexOf('\n', start + anchor.length);
+    const headerValue = buffer.toString('ascii', start + anchor.length, end).trim();
+    return headerValue;
+  }
+
+  return null;
+};
+const sequence = buffer => {
+  /**
+   * CSeq           =  "CSeq" HCOLON cseq-nr
+   * cseq-nr        =  1*9DIGIT
+   */
+  const val = extractHeaderValue(buffer, 'CSeq');
+
+  if (val !== null) {
+    return Number(val);
+  }
+
+  return null;
+};
+const sessionId = buffer => {
+  /**
+   * Session          =  "Session" HCOLON session-id
+   *                     [ SEMI "timeout" EQUAL delta-seconds ]
+   * session-id        =  1*256( ALPHA / DIGIT / safe )
+   * delta-seconds     =  1*19DIGIT
+   */
+  const val = extractHeaderValue(buffer, 'Session');
+  return val ? val.split(';')[0] : null;
+};
+const sessionTimeout = buffer => {
+  /**
+   * Session          =  "Session" HCOLON session-id
+   *                     [ SEMI "timeout" EQUAL delta-seconds ]
+   * session-id        =  1*256( ALPHA / DIGIT / safe )
+   * delta-seconds     =  1*19DIGIT
+   */
+  const val = extractHeaderValue(buffer, 'Session');
+
+  if (val === null) {
+    return null;
+  }
+
+  const defaultTimeout = 60;
+  const timeoutToken = 'timeout=';
+  const timeoutPosition = val.toLowerCase().indexOf(timeoutToken);
+
+  if (timeoutPosition !== -1) {
+    let timeoutVal = val.substring(timeoutPosition + timeoutToken.length);
+    timeoutVal = timeoutVal.split(';')[0];
+    const parsedTimeout = parseInt(timeoutVal);
+    return isNaN(parsedTimeout) ? defaultTimeout : parsedTimeout;
+  }
+
+  return defaultTimeout;
+};
+const statusCode = buffer => {
+  return Number(buffer.toString('ascii', 9, 12));
+};
+const contentBase = buffer => {
+  /**
+   * Content-Base       =  "Content-Base" HCOLON RTSP-URI
+   */
+  return extractHeaderValue(buffer, 'Content-Base');
+};
+const contentLocation = buffer => {
+  /**
+   * Content-Location   =  "Content-Location" HCOLON RTSP-REQ-Ref
+   */
+  return extractHeaderValue(buffer, 'Content-Location');
+};
+const connectionEnded = buffer => {
+  /**
+   * Connection         =  "Connection" HCOLON connection-token
+   *                       *(COMMA connection-token)
+   * connection-token   =  "close" / token
+   */
+  const connectionToken = extractHeaderValue(buffer, 'Connection');
+  return connectionToken !== null && connectionToken.toLowerCase() === 'close';
+};
+const range = buffer => {
+  /**
+   * Range              =  "Range" HCOLON ranges-spec
+   * ranges-spec        =  npt-range / utc-range / smpte-range
+   *                       /  range-ext
+   * npt-range        =  "npt" [EQUAL npt-range-spec]
+   * npt-range-spec   =  ( npt-time "-" [ npt-time ] ) / ( "-" npt-time )
+   * npt-time         =  "now" / npt-sec / npt-hhmmss / npt-hhmmss-comp
+   * npt-sec          =  1*19DIGIT [ "." 1*9DIGIT ]
+   * npt-hhmmss       =  npt-hh ":" npt-mm ":" npt-ss [ "." 1*9DIGIT ]
+   * npt-hh           =  2*19DIGIT   ; any positive number
+   * npt-mm           =  2*2DIGIT  ; 0-59
+   * npt-ss           =  2*2DIGIT  ; 0-59
+   * npt-hhmmss-comp  =  npt-hh-comp ":" npt-mm-comp ":" npt-ss-comp
+   *                     [ "." 1*9DIGIT ] ; Compatibility format
+   * npt-hh-comp      =  1*19DIGIT   ; any positive number
+   * npt-mm-comp      =  1*2DIGIT  ; 0-59
+   * npt-ss-comp      =  1*2DIGIT  ; 0-59
+   */
+  // Example range headers:
+  // Range: npt=now-
+  // Range: npt=1154.598701-3610.259146
+  const npt = extractHeaderValue(buffer, 'Range');
+
+  if (npt !== null) {
+    return npt.split('=')[1].split('-');
+  }
+
+  return undefined;
+};
+/**
+ * Determine the offset of the RTSP body, where the header ends.
+ * If there is no header ending, -1 is returned
+ * @param  chunk - A piece of data
+ * @return The body offset, or -1 if no header end found
+ */
+
+const bodyOffset = chunk => {
+  /**
+   * Strictly speaking, it seems RTSP MUST have CRLF and doesn't allow CR or LF on its own.
+   * That means that the end of the header part should be a pair of CRLF, but we're being
+   * flexible here and also allow LF LF or CR CR instead of CRLF CRLF.
+   */
+  const bodyOffsets = ['\n\n', '\r\r', '\r\n\r\n'].map(s => {
+    const offset = chunk.indexOf(s);
+
+    if (offset !== -1) {
+      return offset + s.length;
+    }
+
+    return offset;
+  }).filter(offset => offset !== -1);
+
+  if (bodyOffsets.length > 0) {
+    return bodyOffsets.reduce((acc, offset) => {
+      return Math.min(acc, offset);
+    });
+  } else {
+    return -1;
+  }
+};
+;// CONCATENATED MODULE: ./lib/components/rtsp-parser/parser.ts
+/* provided dependency */ var rtsp_parser_parser_Buffer = __webpack_require__(7866)["Buffer"];
+function rtsp_parser_parser_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+
+
+
+
+/**
+ * The different possible internal parser states.
+ */
+
+var STATE;
+
+(function (STATE) {
+  STATE[STATE["IDLE"] = 0] = "IDLE";
+  STATE[STATE["INTERLEAVED"] = 1] = "INTERLEAVED";
+  STATE[STATE["RTSP"] = 2] = "RTSP";
+})(STATE || (STATE = {}));
+
+const INTERLEAVED_HEADER_BYTES = 4;
+const ASCII_DOLLAR = 0x24;
+
+/**
+ * Extract packet information from the interleaved header
+ * (4-byte section before the RTP packet).
+ * @param  chunks - Buffers constituting the data.
+ * @return Packet information (channel, begin, end).
+ */
+const rtpPacketInfo = chunks => {
+  const header = rtsp_parser_parser_Buffer.alloc(INTERLEAVED_HEADER_BYTES);
+  let i = 0;
+  let bytesRead = 0;
+
+  while (bytesRead < header.length) {
+    const chunk = chunks[i++];
+    const bytesToRead = Math.min(chunk.length, header.length - bytesRead);
+    chunk.copy(header, bytesRead, 0, bytesToRead);
+    bytesRead += bytesToRead;
+  }
+
+  const channel = header[1];
+  const begin = header.length;
+  const length = header.readUInt16BE(2);
+  const end = begin + length;
+  return {
+    channel,
+    begin,
+    end
+  };
+};
+/**
+ * Parser class with a public method that takes a data chunk and
+ * returns an array of RTP/RTSP/RTCP message objects. The parser
+ * keeps track of the added chunks internally in an array and only
+ * concatenates chunks when data is needed to construct a message.
+ * @type {[type]}
+ */
+
+
+class Parser {
+  /**
+   * Create a new Parser object.
+   * @return {undefined}
+   */
+  constructor() {
+    rtsp_parser_parser_defineProperty(this, "_chunks", []);
+
+    rtsp_parser_parser_defineProperty(this, "_length", 0);
+
+    rtsp_parser_parser_defineProperty(this, "_state", STATE.IDLE);
+
+    rtsp_parser_parser_defineProperty(this, "_packet", void 0);
+
+    this._init();
+  }
+  /**
+   * Initialize the internal properties to their default starting
+   * values.
+   * @return {undefined}
+   */
+
+
+  _init() {
+    this._chunks = [];
+    this._length = 0;
+    this._state = STATE.IDLE;
+  }
+
+  _push(chunk) {
+    this._chunks.push(chunk);
+
+    this._length += chunk.length;
+  }
+  /**
+   * Extract RTSP messages.
+   * @return {Array} An array of messages, possibly empty.
+   */
+
+
+  _parseRtsp() {
+    const messages = [];
+    const buffer = rtsp_parser_parser_Buffer.concat(this._chunks);
+    const chunkBodyOffset = bodyOffset(buffer); // If last added chunk does not have the end of the header, return.
+
+    if (chunkBodyOffset === -1) {
+      return messages;
+    }
+
+    const rtspHeaderLength = chunkBodyOffset;
+    const contentLength = extractHeaderValue(buffer, 'Content-Length');
+
+    if (contentLength && parseInt(contentLength) > buffer.length - rtspHeaderLength) {
+      // we do not have the whole body
+      return messages;
+    }
+
+    this._init(); // resets this._chunks and this._length
+
+
+    if (rtspHeaderLength === buffer.length || buffer[rtspHeaderLength] === ASCII_DOLLAR) {
+      // No body in this chunk, assume there is no body?
+      const packet = buffer.slice(0, rtspHeaderLength);
+      messages.push({
+        type: MessageType.RTSP,
+        data: packet
+      }); // Add the remaining data to the chunk stack.
+
+      const trailing = buffer.slice(rtspHeaderLength);
+
+      this._push(trailing);
+    } else {
+      // Body is assumed to be the remaining data of the last chunk.
+      const packet = buffer;
+      const body = buffer.slice(rtspHeaderLength);
+      messages.push({
+        type: MessageType.RTSP,
+        data: packet
+      });
+      messages.push(messageFromBuffer(body));
+    }
+
+    return messages;
+  }
+  /**
+   * Extract RTP/RTCP messages.
+   * @return {Array} An array of messages, possibly empty.
+   */
+
+
+  _parseInterleaved() {
+    const messages = []; // Skip as long as we don't have the first 4 bytes
+
+    if (this._length < INTERLEAVED_HEADER_BYTES) {
+      return messages;
+    } // Enough bytes to construct the header and extract packet info.
+
+
+    if (!this._packet) {
+      this._packet = rtpPacketInfo(this._chunks);
+    } // As long as we don't have enough chunks, skip.
+
+
+    if (this._length < this._packet.end) {
+      return messages;
+    } // We have enough data to extract the packet.
+
+
+    const buffer = rtsp_parser_parser_Buffer.concat(this._chunks);
+    const packet = buffer.slice(this._packet.begin, this._packet.end);
+    const trailing = buffer.slice(this._packet.end);
+    const channel = this._packet.channel;
+    delete this._packet; // Prepare next bit.
+
+    this._init();
+
+    this._push(trailing); // Extract messages
+
+
+    if (channel % 2 === 0) {
+      // Even channels 0, 2, ...
+      messages.push({
+        type: MessageType.RTP,
+        data: packet,
+        channel
+      });
+    } else {
+      // Odd channels 1, 3, ...
+      let rtcpPackets = packet;
+
+      do {
+        // RTCP packets can be packed together, unbundle them:
+        const rtcpByteSize = rtcpPackets.readUInt16BE(2) * 4 + 4;
+        messages.push(rtcpMessageFromBuffer(channel, rtcpPackets.slice(0, rtcpByteSize)));
+        rtcpPackets = rtcpPackets.slice(rtcpByteSize);
+      } while (rtcpPackets.length > 0);
+    }
+
+    return messages;
+  }
+  /**
+   * Set the internal state based on the type of the first chunk
+   */
+
+
+  _setState() {
+    // Remove leading 0-sized chunks.
+    while (this._chunks.length > 0 && this._chunks[0].length === 0) {
+      this._chunks.shift();
+    }
+
+    const firstChunk = this._chunks[0];
+
+    if (this._chunks.length === 0) {
+      this._state = STATE.IDLE;
+    } else if (firstChunk[0] === ASCII_DOLLAR) {
+      this._state = STATE.INTERLEAVED;
+    } else if (firstChunk.toString('ascii', 0, 4) === 'RTSP') {
+      this._state = STATE.RTSP;
+    } else {
+      throw new Error(`Unknown chunk of length ${firstChunk.length}`);
+    }
+  }
+  /**
+   * Add the next chunk of data to the parser and extract messages.
+   * If no message can be extracted, an empty array is returned, otherwise
+   * an array of messages is returned.
+   * @param  chunk - The next piece of data.
+   * @return An array of messages, possibly empty.
+   */
+
+
+  parse(chunk) {
+    this._push(chunk);
+
+    if (this._state === STATE.IDLE) {
+      this._setState();
+    }
+
+    let messages = [];
+    let done = false;
+
+    while (!done) {
+      let extracted = [];
+
+      switch (this._state) {
+        case STATE.IDLE:
+          break;
+
+        case STATE.INTERLEAVED:
+          extracted = this._parseInterleaved();
+          break;
+
+        case STATE.RTSP:
+          extracted = this._parseRtsp();
+          break;
+
+        default:
+          throw new Error('internal error: unknown state');
+      }
+
+      if (extracted.length > 0) {
+        messages = messages.concat(extracted);
+      } else {
+        done = true;
+      }
+
+      this._setState();
+    }
+
+    return messages;
+  }
+
+}
+;// CONCATENATED MODULE: ./lib/components/rtsp-parser/index.ts
+
+
+
+
+
+/**
+ * A component that converts raw binary data into RTP/RTSP/RTCP packets on the
+ * incoming stream, and converts RTSP commands to raw binary data on the outgoing
+ * stream. The component is agnostic of any RTSP session details (you need an
+ * RTSP session component in the pipeline).
+ * @extends {Component}
+ */
+
+class RtspParser extends Tube {
+  /**
+   * Create a new RTSP parser component.
+   * @return {undefined}
+   */
+  constructor() {
+    const parser = new Parser(); // Incoming stream
+
+    const incoming = new stream_browserify.Transform({
+      objectMode: true,
+      transform: function (msg, encoding, callback) {
+        if (msg.type === MessageType.RAW) {
+          try {
+            parser.parse(msg.data).forEach(message => incoming.push(message));
+            callback();
+          } catch (e) {
+            callback(e);
+          }
+        } else {
+          // Not a message we should handle
+          callback(undefined, msg);
+        }
+      }
+    }); // Outgoing stream
+
+    const outgoing = new stream_browserify.Transform({
+      objectMode: true,
+      transform: function (msg, encoding, callback) {
+        if (msg.type === MessageType.RTSP) {
+          const data = builder(msg);
+          callback(undefined, {
+            type: MessageType.RAW,
+            data
+          });
+        } else {
+          // don't touch other types
+          callback(undefined, msg);
+        }
+      }
+    });
+    super(incoming, outgoing);
+  }
+
+}
+;// CONCATENATED MODULE: ./lib/utils/config.ts
+/**
+ * Flat merge of objects, ignoring undefined override values.
+ * @param  template - The object with default values
+ * @param  override - The object with override values.
+ * @return The template object with override merged in.
+ */
+const merge = (template, override) => {
+  let cleanOverride;
+
+  if (override !== undefined) {
+    if (typeof override !== 'object') {
+      throw new Error('merge expects override to be an object!');
+    } else {
+      cleanOverride = Object.keys(override).reduce((acc, key) => {
+        if (override[key] !== undefined) {
+          acc[key] = override[key];
+        }
+
+        return acc;
+      }, {});
+    }
+  }
+
+  return Object.assign({}, template, cleanOverride);
+};
+;// CONCATENATED MODULE: ./lib/utils/protocols/ntp.ts
+// NTP is offset from 01.01.1900
+const NTP_UNIX_EPOCH_OFFSET = Date.UTC(1900, 0, 1); // Convenience types
+
+/**
+ * Convert NTP time to milliseconds since January 1, 1970, 00:00:00 UTC (Unix Epoch)
+ * @param ntpMost - Seconds since 01.01.1900
+ * @param ntpLeast - Fractions since 01.01.1900
+ */
+function getTime(ntpMost, ntpLeast) {
+  const ntpMilliSeconds = (ntpMost + ntpLeast / 0x100000000) * 1000;
+  return NTP_UNIX_EPOCH_OFFSET + ntpMilliSeconds;
+}
+;// CONCATENATED MODULE: ./lib/components/rtsp-session/index.ts
+/* provided dependency */ var rtsp_session_Buffer = __webpack_require__(7866)["Buffer"];
+
+
+function rtsp_session_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+
+
+
+
+
+
+
+
+
+
+function isAbsolute(url) {
+  return /^[^:]+:\/\//.test(url);
+}
+
+var rtsp_session_STATE;
+
+(function (STATE) {
+  STATE["IDLE"] = "idle";
+  STATE["PLAYING"] = "playing";
+  STATE["PAUSED"] = "paused";
+})(rtsp_session_STATE || (rtsp_session_STATE = {}));
+
+let RTSP_METHOD;
+
+(function (RTSP_METHOD) {
+  RTSP_METHOD["OPTIONS"] = "OPTIONS";
+  RTSP_METHOD["DESCRIBE"] = "DESCRIBE";
+  RTSP_METHOD["SETUP"] = "SETUP";
+  RTSP_METHOD["PLAY"] = "PLAY";
+  RTSP_METHOD["PAUSE"] = "PAUSE";
+  RTSP_METHOD["TEARDOWN"] = "TEARDOWN";
+})(RTSP_METHOD || (RTSP_METHOD = {}));
+
+const MIN_SESSION_TIMEOUT = 5; // minimum timeout for a rtsp session in seconds
+
+// Default RTSP configuration
+const defaultConfig = (hostname = typeof window === 'undefined' ? '' : window.location.hostname, parameters = []) => {
+  const uri = parameters.length > 0 ? `rtsp://${hostname}/axis-media/media.amp?${parameters.join('&')}` : `rtsp://${hostname}/axis-media/media.amp`;
+  return {
+    uri
+  };
+};
+
+class RTSPResponseError extends Error {
+  constructor(message, code) {
+    super(message);
+
+    rtsp_session_defineProperty(this, "code", void 0);
+
+    this.name = 'RTSPResponseError';
+    this.code = code;
+  }
+
+}
+/**
+ * A component that sets up a command queue in order to interact with the RTSP
+ * server. Allows control over the RTSP session by listening to incoming messages
+ * and sending request on the outgoing stream.
+ *
+ * The following handlers can be set on the component:
+ *  - onSdp: will be called when an SDP object is sent with the object as argument
+ *  - onPlay: will be called when an RTSP PLAY response is sent with the media range
+ *            as argument. The latter is an array [start, stop], where start is "now"
+ *            (for live) or a time in seconds, and stop is undefined (for live or
+ *            ongoing streams) or a time in seconds.
+ * @extends {Component}
+ */
+
+class RtspSession extends Tube {
+  /**
+   * Create a new RTSP session controller component.
+   * @param  [config] Details about the session.
+   * @param  [config.hostname] The RTSP server hostname
+   * @param  [config.parameters] The RTSP URI parameters
+   * @param  [config.uri] The full RTSP URI (overrides any hostname/parameters)
+   * @param  [config.defaultHeaders] Default headers to use (for all methods).
+   * @param  [config.headers] Headers to use (mapped to each method).
+   */
+  constructor(config = {}) {
+    const {
+      uri,
+      headers,
+      defaultHeaders
+    } = merge(defaultConfig(config.hostname, config.parameters), config);
+    const incoming = new stream_browserify.Transform({
+      objectMode: true,
+      transform: (msg, _, callback) => {
+        if (msg.type === MessageType.RTSP) {
+          this._onRtsp(msg);
+
+          callback(); // Consumes the RTSP packages
+        } else if (msg.type === MessageType.RTCP) {
+          this._onRtcp(msg); // Execute externally registered SDP handler
+
+
+          this.onRtcp && this.onRtcp(msg.rtcp); // Pass SDP forward
+
+          callback(undefined, msg);
+        } else if (msg.type === MessageType.RTP) {
+          this._onRtp(msg);
+
+          callback(undefined, msg);
+        } else if (msg.type === MessageType.SDP) {
+          this._onSdp(msg); // Execute externally registered SDP handler
+
+
+          this.onSdp && this.onSdp(msg.sdp); // Pass SDP forward
+
+          callback(undefined, msg);
+        } else {
+          // Not a message we should handle
+          callback(undefined, msg);
+        }
+      }
+    });
+    incoming.on('end', () => {
+      // Incoming was ended, assume that outgoing is closed as well
+      this._outgoingClosed = true;
+    });
+    super(incoming);
+
+    rtsp_session_defineProperty(this, "uri", void 0);
+
+    rtsp_session_defineProperty(this, "headers", void 0);
+
+    rtsp_session_defineProperty(this, "defaultHeaders", void 0);
+
+    rtsp_session_defineProperty(this, "t0", void 0);
+
+    rtsp_session_defineProperty(this, "n0", void 0);
+
+    rtsp_session_defineProperty(this, "clockrates", void 0);
+
+    rtsp_session_defineProperty(this, "startTime", void 0);
+
+    rtsp_session_defineProperty(this, "onRtcp", void 0);
+
+    rtsp_session_defineProperty(this, "onSdp", void 0);
+
+    rtsp_session_defineProperty(this, "onError", void 0);
+
+    rtsp_session_defineProperty(this, "onPlay", void 0);
+
+    rtsp_session_defineProperty(this, "retry", void 0);
+
+    rtsp_session_defineProperty(this, "_outgoingClosed", void 0);
+
+    rtsp_session_defineProperty(this, "_sequence", void 0);
+
+    rtsp_session_defineProperty(this, "_callStack", void 0);
+
+    rtsp_session_defineProperty(this, "_callHistory", void 0);
+
+    rtsp_session_defineProperty(this, "_state", void 0);
+
+    rtsp_session_defineProperty(this, "_waiting", void 0);
+
+    rtsp_session_defineProperty(this, "_contentBase", void 0);
+
+    rtsp_session_defineProperty(this, "_contentLocation", void 0);
+
+    rtsp_session_defineProperty(this, "_sessionId", void 0);
+
+    rtsp_session_defineProperty(this, "_sessionControlURL", void 0);
+
+    rtsp_session_defineProperty(this, "_renewSessionInterval", void 0);
+
+    this._outgoingClosed = false;
+
+    this._reset();
+
+    this.update(uri, headers, defaultHeaders);
+    this._sessionControlURL = this._controlURL();
+  }
+  /**
+   * Update the cached RTSP uri and headers.
+   * @param  uri - The RTSP URI.
+   * @param  headers - Maps commands to headers.
+   * @param  defaultHeaders - Default headers.
+   */
+
+
+  update(uri, headers = {}, defaultHeaders = {}) {
+    if (uri === undefined) {
+      throw new Error('You must supply an uri when creating a RtspSessionComponent');
+    }
+
+    this.uri = uri;
+    this.defaultHeaders = defaultHeaders;
+    this.headers = Object.assign({
+      [RTSP_METHOD.OPTIONS]: {},
+      [RTSP_METHOD.PLAY]: {},
+      [RTSP_METHOD.SETUP]: {
+        Blocksize: '64000'
+      },
+      [RTSP_METHOD.DESCRIBE]: {
+        Accept: 'application/sdp'
+      },
+      [RTSP_METHOD.PAUSE]: {}
+    }, headers);
+  }
+  /**
+   * Restore the initial values to the state they were in before any RTSP
+   * connection was made.
+   */
+
+
+  _reset() {
+    this._sequence = 1;
+
+    this.retry = () => console.error("No request sent, can't retry");
+
+    this._callStack = [];
+    this._callHistory = [];
+    this._state = rtsp_session_STATE.IDLE;
+    this._waiting = false;
+    this._contentBase = null;
+    this._sessionId = null;
+
+    if (this._renewSessionInterval !== null) {
+      clearInterval(this._renewSessionInterval);
+    }
+
+    this._renewSessionInterval = null;
+    this.t0 = undefined;
+    this.n0 = undefined;
+    this.clockrates = undefined;
+  }
+
+  _controlURL(attribute) {
+    if (attribute !== undefined && isAbsolute(attribute)) {
+      return attribute;
+    } // Not defined or not absolute, we need a base URI
+
+
+    const baseURL = this._contentBase ?? this._contentLocation ?? this.uri;
+
+    if (baseURL === null || baseURL === undefined) {
+      throw new Error('relative or missing control attribute but no base URL available');
+    }
+
+    if (attribute === undefined || attribute === '*') {
+      return baseURL;
+    }
+
+    return new URL(attribute, baseURL).href;
+  }
+  /**
+   * Handles incoming RTSP messages and send the next command in the queue.
+   * @param  msg - An incoming RTSP message.
+   */
+
+
+  _onRtsp(msg) {
+    this._waiting = false;
+    const status = statusCode(msg.data);
+    const ended = connectionEnded(msg.data);
+    const seq = sequence(msg.data);
+
+    if (seq === null) {
+      throw new Error('rtsp: expected sequence number');
+    }
+
+    if (this._callHistory === undefined) {
+      throw new Error('rtsp: internal error');
+    }
+
+    const method = this._callHistory[seq - 1];
+    browser_default()('msl:rtsp:incoming')(`${msg.data}`);
+
+    if (!this._sessionId && !ended) {
+      // Response on first SETUP
+      this._sessionId = sessionId(msg.data);
+
+      const _sessionTimeout = sessionTimeout(msg.data);
+
+      if (_sessionTimeout !== null) {
+        // The server specified that sessions will timeout if not renewed.
+        // In order to keep it alive we need periodically send a RTSP_OPTIONS message
+        if (this._renewSessionInterval !== null) {
+          clearInterval(this._renewSessionInterval);
+        }
+
+        this._renewSessionInterval = setInterval(() => {
+          this._enqueue({
+            method: RTSP_METHOD.OPTIONS
+          });
+
+          this._dequeue();
+        }, Math.max(MIN_SESSION_TIMEOUT, _sessionTimeout - 5) * 1000);
+      }
+    }
+
+    if (!this._contentBase) {
+      this._contentBase = contentBase(msg.data);
+    }
+
+    if (!this._contentLocation) {
+      this._contentLocation = contentLocation(msg.data);
+    }
+
+    if (status >= 400) {
+      // TODO: Retry in certain cases?
+      this.onError && this.onError(new RTSPResponseError(msg.data.toString('ascii'), status));
+    }
+
+    if (method === RTSP_METHOD.PLAY) {
+      // When starting to play, send the actual range to an external handler.
+      this.onPlay && this.onPlay(range(msg.data));
+    }
+
+    if (ended) {
+      browser_default()('msl:rtsp:incoming')(`RTSP Session ${this._sessionId} ended with statusCode: ${status}`);
+      this._sessionId = null;
+    }
+
+    this._dequeue();
+  }
+
+  _onRtcp(msg) {
+    if (this.t0 === undefined || this.n0 === undefined) {
+      throw new Error('rtsp: internal error');
+    }
+
+    if (isRtcpSR(msg.rtcp)) {
+      const rtpChannel = msg.channel - 1;
+      this.t0[rtpChannel] = msg.rtcp.rtpTimestamp;
+      this.n0[rtpChannel] = getTime(msg.rtcp.ntpMost, msg.rtcp.ntpLeast);
+    }
+  }
+
+  _onRtp(msg) {
+    if (this.t0 === undefined || this.n0 === undefined || this.clockrates === undefined) {
+      throw new Error('rtsp: internal error');
+    }
+
+    const rtpChannel = msg.channel;
+    const t0 = this.t0[rtpChannel];
+    const n0 = this.n0[rtpChannel];
+
+    if (typeof t0 !== 'undefined' && typeof n0 !== 'undefined') {
+      const clockrate = this.clockrates[rtpChannel];
+      const t = timestamp(msg.data); // The RTP timestamps are unsigned 32 bit and will overflow
+      // at some point. We can guard against the overflow by ORing with 0,
+      // which will bring any difference back into signed 32-bit domain.
+
+      const dt = t - t0 | 0;
+      msg.ntpTimestamp = dt / clockrate * 1000 + n0;
+    }
+  }
+  /**
+   * Handles incoming SDP messages, reply with SETUP and optionally PLAY.
+   * @param  msg - An incoming SDP message.
+   */
+
+
+  _onSdp(msg) {
+    this.n0 = {};
+    this.t0 = {};
+    this.clockrates = {};
+    this._sessionControlURL = this._controlURL(msg.sdp.session.control);
+    msg.sdp.media.forEach((media, index) => {
+      // We should actually be able to handle
+      // non-dynamic payload types, but ignored for now.
+      if (media.rtpmap === undefined) {
+        return;
+      }
+
+      const {
+        clockrate
+      } = media.rtpmap;
+      const rtp = index * 2;
+      const rtcp = rtp + 1;
+      const uri = media.control === undefined ? this._sessionControlURL : this._controlURL(media.control);
+
+      this._enqueue({
+        method: RTSP_METHOD.SETUP,
+        headers: {
+          Transport: 'RTP/AVP/TCP;unicast;interleaved=' + rtp + '-' + rtcp
+        },
+        uri
+      }); // TODO: see if we can get rid of this check somehow
+
+
+      if (this.clockrates === undefined) {
+        return;
+      }
+
+      this.clockrates[rtp] = clockrate;
+    });
+
+    if (this._state === rtsp_session_STATE.PLAYING) {
+      this._enqueue({
+        method: RTSP_METHOD.PLAY,
+        headers: {
+          Range: `npt=${this.startTime || 0}-`
+        },
+        uri: this._sessionControlURL
+      });
+    }
+
+    this._dequeue();
+  }
+  /**
+   * Set up command queue in order to start playing, i.e. PLAY optionally
+   * preceeded by OPTIONS/DESCRIBE commands. If not waiting, immediately
+   * start sending.
+   * @param  startTime - Time (seconds) at which to start playing
+   */
+
+
+  play(startTime = 0) {
+    if (this._state === rtsp_session_STATE.IDLE) {
+      this.startTime = Number(startTime) || 0;
+
+      this._enqueue({
+        method: RTSP_METHOD.OPTIONS
+      });
+
+      this._enqueue({
+        method: RTSP_METHOD.DESCRIBE
+      });
+    } else if (this._state === rtsp_session_STATE.PAUSED) {
+      if (this._sessionId === null || this._sessionId === undefined) {
+        throw new Error('rtsp: internal error');
+      }
+
+      this._enqueue({
+        method: RTSP_METHOD.PLAY,
+        headers: {
+          Session: this._sessionId
+        },
+        uri: this._sessionControlURL
+      });
+    }
+
+    this._state = rtsp_session_STATE.PLAYING;
+
+    this._dequeue();
+  }
+  /**
+   * Queue a pause command, and send if not waiting.
+   * @return {undefined}
+   */
+
+
+  pause() {
+    this._enqueue({
+      method: RTSP_METHOD.PAUSE
+    });
+
+    this._state = rtsp_session_STATE.PAUSED;
+
+    this._dequeue();
+  }
+  /**
+   * End the session if there is one, otherwise just cancel
+   * any outstanding calls on the stack.
+   * @return {undefined}
+   */
+
+
+  stop() {
+    if (this._sessionId) {
+      this._enqueue({
+        method: RTSP_METHOD.TEARDOWN
+      });
+    } else {
+      this._callStack = [];
+    }
+
+    this._state = rtsp_session_STATE.IDLE;
+
+    if (this._renewSessionInterval !== null) {
+      clearInterval(this._renewSessionInterval);
+      this._renewSessionInterval = null;
+    }
+
+    this._dequeue();
+  }
+  /**
+   * Pushes an RTSP request onto the outgoing stream.
+   * @param  cmd - The details about the command to send.
+   */
+
+
+  send(cmd) {
+    const {
+      method,
+      headers,
+      uri
+    } = cmd;
+
+    if (method === undefined) {
+      throw new Error('missing method when send request');
+    }
+
+    this._waiting = true;
+    this.retry = this.send.bind(this, cmd);
+
+    if (this._sequence === undefined || this.headers === undefined || this._callHistory === undefined) {
+      throw new Error('rtsp: internal error');
+    }
+
+    const message = Object.assign({
+      type: MessageType.RTSP,
+      uri: uri || this._sessionControlURL,
+      data: rtsp_session_Buffer.alloc(0) // data is a mandatory field. Not used by session -> parser messages.
+
+    }, {
+      method,
+      headers
+    }, {
+      headers: Object.assign({
+        CSeq: this._sequence++
+      }, this.defaultHeaders, // default headers (for all methods)
+      this.headers[method], // preset headers for this method
+      headers // headers that came with the invokation
+      )
+    });
+    this._sessionId && (message.headers.Session = this._sessionId);
+
+    this._callHistory.push(method);
+
+    if (!this._outgoingClosed) {
+      this.outgoing.push(message);
+    } else {
+      // If the socket is closed, dont attempt to send any data
+      browser_default()('msl:rtsp:outgoing')(`Unable to send ${method}, connection closed`);
+    }
+  }
+  /**
+   * Push a command onto the call stack.
+   * @param  cmd - The command to queue
+   */
+
+
+  _enqueue(cmd) {
+    if (this._callStack === undefined) {
+      throw new Error('rtsp: internal error');
+    }
+
+    this._callStack.push(cmd);
+  }
+  /**
+   * If possible, send the next command on the call stack.
+   */
+
+
+  _dequeue() {
+    if (this._callStack === undefined) {
+      throw new Error('rtsp: internal error');
+    }
+
+    if (!this._waiting && this._callStack.length > 0) {
+      const cmd = this._callStack.shift();
+
+      if (cmd !== undefined) {
+        this.send(cmd);
+      }
+    }
+  }
+
+}
+;// CONCATENATED MODULE: ./lib/components/ws-source/openwebsocket.ts
+ // Time in milliseconds we want to wait for a websocket to open
+
+const WEBSOCKET_TIMEOUT = 10007;
+
+// Default configuration
+const openwebsocket_defaultConfig = (host = window.location.host, scheme = window.location.protocol) => {
+  const wsScheme = scheme === 'https:' ? 'wss:' : 'ws:';
+  return {
+    uri: `${wsScheme}//${host}/rtsp-over-websocket`,
+    tokenUri: `${scheme}//${host}/axis-cgi/rtspwssession.cgi`,
+    protocol: 'binary',
+    timeout: WEBSOCKET_TIMEOUT
+  };
+};
+/**
+ * Open a new WebSocket, fallback to token-auth on failure and retry.
+ * @param  [config]  WebSocket configuration.
+ * @param  [config.host]  Specify different host
+ * @param  [config.sheme]  Specify different scheme.
+ * @param  [config.uri]  Full uri for websocket connection
+ * @param  [config.tokenUri]  Full uri for token API
+ * @param  [config.protocol] Websocket protocol
+ * @param  [config.timeout] Websocket connection timeout
+ */
+
+
+const openWebSocket = async (config = {}) => {
+  const {
+    uri,
+    tokenUri,
+    protocol,
+    timeout
+  } = merge(openwebsocket_defaultConfig(config.host, config.scheme), config);
+
+  if (uri === undefined) {
+    throw new Error('ws: internal error');
+  }
+
+  return await new Promise((resolve, reject) => {
+    try {
+      const ws = new WebSocket(uri, protocol);
+      const countdown = setTimeout(() => {
+        clearTimeout(countdown);
+
+        if (ws.readyState === WebSocket.CONNECTING) {
+          ws.onerror = null;
+          reject(new Error('websocket connection timed out'));
+        }
+      }, timeout);
+      ws.binaryType = 'arraybuffer';
+
+      ws.onerror = originalError => {
+        clearTimeout(countdown); // try fetching an authentication token
+
+        function onLoadToken() {
+          if (this.status >= 400) {
+            console.warn('failed to load token', this.status, this.responseText);
+            reject(originalError);
+            return;
+          }
+
+          const token = this.responseText.trim(); // We have a token! attempt to open a WebSocket again.
+
+          const newUri = `${uri}?rtspwssession=${token}`;
+          const ws2 = new WebSocket(newUri, protocol);
+          ws2.binaryType = 'arraybuffer';
+
+          ws2.onerror = err => {
+            reject(err);
+          };
+
+          ws2.onopen = () => resolve(ws2);
+        }
+
+        const request = new XMLHttpRequest();
+        request.addEventListener('load', onLoadToken);
+        request.addEventListener('error', err => {
+          console.warn('failed to get token');
+          reject(err);
+        });
+        request.addEventListener('abort', () => reject(originalError));
+        request.open('GET', `${tokenUri}?${Date.now()}`);
+
+        try {
+          request.send();
+        } catch (error) {
+          reject(originalError);
+        }
+      };
+
+      ws.onopen = () => {
+        clearTimeout(countdown);
+        resolve(ws);
+      };
+    } catch (e) {
+      reject(e);
+    }
+  });
+};
+;// CONCATENATED MODULE: ./lib/components/ws-source/index.ts
+/* provided dependency */ var ws_source_Buffer = __webpack_require__(7866)["Buffer"];
+function ws_source_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+
+
+
+
+ // Named status codes for CloseEvent, see:
+// https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent
+
+const CLOSE_GOING_AWAY = 1001;
+class WSSource extends Source {
+  /**
+   * Create a WebSocket component.
+   *
+   * The constructor sets up two streams and connects them to the socket as
+   * soon as the socket is available (and open).
+   *
+   * @param socket - an open WebSocket.
+   */
+  constructor(socket) {
+    if (socket === undefined) {
+      throw new Error('socket argument missing');
+    }
+    /**
+     * Set up an incoming stream and attach it to the socket.
+     * @type {Readable}
+     */
+
+
+    const incoming = new stream_browserify.Readable({
+      objectMode: true,
+      read: function () {//
+      }
+    });
+
+    socket.onmessage = msg => {
+      const buffer = ws_source_Buffer.from(msg.data);
+
+      if (!incoming.push({
+        data: buffer,
+        type: MessageType.RAW
+      })) {
+        // Something happened down stream that it is no longer processing the
+        // incoming data, and the stream buffer got full. In this case it is
+        // best to just close the socket instead of throwing away data in the
+        // hope that the situation will get resolved.
+        if (socket.readyState === WebSocket.OPEN) {
+          browser_default()('msl:websocket:incoming')('downstream frozen');
+          socket.close();
+        }
+      }
+    }; // When an error is sent on the incoming stream, close the socket.
+
+
+    incoming.on('error', e => {
+      console.warn('closing socket due to incoming error', e);
+      socket.close();
+    });
+    /**
+     * Set up outgoing stream and attach it to the socket.
+     * @type {Writable}
+     */
+
+    const outgoing = new stream_browserify.Writable({
+      objectMode: true,
+      write: function (msg, encoding, callback) {
+        try {
+          socket.send(msg.data);
+        } catch (e) {
+          console.warn('message lost during send:', msg);
+        }
+
+        callback();
+      }
+    }); // When an error happens on the outgoing stream, just warn.
+
+    outgoing.on('error', e => {
+      console.warn('error during websocket send, ignoring:', e);
+    }); // When there is no more data going to be written, close!
+
+    outgoing.on('finish', () => {
+      browser_default()('msl:websocket:outgoing')('finish');
+
+      if (socket.readyState !== WebSocket.CLOSED) {
+        socket.close();
+      }
+    });
+    /**
+     * Handler for when WebSocket is CLOSED
+     * @param  e - The event associated with a close
+     * @param  e.code The status code sent by the server
+     *   Possible codes are documented here:
+     *   https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent
+     */
+
+    socket.onclose = e => {
+      browser_default()('msl:websocket:close')(`${e.code}`);
+
+      if (e.code === CLOSE_GOING_AWAY) {
+        this.onServerClose && this.onServerClose();
+      } // Terminate the streams.
+
+
+      incoming.push(null);
+      outgoing.end();
+    };
+    /**
+     * initialize the component.
+     */
+
+
+    super(incoming, outgoing);
+
+    ws_source_defineProperty(this, "onServerClose", void 0);
+  }
+  /**
+   * Expose websocket opener as a class method that returns a promise which
+   * resolves with a new WebSocketComponent.
+   */
+
+
+  static async open(config) {
+    return await openWebSocket(config).then(socket => new WSSource(socket));
+  }
+
+}
+;// CONCATENATED MODULE: ./lib/components/index.browser.ts
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+;// CONCATENATED MODULE: ./lib/pipelines/pipeline.ts
+function pipeline_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+/**
+ * Pipeline
+ *
+ * A pipeline is a linked list of components with some convenience methods to
+ * handle inserting or removing components from the linked list.
+ *
+ * A internal set keeps track of which components the pipeline contains, while
+ * any order is completely determined by the component's connectedness.
+ */
+class Pipeline {
+  /**
+   * @param components - The components of the pipeline in order.
+   */
+  constructor(...components) {
+    pipeline_defineProperty(this, "firstComponent", void 0);
+
+    pipeline_defineProperty(this, "lastComponent", void 0);
+
+    pipeline_defineProperty(this, "_set", void 0);
+
+    const [car, ...cdr] = components;
+    this._set = new Set(components);
+    this.firstComponent = car;
+    this.lastComponent = cdr.reduce((last, component) => {
+      return last.connect(component);
+    }, car);
+  }
+  /**
+   * @param components - The components of the pipeline in order.
+   */
+
+
+  init(...components) {
+    const [car, ...cdr] = components;
+    this._set = new Set(components);
+    this.firstComponent = car;
+    this.lastComponent = cdr.reduce((last, component) => {
+      return last.connect(component);
+    }, car);
+  }
+  /**
+   * Inserts a component into the pipeline.
+   *
+   * @param component - Tube or Source behind which to insert a new component.
+   * @param component - Tube or Sink to insert.
+   */
+
+
+  insertAfter(component, newComponent) {
+    if (!this._set.has(component)) {
+      throw new Error('insertion point not part of pipeline');
+    }
+
+    if (this._set.has(newComponent)) {
+      throw new Error('new component already in the pipeline');
+    }
+
+    const cdr = component.next;
+
+    if (cdr === null) {
+      component.connect(newComponent);
+      this.lastComponent = newComponent;
+    } else {
+      component.disconnect();
+      component.connect(newComponent).connect(cdr);
+    }
+
+    this._set.add(newComponent);
+
+    return this;
+  }
+  /**
+   * Inserts a component into the pipeline.
+   *
+   * @param component - Tube or Sink in front of which to insert a new component.
+   * @param component - Tube or Source to insert.
+   */
+
+
+  insertBefore(component, newComponent) {
+    if (!this._set.has(component)) {
+      throw new Error('insertion point not part of pipeline');
+    }
+
+    if (this._set.has(newComponent)) {
+      throw new Error('new component already in the pipeline');
+    }
+
+    const car = component.prev;
+
+    if (car === null) {
+      newComponent.connect(component);
+      this.firstComponent = newComponent;
+    } else {
+      car.disconnect();
+      car.connect(newComponent).connect(component);
+    }
+
+    this._set.add(newComponent);
+
+    return this;
+  }
+  /**
+   * Removes a component from the pipeline.
+   *
+   * @param component - Component to remove.
+   */
+
+
+  remove(component) {
+    if (!this._set.has(component)) {
+      throw new Error('component not part of pipeline');
+    }
+
+    const car = component.prev;
+    const cdr = component.next;
+
+    if (car === null && cdr === null) {
+      throw new Error('cannot remove last component');
+    } else if (car === null && cdr !== null) {
+      component.disconnect();
+      this.firstComponent = cdr;
+    } else if (car !== null && cdr === null) {
+      car.disconnect();
+      this.lastComponent = car;
+    } else if (car !== null && cdr !== null) {
+      car.disconnect();
+      component.disconnect();
+      car.connect(cdr);
+    }
+
+    this._set.delete(component);
+
+    return this;
+  }
+  /**
+   * Inserts a component at the end of the pipeline.
+   *
+   * @param component - Tube or Sink to insert.
+   */
+
+
+  append(...components) {
+    components.forEach(component => {
+      this.insertAfter(this.lastComponent, component);
+    });
+    return this;
+  }
+  /**
+   * Inserts a component at the beginning of the pipeline.
+   *
+   * @param component - Tube or Source to insert.
+   */
+
+
+  prepend(...components) {
+    components.forEach(component => {
+      this.insertBefore(this.firstComponent, component);
+    });
+    return this;
+  }
+
+}
+;// CONCATENATED MODULE: ./lib/pipelines/rtsp-pipeline.ts
+function rtsp_pipeline_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+
+
+
+
+/**
+ * RtspPipeline
+ *
+ * A pipeline that converts interleaved RTSP/RTP into a series of RTP, RTCP, and
+ * RTSP packets.  The pipeline exposes the RTSP session component as
+ * `this.session`, and wraps its play, pause and stop methods.
+ *
+ * The following handlers can be defined:
+ * - onSdp: called when the session descript protocol is available, with the SDP
+ *   object as argument
+ * - onPlay: called when a response from the PLAY command arrives, with the play
+ *   range as argument
+ */
+class RtspPipeline extends Pipeline {
+  constructor(rtspConfig) {
+    const rtspParser = new RtspParser();
+    const rtspSession = new RtspSession(rtspConfig);
+
+    rtspSession.onSdp = sdp => {
+      this.onSdp && this.onSdp(sdp);
+    };
+
+    rtspSession.onPlay = range => {
+      this.onPlay && this.onPlay(range);
+    };
+
+    super(rtspParser, rtspSession); // Expose session for external use
+
+    rtsp_pipeline_defineProperty(this, "onSdp", void 0);
+
+    rtsp_pipeline_defineProperty(this, "onPlay", void 0);
+
+    rtsp_pipeline_defineProperty(this, "rtsp", void 0);
+
+    this.rtsp = rtspSession;
+  }
+
+}
+;// CONCATENATED MODULE: ./lib/pipelines/rtsp-mp4-pipeline.ts
+function rtsp_mp4_pipeline_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+
+
+
+
+/**
+ * RtspMp4Pipeline
+ *
+ * A pipeline that can process H264/AAC RTP data, and converts it to streaming
+ * MP4 format (ISO BMFF bytestream).
+ *
+ * The following handlers can be defined:
+ * - all handlers from the RtspPipeline
+ * - `onSync`: called when the NTP time of the first frame is known, with the
+ *   timestamp as argument (the timestamp is UNIX milliseconds)
+ */
+
+class RtspMp4Pipeline extends RtspPipeline {
+  constructor(rtspConfig) {
+    super(rtspConfig);
+
+    rtsp_mp4_pipeline_defineProperty(this, "onSync", void 0);
+
+    rtsp_mp4_pipeline_defineProperty(this, "_mp4Muxer", void 0);
+
+    const h264Depay = new H264Depay();
+    const aacDepay = new AACDepay();
+    const mp4Muxer = new Mp4Muxer();
+
+    mp4Muxer.onSync = ntpPresentationTime => {
+      this.onSync && this.onSync(ntpPresentationTime);
+    };
+
+    this.append(h264Depay, aacDepay, mp4Muxer);
+    this._mp4Muxer = mp4Muxer;
+  }
+
+  get bitrate() {
+    return this._mp4Muxer.bitrate;
+  }
+
+  get framerate() {
+    return this._mp4Muxer.framerate;
+  }
+
+}
+;// CONCATENATED MODULE: ./lib/pipelines/rtsp-mjpeg-pipeline.ts
+
+
+/**
+ * RtspMjpegPipeline
+ *
+ * A pipeline that can process JPEG RTP data, and converts it to streaming
+ * motion JPEG format (sequence of JPEG images).
+ *
+ * The following handlers can be defined:
+ * - all handlers from the RtspPipeline
+ */
+
+class RtspMjpegPipeline extends RtspPipeline {
+  constructor(rtspConfig) {
+    super(rtspConfig);
+    const jpegDepay = new JPEGDepay();
+    this.append(jpegDepay);
+  }
+
+}
+// EXTERNAL MODULE: ./.yarn/cache/ts-md5-npm-1.2.9-8ae03cfacf-e631e781a3.zip/node_modules/ts-md5/dist/md5.js
+var md5 = __webpack_require__(2993);
+;// CONCATENATED MODULE: ./lib/components/auth/digest.ts
+function digest_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+// https://tools.ietf.org/html/rfc2617#section-3.2.1
+
+class DigestAuth {
+  constructor(params, username, password) {
+    digest_defineProperty(this, "realm", void 0);
+
+    digest_defineProperty(this, "nonce", void 0);
+
+    digest_defineProperty(this, "opaque", void 0);
+
+    digest_defineProperty(this, "algorithm", void 0);
+
+    digest_defineProperty(this, "qop", void 0);
+
+    digest_defineProperty(this, "username", void 0);
+
+    digest_defineProperty(this, "ha1Base", void 0);
+
+    digest_defineProperty(this, "count", void 0);
+
+    digest_defineProperty(this, "nc", () => {
+      ++this.count;
+      return this.count.toString(16).padStart(8, '0');
+    });
+
+    digest_defineProperty(this, "cnonce", () => {
+      return new Array(4).fill(0).map(() => Math.floor(Math.random() * 256)).map(n => n.toString(16)).join('');
+    });
+
+    digest_defineProperty(this, "ha1", cnonce => {
+      let ha1 = this.ha1Base;
+
+      if (this.algorithm === 'md5-sess') {
+        ha1 = new md5/* Md5 */.V().appendStr(`${ha1}:${this.nonce}:${cnonce}`).end().toString();
+      }
+
+      return ha1;
+    });
+
+    digest_defineProperty(this, "ha2", (method, uri, body = '') => {
+      let ha2 = new md5/* Md5 */.V().appendStr(`${method}:${uri}`).end().toString();
+
+      if (this.algorithm === 'md5-sess') {
+        const hbody = new md5/* Md5 */.V().appendStr(body).end().toString();
+        ha2 = new md5/* Md5 */.V().appendStr(`${method}:${uri}:${hbody}`).end().toString();
+      }
+
+      return ha2;
+    });
+
+    digest_defineProperty(this, "authorization", (method = 'GET', uri = '', body) => {
+      // Increase count
+      const nc = this.nc();
+      const cnonce = this.cnonce();
+      const ha1 = this.ha1(cnonce);
+      const ha2 = this.ha2(method, uri, body);
+      const response = this.qop === undefined ? new md5/* Md5 */.V().appendStr(`${ha1}:${this.nonce}:${ha2}`).end().toString() : new md5/* Md5 */.V().appendStr(`${ha1}:${this.nonce}:${nc}:${cnonce}:${this.qop}:${ha2}`).end().toString();
+      const authorizationParams = [];
+      authorizationParams.push(`username="${this.username}"`);
+      authorizationParams.push(`realm="${this.realm}"`);
+      authorizationParams.push(`nonce="${this.nonce}"`);
+      authorizationParams.push(`uri="${uri}"`);
+
+      if (this.qop !== undefined) {
+        authorizationParams.push(`qop=${this.qop}`);
+        authorizationParams.push(`nc=${nc}`);
+        authorizationParams.push(`cnonce="${cnonce}"`);
+      }
+
+      authorizationParams.push(`response="${response}"`);
+
+      if (this.opaque !== undefined) {
+        authorizationParams.push(`opaque="${this.opaque}"`);
+      }
+
+      return `Digest ${authorizationParams.join(', ')}`;
+    });
+
+    const realm = params.get('realm');
+
+    if (realm === undefined) {
+      throw new Error('no realm in digest challenge');
+    }
+
+    this.realm = realm;
+    this.ha1Base = new md5/* Md5 */.V().appendStr(`${username}:${realm}:${password}`).end().toString();
+    const nonce = params.get('nonce');
+
+    if (nonce === undefined) {
+      throw new Error('no nonce in digest challenge');
+    }
+
+    this.nonce = nonce;
+    this.opaque = params.get('opaque');
+    const algorithm = params.get('algorithm');
+
+    if (algorithm !== undefined) {
+      if (algorithm === 'md5') {
+        this.algorithm = 'md5';
+      } else if (algorithm === 'md5-sess') {
+        this.algorithm = 'md5-sess';
+      }
+    } else {
+      this.algorithm = 'md5';
+    }
+
+    const qop = params.get('qop');
+
+    if (qop !== undefined) {
+      const possibleQops = qop.split(',').map(qopType => qopType.trim());
+
+      if (possibleQops.some(qopValue => qopValue === 'auth')) {
+        this.qop = 'auth';
+      } else if (possibleQops.some(qopValue => qopValue === 'auth-int')) {
+        this.qop = 'auth-int';
+      }
+    }
+
+    this.count = 0;
+    this.username = username;
+  }
+
+}
+;// CONCATENATED MODULE: ./lib/components/auth/www-authenticate.ts
+const parseWWWAuthenticate = header => {
+  const [, type, ...challenge] = header.split(' ');
+  const pairs = [];
+  const re = /\s*([^=]+)="([^"]*)",?/gm;
+  let match;
+
+  do {
+    match = re.exec(challenge.join(' '));
+
+    if (match !== null) {
+      const [, key, value] = match;
+      pairs.push([key, value]);
+    }
+  } while (match !== null);
+
+  const params = new Map(pairs);
+  return {
+    type: type.toLowerCase(),
+    params
+  };
+};
+;// CONCATENATED MODULE: ./lib/components/auth/index.ts
+/* provided dependency */ var auth_Buffer = __webpack_require__(7866)["Buffer"];
+
+
+
+
+
+
+
+const UNAUTHORIZED = 401;
+const DEFAULT_CONFIG = {
+  username: 'root',
+  password: 'pass'
+};
+/*
+ * This component currently only supports Basic authentication
+ * It should be placed between the RTSP parser and the RTSP Session.
+ */
+
+class Auth extends Tube {
+  constructor(config = {}) {
+    const {
+      username,
+      password
+    } = merge(DEFAULT_CONFIG, config);
+
+    if (username === undefined || password === undefined) {
+      throw new Error('need username and password');
+    }
+
+    let lastSentMessage;
+    let authHeader;
+    const outgoing = createTransform(function (msg, encoding, callback) {
+      if (msg.type === MessageType.RTSP) {
+        lastSentMessage = msg;
+
+        if (authHeader && msg.headers) {
+          msg.headers.Authorization = authHeader;
+        }
+      }
+
+      callback(undefined, msg);
+    });
+    const incoming = createTransform(function (msg, encoding, callback) {
+      if (msg.type === MessageType.RTSP && statusCode(msg.data) === UNAUTHORIZED) {
+        const headers = msg.data.toString().split('\n');
+        const wwwAuth = headers.find(header => /WWW-Auth/i.test(header));
+
+        if (wwwAuth === undefined) {
+          throw new Error('cannot find WWW-Authenticate header');
+        }
+
+        const challenge = parseWWWAuthenticate(wwwAuth);
+
+        if (challenge.type === 'basic') {
+          authHeader = 'Basic ' + auth_Buffer.from(username + ':' + password).toString('base64');
+        } else if (challenge.type === 'digest') {
+          const digest = new DigestAuth(challenge.params, username, password);
+          authHeader = digest.authorization(lastSentMessage.method, lastSentMessage.uri);
+        } else {
+          // unkown authentication type, give up
+          return;
+        } // Retry last RTSP message
+        // Write will fire our outgoing transform function.
+
+
+        outgoing.write(lastSentMessage, () => callback());
+      } else {
+        // Not a message we should handle
+        callback(undefined, msg);
+      }
+    });
+    super(incoming, outgoing);
+  }
+
+}
+;// CONCATENATED MODULE: ./lib/pipelines/html5-canvas-pipeline.ts
+function html5_canvas_pipeline_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+
+
+
+
+
+/**
+ * Html5CanvasPipeline
+ *
+ * A pipeline that connects to an RTSP server over a WebSocket connection and
+ * can process JPEG RTP data to produce an motion JPEG data stream that is sent
+ * to a HTML canvas element.
+ *
+ * Handlers that can be set on the pipeline:
+ * - all handlers inherited from the RtspMjpegPipeline
+ * - `onSync`: called when the NTP time of the first frame is known, with the
+ *   timestamp as argument (the timestamp is UNIX milliseconds)
+ * - `onServerClose`: called when the WebSocket server closes the connection
+ *   (only then, not when the connection is closed in a different way)
+ */
+class Html5CanvasPipeline extends RtspMjpegPipeline {
+  constructor(config) {
+    const {
+      ws: wsConfig,
+      rtsp: rtspConfig,
+      mediaElement,
+      auth: authConfig
+    } = config;
+    super(rtspConfig);
+
+    html5_canvas_pipeline_defineProperty(this, "onCanplay", void 0);
+
+    html5_canvas_pipeline_defineProperty(this, "onSync", void 0);
+
+    html5_canvas_pipeline_defineProperty(this, "onServerClose", void 0);
+
+    html5_canvas_pipeline_defineProperty(this, "ready", void 0);
+
+    html5_canvas_pipeline_defineProperty(this, "_src", void 0);
+
+    html5_canvas_pipeline_defineProperty(this, "_sink", void 0);
+
+    if (authConfig) {
+      const auth = new Auth(authConfig);
+      this.insertBefore(this.rtsp, auth);
+    }
+
+    const canvasSink = new CanvasSink(mediaElement);
+
+    canvasSink.onCanplay = () => {
+      canvasSink.play();
+      this.onCanplay && this.onCanplay();
+    };
+
+    canvasSink.onSync = ntpPresentationTime => {
+      this.onSync && this.onSync(ntpPresentationTime);
+    };
+
+    this.append(canvasSink);
+    this._sink = canvasSink;
+    const waitForWs = WSSource.open(wsConfig);
+    this.ready = waitForWs.then(wsSource => {
+      wsSource.onServerClose = () => {
+        this.onServerClose && this.onServerClose();
+      };
+
+      this.prepend(wsSource);
+      this._src = wsSource;
+    });
+  }
+
+  close() {
+    this._src && this._src.outgoing.end();
+  }
+
+  get currentTime() {
+    return this._sink.currentTime;
+  }
+
+  play() {
+    return this._sink.play();
+  }
+
+  pause() {
+    return this._sink.pause();
+  }
+
+  get bitrate() {
+    return this._sink.bitrate;
+  }
+
+  get framerate() {
+    return this._sink.framerate;
+  }
+
+}
+;// CONCATENATED MODULE: ./lib/pipelines/html5-video-pipeline.ts
+function html5_video_pipeline_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+
+
+
+
+
+/*
+ * Html5VideoPipeline
+ *
+ * A pipeline that connects to an RTSP server over a WebSocket connection and
+ * can process H.264/AAC RTP data to produce an MP4 data stream that is sent to
+ * a HTML video element.
+ *
+ * Handlers that can be set on the pipeline:
+ * - all handlers inherited from the RtspMp4Pipeline
+ * - `onServerClose`: called when the WebSocket server closes the connection
+ *   (only then, not when the connection is closed in a different way)
+ *
+ */
+class Html5VideoPipeline extends RtspMp4Pipeline {
+  constructor(config) {
+    const {
+      ws: wsConfig,
+      rtsp: rtspConfig,
+      mediaElement,
+      auth: authConfig
+    } = config;
+    super(rtspConfig);
+
+    html5_video_pipeline_defineProperty(this, "onSourceOpen", void 0);
+
+    html5_video_pipeline_defineProperty(this, "onServerClose", void 0);
+
+    html5_video_pipeline_defineProperty(this, "ready", void 0);
+
+    html5_video_pipeline_defineProperty(this, "tracks", void 0);
+
+    html5_video_pipeline_defineProperty(this, "_src", void 0);
+
+    html5_video_pipeline_defineProperty(this, "_sink", void 0);
+
+    if (authConfig) {
+      const auth = new Auth(authConfig);
+      this.insertBefore(this.rtsp, auth);
+    }
+
+    const mseSink = new MseSink(mediaElement);
+
+    mseSink.onSourceOpen = (mse, tracks) => {
+      this.tracks = tracks;
+      this.onSourceOpen && this.onSourceOpen(mse, tracks);
+    };
+
+    this.append(mseSink);
+    this._sink = mseSink;
+    const waitForWs = WSSource.open(wsConfig);
+    this.ready = waitForWs.then(wsSource => {
+      wsSource.onServerClose = () => {
+        this.onServerClose && this.onServerClose();
+      };
+
+      this.prepend(wsSource);
+      this._src = wsSource;
+    });
+  }
+
+  close() {
+    this._src && this._src.outgoing.end();
+  }
+
+  get currentTime() {
+    return this._sink.currentTime;
+  }
+
+  async play() {
+    return await this._sink.play();
+  }
+
+  pause() {
+    return this._sink.pause();
+  }
+
+}
+;// CONCATENATED MODULE: ./lib/pipelines/html5-video-metadata-pipeline.ts
+
+
+
+
+
+/*
+ * Html5VideoPipeline
+ *
+ * A pipeline that connects to an RTSP server over a WebSocket connection and
+ * can process H.264/AAC RTP data to produce an MP4 data stream that is sent to
+ * a HTML video element.  Additionally, this pipeline passes XML metadata sent
+ * in the same stream to a separate handler.
+ *
+ * Handlers that can be set on the pipeline:
+ * - all handlers inherited from the Html5VideoPipeline
+ *
+ */
+class Html5VideoMetadataPipeline extends Html5VideoPipeline {
+  constructor(config) {
+    const {
+      metadataHandler
+    } = config;
+    super(config);
+    const onvifDepay = new ONVIFDepay();
+    this.insertAfter(this.rtsp, onvifDepay);
+    const onvifHandlerPipe = Tube.fromHandlers(msg => {
+      if (msg.type === MessageType.XML) {
+        metadataHandler(msg);
+      }
+    }, undefined);
+    this.insertAfter(onvifDepay, onvifHandlerPipe);
+  }
+
+}
+;// CONCATENATED MODULE: ./lib/pipelines/metadata-pipeline.ts
+function metadata_pipeline_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+
+
+
+
+ // Default configuration for XML event stream
+
+const DEFAULT_RTSP_PARAMETERS = {
+  parameters: ['audio=0', 'video=0', 'event=on', 'ptz=all']
+};
+
+/*
+ * MetadataPipeline
+ *
+ * A pipeline that connects to an RTSP server over a WebSocket connection and
+ * can process XML RTP data and calls a handler to process the XML messages.
+ *
+ * Handlers that can be set on the pipeline:
+ * - all handlers inherited from the RtspPipeline
+ * - `onServerClose`: called when the WebSocket server closes the connection
+ *   (only then, not when the connection is closed in a different way)
+ *
+ */
+class MetadataPipeline extends RtspPipeline {
+  constructor(config) {
+    const {
+      ws: wsConfig,
+      rtsp: rtspConfig,
+      metadataHandler
+    } = config;
+    super(Object.assign({}, DEFAULT_RTSP_PARAMETERS, rtspConfig));
+
+    metadata_pipeline_defineProperty(this, "onServerClose", void 0);
+
+    metadata_pipeline_defineProperty(this, "ready", void 0);
+
+    metadata_pipeline_defineProperty(this, "_src", void 0);
+
+    const onvifDepay = new ONVIFDepay();
+    this.append(onvifDepay);
+    const handlerSink = Sink.fromHandler(msg => {
+      if (msg.type === MessageType.XML) {
+        metadataHandler(msg);
+      }
+    });
+    this.append(handlerSink);
+    const waitForWs = WSSource.open(wsConfig);
+    this.ready = waitForWs.then(wsSource => {
+      wsSource.onServerClose = () => {
+        this.onServerClose && this.onServerClose();
+      };
+
+      this.prepend(wsSource);
+      this._src = wsSource;
+    });
+  }
+
+  close() {
+    this._src && this._src.outgoing.end();
+  }
+
+}
+;// CONCATENATED MODULE: ./lib/pipelines/ws-sdp-pipeline.ts
+function ws_sdp_pipeline_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+
+
+
+
+
+/**
+ * WsSdpPipeline
+ *
+ * Pipeline requesting an SDP object from an RTSP server and then
+ * immediately tears down the RTSP session.
+ */
+class WsSdpPipeline extends RtspPipeline {
+  constructor(config) {
+    const {
+      ws: wsConfig,
+      rtsp: rtspConfig,
+      auth: authConfig
+    } = config;
+    super(rtspConfig);
+
+    ws_sdp_pipeline_defineProperty(this, "onServerClose", void 0);
+
+    ws_sdp_pipeline_defineProperty(this, "ready", void 0);
+
+    ws_sdp_pipeline_defineProperty(this, "_src", void 0);
+
+    if (authConfig) {
+      const auth = new Auth(authConfig);
+      this.insertBefore(this.rtsp, auth);
+    }
+
+    const waitForWs = WSSource.open(wsConfig);
+    this.ready = waitForWs.then(wsSource => {
+      wsSource.onServerClose = () => {
+        this.onServerClose && this.onServerClose();
+      };
+
+      this.prepend(wsSource);
+      this._src = wsSource;
+    });
+  }
+
+  close() {
+    this._src && this._src.outgoing.end();
+  }
+
+  get sdp() {
+    return this.ready.then(async () => {
+      const sdpPromise = new Promise(resolve => {
+        this.rtsp.onSdp = resolve;
+      });
+      this.rtsp.send({
+        method: RTSP_METHOD.DESCRIBE
+      });
+      this.rtsp.send({
+        method: RTSP_METHOD.TEARDOWN
+      });
+      return sdpPromise;
+    });
+  }
+
+}
+;// CONCATENATED MODULE: ./lib/components/http-mp4/index.ts
+/* provided dependency */ var http_mp4_Buffer = __webpack_require__(7866)["Buffer"];
+function http_mp4_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }
+
+function http_mp4_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { http_mp4_ownKeys(Object(source), true).forEach(function (key) { http_mp4_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { http_mp4_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
+
+function http_mp4_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+
+
+
+
+const http_mp4_debug = browser_default()('msl:http-mp4');
+
+/**
+ * HttpMp4
+ *
+ * Stream MP4 data over HTTP/S, and use Axis-specific
+ * headers to determine MIME type and stream transformation.
+ */
+class HttpMp4Source extends Source {
+  /**
+   * Create an HTTP component.
+   *
+   * The constructor sets a single readable stream from a fetch.
+   */
+  constructor(config) {
+    const {
+      uri,
+      options
+    } = config;
+    /**
+     * Set up an incoming stream and attach it to the socket.
+     */
+
+    const incoming = new stream_browserify.Readable({
+      objectMode: true,
+      read: function () {//
+      }
+    }); // When an error is sent on the incoming stream, close the socket.
+
+    incoming.on('error', e => {
+      console.warn('closing socket due to incoming error', e);
+      this._reader && this._reader.cancel();
+    });
+    /**
+     * initialize the component.
+     */
+
+    super(incoming); // When a read is requested, continue to pull data
+
+    http_mp4_defineProperty(this, "uri", void 0);
+
+    http_mp4_defineProperty(this, "options", void 0);
+
+    http_mp4_defineProperty(this, "length", void 0);
+
+    http_mp4_defineProperty(this, "onHeaders", void 0);
+
+    http_mp4_defineProperty(this, "onServerClose", void 0);
+
+    http_mp4_defineProperty(this, "_reader", void 0);
+
+    http_mp4_defineProperty(this, "_abortController", void 0);
+
+    http_mp4_defineProperty(this, "_allDone", void 0);
+
+    incoming._read = () => {
+      this._pull();
+    };
+
+    this.uri = uri;
+    this.options = options;
+    this._allDone = false;
+  }
+
+  play() {
+    if (this.uri === undefined) {
+      throw new Error('cannot start playing when there is no URI');
+    }
+
+    this._abortController = new AbortController();
+    this.length = 0;
+    fetch(this.uri, http_mp4_objectSpread({
+      credentials: 'include',
+      signal: this._abortController.signal
+    }, this.options)).then(rsp => {
+      if (rsp.body === null) {
+        throw new Error('empty response body');
+      }
+
+      const contentType = rsp.headers.get('Content-Type');
+      this.incoming.push({
+        data: http_mp4_Buffer.alloc(0),
+        type: MessageType.ISOM,
+        mime: contentType
+      });
+      this.onHeaders && this.onHeaders(rsp.headers);
+      this._reader = rsp.body.getReader();
+
+      this._pull();
+    }).catch(err => {
+      console.error('http-source: fetch failed: ', err);
+    });
+  }
+
+  abort() {
+    this._reader && this._reader.cancel().catch(err => {
+      console.log('http-source: cancel reader failed: ', err);
+    });
+    this._abortController && this._abortController.abort();
+  }
+
+  _isClosed() {
+    return this._allDone;
+  }
+
+  _close() {
+    var _this$onServerClose;
+
+    this._reader = undefined;
+    this._allDone = true;
+    this.incoming.push(null);
+    (_this$onServerClose = this.onServerClose) === null || _this$onServerClose === void 0 ? void 0 : _this$onServerClose.call(this);
+  }
+
+  _pull() {
+    if (this._reader === undefined) {
+      return;
+    }
+
+    this._reader.read().then(({
+      done,
+      value
+    }) => {
+      if (done) {
+        if (!this._isClosed()) {
+          http_mp4_debug('fetch completed, total downloaded: ', this.length, ' bytes');
+
+          this._close();
+        }
+
+        return;
+      }
+
+      if (value === undefined) {
+        throw new Error('expected value to be defined');
+      }
+
+      if (this.length === undefined) {
+        throw new Error('expected length to be defined');
+      }
+
+      this.length += value.length;
+      const buffer = http_mp4_Buffer.from(value);
+
+      if (!this.incoming.push({
+        data: buffer,
+        type: MessageType.ISOM
+      })) {
+        // Something happened down stream that it is no longer processing the
+        // incoming data, and the stream buffer got full.
+        // This could be because we are downloading too much data at once,
+        // or because the downstream is frozen. The latter is most likely
+        // when dealing with a live stream (as in that case we would expect
+        // downstream to be able to handle the data).
+        http_mp4_debug('downstream back pressure: pausing read');
+      } else {
+        // It's ok to read more data
+        this._pull();
+      }
+    }).catch(err => {
+      http_mp4_debug('http-source: read failed: ', err);
+
+      if (!this._isClosed()) {
+        this._close();
+      }
+    });
+  }
+
+}
+;// CONCATENATED MODULE: ./lib/pipelines/http-mse-pipeline.ts
+function http_mse_pipeline_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+
+
+
+
+/*
+ * HttpMsePipeline
+ *
+ * A pipeline that connects to an HTTP server and can process an MP4 data stream
+ * that is then sent to a HTML video element
+ *
+ * Handlers that can be set on the pipeline:
+ * - `onServerClose`: called when the server closes the connection
+ */
+class HttpMsePipeline extends Pipeline {
+  constructor(config) {
+    const {
+      http: httpConfig,
+      mediaElement
+    } = config;
+    const httpSource = new HttpMp4Source(httpConfig);
+    const mseSink = new MseSink(mediaElement);
+
+    httpSource.onHeaders = headers => {
+      this.onHeaders && this.onHeaders(headers);
+    };
+
+    httpSource.onServerClose = () => {
+      var _this$onServerClose;
+
+      return (_this$onServerClose = this.onServerClose) === null || _this$onServerClose === void 0 ? void 0 : _this$onServerClose.call(this);
+    };
+
+    super(httpSource, mseSink);
+
+    http_mse_pipeline_defineProperty(this, "onHeaders", void 0);
+
+    http_mse_pipeline_defineProperty(this, "onServerClose", void 0);
+
+    http_mse_pipeline_defineProperty(this, "http", void 0);
+
+    http_mse_pipeline_defineProperty(this, "_src", void 0);
+
+    http_mse_pipeline_defineProperty(this, "_sink", void 0);
+
+    this._src = httpSource;
+    this._sink = mseSink; // Expose session for external use
+
+    this.http = httpSource;
+  }
+
+  close() {
+    this._src && this._src.abort();
+  }
+
+  get currentTime() {
+    return this._sink.currentTime;
+  }
+
+  async play() {
+    return await this._sink.play();
+  }
+
+  pause() {
+    return this._sink.pause();
+  }
+
+}
+;// CONCATENATED MODULE: ./lib/pipelines/index.browser.ts
+
+
+
+
+
+
+
+
+
+
+;// CONCATENATED MODULE: ./lib/utils/protocols/index.ts
+
+
+
+
+
+;// CONCATENATED MODULE: ./lib/utils/retry.ts
+/**
+ * Retry failed commands.
+ *
+ * This retries RTSP commands that fails up to a certain
+ * limit of times.
+ */
+const addRTSPRetry = (rtspSession, {
+  maxRetries,
+  errors
+} = {
+  maxRetries: 20,
+  errors: [503]
+}) => {
+  let retries = 0;
+  const oldOnError = rtspSession.onError;
+
+  rtspSession.onError = err => {
+    oldOnError === null || oldOnError === void 0 ? void 0 : oldOnError(err);
+
+    if (!errors.includes(err.code)) {
+      return;
+    } // Stop retrying after 20 tries (~20 seconds)
+
+
+    if ((retries += 1) > maxRetries) {
+      console.log('retry, too many', retries, maxRetries);
+      return;
+    } // Retry
+
+
+    setTimeout(() => {
+      var _rtspSession$retry;
+
+      return (_rtspSession$retry = rtspSession.retry) === null || _rtspSession$retry === void 0 ? void 0 : _rtspSession$retry.call(rtspSession);
+    }, retries * 100);
+  };
+};
+;// CONCATENATED MODULE: ./lib/utils/index.browser.ts
+
+
+
+;// CONCATENATED MODULE: ./lib/index.browser.ts
+
+
+
+
+
+
+
+})();
+
+/******/ 	return __webpack_exports__;
+/******/ })()
+;
+});
\ No newline at end of file
